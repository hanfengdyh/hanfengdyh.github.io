<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>瑞芯微ROS</title>
      <link href="/2024/12/23/2024-12-23-%E7%91%9E%E8%8A%AF%E5%BE%AEROS/"/>
      <url>/2024/12/23/2024-12-23-%E7%91%9E%E8%8A%AF%E5%BE%AEROS/</url>
      
        <content type="html"><![CDATA[<h1 id="Buildroot配合ROS"><a href="#Buildroot配合ROS" class="headerlink" title="Buildroot配合ROS"></a>Buildroot配合ROS</h1><p>目标平台：rk3566</p><p>首先下载SDK包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##搭建基础环境</span></span><br><span class="line">sudo apt-get install git ssh make gcc libssl-dev liblz4-tool expect \</span><br><span class="line">g++ patchelf chrpath gawk texinfo chrpath diffstat binfmt-support \</span><br><span class="line">qemu-user-static live-build bison flex fakeroot cmake gcc-multilib \</span><br><span class="line">g++-multilib unzip device-tree-compiler ncurses-dev</span><br><span class="line"><span class="comment">##解压</span></span><br><span class="line">tar -zxvf tspi_linux_sdk_20230916.tar.gz</span><br><span class="line"><span class="built_in">cd</span> buildroot</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>在menuconfig里使用&#x2F;搜索格式查找ros软件包的位置以及依赖项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Location:                                                                            │  </span><br><span class="line">  │     -&gt; Target packages                                                           │  </span><br><span class="line">  │       -&gt; Rockchip BSP packages (BR2_PACKAGE_ROCKCHIP [=y])                       │  </span><br><span class="line">  │         -&gt; ros BSP package (BR2_PACKAGE_ROS_SUPPORT_SET [=n])                    │  </span><br></pre></td></tr></table></figure><p><strong>只有先使能依赖项menuconfig里才能显示ros package的内容。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config BR2_PACKAGE_ROS_SUPPORT_SET</span><br><span class="line">    bool &quot;ros BSP package&quot;</span><br><span class="line">    depends on BR2_PACKAGE_PYTHON</span><br><span class="line">    depends on BR2_PACKAGE_BOOST</span><br></pre></td></tr></table></figure><p>同理通过&#x2F;查询PYTHON和BOOST软件包进行使能，之后就可以在Rockchip BSP packages里找到关于ros BSP package的包。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
      <url>/2024/12/08/blog_makedown/%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-系统虚拟化和容器"><a href="#title-系统虚拟化和容器" class="headerlink" title="title:系统虚拟化和容器"></a>title:系统虚拟化和容器</h2><h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p>将不存在的事务或者现象虚拟成为存在的事务或者现象方法。</p><blockquote><p>指令集虚拟化</p><ul><li>纯软件实现</li><li>模拟器</li><li>可以实现模拟环境中的程序</li></ul><p>资源虚拟化</p><ul><li>内存</li><li>网络资源</li></ul><p>程序库级虚拟化</p><ul><li><p>在应用程序和运行库间引入仿真的系统API</p></li><li><p>隐藏与操作系统相关的程序库细节</p></li><li><p>包括仿真、模拟、解释技术等</p></li></ul><p>编程语言虚拟化</p><ul><li>提供一套自定义的、处理器无关的编程语言指令集</li><li>屏蔽了硬件的异构性</li><li>解决了可执行程序在不同体系结构计算机间迁移的问题</li></ul><p>系统虚拟化</p><ul><li>针对计算机和操作系统</li><li>提供一个不存在的硬件如内存、磁盘等</li></ul></blockquote><p>旨在计算机系统上模拟运行多个操作系统平台。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E9%93%BE%E7%BC%96%E8%AF%91%E5%8C%85%E5%90%ABRVV-Intrinsic%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2024/12/08/blog_makedown/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E9%93%BE%E7%BC%96%E8%AF%91%E5%8C%85%E5%90%ABRVV-Intrinsic%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-RVV-Intrinsic"><a href="#title-RVV-Intrinsic" class="headerlink" title="title:RVV Intrinsic"></a>title:RVV Intrinsic</h2><h1 id="RVV向量扩展"><a href="#RVV向量扩展" class="headerlink" title="RVV向量扩展"></a>RVV向量扩展</h1><p><a href="https://www.xrvm.cn/community/post/detail?id=4187650891316269056">向量扩展</a></p><p><a href="https://fprox.substack.com/p/risc-v-vector-programming-in-c-with">使用 Intrinsics 的 C 语言 RISC-V 向量编程</a></p><p>RVV 的灵活性体现在以下几个方面：</p><ol><li><strong>向量长度的可变性</strong>：RVV 提供了灵活的向量长度（VL）设置，使得同一指令可以处理不同数量的数据元素。例如，你可以在同一程序中为不同的操作指定不同的向量长度，以适应硬件的能力或特定的计算任务。一个寄存器可以包含多个数据元素（例如 32 位整数、64 位浮点数等），并根据当前的 <code>vl</code> 设置来决定每个寄存器要处理多少数据元素。因此，向量寄存器组有时可以半满或不满——取决于 <code>vl</code> 设置以及每个操作处理的数据量。</li><li><strong>向量寄存器组的大小</strong>：RISC-V 向量寄存器组通常由多个寄存器组成，每个寄存器的大小是固定的。寄存器的大小和数据类型（如整数或浮点数）是固定的，但由于 <code>vl</code> 是动态可调整的，寄存器的填充率可能会小于其最大容量。例如，假设一个寄存器是 128 位宽，如果你只需要处理 64 位的数据元素，寄存器的 “半满” 情况就可能发生。</li><li><strong>指令和掩码的作用</strong>：在 RVV 中，某些指令可以允许掩码操作（例如，<code>vfmv_v_f_f64m1</code>），这意味着某些元素可能会被忽略或处理为零，而不影响其他寄存器元素的计算。这使得向量寄存器的实际使用情况（如 1&#x2F;2 或更少）变得有可能。</li></ol><h1 id="可行性方案"><a href="#可行性方案" class="headerlink" title="可行性方案"></a>可行性方案</h1><h3 id="工具链的安装"><a href="#工具链的安装" class="headerlink" title="工具链的安装"></a>工具链的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/riscv-collab/riscv-gnu-toolchain</span><br><span class="line">cd riscv-gnu-toolchain</span><br><span class="line">git submodule update --init --recursive##速度很慢</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">../configure --prefix=/opt/riscv64 --enable-multilib --enable-languages=c,c++ --with-arch=rv64gcv --with-abi=lp64 --enable-rvv</span><br><span class="line">make -$(nproc)j</span><br><span class="line">riscv64-unknown-elf-gcc --version</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">riscv64-unknown-elf-gcc (g04696df0963) 14.2.0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Copyright (C) 2024 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><blockquote><p>经过测试以上配置的工具版本只能支持具有riscv前缀的函数如__riscv_vle32_v_i32m2(lhs, vl)</p><p>更高版本对向量指令的处理方式更严格，因此它不再直接解析某些低级别函数，特别是那些没有前缀的 RVV 内建函数。这种变化旨在减少混淆，并统一 LLVM 中的向量扩展处理。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reference: https://pages.dogdog.run/toolchain/riscv_vector_extension.html</span></span><br><span class="line"><span class="comment">// #define __riscv_vector // make VSC happy when reading riscv_vector.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">10</span>], z_real[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vec_add_rvv</span><span class="params">(<span class="type">int</span>* dst, <span class="type">int</span>* lhs, <span class="type">int</span>* rhs, <span class="type">size_t</span> avl)</span> &#123;</span><br><span class="line">    <span class="type">vint32m2_t</span> vlhs, vrhs, vres;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> vl; (vl = __riscv_vsetvl_e32m2(avl));</span><br><span class="line">         avl -= vl, lhs += vl, rhs += vl, dst += vl) &#123;</span><br><span class="line">        vlhs = __riscv_vle32_v_i32m2(lhs, vl);</span><br><span class="line">        vrhs = __riscv_vle32_v_i32m2(rhs, vl);</span><br><span class="line">        vres = __riscv_vadd_vv_i32m2(vlhs, vrhs, vl);</span><br><span class="line">        __riscv_vse32_v_i32m2(dst, vres, vl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vec_add_real</span><span class="params">(<span class="type">int</span>* dest, <span class="type">int</span>* lhs, <span class="type">int</span>* rhs, <span class="type">size_t</span> vlen)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">        dest[i] = lhs[i] + rhs[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_vec</span><span class="params">(<span class="type">int</span>* v, <span class="type">size_t</span> vlen, <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s=&#123; &quot;</span>, msg);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, v[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check RVV support</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __riscv_v_intrinsic</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RVV NOT supported in this compiler\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    vec_add_rvv(z, x, y, <span class="number">10</span>);</span><br><span class="line">    vec_add_real(z_real, x, y, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    print_vec(x, <span class="number">10</span>, <span class="string">&quot;x[10]&quot;</span>);</span><br><span class="line">    print_vec(y, <span class="number">10</span>, <span class="string">&quot;y[10]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z[i] != z_real[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;==========\nTest FAILED: pos %d mismatch\n&quot;</span>, i);</span><br><span class="line">            print_vec(z, <span class="number">10</span>, <span class="string">&quot;z[10]&quot;</span>);</span><br><span class="line">            print_vec(z_real, <span class="number">10</span>, <span class="string">&quot;z_real[10]&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_vec(z, <span class="number">10</span>, <span class="string">&quot;z[10]&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==========\nTest PASSED\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模拟器对于RVV的支持"><a href="#模拟器对于RVV的支持" class="headerlink" title="模拟器对于RVV的支持"></a>模拟器对于RVV的支持</h3><h4 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##编译执行报错，说是不支持rvv扩展，所以采用了spike模拟器</span><br><span class="line">qemu-riscv64 -cpu rv64,v=true,vlen=128,vext_spec=v1.0 ./vadd</span><br><span class="line">qemu-riscv64: can&#x27;t apply global rv64-riscv-cpu.v=true: Property &#x27;rv64-riscv-cpu.v&#x27; not found</span><br></pre></td></tr></table></figure><h4 id="Spike"><a href="#Spike" class="headerlink" title="Spike"></a>Spike</h4><p><strong>安装依赖</strong></p><p>在开始之前，你需要确保你的系统上安装了必要的依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#复制代码</span></span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y autoconf automake libtool g++ pkg-config make python3</span><br></pre></td></tr></table></figure><p><strong>克隆 Spike 仓库</strong></p><p>首先克隆 Spike 仓库到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复制代码</span><br><span class="line">git clone https://github.com/riscv/riscv-isa-sim.git</span><br><span class="line">cd riscv-isa-sim</span><br></pre></td></tr></table></figure><p><strong>配置和编译 Spike</strong></p><p>配置和编译 Spike，使其支持 RVV 扩展。通过以下步骤来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#复制代码</span></span></span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure --prefix=/opt/riscv --enable-rvv</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>在这里，<code>--enable-rvv</code> 确保 Spike 配置支持 RISC-V 向量扩展 (RVV)。</p><p><strong>配置环境变量</strong></p><p>安装完成后，确保将 <code>/opt/riscv/bin</code> 添加到你的 <code>PATH</code> 环境变量中，以便可以方便地调用 Spike。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#复制代码</span></span></span><br><span class="line">vi ~./basrch #将一下内容放入最后</span><br><span class="line">export PATH=/opt/riscv/bin:$PATH</span><br></pre></td></tr></table></figure><p>为了让Spike，正确执行成程序需要将RISCV-V Proxy Kernel(pk)。</p><p><strong>安装PK</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/riscv/riscv-pk.git</span><br><span class="line">cd riscv-pk</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line"> ../configure --prefix=/opt/riscv --host=riscv64-unknown-linux-gnu</span><br><span class="line">make </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">报错</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#../machine/flush_icache.c: Assembler messages:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#../machine/flush_icache.c:4: Error: unrecognized opcode fence.i&#x27;, extension ##zifencei&#x27; required</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#make: *** [Makefile:336：flush_icache.o] 错误 1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># vim Makefile</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启用 zifencei 扩展</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 在CFLAGS中添加 -march=rv64imafdc_zifencei</span></span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 验证安装成不成功</span></span></span><br><span class="line">ls /opt/riscv/riscv64-unknown-linux-gnu/lib/riscv-pk</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#看到诸如 libpk.a、libbbl.a、libsoftfloat.a 等文件。</span></span></span><br></pre></td></tr></table></figure><h3 id="gcc编译"><a href="#gcc编译" class="headerlink" title="gcc编译"></a>gcc编译</h3><p><code>spike只能跑静态编译的程序。</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#执行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-unknown-linux-gnu-gcc -march=rv64gcv  -O2 -g -static ./vadd.c -o ./vadd</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#或者</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-unknown-elf-gcc -march=rv64gcv  -O2 -g -static ./vadd.c -o ./vadd</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#执行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">spike --isa=rv64gcv /opt/riscv/riscv64-unknown-linux-gnu/bin/pk ./vadd</span></span><br></pre></td></tr></table></figure><p><strong>clang编译</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang --target=riscv64-unknown-linux-gnu -O2 -g -march=rv64gcv1p0 -menable-experimental-extensions --gcc-toolchain=/opt/riscv64 --sysroot=/opt/riscv64/sysroot -mllvm --riscv-v-vector-bits-min=256 ./vadd.c -o vadd</span></span><br></pre></td></tr></table></figure><p><strong>报错</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">./vadd.c:<span class="number">10</span>:<span class="number">14</span>: warning: implicit declaration of function <span class="string">&#x27;__riscv_vsetvl_e32m1&#x27;</span> is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">        vl = __riscv_vsetvl_e32m1(vlen - i);</span><br><span class="line">             ^</span><br><span class="line">./vadd.c:<span class="number">12</span>:<span class="number">27</span>: warning: implicit declaration of function <span class="string">&#x27;__riscv_vle32_v_f32m1&#x27;</span> is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">        <span class="type">vfloat32m1_t</span> va = __riscv_vle32_v_f32m1(&amp;a[i], vl);</span><br><span class="line">                          ^</span><br><span class="line">./vadd.c:<span class="number">12</span>:<span class="number">22</span>: error: initializing <span class="string">&#x27;vfloat32m1_t&#x27;</span> (aka <span class="string">&#x27;__rvv_float32m1_t&#x27;</span>) with an expression of incompatible type <span class="string">&#x27;int&#x27;</span></span><br><span class="line">        <span class="type">vfloat32m1_t</span> va = __riscv_vle32_v_f32m1(&amp;a[i], vl);</span><br><span class="line">                     ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">./vadd.c:<span class="number">13</span>:<span class="number">22</span>: error: initializing <span class="string">&#x27;vfloat32m1_t&#x27;</span> (aka <span class="string">&#x27;__rvv_float32m1_t&#x27;</span>) with an expression of incompatible type <span class="string">&#x27;int&#x27;</span></span><br><span class="line">        <span class="type">vfloat32m1_t</span> vb = __riscv_vle32_v_f32m1(&amp;b[i], vl);</span><br><span class="line">                     ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">./vadd.c:<span class="number">15</span>:<span class="number">29</span>: warning: implicit declaration of function <span class="string">&#x27;__riscv_vfmul_vv_f32m1&#x27;</span> is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">        <span class="type">vfloat32m1_t</span> vres = __riscv_vfmul_vv_f32m1(va, vb, vl);</span><br><span class="line">                            ^</span><br><span class="line">./vadd.c:<span class="number">15</span>:<span class="number">22</span>: error: initializing <span class="string">&#x27;vfloat32m1_t&#x27;</span> (aka <span class="string">&#x27;__rvv_float32m1_t&#x27;</span>) with an expression of incompatible type <span class="string">&#x27;int&#x27;</span></span><br><span class="line">        <span class="type">vfloat32m1_t</span> vres = __riscv_vfmul_vv_f32m1(va, vb, vl);</span><br><span class="line">                     ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">./vadd.c:<span class="number">17</span>:<span class="number">9</span>: warning: implicit declaration of function <span class="string">&#x27;__riscv_vse32_v_f32m1&#x27;</span> is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">        __riscv_vse32_v_f32m1(&amp;dest[i], vres, vl);</span><br><span class="line">        ^</span><br><span class="line">./vadd.c:<span class="number">55</span>:<span class="number">66</span>: warning: format specifies type <span class="string">&#x27;int&#x27;</span> but the argument has type <span class="string">&#x27;size_t&#x27;</span> (aka <span class="string">&#x27;unsigned long&#x27;</span>) [-Wformat]</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;==========\nTest FAILED: pos %d mismatch\n&quot;</span>, i);</span><br><span class="line">                                                 ~~              ^</span><br><span class="line">                                                 %zu</span><br><span class="line"><span class="number">5</span> warnings and <span class="number">3</span> errors generated.</span><br></pre></td></tr></table></figure><h3 id="等待验证方案"><a href="#等待验证方案" class="headerlink" title="等待验证方案"></a>等待验证方案</h3><p>qemu的RVV扩展以及clang为什么编译报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用的qemu是9.0.1的，但是在命令中识别不了vv=<span class="literal">true</span>,</span></span><br></pre></td></tr></table></figure><p>参考链接：[中科院RVV配置Intrinsic](<a href="https://learning.eulixos.com/posts/2024-01/zyx_01_config/">RVV C Intrinsic 配置教程</a>)</p><p>参考报告中的工具链版本是13.2，使用的clang是14.0.6，但是我使用的工具链是最新版的14.2.0，这个更高的版本clang14还支持不了，需要更高的版本才可以对RVV的全面支持。</p><p><img src="https://img.picgo.net/2024/11/15/-2024-11-15-16172237daeb92e2d520cb.png" alt="屏幕截图 2024 11 15 161722"></p><p>使用clang17是可以编译的。</p><p>后续编程实例：</p><p><a href="https://github.com/riscv-non-isa/rvv-intrinsic-doc/blob/v0.11.x/examples/rvv_branch.c">https://github.com/riscv-non-isa/rvv-intrinsic-doc/blob/v0.11.x/examples/rvv_branch.c</a></p><p>函数API为：</p><p><a href="https://dzaima.github.io/intrinsics-viewer/">Intrinsics viewer</a></p><p>qemu关于RVV的编译报错：</p><p><img src="https://img.picgo.net/2024/11/18/QEMU-RVVe6d6b32d2c5c93d7.png" alt="QEMU RVV"></p><p><code>在Ubuntu20.04上可以成功运行。</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/RVV%E5%90%91%E9%87%8F%E5%8C%96/"/>
      <url>/2024/12/08/blog_makedown/RVV%E5%90%91%E9%87%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title：RVV向量化"><a href="#title：RVV向量化" class="headerlink" title="title：RVV向量化"></a>title：RVV向量化</h2><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><blockquote><p>首先硬件可能支持不同版本的向量扩展，这之间不同版本互不兼容。</p><p>qemu上虽然可以跑RVV程序，但是开销比标量运算还大，所以只能做程序验证，实际运行效率要上实际的riscvgv的机器上才行。</p><p>ubuntu22.04尽管使用qemu但是也不支持rvv，因为kernel内核中的mstatus寄存器（机器模式下的状态寄存器）未初始化，当mstatus.vs域值被写0时候，试图执行向量指令或访问向量寄存器均会引发非法指令异常。</p></blockquote><h1 id="自动向量化和手动向量化"><a href="#自动向量化和手动向量化" class="headerlink" title="自动向量化和手动向量化"></a>自动向量化和手动向量化</h1><blockquote><p><strong>关于向量化：</strong></p><ol><li><strong>对GCC或者LLVM进行开发（自动向量化）</strong></li></ol><p>​    **前端编译扩展 Target Transform Info (TTI)**：</p><ul><li>定义目标架构的向量化能力（RVV 支持可扩展向量）。</li><li>例如为 RISC-V 增强 <code>getRegisterBitWidth</code> 和 <code>getTypeLegalizationCost</code> 方法。</li></ul><p>​    <strong>修改 Loop 和 SLP Vectorizer</strong>：</p><ul><li>添加对 RVV 动态向量寄存器的支持。</li><li>修改默认的向量化策略以生成动态向量类型。</li></ul><p>​    <strong>支持 RVV 的 IR 到目标代码映射</strong>：</p><ul><li>在后端的 <code>SelectionDAG</code> 或 <code>GlobalISel</code> 中实现 RVV 指令的生成逻辑。</li></ul><ol start="2"><li><strong>Intrinsic函数的开发（手动向量化）</strong><ul><li>本质上跳过了自动向量化的逻辑，不需要向量化Pass介入。</li><li>直接提供了向量化代码的“翻译规则”，编译器无需再生成向量化逻辑或 IR，代码中调用的 Intrinsic 已经指定了目标平台指令。</li></ul></li><li><strong>自动向量化与显式使用 Intrinsic 的关系</strong><ul><li>显式调用 Intrinsic：<ul><li>开发者直接编写 Intrinsic，相当于手动向量化。</li><li>编译器只负责将这些 Intrinsic 映射到硬件指令，而不会尝试进行进一步优化。</li><li>优点：避免冗余优化，无需等待编译器的进一步支持。</li><li>缺点：增加了维护成本。</li></ul></li><li>自动向量化：<ul><li>开发者编写标量代码，向量化 Pass 根据硬件平台的能力和代码逻辑，自动生成调用 Intrinsic 的 IR。</li><li>编译器根据向量化 Pass 生成的规则，优化代码并映射到目标平台指令。</li></ul></li></ul></li></ol></blockquote><h2 id="向量扩展"><a href="#向量扩展" class="headerlink" title="向量扩展"></a>向量扩展</h2><p>RISC-V 向量扩展（RVV）是一种灵活的矢量处理架构，允许程序在运行时动态调整向量长度（VL），以适应不同硬件实现的特性（例如矢量寄存器大小）。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>1. 向量寄存器</strong></p><p>RVV 定义了一组 <strong>向量寄存器（Vector Registers, VRs）</strong>：</p><ul><li>寄存器名：<code>v0</code> 至 <code>v31</code>，共 32 个。</li><li><strong>每个寄存器的实际宽度（VLEN</strong>，以位为单位）由硬件实现决定。例如，硬件可能支持 128 位、256 位或 512 位寄存器。</li><li><strong>基本元素宽度（SEW，Standard Element Width）</strong>：表示每个向量元素的大小，例如 <code>8-bit</code>, <code>16-bit</code>, <code>32-bit</code>, <code>64-bit</code>。</li><li>每个寄存器可以存储的最大元素个数为 <code>VLEN / SEW</code>，称为 <strong>最大向量长度（VLmax）</strong>。</li></ul><blockquote><p>补充：<strong>一个向量元素的最大位宽为ELEN（&lt;VLEN）</strong></p><p>本文的位宽都是2的次幂</p></blockquote><p><strong>2.LMUL（Vector register group multiplier)</strong></p><p>当一个向量寄存器不够用，就将多个寄存器组进行合并叫做LMUL（(合并寄存器组数量），有合并就有拆解，可以分份：1&#x2F;2，1&#x2F;4，1&#x2F;8 （小数表示一个向量寄存器的被使用的位宽）<br>$$<br>LMUL &gt;&#x3D; \frac{SEW}{ELEN}<br>$$</p><p><strong>向量长度（VL）</strong></p><ul><li><strong>动态向量长度（VL）</strong> 是指当前有效的向量长度（单位：元素个数），由程序通过指令动态设置。</li><li>动态设置使得程序可以在剩余数据不足时调整向量长度，从而避免浪费计算资源。</li></ul><h3 id="设置向量长度"><a href="#设置向量长度" class="headerlink" title="设置向量长度"></a><strong>设置向量长度</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> vl = __riscv_vsetvl_e32m8(n);</span><br></pre></td></tr></table></figure><p>例如这个函数：获取32位数据(SEW)，并且8倍寄存器宽度倍数(LMUL)的数据长度，如果硬件支持的矢量寄存器长度位VLEN是128位，那么根据公式<br>$$<br>元素数目 &#x3D; ( \frac{\text{VLEN}}{\text{SEW}} \times \text{LMUL} &#x3D; \frac{128}{32} \times 8 &#x3D; 32 )<br>$$<br>因此这个函数是说明一次性处理32个32位数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> vl = __riscv_vsetvl_e16m1(n);</span><br></pre></td></tr></table></figure><p>还假设VLEN &#x3D; 128，这个函数将设置一次性处理8个16位数据。</p><p><strong>如何计算最终的 VL</strong></p><p>对于每次向量指令的实际运行，向量长度（<code>VL</code>）取决于待处理数据的个数 <code>n</code> 和硬件寄存器的处理能力 <code>VLmax</code>（即硬件最大能处理的数据量）。通常 <code>VL</code> 取以下值：<br>$$<br>VL &#x3D; \min(n, \frac{VLEN}{SEW} \times LMUL)<br>$$</p><p>即从待处理元素数 <code>n</code> 和硬件支持的最大向量长度 <code>VLmax</code> 中选择较小的那个值。</p><ul><li><strong>vsetvl_e32m8</strong>：假设有 100 个 32 位数据，硬件支持最大处理 32 个 32 位数据，那么： VL&#x3D;min⁡(100,32)&#x3D;32VL &#x3D; \min(100, 32) &#x3D; 32VL&#x3D;min(100,32)&#x3D;32</li><li><strong>vsetvl_e16m1</strong>：假设有 10 个 16 位数据，硬件支持最大处理 8 个 16 位数据，那么： VL&#x3D;min⁡(10,8)&#x3D;8VL &#x3D; \min(10, 8) &#x3D; 8VL&#x3D;min(10,8)&#x3D;8</li></ul><p>这种动态调整向量长度的方式使得 RVV 架构能够灵活适应不同大小的数据处理，优化性能。</p><h2 id="通用Intrinsic编程-手动向量化"><a href="#通用Intrinsic编程-手动向量化" class="headerlink" title="通用Intrinsic编程(手动向量化)"></a>通用Intrinsic编程(手动向量化)</h2><ol><li>使用适当的向量长度设置函数</li><li>采用合适数据加载存储函数</li><li>通过向量操作（乘法、加法等）实习复杂运算</li><li>逐步迭代处理数据</li></ol><h3 id="IntrinsicAPI函数解析"><a href="#IntrinsicAPI函数解析" class="headerlink" title="IntrinsicAPI函数解析"></a>IntrinsicAPI函数解析</h3><p>Intrinsic 命名遵循着以下通用规则：</p><p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1ebb6245-255e-454c-85bc-ec2df76607cd_727x424.png"></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__riscv_vle8_v_i8mf4</span><br></pre></td></tr></table></figure><p>构成为：__riscv_前缀，在最新的版本中这个前缀不能省略。</p><p>执行操作常用的有：vadd加法，vmul乘法，vle向量加载，vse向量存储，vsetvl设置向量长度。</p><p>数据类型：</p><ul><li><p>u32：无符号32整形</p></li><li><p>f64:    64位浮点型</p></li></ul><p>操作对象是向量还是标量，通过后缀区分，以下为常用操作：</p><ul><li><code>vv</code>：两个向量操作</li><li><code>vx</code>：向量与标量操作</li><li><code>vi</code>：向量与立即数操作</li><li><code>v</code>:针对向量的</li></ul><p>LMUL表示向量寄存器逻辑长度是基础寄存器长度的倍数，即VLEN的倍数，例如：</p><ul><li><p><strong>LMUL &#x3D; 1</strong>: 一个逻辑向量寄存器等于一个物理向量寄存器。</p></li><li><p><strong>LMUL &#x3D; 2</strong>: 一个逻辑向量寄存器需要两个物理向量寄存器。</p></li><li><p><strong>LMUL &#x3D; 1&#x2F;2 或 1&#x2F;4</strong>: 一个物理向量寄存器被划分为多个逻辑寄存器</p></li></ul><p>_tumu是操作掩码</p><p>在执行时会参考一个布尔掩码向量（类型通常是 <code>vboolN_t</code>）。掩码决定了哪些向量元素参与计算：</p><ul><li><strong>掩码值为 1</strong>（<code>true</code>）：参与计算。</li><li><strong>掩码值为 0</strong>（<code>false</code>）：跳过计算，通常保留原值或设置为零，具体行为由指令定义。</li></ul><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vint32m1_t</span> __riscv_vadd_vv_i32m1_m(<span class="type">vbool32_t</span> mask, <span class="type">vint32m1_t</span> dest, <span class="type">vint32m1_t</span> op1, <span class="type">vint32m1_t</span> op2);</span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><strong>mask</strong>: 掩码向量，类型为 <code>vbool32_t</code>，控制哪些元素参与运算。</li><li><strong>dest</strong>: 原目标向量，对于未参与计算的元素，将保留此向量中的对应值。</li><li><strong>op1, op2</strong>: 输入向量，表示两个操作数。</li></ul><p><strong>输入</strong>:</p><ul><li><code>op1 = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</code></li><li><code>op2 = &#123;8, 7, 6, 5, 4, 3, 2, 1&#125;</code></li><li><code>mask = &#123;1, 0, 1, 1, 0, 0, 1, 0&#125;</code></li></ul><p><strong>结果</strong>:</p><ul><li>按掩码启用元素计算：<code>&#123;(1+8), 0, (3+6), (4+5), 0, 0, (7+2), 0&#125;</code></li><li>最终结果：<code>&#123;9, 0, 9, 9, 0, 0, 9, 0&#125;</code></li></ul><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">vint32m1_t</span> va, vb, vc;  </span><br><span class="line">        <span class="type">size_t</span> vlmax = __riscv_vsetvlmax_e32m1();</span><br><span class="line">                       </span><br><span class="line">        <span class="type">int32_t</span> ia[N] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int32_t</span> ib[N] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int32_t</span> ic[N] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        va = __riscv_vle32_v_i32m1(ia, N);</span><br><span class="line">        vb = __riscv_vle32_v_i32m1(ib, N);</span><br><span class="line">        vc = __riscv_vadd_vv_i32m1(va, vb, N);</span><br><span class="line">        __riscv_vse32_v_i32m1(ic, vc, N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">unsigned</span> i=<span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ic[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p>在实际应用中，选择 SEW 时需要综合考虑以下因素：</p><ol><li>数据类型（决定了基本的 SEW）。</li><li>精度要求（高精度需要 64 位，性能优先则选择 32 位）。</li><li>硬件资源（寄存器长度和支持的 SEW）。</li><li>并行性能（更小的 SEW 提高并行性，但可能导致精度不足）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算时间差的辅助函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">calc_elapsed_time</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *label, <span class="keyword">struct</span> timespec start, <span class="keyword">struct</span> timespec end)</span> &#123;</span><br><span class="line">  <span class="type">long</span> seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">  <span class="type">long</span> nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">  <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">    --seconds;</span><br><span class="line">    nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s elapsed time: %ld.%09ld seconds\n&quot;</span>, label, seconds, nanoseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index arithmetic</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">index_golden</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = b[i] + (<span class="type">double</span>)i * c[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">index_</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> vlmax = __riscv_vsetvlmax_e32m1();</span><br><span class="line">  <span class="type">vuint32m1_t</span> vec_i = __riscv_vid_v_u32m1(vlmax);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> vl; n &gt; <span class="number">0</span>; n -= vl, a += vl, b += vl, c += vl) &#123;</span><br><span class="line">    vl = __riscv_vsetvl_e64m2(n);</span><br><span class="line"></span><br><span class="line">    <span class="type">vfloat64m2_t</span> vec_i_double = __riscv_vfwcvt_f_xu_v_f64m2(vec_i, vl);</span><br><span class="line"></span><br><span class="line">    <span class="type">vfloat64m2_t</span> vec_b = __riscv_vle64_v_f64m2(b, vl);</span><br><span class="line">    <span class="type">vfloat64m2_t</span> vec_c = __riscv_vle64_v_f64m2(c, vl);</span><br><span class="line"></span><br><span class="line">    <span class="type">vfloat64m2_t</span> vec_a =</span><br><span class="line">        __riscv_vfadd_vv_f64m2(vec_b, __riscv_vfmul_vv_f64m2(vec_c, vec_i_double, vl), vl);</span><br><span class="line">    __riscv_vse64_v_f64m2(a, vec_a, vl);</span><br><span class="line"></span><br><span class="line">    vec_i = __riscv_vadd_vx_u32m1(vec_i, vl, vl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">31</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> seed = <span class="number">0xdeadbeef</span>;</span><br><span class="line">  srand(seed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// data gen</span></span><br><span class="line">  <span class="type">double</span> B[N], C[N];</span><br><span class="line">  gen_rand_1d(B, N);</span><br><span class="line">  gen_rand_1d(C, N);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compute</span></span><br><span class="line">  <span class="type">double</span> golden[N], actual[N];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行黄金实现</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start1</span>, <span class="title">end1</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;start1);</span><br><span class="line">  index_golden(golden, B, C, N);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;end1);</span><br><span class="line">  calc_elapsed_time(<span class="string">&quot;Golden implementation&quot;</span>, start1, end1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行优化实现</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start2</span>, <span class="title">end2</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;start2);</span><br><span class="line">  index_(actual, B, C, N);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;end2);</span><br><span class="line">  calc_elapsed_time(<span class="string">&quot;Vector implementation&quot;</span>, start2, end2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compare</span></span><br><span class="line">  <span class="built_in">puts</span>(compare_1d(golden, actual, N) ? <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;fail&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[^为什么仍需要循环？]: 为什么仍需要循环？向量寄存器长度有限,向量寄存器（例如 RVV 中的 VLEN）有固定的硬件限制。例如，VLEN 是 128、256 或 512 位等。每次操作能处理的元素数量取决于：数据类型的大小 (SEW: Scalar Element Width)。当前配置的 LMUL 倍数。如果数据量 <code>n</code> 超过硬件支持的向量长度，就必须分块处理，循环每次操作一个向量块。<strong>数据长度不一定是向量寄存器的倍数</strong> 数据长度 <code>n</code> 通常不是向量寄存器所能处理的元素数（<code>VLEN / SEW</code>）的整数倍，因此需要动态调整向量长度 (VL) 并处理剩余的尾部数据。<strong>循环有助于动态优化</strong> 向量化可以动态调整每次处理的元素数，利用循环灵活适配各种数据量。</p><h2 id="向量化优化影响要素"><a href="#向量化优化影响要素" class="headerlink" title="向量化优化影响要素"></a>向量化优化影响要素</h2><p><strong>1. 数据对齐 (Data Alignment)</strong></p><p>向量指令通常要求数据在内存中是对齐的（aligned），以便更高效地加载和存储：</p><ul><li><strong>对齐数据</strong>（如 64 位数据按 8 字节对齐）可以显著提高加载&#x2F;存储性能。</li><li><strong>未对齐数据</strong>需要额外处理（例如使用 <code>vle64ff</code> 等指令），可能导致性能下降。</li></ul><p><strong>优化建议</strong>：尽量确保输入数据地址是对齐的，尤其在加载和存储时。</p><p><strong>2. 数据大小与边界处理</strong></p><p>向量化时，处理的数据大小往往不是向量寄存器长度的整数倍：</p><ul><li><strong>完整向量操作</strong>：在主要循环中可以使用完整的向量寄存器。</li><li><strong>尾部处理</strong>：剩余的元素（小于寄存器宽度）需要额外的标量代码或专用尾处理逻辑。RVV 中可以用 <code>vl</code> 动态调整处理的元素数量。</li></ul><p><strong>优化建议</strong>：</p><ul><li>利用 RVV 的动态向量长度特性，通过调整 <code>vl</code> 来处理剩余数据，无需显式的标量处理代码。</li></ul><p><strong>3. 数据依赖 (Data Dependency)</strong></p><ul><li>如果当前迭代的计算依赖于前一迭代的结果（循环相关性），会限制向量化的潜力。</li><li>RVV 提供的<strong>掩码操作</strong>（masking）可以处理部分依赖问题，但性能可能下降。</li></ul><p><strong>优化建议</strong>：尝试重写算法，减少循环相关性或数据依赖。</p><p><strong>4. 向量化指令集的特性</strong></p><ul><li><strong>RVV 的灵活性</strong>：RVV 支持可变长度向量和 SEW，这使得编程灵活性更高，但需要仔细设计循环逻辑以充分利用硬件。</li><li><strong>向量扩展指令</strong>（例如 <code>vfwcvt</code>）：将低精度数据扩展为高精度时会引入额外开销。</li><li><strong>掩码（Mask）操作</strong>：对部分元素操作时使用掩码，但这会降低性能，因为部分元素的计算会被跳过。</li></ul><p><strong>5. 分支与条件判断</strong></p><p>在向量化代码中，分支和条件判断可能导致性能下降：</p><ul><li>RVV 中可以通过掩码指令（masking）处理条件分支，但仍会产生一些冗余操作。</li><li>如果分支逻辑复杂且数据不均匀，可能需要拆分数据进行分别处理。</li></ul><p><strong>优化建议</strong>：</p><ul><li>尽量减少分支逻辑，或将分支替换为掩码操作。</li><li>优化数据布局，使条件判断逻辑更简单。</li></ul><p><strong>6. 向量长度和 LMUL 配置</strong></p><ul><li><p>RVV 的向量寄存器长度（VLEN）和宽度配置（LMUL）会影响并行性能：</p><ul><li><strong>LMUL 增大</strong>（如 <code>m4</code>、<code>m8</code>）：更多寄存器组合，处理更多数据，性能更高，但资源消耗增加。</li><li><strong>LMUL 减小</strong>（如 <code>mf2</code>、<code>mf4</code>）：每次操作处理的元素少，功耗低，但并行度下降。</li></ul></li></ul><p><strong>优化建议</strong>：选择合适的 <code>LMUL</code>，在寄存器使用率和并行度之间找到平衡。</p><p><strong>7. 循环展开 (Loop Unrolling)</strong></p><ul><li>手动展开循环可以减少循环开销（如分支和索引计算），提高性能。</li><li>但循环展开会增加代码复杂度，可能需要调整以适应不同 <code>VLEN</code>。</li></ul><p><strong>优化建议</strong>：根据具体硬件配置展开循环，以充分利用寄存器。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/RVOS%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/12/08/blog_makedown/RVOS%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="RVOS系统"><a href="#RVOS系统" class="headerlink" title="RVOS系统"></a>RVOS系统</h1><p>start.s文件（.s文件是汇编语言源代码文件的扩展，包含了汇编语言代码，直接对应目标处理器的ISA）</p><p>一个典型的.s文件文件包含了以下几个部分：</p><p>数据段：存储程序使用的常量、字符串、数组等数据。</p><p>代码段：存储实际程序指令。</p><p>全局符号和标签：定义程序中的使用的标识符和函数名，供汇编器和链接器使用</p><p><strong>编写一个简单RISC-V的系统</strong></p><p>需要以下几个文件部分：</p><p>platform.h(硬件信息)</p><p>start.s（</p><blockquote><p><strong>初始化堆栈</strong>：为每个 <code>hart</code> 分配堆栈空间，并初始化栈指针 <code>sp</code>。</p><p><strong>挂起非 hart 0 的核心</strong>：通过 <code>wfi</code> 指令将非 <code>hart 0</code> 的核心挂起，直到 <code>hart 0</code> 启动内核。</p><p><strong>设置堆栈对齐</strong>：确保堆栈空间的对齐，以便符合 RISC-V 的 16 字节对齐规则。</p><p><strong>多核心初始化</strong>：通过 <code>hart id</code> 为每个核心分配独立的堆栈空间。）</p></blockquote><p>uart.c(交互显示)</p><blockquote><p>宏定义uart所需要的寄存器。</p><p>uart初始化（打开或者关闭中断，设置串口的数据位、停止位、校验位、禁止波特锁存器)</p><p>定义uart输出函数输入函数</p></blockquote><p>Makefile(编译的构建规则)</p><p>types.h(记录数据类型)</p><p>kernel.c(内核执行文件等同于int main)</p><h2 id="最小RVOS"><a href="#最小RVOS" class="headerlink" title="最小RVOS"></a>最小RVOS</h2><p>platform.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PLATFORM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PLATFORM_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM_CPU 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>start.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;platform.h&quot;</span><br><span class="line">.equ STACK_SIZE ,1024</span><br><span class="line">.global _start</span><br><span class="line">.text</span><br><span class="line">_start:</span><br><span class="line">csrrt0, mhartid# read current hart id</span><br><span class="line">mvtp, t0# keep CPU&#x27;s hartid in its tp for later usage.</span><br><span class="line">bnezt0, park# if we&#x27;re not on the hart 0</span><br><span class="line"># we park the hart</span><br><span class="line"># Setup stacks, the stack grows from bottom to top, so we put the</span><br><span class="line"># stack pointer to the very end of the stack range.</span><br><span class="line">sllit0, t0, 10# shift left the hart id by 1024</span><br><span class="line">lasp, stacks + STACK_SIZE# set the initial stack pointer</span><br><span class="line"># to the end of the first stack space</span><br><span class="line">addsp, sp, t0# move the current hart stack pointer</span><br><span class="line"># to its place in the stack space</span><br><span class="line"></span><br><span class="line">jstart_kernel# hart 0 jump to c</span><br><span class="line"></span><br><span class="line">park:</span><br><span class="line">wfi</span><br><span class="line">jpark</span><br><span class="line"></span><br><span class="line"># In the standard RISC-V calling convention, the stack pointer sp</span><br><span class="line"># is always 16-byte aligned.</span><br><span class="line">.balign 16</span><br><span class="line">stacks:</span><br><span class="line">.skipSTACK_SIZE * MAXNUM_CPU # allocate space for all the harts stacks</span><br><span class="line"></span><br><span class="line">.end# End of file</span><br></pre></td></tr></table></figure><p>uart.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;platform.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_REG(reg) ((volatile uint8_t *)(UART0 + reg))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * UART control registers map. see [1] &quot;PROGRAMMING TABLE&quot;</span></span><br><span class="line"><span class="comment"> * note some are reused by multiple functions</span></span><br><span class="line"><span class="comment"> * 0 (write mode): THR/DLL</span></span><br><span class="line"><span class="comment"> * 1 (write mode): IER/DLM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RHR 0<span class="comment">// Receive Holding Register (read mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THR 0<span class="comment">// Transmit Holding Register (write mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL 0<span class="comment">// LSB of Divisor Latch (write mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER 1<span class="comment">// Interrupt Enable Register (write mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLM 1<span class="comment">// MSB of Divisor Latch (write mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR 2<span class="comment">// FIFO Control Register (write mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR 2<span class="comment">// Interrupt Status Register (read mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR 3<span class="comment">// Line Control Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCR 4<span class="comment">// Modem Control Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5<span class="comment">// Line Status Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSR 6<span class="comment">// Modem Status Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPR 7<span class="comment">// ScratchPad Register</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * POWER UP DEFAULTS</span></span><br><span class="line"><span class="comment"> * IER = 0: TX/RX holding register interrupts are both disabled</span></span><br><span class="line"><span class="comment"> * ISR = 1: no interrupt penting</span></span><br><span class="line"><span class="comment"> * LCR = 0</span></span><br><span class="line"><span class="comment"> * MCR = 0</span></span><br><span class="line"><span class="comment"> * LSR = 60 HEX</span></span><br><span class="line"><span class="comment"> * MSR = BITS 0-3 = 0, BITS 4-7 = inputs</span></span><br><span class="line"><span class="comment"> * FCR = 0</span></span><br><span class="line"><span class="comment"> * TX = High</span></span><br><span class="line"><span class="comment"> * OP1 = High</span></span><br><span class="line"><span class="comment"> * OP2 = High</span></span><br><span class="line"><span class="comment"> * RTS = High</span></span><br><span class="line"><span class="comment"> * DTR = High</span></span><br><span class="line"><span class="comment"> * RXRDY = High</span></span><br><span class="line"><span class="comment"> * TXRDY = Low</span></span><br><span class="line"><span class="comment"> * INT = Low</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LINE STATUS REGISTER (LSR)</span></span><br><span class="line"><span class="comment"> * LSR BIT 0:</span></span><br><span class="line"><span class="comment"> * 0 = no data in receive holding register or FIFO.</span></span><br><span class="line"><span class="comment"> * 1 = data has been receive and saved in the receive holding register or FIFO.</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> * LSR BIT 5:</span></span><br><span class="line"><span class="comment"> * 0 = transmit holding register is full. 16550 will not accept any data for transmission.</span></span><br><span class="line"><span class="comment"> * 1 = transmitter hold register (or FIFO) is empty. CPU can load the next character.</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE  (1&lt;&lt;5)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* disable interrupts. */</span></span><br><span class="line">uart_write_reg(IER, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setting baud rate. Just a demo here if we care about the divisor,</span></span><br><span class="line"><span class="comment"> * but for our purpose [QEMU-virt], this doesn&#x27;t really do anything.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notice that the divisor register DLL (divisor latch least) and DLM (divisor</span></span><br><span class="line"><span class="comment"> * latch most) have the same base address as the receiver/transmitter and the</span></span><br><span class="line"><span class="comment"> * interrupt enable register. To change what the base address points to, we</span></span><br><span class="line"><span class="comment"> * open the &quot;divisor latch&quot; by writing 1 into the Divisor Latch Access Bit</span></span><br><span class="line"><span class="comment"> * (DLAB), which is bit index 7 of the Line Control Register (LCR).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Regarding the baud rate value, see [1] &quot;BAUD RATE GENERATOR PROGRAMMING TABLE&quot;.</span></span><br><span class="line"><span class="comment"> * We use 38.4K when 1.8432 MHZ crystal, so the corresponding value is 3.</span></span><br><span class="line"><span class="comment"> * And due to the divisor register is two bytes (16 bits), so we need to</span></span><br><span class="line"><span class="comment"> * split the value of 3(0x0003) into two bytes, DLL stores the low byte,</span></span><br><span class="line"><span class="comment"> * DLM stores the high byte.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> lcr = uart_read_reg(LCR);</span><br><span class="line">uart_write_reg(LCR, lcr | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>));</span><br><span class="line">uart_write_reg(DLL, <span class="number">0x03</span>);</span><br><span class="line">uart_write_reg(DLM, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Continue setting the asynchronous data communication format.</span></span><br><span class="line"><span class="comment"> * - number of the word length: 8 bits</span></span><br><span class="line"><span class="comment"> * - number of stop bits：1 bit when word length is 8 bits</span></span><br><span class="line"><span class="comment"> * - no parity</span></span><br><span class="line"><span class="comment"> * - no break control</span></span><br><span class="line"><span class="comment"> * - disabled baud latch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">lcr = <span class="number">0</span>;</span><br><span class="line">uart_write_reg(LCR, lcr | (<span class="number">3</span> &lt;&lt; <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_putc</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> ((uart_read_reg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> uart_write_reg(THR, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_puts</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (*s) &#123;</span><br><span class="line">uart_putc(*s++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_getc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((uart_read_reg(LSR) &amp; LSR_RX_READY) ==<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="type">char</span>)uart_read_reg(RHR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_gets</span><span class="params">(<span class="type">char</span> *buffer)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;  <span class="comment">// 初始化变量</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; BUFFER_SIZE - <span class="number">1</span>) &#123;  <span class="comment">// 防止缓冲区溢出</span></span><br><span class="line">        ch = uart_getc();  <span class="comment">// 获取一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span> || ch == <span class="string">&#x27;\r&#x27;</span>) &#123;  <span class="comment">// 如果是换行或回车</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 结束输入</span></span><br><span class="line">        &#125;</span><br><span class="line">        buffer[i++] = ch;  <span class="comment">// 将字符存入缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    buffer[i] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 确保字符串以 &#x27;\0&#x27; 结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>types.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TYPES_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TYPES_H__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>kernel.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">uart_puts</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">uart_gets</span><span class="params">(<span class="type">char</span> *buffer)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> chr[<span class="number">100</span>];</span><br><span class="line">uart_init();</span><br><span class="line">uart_puts(<span class="string">&quot;Hello, RVOS!\n&quot;</span>);</span><br><span class="line">uart_gets(chr);</span><br><span class="line">uart_puts(<span class="string">&quot;Echo:&quot;</span>);</span><br><span class="line">uart_puts(chr);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125; <span class="comment">// stop here!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存管理分类：</p><p>自动管理内存-Stack</p><p>静态内存-全局变量&#x2F;静态变量</p><p>动态管理内存-堆(heap)</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/751178c88f2dfa909fbe84702fcdb331.png"></p><p>总体流程如下：</p><ol><li><p><strong>内存初始化</strong>：启动时划分内存区域，生成管理结构（链表或位图）。</p></li><li><p><strong>内存分配</strong>：根据算法分配内存块，并在需要时拆分大块。</p></li><li><p><strong>内存释放</strong>：释放后合并相邻块以减少碎片。</p></li><li><p><strong>内存碎片整理</strong>：定期合并空闲块，防止碎片化。</p></li><li><p><strong>内存保护</strong>：使用 MMU&#x2F;MPU 实现任务间内存隔离。</p></li><li><p><strong>监控与调试</strong>：提供工具查看内存使用状况，调试内存管理问题</p><p>更多资料：<a href="https://cloud.tencent.com/developer/article/2337435">从零手写操作系统之RVOS内存管理模块简单实现-02-腾讯云开发者社区-腾讯云</a></p></li></ol><h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><p>异常是同步的，由所执行指令触发的，中断是异步的，是由外部设备的事件触发的。中断与被中断的指令及进程无直接关联，异常关联被中断的指令与进程，异常的处理可能会<code>阻塞杀死</code>本进程.</p><p><strong>中断分类：</strong></p><ol><li>软中断</li><li>定时中断</li><li>外部中断</li></ol><p><strong>中断采用的寄存器(RISCV)：</strong></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/67d898ccd0d873c9ba7931d2430807e8.png"></p><p><img src="https://img.picgo.net/2024/11/08/8f7dc42c83e3fb91bfeeb01a7abc625abcfcae5e8be8adef.png" alt="中断"></p><p>更多中断详细资料可看：<a href="https://cloud.tencent.com/developer/article/2337437">从零手写操作系统之RVOS外设中断实现-04-腾讯云开发者社区-腾讯云</a></p><p>中断信号转换和汇聚由<strong>PILC</strong>（中断平台控制器，<code>Platform-Level Interrupt Controller</code>）完成。</p><p><strong>PILC是RISCV架构中特有的存在。</strong></p><blockquote><p>在其他架构上，中断控制器的实现有所不同。例如：</p><ul><li><strong>ARM架构</strong>：使用 GIC（Generic Interrupt Controller，通用中断控制器）。</li><li><strong>x86架构</strong>：使用 APIC（Advanced Programmable Interrupt Controller，高级可编程中断控制器）或传统的 PIC（Programmable Interrupt Controller）。</li><li><strong>MIPS架构</strong>：有自己的中断控制机制。</li></ul></blockquote><p>每个 PLIC 包含 2 个 32 位的 Pending 寄存器，每一个 bit 对应一个中断源，如果为 1 表示该中断源上发生了中断（进入Pending 状态），有待 hart 处理，否则表示该中断源上当前无中断发生。<br>Pending 寄存器中断的 Pending 状态可以通过 claim 方式清除。<br>第一个 Pending 寄存器的第 0 位对应不存在的 0 号中断源，其值永远为 0。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/c011ea8939e708b07b8edb7c89c75ec5.png"></p><h3 id="uart中断"><a href="#uart中断" class="headerlink" title="uart中断"></a>uart中断</h3><p>Linux系统上，<strong>UART的中断机制通常支持接收中断、数据寄存器空、发送完成中断</strong>。</p><ol><li><strong>接收完成中断（Receive Complete Interrupt）</strong></li></ol><ul><li><strong>作用</strong>：当 UART 接收到一个字节的数据并存储在接收数据寄存器中时，会触发接收完成中断。操作系统可以通过这个中断来读取数据。</li><li><strong>硬件寄存器</strong>：接收完成中断通常基于 UART 接收数据寄存器（如 <code>RXD</code>）中的数据填充，硬件会设置一个标志位（如 <code>RXC</code>）表示接收到新数据。</li><li><strong>Linux 驱动</strong>：在 Linux 中，串口驱动通常会监听这个中断，当接收到数据时，通过 <code>tty</code> 驱动将数据从接收寄存器读取到内核缓冲区。</li><li>会在每接收到一个字节后触发一次，直到所有字节都读完，关于多字节的处理，可以采用DMA或者中断合并机制来减少中断次数，可中断一次处理多个字节数据。或者某平台提供接收FIFO缓冲区，这种情况下接收中断会在FIFO缓冲区满时候触发中断。</li></ul><ol start="2"><li><strong>数据寄存器空中断（Data Register Empty Interrupt）</strong></li></ol><ul><li><strong>作用</strong>：当 UART 的发送数据寄存器空闲时，会触发数据寄存器空中断。通常情况下，硬件会根据 <code>TXD</code> 寄存器的状态设置一个标志（如 <code>TXE</code>）来表示发送缓冲区为空。</li><li><strong>硬件寄存器</strong>：当发送数据寄存器为空时，硬件会通过设置 <code>TXE</code>（Transmit Empty）标志来触发中断。驱动程序可以通过这个中断写入新的数据到发送寄存器。</li><li><strong>Linux 驱动</strong>：Linux 串口驱动通过 <code>uart</code> 驱动程序监听此中断，一旦发送寄存器空，驱动会将缓冲区中的数据写入发送寄存器，继续数据发送。</li></ul><ol start="3"><li><strong>发送完成中断（Transmit Complete Interrupt）</strong></li></ol><ul><li><strong>作用</strong>：当 UART 完成数据的发送（即所有数据已从发送数据寄存器传输到硬件并已送出）时，会触发发送完成中断。通常，这是一个可选的中断，取决于硬件设计。</li><li><strong>硬件寄存器</strong>：发送完成中断可能通过 <code>TXC</code>（Transmit Complete）标志来触发，表示所有数据已经发送完毕。</li><li><strong>Linux 驱动</strong>：这个中断常用于确认所有数据已经成功发送并清空相关状态，驱动程序通常会通过中断来完成后续任务，如通知应用程序或管理发送队列。</li></ul><h2 id="多任务切换"><a href="#多任务切换" class="headerlink" title="多任务切换"></a>多任务切换</h2><p>参考资料：</p><p><a href="https://cloud.tencent.com/developer/article/2337436">从零手写操作系统之RVOS协作式多任务切换实现-03-腾讯云开发者社区-腾讯云</a></p><p><a href="https://cloud.tencent.com/developer/article/2337439">从零手写操作系统之RVOS抢占式多任务实现-06-腾讯云开发者社区-腾讯云</a></p><p>多任务切换机制分为以下几种：</p><blockquote><p>1.协作式多任务切换（Cooperative Multitasking）</p><p>在协作式多任务切换中，任务需要<strong>主动让出 CPU</strong>，即任务自身在某个执行点上调用“让出 CPU”的指令（例如 <code>yield()</code>），切换到其他任务。任务切换通常发生在任务完成一个工作单元或者进入等待状态的时候。</p><ul><li><strong>实现方式</strong>：任务执行到安全点时调用让出函数，触发上下文切换。</li><li><strong>优点</strong>：实现简单，适合嵌入式系统，任务可以控制自己的切换点。</li><li><strong>缺点</strong>：如果某个任务没有主动让出 CPU，其他任务会处于“饥饿”状态。</li></ul><ol start="2"><li>抢占式多任务切换（Preemptive Multitasking）</li></ol><p>在抢占式多任务切换中，系统通过<strong>定时器中断</strong>等硬件机制强制让任务让出 CPU，确保各任务可以在固定的时间片内执行，保证调度公平性。</p><ul><li><strong>实现方式</strong>：通过定时器中断周期性触发任务切换，当前任务的状态被保存，切换到下一个任务。</li><li><strong>优点</strong>：公平性强，任务不需要主动让出 CPU，因此不会出现某个任务长期占用 CPU 的情况。</li><li><strong>缺点</strong>：实现较为复杂，通常需要硬件支持。</li></ul><ol start="3"><li>时间片轮转调度（Round-Robin Scheduling）</li></ol><p>时间片轮转调度是一种基于<strong>时间片</strong>的抢占式调度。每个任务按照顺序在 CPU 上执行一个固定的时间片，到期后切换到下一个任务。</p><ul><li><strong>实现方式</strong>：为每个任务分配一个时间片，到期时通过定时器中断切换到下一个任务。</li><li><strong>优点</strong>：简单公平，所有任务轮流执行，避免任务饥饿。</li><li><strong>缺点</strong>：对于短任务，可能会出现较高的切换开销。</li></ul><ol start="4"><li>优先级调度（Priority-Based Scheduling）</li></ol><p>在优先级调度中，系统根据任务的优先级来选择执行的任务。通常由抢占式机制实现，高优先级任务可以<strong>中断低优先级任务</strong>来获得 CPU 资源。（可以是抢占的或者非抢占的）</p><ul><li><strong>实现方式</strong>：任务被分配优先级，当新的高优先级任务需要执行时，中断当前任务。</li><li><strong>优点</strong>：高优先级任务能及时得到执行，适合实时系统。</li><li><strong>缺点</strong>：可能导致“优先级反转”或“低优先级任务饥饿”。</li></ul><ol start="5"><li>实时调度（Real-Time Scheduling）</li></ol><p>实时调度是一种基于任务的<strong>时间约束</strong>的调度方法。分为<strong>硬实时</strong>和<strong>软实时</strong>两类：</p><ul><li><strong>硬实时</strong>：必须在严格的时间内完成任务，否则可能会导致系统失败。</li><li><strong>软实时</strong>：尽量在一定时间内完成任务，但允许一定的延迟。</li><li><strong>实现方式</strong>：基于优先级或时间片调度，结合任务的时间约束来决定切换。</li></ul><ol start="6"><li>分时调度（Time-Sharing Scheduling）</li></ol><p>分时调度让多个用户或任务<strong>共享 CPU 时间</strong>。每个任务得到的时间片较长，适合交互式操作，让用户感到系统始终在响应。</p><ul><li><strong>实现方式</strong>：为每个任务分配较长的时间片，在时间片到期后切换任务。</li><li><strong>优点</strong>：用户感到操作流畅，适合交互式系统。</li><li><strong>缺点</strong>：不能保证实时性，不适合对响应时间要求严格的应用。</li></ul><ol start="7"><li>双核或多核系统的任务切换（Multicore Scheduling）</li></ol><p>在双核或多核系统中，任务切换不仅发生在单个 CPU 内核上，还可以跨多个内核调度。调度器需决定任务在各个内核之间的分配和切换，通常实现更复杂的并行调度机制。</p><ul><li><strong>实现方式</strong>：分布式调度，多个内核各自执行任务切换，或者统一调度器分配任务到各个内核。</li><li><strong>优点</strong>：高效利用多核资源，提升系统并发能力。</li><li><strong>缺点</strong>：任务在多个内核间切换有开销，需考虑负载均衡和内核间通信。</li></ul></blockquote><table><thead><tr><th>特点</th><th>协作式任务切换中的 trap handler</th><th>抢占式任务切换中的 trap handler</th></tr></thead><tbody><tr><td><strong>触发方式</strong></td><td>由任务主动调用（如 <code>yield()</code>）</td><td>由定时器中断强制触发</td></tr><tr><td><strong>trap handler 的使用频率</strong></td><td>取决于任务调用频率，任务在特定点自愿放弃 CPU</td><td>频率固定，由定时器中断控制</td></tr><tr><td><strong>上下文切换时机</strong></td><td>当任务执行到 <code>yield()</code> 或自愿让出 CPU 时</td><td>时间片到期强制切换</td></tr><tr><td><strong>任务切换的控制权</strong></td><td>任务自身控制，让出 CPU</td><td>系统控制，定时器到期强制切换</td></tr><tr><td><strong>可靠性和实时性</strong></td><td>较低，可能出现长时间占用 CPU 的任务</td><td>较高，任务被固定时间片切换，保证实时性</td></tr></tbody></table><p>在RISC-V架构中，Trap Handler的定位是通过一系列的硬件寄存器来实现的。当发生异常（exception）或中断（interrupt）时，CPU会自动跳转到一个预定义的地址，这个地址是通过机器模式的控制和状态寄存器（CSRs）中的MTVEC（Machine Trap Base Address）寄存器来配置的。当Trap发生时，CPU会读取MTVEC寄存器中的值作为中断服务例程（ISR）的入口点，并跳转到该处执行相应的中断处理逻辑。</p><p>此外，为了能够处理不同类型的中断和异常，RISC-V提供了MCause（Machine Cause）寄存器来指示触发Trap的具体原因，以及MEPC（Machine Exception Program Counter）寄存器来记录导致Trap的指令地址。这些机制确保了操作系统能够准确地响应和处理各种硬件和软件引起的中断事件。</p><p><strong>Trap Handler的工作机制</strong></p><p>当 RISC-V CPU 遇到异常或中断时，会自动跳转到 trap handler 执行。以下是详细的执行步骤：</p><p><strong>1.检测和保存当前状态</strong></p><ul><li><p><strong>触发 trap</strong>：当硬件中断、软件中断、异常或系统调用发生时，CPU 会触发 trap，并自动切换到 Machine Mode（M 模式）。</p></li><li><p><strong>保存程序计数器</strong>：CPU 会将触发 trap 的指令地址保存到 <code>mepc</code> 寄存器中，以便在完成处理后能够恢复到正确的执行位置。</p></li><li><p>记录 trap 原因</p><p>：CPU 将 trap 的具体原因记录到 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mcause</span><br></pre></td></tr></table></figure><p> 寄存器中。该寄存器的值分为两部分：</p><ul><li>最高位：0 表示异常，1 表示中断。</li><li>低位：表示异常或中断的具体类型，例如指令地址错误、非法指令或定时器中断等。</li></ul></li><li><p><strong>存储 trap 值</strong>：在某些异常中，CPU 会将 trap 相关的附加信息存储到 <code>mtval</code> 寄存器中（如发生地址错误时，存储异常的具体地址）。</p></li></ul><p><strong>2.定位 trap handler 地址</strong></p><ul><li><strong>读取 mtvec 寄存器</strong>：<code>mtvec</code> 寄存器存储了 trap handler 的入口地址。它有两种模式：直接模式和向量模式。<ul><li><strong>直接模式（Direct Mode）</strong>：所有 trap 都会跳转到 <code>mtvec</code> 指定的单一地址（通常是操作系统的通用 trap handler 地址）。</li><li><strong>向量模式（Vectored Mode）</strong>：不同的中断类型跳转到不同的地址，即 <code>mtvec</code> 基地址加上中断类型编号偏移量，从而实现更高效的 trap 处理。</li></ul></li><li><strong>跳转到 trap handler</strong>：根据 <code>mtvec</code> 中的地址，CPU 跳转到相应的 trap handler，开始执行具体的处理逻辑。</li><li><strong>3.执行 trap handler</strong></li></ul><p>在 trap handler 中，操作系统会根据 trap 的具体类型执行不同的操作：</p><ul><li><p><strong>保存当前上下文</strong>：trap handler 会将当前任务的 CPU 状态（包括通用寄存器）保存到内核栈中。保存上下文的操作通常会通过汇编完成，以确保在被打断的任务恢复后可以继续执行。</p></li><li><p>判断 trap 类型</p><p>：操作系统读取 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mcause</span><br></pre></td></tr></table></figure><p> 寄存器来判断 trap 的类型，以执行适当的处理。</p><ul><li><strong>时钟中断</strong>：用于周期性触发任务调度器，进行任务切换。</li><li><strong>外部中断</strong>（如 I&#x2F;O 中断）：用于处理来自外部设备的请求。</li><li><strong>系统调用</strong>：trap handler 识别出系统调用后，会根据调用编号来执行相应的操作（如文件读写、内存分配）。</li><li><strong>异常处理</strong>：如果是非法指令或地址错误等异常，操作系统可能会终止任务或记录错误信息。</li></ul></li><li><p><strong>执行特定处理逻辑</strong>：根据 trap 类型，调用相应的处理函数。对于中断，可能是完成 I&#x2F;O 操作；对于时钟中断，可能是触发任务调度；对于系统调用，执行用户进程请求的系统服务。</p></li></ul><p><strong>4.恢复上下文</strong></p><p>在完成 trap 处理后，trap handler 会恢复被打断的任务上下文：</p><ul><li><strong>恢复通用寄存器</strong>：trap handler 从内核栈中将保存的寄存器值恢复到通用寄存器。</li><li><strong>恢复程序计数器</strong>：将 <code>mepc</code> 中保存的地址恢复到 <code>PC</code>，确保任务能够从中断或异常发生的位置继续执行。</li></ul><p><strong>5.返回到用户模式（或被打断的权限模式）</strong></p><ul><li><p>关闭 Machine Mode 并返回</p><p>：在恢复完上下文后，trap handler 使用 <code>mret</code> 指令（Machine Mode Return）从 Machine Mode 返回到之前的执行模式（通常是用户模式）。</p><ul><li><code>mret</code> 指令会将 <code>mepc</code> 中的地址载入 <code>PC</code>，从而让被打断的程序继续执行。</li><li>如果任务处于用户模式，则会回到用户模式继续执行。</li></ul></li></ul><p>关键寄存器在 trap handler 中的作用总结</p><table><thead><tr><th>寄存器</th><th>作用</th></tr></thead><tbody><tr><td><code>mstatus</code></td><td>保存和恢复 CPU 状态、管理中断使能</td></tr><tr><td><code>mtvec</code></td><td>指定 trap handler 的入口地址</td></tr><tr><td><code>mepc</code></td><td>保存被打断指令的地址</td></tr><tr><td><code>mcause</code></td><td>记录 trap 的原因（中断或异常类型）</td></tr><tr><td><code>mtval</code></td><td>存储与异常相关的具体信息</td></tr><tr><td><code>mie/mip</code></td><td>管理中断的使能和挂起状态</td></tr></tbody></table><h2 id="软件定时器和硬件定时器"><a href="#软件定时器和硬件定时器" class="headerlink" title="软件定时器和硬件定时器"></a>软件定时器和硬件定时器</h2><p>tick是计算机系统中的一个基本时间单位，尤其常见于操作系统的时间管理和任务调度。每一个tick代表一个固定的时间间隔。</p><p>硬件定时是指利用硬件定时器（硬件晶振来提供时钟周期）来精确地控制和测量时间。提供高精度的时间测量与控制。</p><p>CLINT（Core Local Interruptor，核心本地中断控制器）是RISCV架构中的另一个中断控制器负责处理核心本地中断，包括软件中断和定时器中断。</p><p><code>mtimecmp</code>（Machine Timer Compare Register）</p><p><code>mtimecmp</code> 是一个定时器比较寄存器，用于定时器中断。每个内核都有一个 <code>mtimecmp</code> 寄存器，通过设置它的值可以控制定时器中断的触发时刻。</p><ul><li><strong>作用</strong>：当 <code>mtime</code> 的值大于或等于 <code>mtimecmp</code> 时，将触发定时器中断。要取消定时器中断，可以将 <code>mtimecmp</code> 设置为一个大于 <code>mtime</code> 的值。</li></ul><p> <code>mtime</code>（Machine Time Register）</p><p><code>mtime</code> 是机器时间寄存器，保存着系统自启动以来的时间计数值（通常以周期计时）。<code>mtime</code> 会不断递增，通常由一个外部时钟源驱动。</p><ul><li><strong>作用</strong>：保存系统当前时间计数值，单位为时钟周期。<code>mtime</code> 是只读的。</li></ul><h3 id="硬件定时流程"><a href="#硬件定时流程" class="headerlink" title="硬件定时流程"></a>硬件定时流程</h3><p><img src="https://img.picgo.net/2024/11/08/0a9e2df33a8db24915751d3e7e5f32c2f068be6623416e0d.png" alt="硬件定时"></p><p>软件中断</p><p>软件定时器的设计流程：</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/d83ed6635e98a81480e1fa3bdba9a407.png"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>RISCV支持三种模式：simple embedded systems，secure embedded systems ，systems running Unix-like operating systems。</p><p>系统模式：用户态和内核态，想让系统开始跑在用户态就要设置对应的寄存器。</p><p>首先在之前.s启动文件中，设置了mstatus的寄存器MPP位和MPIE为1</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/3fbbd0b142bb0b1679d7632ae6282f6e.png"></p><p>mstatus寄存器不进行设置就是0，所以进入用户态就是MPP位不设置。</p><p>RISC-V处于安全考虑，不允许用户态程序直接执行部分特权指令，因此只能采用间接的方式进行访问，也就是通过系统调用的方式进行特权资源访问。</p><p><strong>所谓系统调用，就是通过一条特殊的ecall指令，帮助我们从用户态切换到内核态执行，然后通过一条eret指令，从内核态再切换回用户态执行:</strong></p><p><strong>系统调用执行流程</strong></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/16b817365142f6c92a132a1fdcd05e52.png"></p><h2 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h2><h3 id="加电自检"><a href="#加电自检" class="headerlink" title="加电自检"></a>加电自检</h3><p>初始化BIOS</p><p>检查CPU</p><p>寄存器</p><p>检查BIOS代码的完整性</p><p>检查DMA、timer、interrupt controller</p><p>检查系统内存</p><p>检查总线和外部设备</p><p><strong>RISCV开发板Linux启动流程</strong></p><p>-板子上电后，CPU从固定地址运行ROM中的代码</p><p>-ROM包含简单的设备驱动，从flash或者SD卡加载bootloader</p><p>-再由bootloader加载内核、initramfs等到内存，跳转到Linux内核启动</p><p><img src="https://img.picgo.net/2024/11/11/-173d63b3e456e669b.png" alt="药品养护流程图 (1)"></p><p><a href="https://tinylab.org/riscv-uefi-part1/">RISC-V UEFI 架构支持详解，第 1 部分 - OpenSBI&#x2F;U-Boot&#x2F;UEFI 简介 - 泰晓科技</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/llvm/"/>
      <url>/2024/12/08/blog_makedown/llvm/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title：llvm入门"><a href="#title：llvm入门" class="headerlink" title="title：llvm入门"></a>title：llvm入门</h2><h1 id="LLVM概念"><a href="#LLVM概念" class="headerlink" title="LLVM概念"></a>LLVM概念</h1><p>LLVM编译器是基于模块化、可扩展化的设计，将编译器过程分为多个阶段，而gcc编译器则是集成了多个前端和后端的传统编译器，设计更紧密一体化。</p><p>LLVM编译器因具有高度模块化的中间表示IR为基础，具有能实现更细粒度的优化。</p><p>LLVM结构</p><p>前端解析源代码，检查错误，并构建特定语言的抽象语法树(AST)来表示输入代码。AST额可以选择转换为新的表示形式来进行优化。</p><p>优化器负责进行各种转换以尝试提高代码的运行时间，例如消除冗余计算</p><p>后端将代码映射到目标指令集。除了编写正确代码之外，它还负责生成利用受支持架构的不寻常的功能的良好代码。后端常见部分包括指令选择、寄存器分配和指令调度。</p><p><img src="https://img.picgo.net/2024/11/28/-2024-11-28-11415752d6b1a600dbeb82.png" alt="屏幕截图 2024 11 28 114157"></p><h1 id="编译构建LLVM"><a href="#编译构建LLVM" class="headerlink" title="编译构建LLVM"></a>编译构建LLVM</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#git克隆LLVM-project</span></span></span><br><span class="line">git clone --depth 10 https://github.com/llvm/llvm-project.git </span><br><span class="line">git chectout 19.1.3</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;Unix Makefiles&quot; \</span><br><span class="line">    -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">    -DLLVM_ENABLE_PROJECTS=&quot;clang;lld;mlir&quot; \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=/opt/llvm19 \</span><br><span class="line">    /home/riscv/llvm-project/llvm  ##工程下的llvm目录</span><br><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br><span class="line">sudo vi ~/.bashrc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#add</span></span> </span><br><span class="line">  export PATH=$PATH:/opt/llvm19/bin</span><br><span class="line">source ~/.bashrc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># version find</span></span></span><br><span class="line">llvm-config --version</span><br></pre></td></tr></table></figure><h2 id="LLVM常用命令"><a href="#LLVM常用命令" class="headerlink" title="LLVM常用命令"></a>LLVM常用命令</h2><p><img src="https://img.picgo.net/2024/11/28/xiangguanput824ea8c179d62cff.png" alt="xiangguanput"></p><p><code>.ll</code> 文件是 <strong>LLVM汇编语言格式</strong>的源代码文件，它是LLVM中间表示的一种文本格式，通常用于人类阅读和调试。它与机器代码无关，旨在展示程序的逻辑和结构，适用于编译、优化以及生成目标代码的各个阶段。</p><p><code>.bc</code> 文件是 <strong>LLVM Bitcode</strong> 文件，它是LLVM IR的二进制表示格式。<code>.bc</code> 是平台无关的二进制格式，适用于编译过程中的中间步骤。<code>.bc</code> 文件通常用于优化、链接和跨平台处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-as： 将IR文件编译为二进制文件，默认生成后缀名为.bc的文件，也可以使用-o指定输出:</span></span></span><br><span class="line">llvm-as -o hello hello.ll</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-dis 将二进制生成IR文件生成.ll后缀文件</span></span></span><br><span class="line">llvm-dis hello</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llc将.ll或.bc文件编译成汇编文件，输出.s文件</span></span></span><br><span class="line">llc hello.ll</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#将.ll或.bc文件编译为汇编文件,输出后缀名为.s文件</span></span></span><br><span class="line">lli hello.bc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-link将多个LLVM的二进制文件合并为一个二进制文件</span></span></span><br><span class="line">llvm-link -o hello hello.bc bye.bc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-diff对比两个文件的区别,可以用来比较.ll文件和LLVM的二进制文件</span></span></span><br><span class="line">llvm-diff hello1.ll hello2.ll</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-nm:列出LLVM二进制文件或静态库文件的符号表</span></span></span><br><span class="line">llvm-nm hello.a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-ar:创建静态库,值得注意的是llvm-ar会创建一个新的符号表来统一记录静态库中所有的成员，这有助于提升速度</span></span></span><br><span class="line">llvm-ar r hello.a hello.bc bye.bc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#opt是LLVM的优化器和分析器，输入LLVM源文件，会对其进行优化或分析，然后输出优化文件或分析结果。</span></span></span><br><span class="line">opt [options] &lt;input-file&gt; -o &lt;output-file&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#[options]：指定一个或多个要应用的优化 Pass。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#&lt;input-file&gt;：输入的 LLVM IR 文件（可以是 .bc 或 .ll 格式）。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#-o &lt;output-file&gt;：指定优化后的输出文件。</span></span></span><br></pre></td></tr></table></figure><h1 id="Clang前端"><a href="#Clang前端" class="headerlink" title="Clang前端"></a>Clang前端</h1><p>目录：<code>llvm-project/clang/</code></p><ul><li>预处理：头文件以及宏的处理</li><li>词法分析：词法分析器的任务是从左向右逐行扫描源程序的字符，识别除哥哥单词并确定单词的类型，将识别出的单词转换成同意的机内表示————词法单元形式。</li><li>语法分析：主要任务是从词法分析器输出的token序列中识别除各类短语，并构造语法分析树。如果输入字符串的哥哥单词敲好自左至右地站在分析树的各个节点上，那么这个词串就是该语言的一个句子，语法分析树描述了句子的语法结构</li><li>语义分析：收集标识符的属性信息与语义检查。表示符的属性包括种属，类型，存储位置和长度、值、作用域、参数和返回值类型。语义检查包括变量或过程未经声明就是用，重复声明、运算分量类型不匹配、操作符与操作数之间类型不匹配。</li><li>代码生成:将AST转换成相依的LLVM代码。</li></ul><h1 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h1><p>高级语言经过Clang等前端解析为平台无关的中间表示(<strong>IR</strong>),使编译器能够在编译、链接以及代码生成的各个阶段忽略语言特性，进行全面优化分析。LLVM的各种pass都是作用在LLVM IR上的，通常设计一门语言就是生成一个语言的编译器前端Clang即可。</p><p>LLVM IR三种表示形式：</p><ul><li><p>内存中的表示形式，如BasicBlock，Instruction这种cpp类；</p></li><li><p>bitcode形式，这是序列化的二进制表示形式</p></li><li><p>LLVM汇编文件形式，也是序列化的表达形式。</p></li></ul><p>IR表达：</p><ul><li>Module类，Module可以理解一个完整的编译单元。一般来说，这个编译单元就是个源码文件，如一个后缀为cpp的源文件</li><li>Function类，对一个函数单元，两种情况分别是函数定义和函数声明。</li><li>BasticBlock类，表示一个基本代码块（就是一段没有控制流逻辑的基本流程）</li><li>Instruction类，指令类就是LLVM中定义的基本操作。</li></ul><h2 id="控制流程图"><a href="#控制流程图" class="headerlink" title="控制流程图"></a>控制流程图</h2><p>在LLVM的编译和优化过程中，控制流图用来描述函数或程序的执行顺序和控制流结构。它帮助LLVM分析每个基本块（Basic Block）之间的跳转关系，从而进行各种优化，如死代码消除、循环展开、常量传播等。</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = foo(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result:%d\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编译器生成LLVM IR</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -emit-llvm program.c -o program.ll</span><br></pre></td></tr></table></figure><p><code>-S</code> 选项表示编译为汇编语言（但这里是LLVM IR汇编格式）。</p><p><code>-emit-llvm</code> 告诉 <code>clang</code> 生成LLVM IR，而不是机器代码。</p><p><code>program.c</code> 是你编写的C源代码文件。</p><p><code>program.ll</code> 是输出的LLVM IR文件。</p><ol start="2"><li>使用llvm-opt 工具查看LLVM IR 控制流的结构图(每个版本的都不一样,使用的是LLVM19.1.4)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opt --dot-regions program.ll</span><br><span class="line"></span><br><span class="line">dot -Tpng program.dot -o program.png</span><br></pre></td></tr></table></figure><blockquote><p>LLVM19.1.4的opt工具是有问题的，生成多个dot图形文件时候都报错，这版的开发工具并不完善。唯一不报错的就是–dot-regions 选项了</p></blockquote><h2 id="中间优化遍"><a href="#中间优化遍" class="headerlink" title="中间优化遍"></a>中间优化遍</h2><p>目录：<code>llvm-project/llvm/lib/Transforms/</code></p><ul><li>Analysis Passes</li><li>Transform Passes</li><li>Unility Passes</li></ul><p><a href="https://llvm.org/docs/Passes.html">https://llvm.org/docs/Passes.html</a></p><h3 id="Pass管理器"><a href="#Pass管理器" class="headerlink" title="Pass管理器"></a>Pass管理器</h3><p><a href="https://llvm.org/docs/NewPassManager.html">https://llvm.org/docs/NewPassManager.html</a></p><h1 id="LLVM后端"><a href="#LLVM后端" class="headerlink" title="LLVM后端"></a>LLVM后端</h1><p>目录位置：<code>llvm-project/llvm/lib/Target/</code></p><p>LLVM后端主要功能是代码生成，所以也叫代码生成器，负责将LLVM IR 转换特定目标架构的机器代码。</p><p>用于实现本机代码生成的各个阶段的目标无关算法。此代码位于lib&#x2F;CodeGen中。</p><p>目标独立JIT组件。LLVM JIT完全独立于目标。</p><p>在代码生成过程中，LLVM 后端会根据目标硬件平台的特性和要求，将 LLVM IR 转换为适合该平台的机器码或汇编语言。这个过程涉及到指令选择（Instruction Selection）、寄存器分配（Register Allocation）、指令调度（Instruction Scheduling）等关键步骤，以确保生成的目标代码在目标平台上能够高效运行。</p><h2 id="LLVM-后端-Pass"><a href="#LLVM-后端-Pass" class="headerlink" title="LLVM 后端 Pass"></a>LLVM 后端 Pass</h2><p>整个后端流水线涉及到四种不同层次的指令表示，包括：</p><ul><li>内存中的 LLVM IR：LLVM 中间表现形式，提供了高级抽象的表示，用于描述程序的指令和数据流。</li><li>SelectionDAG 节点：在编译优化阶段生成的一种抽象的数据结构，用以表示程序的计算过程，帮助优化器进行高效的指令选择和调度。</li><li>Machinelnstr：机器相关的指令格式，用于描述特定目标架构下的指令集和操作码。</li><li>MCInst：机器指令，是具体的目标代码表示，包含了特定架构下的二进制编码指令。</li></ul><p>不是重点操作目标，详情请看<a href="https://www.cnblogs.com/ZOMI/articles/18558930">【AI系统】LLVM 后端代码生成 - ZOMI酱酱 - 博客园</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>前端阶段</li></ol><ul><li>词法分析（Lexical Analysis）：源代码被分解为词法单元，如标识符、关键字和常量。</li><li>语法分析（Syntax Analysis）：词法单元被组织成语法结构，构建抽象语法树（AST）。</li><li>语义分析（Semantic Analysis）：AST 被分析以确保语义的正确性和一致性。</li></ul><ol><li>中间表示（IR）阶段</li></ol><ul><li>将 AST 转化为中间表示（IR），采用 SSA 形式的三地址指令表示代码结构。</li><li>通过多段 pass 进行代码优化，包括常量传播、死代码消除、循环优化等，以提高代码性能和效率。</li><li>IR 进一步转化为 DAG 图，其中每个节点代表一个指令，边表示数据流动。</li></ul><ol><li>后端阶段</li></ol><ul><li>指令选择（Instruction Selection）：根据目标平台特性选择合适的指令。</li><li>寄存器分配（Register Allocation）：分配寄存器以最大程度减少内存访问。</li><li>指令调度（Instruction Scheduling）：优化指令执行顺序以减少延迟。</li></ul><p>最终生成目标代码，用于目标平台的执行。</p><p>Pass 管理：</p><p>在编译器的每个模块和 Pass 均可通过 Pass manager 进行管理，可以动态添加、删除或调整 Pass 来优化编译过程中的各个阶段。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/RVV%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/12/08/blog_makedown/RVV%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>RVV的性能测试</p><hr><h2 id="进行数组上的数据相加合并"><a href="#进行数组上的数据相加合并" class="headerlink" title="进行数组上的数据相加合并"></a>进行数组上的数据相加合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常的数组相加函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_add_normal</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> <span class="type">float</span> *a, <span class="type">const</span> <span class="type">float</span> *b, <span class="type">float</span> *c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        c[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 RVV 向量化的数组相加函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_add_rvv</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> <span class="type">float</span> *a, <span class="type">const</span> <span class="type">float</span> *b, <span class="type">float</span> *c)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> l;</span><br><span class="line">    <span class="type">vfloat32m8_t</span> va, vb, vc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n -= l) &#123;</span><br><span class="line">        l = __riscv_vsetvl_e32m8(n);  <span class="comment">// 设置向量长度</span></span><br><span class="line">        va = __riscv_vle32_v_f32m8(a, l);  <span class="comment">// 加载 a</span></span><br><span class="line">        vb = __riscv_vle32_v_f32m8(b, l);  <span class="comment">// 加载 b</span></span><br><span class="line">        vc = __riscv_vfadd_vv_f32m8(va, vb, l);  <span class="comment">// 向量加法</span></span><br><span class="line">        __riscv_vse32_v_f32m8(c, vc, l);  <span class="comment">// 存回 c</span></span><br><span class="line">        a += l;</span><br><span class="line">        b += l;</span><br><span class="line">        c += l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> N = <span class="number">1024</span>;  <span class="comment">// 数组大小</span></span><br><span class="line">    <span class="type">float</span> *a, *b, *c, *d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存，确保数据对齐</span></span><br><span class="line">    posix_memalign((<span class="type">void</span>**)&amp;a, <span class="number">32</span>, N * <span class="keyword">sizeof</span>(<span class="type">float</span>));  </span><br><span class="line">    posix_memalign((<span class="type">void</span>**)&amp;b, <span class="number">32</span>, N * <span class="keyword">sizeof</span>(<span class="type">float</span>));  </span><br><span class="line">    posix_memalign((<span class="type">void</span>**)&amp;c, <span class="number">32</span>, N * <span class="keyword">sizeof</span>(<span class="type">float</span>));  </span><br><span class="line">    posix_memalign((<span class="type">void</span>**)&amp;d, <span class="number">32</span>, N * <span class="keyword">sizeof</span>(<span class="type">float</span>));  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] = i * <span class="number">1.0f</span>;</span><br><span class="line">        b[i] = i * <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用正常的数组加法</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line">    array_add_normal(N, a, b, c);</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line">    <span class="type">long</span> seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">    <span class="type">long</span> nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">    <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">        --seconds;</span><br><span class="line">        nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time for normal add: %ld.%09ld seconds\n&quot;</span>, seconds, nanoseconds);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 RVV 向量化的加法</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line">    array_add_rvv(N, a, b, d);</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line">    seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">    nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">    <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">        --seconds;</span><br><span class="line">        nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time for RVV add: %ld.%09ld seconds\n&quot;</span>, seconds, nanoseconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在这里打印部分结果，验证两种方法是否一致</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c[0]: %f, d[0]: %f\n&quot;</span>, c[<span class="number">0</span>], d[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    <span class="built_in">free</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="qemu测试结果"><a href="#qemu测试结果" class="headerlink" title="qemu测试结果"></a>qemu测试结果</h3><table><thead><tr><th></th><th>-O</th><th>-O1</th><th>-O2</th><th>-O3</th></tr></thead><tbody><tr><td>normal add</td><td>0.000056136 seconds</td><td>0.000057337 seconds</td><td>0.000139442 seconds</td><td>0.000212970 seconds</td></tr><tr><td>RVV add</td><td>0.000126027 seconds</td><td>0.000147346 seconds</td><td>0.000139222 seconds</td><td>0.000095841 seconds</td></tr></tbody></table><h3 id="实机测试结果"><a href="#实机测试结果" class="headerlink" title="实机测试结果"></a>实机测试结果</h3><table><thead><tr><th></th><th>-O</th><th>-O1</th><th>-O2</th><th>-O3</th></tr></thead><tbody><tr><td>normal add</td><td>0.000000500 seconds</td><td>0.000000500 seconds</td><td>0.000012375</td><td>0.000008125</td></tr><tr><td>RVV add</td><td>0.000007459 seconds</td><td>0.0006959 seconds</td><td>0.000000833</td><td>0.000000667</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单加减法上，qemu上编译器优化会增加常规函数的运行时间（因为qemu对向量指令开销大），数据量不大时候常规未经优化标量的运行时间比优化后的RVV还要快。</p><h2 id="线性运算"><a href="#线性运算" class="headerlink" title="线性运算"></a>线性运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 31</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> input[N] = &#123;<span class="number">-0.4325648115282207</span>, <span class="number">-1.6655843782380970</span>, <span class="number">0.1253323064748307</span>,</span><br><span class="line">                  <span class="number">0.2876764203585489</span>,  <span class="number">-1.1464713506814637</span>, <span class="number">1.1909154656429988</span>,</span><br><span class="line">                  <span class="number">1.1891642016521031</span>,  <span class="number">-0.0376332765933176</span>, <span class="number">0.3272923614086541</span>,</span><br><span class="line">                  <span class="number">0.1746391428209245</span>,  <span class="number">-0.1867085776814394</span>, <span class="number">0.7257905482933027</span>,</span><br><span class="line">                  <span class="number">-0.5883165430141887</span>, <span class="number">2.1831858181971011</span>,  <span class="number">-0.1363958830865957</span>,</span><br><span class="line">                  <span class="number">0.1139313135208096</span>,  <span class="number">1.0667682113591888</span>,  <span class="number">0.0592814605236053</span>,</span><br><span class="line">                  <span class="number">-0.0956484054836690</span>, <span class="number">-0.8323494636500225</span>, <span class="number">0.2944108163926404</span>,</span><br><span class="line">                  <span class="number">-1.3361818579378040</span>, <span class="number">0.7143245518189522</span>,  <span class="number">1.6235620644462707</span>,</span><br><span class="line">                  <span class="number">-0.6917757017022868</span>, <span class="number">0.8579966728282626</span>,  <span class="number">1.2540014216025324</span>,</span><br><span class="line">                  <span class="number">-1.5937295764474768</span>, <span class="number">-1.4409644319010200</span>, <span class="number">0.5711476236581780</span>,</span><br><span class="line">                  <span class="number">-0.3998855777153632</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> output_golden[N] = &#123;</span><br><span class="line">    <span class="number">1.7491401329284098</span>,  <span class="number">0.1325982188803279</span>,  <span class="number">0.3252281811989881</span>,</span><br><span class="line">    <span class="number">-0.7938091410349637</span>, <span class="number">0.3149236145048914</span>,  <span class="number">-0.5272704888029532</span>,</span><br><span class="line">    <span class="number">0.9322666565031119</span>,  <span class="number">1.1646643544607362</span>,  <span class="number">-2.0456694357357357</span>,</span><br><span class="line">    <span class="number">-0.6443728590041911</span>, <span class="number">1.7410657940825480</span>,  <span class="number">0.4867684246821860</span>,</span><br><span class="line">    <span class="number">1.0488288293660140</span>,  <span class="number">1.4885752747099299</span>,  <span class="number">1.2705014969484090</span>,</span><br><span class="line">    <span class="number">-1.8561241921210170</span>, <span class="number">2.1343209047321410</span>,  <span class="number">1.4358467535865909</span>,</span><br><span class="line">    <span class="number">-0.9173023332875400</span>, <span class="number">-1.1060770780029008</span>, <span class="number">0.8105708062681296</span>,</span><br><span class="line">    <span class="number">0.6985430696369063</span>,  <span class="number">-0.4015827425012831</span>, <span class="number">1.2687512030669628</span>,</span><br><span class="line">    <span class="number">-0.7836083053674872</span>, <span class="number">0.2132664971465569</span>,  <span class="number">0.7878984786088954</span>,</span><br><span class="line">    <span class="number">0.8966819356782295</span>,  <span class="number">-0.1869172943544062</span>, <span class="number">1.0131816724341454</span>,</span><br><span class="line">    <span class="number">0.2484350696132857</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> output[N] = &#123;</span><br><span class="line">    <span class="number">1.7491401329284098</span>,  <span class="number">0.1325982188803279</span>,  <span class="number">0.3252281811989881</span>,</span><br><span class="line">    <span class="number">-0.7938091410349637</span>, <span class="number">0.3149236145048914</span>,  <span class="number">-0.5272704888029532</span>,</span><br><span class="line">    <span class="number">0.9322666565031119</span>,  <span class="number">1.1646643544607362</span>,  <span class="number">-2.0456694357357357</span>,</span><br><span class="line">    <span class="number">-0.6443728590041911</span>, <span class="number">1.7410657940825480</span>,  <span class="number">0.4867684246821860</span>,</span><br><span class="line">    <span class="number">1.0488288293660140</span>,  <span class="number">1.4885752747099299</span>,  <span class="number">1.2705014969484090</span>,</span><br><span class="line">    <span class="number">-1.8561241921210170</span>, <span class="number">2.1343209047321410</span>,  <span class="number">1.4358467535865909</span>,</span><br><span class="line">    <span class="number">-0.9173023332875400</span>, <span class="number">-1.1060770780029008</span>, <span class="number">0.8105708062681296</span>,</span><br><span class="line">    <span class="number">0.6985430696369063</span>,  <span class="number">-0.4015827425012831</span>, <span class="number">1.2687512030669628</span>,</span><br><span class="line">    <span class="number">-0.7836083053674872</span>, <span class="number">0.2132664971465569</span>,  <span class="number">0.7878984786088954</span>,</span><br><span class="line">    <span class="number">0.8966819356782295</span>,  <span class="number">-0.1869172943544062</span>, <span class="number">1.0131816724341454</span>,</span><br><span class="line">    <span class="number">0.2484350696132857</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saxpy_golden</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> <span class="type">float</span> a, <span class="type">const</span> <span class="type">float</span> *x, <span class="type">float</span> *y)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    y[i] = a * x[i] + y[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference https://github.com/riscv/riscv-v-spec/blob/master/example/saxpy.s</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">saxpy_vec</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> <span class="type">float</span> a, <span class="type">const</span> <span class="type">float</span> *x, <span class="type">float</span> *y)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> l;</span><br><span class="line"></span><br><span class="line">  <span class="type">vfloat32m8_t</span> vx, vy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n -= l) &#123;</span><br><span class="line">    l = __riscv_vsetvl_e32m8(n);</span><br><span class="line">    vx = __riscv_vle32_v_f32m8(x, l);</span><br><span class="line">    x += l;</span><br><span class="line">    vy = __riscv_vle32_v_f32m8(y, l);</span><br><span class="line">    vy = __riscv_vfmacc_vf_f32m8(vy, a, vx, l);</span><br><span class="line">    __riscv_vse32_v_f32m8 (y, vy, l);</span><br><span class="line">    y += l;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fp_eq</span><span class="params">(<span class="type">float</span> reference, <span class="type">float</span> actual, <span class="type">float</span> relErr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// if near zero, do absolute error instead.</span></span><br><span class="line">  <span class="type">float</span> absErr = relErr * ((fabsf(reference) &gt; relErr) ? fabsf(reference) : relErr);</span><br><span class="line">  <span class="keyword">return</span> fabsf(actual - reference) &lt; absErr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line">    saxpy_golden(N, <span class="number">55.66</span>, input, output_golden);</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line">    <span class="type">long</span> seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">    <span class="type">long</span> nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">    <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">        --seconds;</span><br><span class="line">        nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time for normal add: %ld.%09ld seconds\n&quot;</span>, seconds, nanoseconds);</span><br><span class="line">    </span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line">    saxpy_vec(N, <span class="number">55.66</span>, input, output);</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line">    seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">    nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">    <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">        --seconds;</span><br><span class="line">        nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time for    RVV add: %ld.%09ld seconds\n&quot;</span>, seconds, nanoseconds);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> pass = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fp_eq(output_golden[i], output[i], <span class="number">1e-6</span>)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;failed, %f=!%f\n&quot;</span>, output_golden[i], output[i]);</span><br><span class="line">      pass = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pass)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;passed\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (pass == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="qemu测试结果-1"><a href="#qemu测试结果-1" class="headerlink" title="qemu测试结果"></a>qemu测试结果</h3><table><thead><tr><th>RVV</th><th>-O</th><th>-O1</th><th>-O2</th><th>-O3</th></tr></thead><tbody><tr><td>1</td><td>0.000066337 seconds</td><td>0.000063587 seconds</td><td>0.000053899 seconds</td><td>0.000044271 seconds</td></tr><tr><td>2</td><td>0.000063456 seconds</td><td>0.000076642 seconds</td><td>0.000063870 seconds</td><td>0.000059106 seconds</td></tr><tr><td>3</td><td>0.000071483 seconds</td><td>0.000076432 seconds</td><td>0.000051195 seconds</td><td>0.000044282 seconds</td></tr><tr><td>4</td><td>0.000065239 seconds</td><td>0.000072144 seconds</td><td>0.000046892 seconds</td><td>0.000049881 seconds</td></tr></tbody></table><table><thead><tr><th><strong>normal</strong></th><th>-O</th><th>-O1</th><th>-O2</th><th>-O3</th></tr></thead><tbody><tr><td>1</td><td>0.000061757 seconds</td><td>0.000055580 seconds</td><td>0.000141593 seconds</td><td>0.000122429 seconds</td></tr><tr><td>2</td><td>0.000055796 seconds</td><td>0.000055420 seconds</td><td>0.000138452 seconds</td><td>0.000122429 seconds</td></tr></tbody></table><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>线性运算上，通过编译器的优化，发现RVV运行时间是有优化的,优化后的RVV比常规函数运行时间少，运行时间少20~28%。</p><h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_array_2d</span><span class="params">(<span class="type">double</span> **<span class="built_in">array</span>, <span class="type">int</span> rows)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>[i]); <span class="comment">// 释放每一行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(<span class="built_in">array</span>); <span class="comment">// 释放指向行指针的数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵乘法的黄金实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">matmul_golden</span><span class="params">(<span class="type">double</span> **a, <span class="type">double</span> **b, <span class="type">double</span> **c, <span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> o)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      c[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; o; ++k)</span><br><span class="line">        c[i][j] += a[i][k] * b[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 RISC-V 向量扩展优化的矩阵乘法实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">matmul</span><span class="params">(<span class="type">double</span> **a, <span class="type">double</span> **b, <span class="type">double</span> **c, <span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> o)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> vlmax = __riscv_vsetvlmax_e64m1();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      <span class="type">double</span> *ptr_a = &amp;a[i][<span class="number">0</span>];</span><br><span class="line">      <span class="type">double</span> *ptr_b = &amp;b[j][<span class="number">0</span>];</span><br><span class="line">      <span class="type">int</span> k = o;</span><br><span class="line">      <span class="type">vfloat64m1_t</span> vec_s = __riscv_vfmv_v_f_f64m1(<span class="number">0</span>, vlmax);</span><br><span class="line">      <span class="type">vfloat64m1_t</span> vec_zero = __riscv_vfmv_v_f_f64m1(<span class="number">0</span>, vlmax);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> vl; k &gt; <span class="number">0</span>; k -= vl, ptr_a += vl, ptr_b += vl) &#123;</span><br><span class="line">        vl = __riscv_vsetvl_e64m1(k);</span><br><span class="line"></span><br><span class="line">        <span class="type">vfloat64m1_t</span> vec_a = __riscv_vle64_v_f64m1(ptr_a, vl);</span><br><span class="line">        <span class="type">vfloat64m1_t</span> vec_b = __riscv_vle64_v_f64m1(ptr_b, vl);</span><br><span class="line"></span><br><span class="line">        vec_s = __riscv_vfmacc_vv_f64m1(vec_s, vec_a, vec_b, vl);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">vfloat64m1_t</span> vec_sum;</span><br><span class="line">      vec_sum = __riscv_vfredusum_vs_f64m1_f64m1(vec_s, vec_zero, vlmax);</span><br><span class="line">      <span class="type">double</span> sum = __riscv_vfmv_f_s_f64m1_f64(vec_sum);</span><br><span class="line">      c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算时间差的辅助函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">calc_elapsed_time</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *label, <span class="keyword">struct</span> timespec start, <span class="keyword">struct</span> timespec end)</span> &#123;</span><br><span class="line">  <span class="type">long</span> seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">  <span class="type">long</span> nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">  <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">    --seconds;</span><br><span class="line">    nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s elapsed time: %ld.%09ld seconds\n&quot;</span>, label, seconds, nanoseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">512</span>; <span class="comment">// 矩阵 A 的行数</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> M = <span class="number">512</span>; <span class="comment">// 矩阵 B 的行数（等于 C 的列数）</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> O = <span class="number">512</span>; <span class="comment">// 矩阵 A 的列数（等于 B 的列数）</span></span><br><span class="line">  <span class="type">uint32_t</span> seed = <span class="number">0xdeadbeef</span>;</span><br><span class="line">  srand(seed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配内存并生成随机数据</span></span><br><span class="line">  <span class="type">double</span> **A = alloc_array_2d(N, O);</span><br><span class="line">  <span class="type">double</span> **B = alloc_array_2d(M, O);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line">  gen_rand_2d(A, N, O);</span><br><span class="line">  gen_rand_2d(B, M, O);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line"></span><br><span class="line">  calc_elapsed_time(<span class="string">&quot;Data generation&quot;</span>, start, end);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配内存用于存储结果</span></span><br><span class="line">  <span class="type">double</span> **golden = alloc_array_2d(N, M);</span><br><span class="line">  <span class="type">double</span> **actual = alloc_array_2d(N, M);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行黄金实现</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start1</span>, <span class="title">end1</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;start1);</span><br><span class="line">  matmul_golden(A, B, golden, N, M, O);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;end1);</span><br><span class="line">  calc_elapsed_time(<span class="string">&quot;Golden implementation&quot;</span>, start1, end1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行优化实现</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start2</span>, <span class="title">end2</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;start2);</span><br><span class="line">  matmul(A, B, actual, N, M, O);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;end2);</span><br><span class="line">  calc_elapsed_time(<span class="string">&quot;Vector implementation&quot;</span>, start2, end2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较结果</span></span><br><span class="line">  <span class="built_in">puts</span>(compare_2d(golden, actual, N, M) ? <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;fail&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放内存</span></span><br><span class="line">  free_array_2d(A, N);</span><br><span class="line">  free_array_2d(B, M);</span><br><span class="line">  free_array_2d(golden, N);</span><br><span class="line">  free_array_2d(actual, N);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际机器测试结果"><a href="#实际机器测试结果" class="headerlink" title="实际机器测试结果"></a>实际机器测试结果</h3><table><thead><tr><th></th><th>-O</th><th>-O1</th><th>-O2</th><th>-O3</th></tr></thead><tbody><tr><td>normal</td><td>0.58</td><td>0.66</td><td>0.46</td><td>0.45</td></tr><tr><td>rvv</td><td>0.33</td><td>0.34</td><td>0.34</td><td>0.33</td></tr></tbody></table><p>qemu可以执行RVV的指令，但是开销很大，实机的运行效率更高。 </p><p>目前自动向量化的效率在矩阵运算上慢与手动向量化Intrinsic。编译器的自动向量化对于程序的运行效率是有提升的。</p><table><thead><tr><th>-O2</th><th>strcpy</th><th>strncpy</th><th>strlen</th></tr></thead><tbody><tr><td>常量</td><td>0.000002333</td><td>0.000003750</td><td>0.000000959</td></tr><tr><td>向量</td><td>0.000010833</td><td>0.000001125</td><td>0.000007666</td></tr></tbody></table><blockquote><p><strong>总结</strong>：编译器GCC或者LLVM可以对程序进行自动向量化的优化，但是因为目前的编译器版本对自动向量化的支持还不完善，通过测试结果可看到实际机器上跑Intrinsic的向量化优化的效率要比编译器的优化更高。</p></blockquote><h2 id="性能影响因素"><a href="#性能影响因素" class="headerlink" title="性能影响因素"></a>性能影响因素</h2><p>内存对齐：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10 <span class="comment">// 矩阵的维度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用RVV实现未对齐的矩阵加法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">matrix_add_unaligned</span><span class="params">(<span class="type">const</span> <span class="type">int32_t</span>* matA, <span class="type">const</span> <span class="type">int32_t</span>* matB, <span class="type">int32_t</span>* matC)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> vl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; N; j += vl) &#123;</span><br><span class="line">            vl = __riscv_vsetvl_e32m1(N - j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非对齐加载</span></span><br><span class="line">            <span class="type">vint32m1_t</span> vecA = __riscv_vle32_v_i32m1(matA + i * N + j, vl);</span><br><span class="line">            <span class="type">vint32m1_t</span> vecB = __riscv_vle32_v_i32m1(matB + i * N + j, vl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 元素加法</span></span><br><span class="line">            <span class="type">vint32m1_t</span> vecC = __riscv_vadd_vv_i32m1(vecA, vecB, vl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存结果</span></span><br><span class="line">            __riscv_vse32_v_i32m1(matC + i * N + j, vecC, vl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用RVV实现对齐的矩阵加法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">matrix_add_aligned</span><span class="params">(<span class="type">const</span> <span class="type">int32_t</span>* matA, <span class="type">const</span> <span class="type">int32_t</span>* matB, <span class="type">int32_t</span>* matC)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> vl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; N; j += vl) &#123;</span><br><span class="line">            vl = __riscv_vsetvl_e32m1(N - j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对齐加载</span></span><br><span class="line">            <span class="type">vint32m1_t</span> vecA = __riscv_vle32_v_i32m1((<span class="type">int32_t</span>*)__builtin_assume_aligned(matA + i * N + j, <span class="number">4</span>), vl);</span><br><span class="line">            <span class="type">vint32m1_t</span> vecB = __riscv_vle32_v_i32m1((<span class="type">int32_t</span>*)__builtin_assume_aligned(matB + i * N + j, <span class="number">4</span>), vl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 元素加法</span></span><br><span class="line">            <span class="type">vint32m1_t</span> vecC = __riscv_vadd_vv_i32m1(vecA, vecB, vl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存结果</span></span><br><span class="line">            __riscv_vse32_v_i32m1((<span class="type">int32_t</span>*)__builtin_assume_aligned(matC + i * N + j, <span class="number">4</span>), vecC, vl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> matA[N][N] __attribute__((aligned(<span class="number">4</span>))) = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int32_t</span> matB[N][N] __attribute__((aligned(<span class="number">4</span>))) = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int32_t</span> matC_unaligned[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int32_t</span> matC_aligned[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化矩阵数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            matA[i][j] = i + j;</span><br><span class="line">            matB[i][j] = i - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试未对齐加法</span></span><br><span class="line">    <span class="type">clock_t</span> start_unaligned = clock();</span><br><span class="line">    matrix_add_unaligned(&amp;matA[<span class="number">0</span>][<span class="number">0</span>], &amp;matB[<span class="number">0</span>][<span class="number">0</span>], &amp;matC_unaligned[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="type">clock_t</span> end_unaligned = clock();</span><br><span class="line">    <span class="type">double</span> time_unaligned = (<span class="type">double</span>)(end_unaligned - start_unaligned) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试对齐加法</span></span><br><span class="line">    <span class="type">clock_t</span> start_aligned = clock();</span><br><span class="line">    matrix_add_aligned(&amp;matA[<span class="number">0</span>][<span class="number">0</span>], &amp;matB[<span class="number">0</span>][<span class="number">0</span>], &amp;matC_aligned[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="type">clock_t</span> end_aligned = clock();</span><br><span class="line">    <span class="type">double</span> time_aligned = (<span class="type">double</span>)(end_aligned - start_aligned) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印未对齐结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未对齐计算结果:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matC_unaligned[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印对齐结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n对齐计算结果:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matC_aligned[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印时间比较</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n未对齐计算时间: %.6f 秒\n&quot;</span>, time_unaligned);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;对齐计算时间: %.6f 秒\n&quot;</span>, time_aligned);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.picgo.net/2024/11/25/-2024-11-25-151948f556dc8fc85bc92e.png" alt="屏幕截图 2024 11 25 151948"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/title%EF%BC%9Agit%E4%BD%BF%E7%94%A8%E5%9B%9E%E9%A1%BE/"/>
      <url>/2024/12/08/blog_makedown/title%EF%BC%9Agit%E4%BD%BF%E7%94%A8%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<p>title：git使用回顾</p><hr><h2 id="使用ssh建立git仓库连接"><a href="#使用ssh建立git仓库连接" class="headerlink" title="使用ssh建立git仓库连接"></a>使用ssh建立git仓库连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;github@com&quot;</span><br><span class="line">cat ~/.ssh/id_isa.pub</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">内容拷贝到github的ssh设置里</span></span><br></pre></td></tr></table></figure><h2 id="将本地与远程建立连接"><a href="#将本地与远程建立连接" class="headerlink" title="将本地与远程建立连接"></a>将本地与远程建立连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:hanfengdyh/code.git</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#初始化</span></span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#获取远程的分支</span></span></span><br><span class="line">git fetch origin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#切换分支</span></span></span><br><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#添加内容</span></span></span><br><span class="line">git add file</span><br><span class="line">git commit -m &quot;information&quot;</span><br><span class="line">git push orgin &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#创立分支</span></span></span><br><span class="line">git checkout -b &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#上传分支</span></span></span><br><span class="line">git push -u origin &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#合并分支</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#获取最新的分支和改变</span></span></span><br><span class="line">git fetch origin</span><br><span class="line">git checkout main</span><br><span class="line">git merge origin/feature-branch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#删除分支</span></span></span><br><span class="line">git branch -d &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#验证</span></span></span><br><span class="line">git branch -r</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#编译制定版本的代码</span></span></span><br><span class="line">cd llvm-project</span><br><span class="line">git tag</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">llvmorg-19.0.0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">llvmorg-19.0.1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">llvmorg-19.1.0</span></span><br><span class="line">git checkout llvmorg-19.1.4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RISCV内存管理单元</title>
      <link href="/2024/12/08/blog_makedown/RISCV%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83/"/>
      <url>/2024/12/08/blog_makedown/RISCV%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.picgo.net/2024/11/12/mmu63423688102025c3.webp" alt="mmu"></p><p><img src="https://img.picgo.net/2024/11/12/-2024-11-12-111925e80e2ddbe0cc53d7.png" alt="屏幕截图 2024 11 12 111925"></p><h1 id="MMU-内存管理单元"><a href="#MMU-内存管理单元" class="headerlink" title="MMU(内存管理单元)"></a>MMU(内存管理单元)</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>在用户的视角里，每个进程都有自己独立的地址空间，A进程的4GB和B进程4GB是完全独立不相关的，他们看到的都是操作系统虚拟出来的地址空间。但是呢，虚拟地址最终还是要落在实际内存的物理地址上进行操作的。操作系统就会通过页表的机制来实现进程的虚拟地址到物理地址的翻译工作。其中每一页的大小都是固定的。页表管理有两个关键点，分别是页面大小和页表级数。</p><h2 id="页表级数"><a href="#页表级数" class="headerlink" title="页表级数"></a>页表级数</h2><p>页表级数越少，虚拟地址到物理地址的映射就会越快，但是需要管理的页表项会越多，能支持的地址空间也有限，相反页表的级数越多，需要的存储的页表数据就会越少，而且能支持到比较大的地址空间，但是虚拟地址到物理地址的映射就会越慢。</p><p><img src="https://img.picgo.net/2024/11/12/cfa0c8d0de1d9db011f57ad8d1e5ba76d3f6bd720ddc60ff.png" alt="cfa0c8d0de1d9db011f57ad8d1e5ba76"></p><blockquote><p>PGD：Page Global Directory，页全局目录，它是多级页表的顶层，包含指向下一级页表的基地址。</p><p>PUD：Page Upper Directory， 页上级目录，位于PGD之下，包含了指向PMD的基地址。</p><p>PMD：Page Middle Directory，页中级目录，位于PUD之下，包含了指向PTE的及地址。</p><p>PTE：Page Table Entry，页表项，位于PMD之下，包含了虚拟地址到物理地址的具体映射信息。</p></blockquote><h2 id="RISCV内存管理机制"><a href="#RISCV内存管理机制" class="headerlink" title="RISCV内存管理机制"></a>RISCV内存管理机制</h2><p><strong>RV32（32 位地址空间）</strong>：主要用于嵌入式系统和资源受限的设备。虚拟和物理地址都限制为 32 位，通常采用两级页表，支持的页大小为 4KB、2MB 或 1GB。RV32 并没有 39 位地址管理。</p><p><strong>RV39（39 位虚拟地址空间）</strong>：主要用于中小型系统，比如一般的操作系统环境。虚拟地址为 39 位，物理地址宽度则可以根据硬件实际支持的位宽（通常在 36-40 位之间）进行设置。RV39 使用三级页表，支持的页大小同样是 4KB、2MB 或 1GB。</p><p><strong>RV48（48 位虚拟地址空间）</strong>：适合高性能计算或服务器系统。虚拟地址为 48 位，物理地址宽度可以支持 44-52 位，具体取决于硬件配置。RV48 使用四级页表，允许更大的虚拟地址空间，支持的页大小为 4KB、2MB 和 1GB。</p><p><strong>RV64（64 位虚拟地址空间）</strong>：理论上支持 64 位虚拟地址，但实际上限制在 RV48，适合未来超大规模系统。不过在目前的 RISC-V 实现中，64 位的地址空间通常没有完全实现，因为绝大多数系统的虚拟地址需求并未达到如此高的级别。</p><p>Riscv使用<strong>satp寄存器</strong>来保存MMU的映射表的根地址。</p><p><img src="https://img.picgo.net/2024/11/12/stapea79c558971c617f.png" alt="stap"></p><blockquote><p><strong>MODE（位 63 到位 60）</strong>：</p><ul><li>用于表示虚拟内存的模式。不同的模式代表不同的页表格式，RISC-V 支持多个页表层级。常见的模式如下：<ul><li><code>0b0000</code>：禁用虚拟地址翻译。</li><li><code>0b0001</code>：SV32（2级页表）。</li><li><code>0b0010</code>：SV39（3级页表）。</li><li><code>0b0011</code>：SV48（4级页表）。</li><li><code>0b0100</code>：SV57（5级页表）。</li><li><code>0b0101</code>：SV64（6级页表）。</li></ul></li></ul><p><strong>ASID（位 59 到位 38）</strong>：</p><ul><li>地址空间标识符（Address Space Identifier），用于区分不同进程的虚拟地址空间。ASID 的作用是避免进程间的虚拟地址映射冲突。</li></ul><p><strong>PPN（位 37 到位 0）</strong>：</p><ul><li>页表的物理页号（Physical Page Number），指示当前页表的物理地址基址。页表基址会用该值来进行虚拟地址到物理地址的映射。它以4KB的页面大小为单位。</li></ul></blockquote><p>页表是一个很庞大的数据结构且储存在内存中，直接由MMU访问内存中的页表从而得到物理地址会产生非常大的开销，进而影响CPU的运行效率。为了解决这一问题，利用局域性原理，通常会在内存与MMU之间增加一级缓存，该缓存有一个特殊的名称，即TLB（Translation Look-aside Buffer），用于缓存近期经常使用的页表项（Page Table Entry）。为了减小TLB的缺失率，通常TLB为全相联的结构。</p><p><img src="https://img.picgo.net/2024/11/12/TLB20dea606ed02565e1.png" alt="TLB2"></p><p>在<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=1&q=%E7%8E%84%E9%93%81C910&zhida_source=entity">玄铁C910</a>中TLB被分为了两级，第一级称为UTLB，且UTLB被分为了ITLB与DTLB，ITLB储存由IFU请求的指令虚拟地址（即指令PC）对应的虚实地址转换的页表项，DTLB储存由LSU中Load&#x2F;Store指令访存的虚拟地址对应的虚实地址转换的页表项。ITLB和DTLB均为全相联结构。第二级TLB称为JTLB，为四路组相联结构，页表项信息储存在SRAM中，访问JTLB需要一个周期得到结构。</p><p><img src="https://img.picgo.net/2024/11/12/TLB934b1cbc096bb55f.png" alt="TLB"><img src="https://img.picgo.net/2024/11/12/PPNe4a4095ca50d08ea.png" alt="PPN"></p><p>当IFU或LSU发送请求<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=3&q=%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2&zhida_source=entity">虚实地址转换</a>的请求时，会首先访问ITLB或DTLB，若命中UTLB，经过物理内存保护单元（Physical Memory Protection）检查相应地址范围的权限后，若检查未通过，将产生访问异常（Access Error Exception）。若检查通过，经过转换得到的物理地址将根据需要发送到<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=1&q=%E6%8C%87%E4%BB%A4%E7%BC%93%E5%AD%98&zhida_source=entity">指令缓存</a>或者数据缓存用于缓存命中的判断。若第一级TLB访问缺失，将会访问第二级的JTLB，若JTLB进一步失配，则MMU会启动Hardware Page Table Walk，访问内存得到最终的地址转换结果。在UTLB、JTLB或从PTW模块中找到虚拟地址对应的页表项后，还需判断该页的属性，比如该页是否为可执行，可读，可写，是否有效（在内存中是否存在）等等，若访存操作违反页面属性的规定，会产生<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=1&q=%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8&zhida_source=entity">缺页异常</a>（Page Fault Exception），代表CPU无法获取该页的数据。由于CPU没有数据就无法进行计算，CPU罢工了用户进程也就出现了<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=1&q=%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD&zhida_source=entity">缺页中断</a>，进程会从用户态切换到<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=1&q=%E5%86%85%E6%A0%B8%E6%80%81&zhida_source=entity">内核态</a>，并将缺页中断交给内核的Page Fault Handler处理。</p><p>若命中JTLB或内存中的页表且未产生缺页异常，MMU会根据请求JTLB重新填充的来源选择更新ITLB还是DTLB，或者以请求PTW模块的虚拟内存信息为索引更新JTLB。命中JTLB或内存中的页表后物理地址同样要通过物理内存保护单元（PMP）进行检查权限后，才能发送给请求虚实地址转换缓存。</p><p><strong>在多核系统中，当操作系统（OS）修改了页表后，通常需要确保所有核上的 TLB（Translation Lookaside Buffer） 都反映了最新的页表内容。否则，不同核心可能会依然使用旧的页表映射，导致地址转换错误和数据不一致。</strong></p><div style="display: flex;">  <div style="flex: 1; padding: 10px;">    为什么需要刷掉其他核的 TLB？每个 CPU 核心都有自己的 TLB，它们缓存着虚拟地址到物理地址的映射，以提高地址转换的效率。如果操作系统修改了页表（如在上下文切换时更改进程的虚拟地址映射，或者执行了某些系统调用，如 mmap），其他核心可能会继续访问旧的 TLB 条目，导致地址转换错误。为避免这个问题，操作系统需要确保所有核心的 TLB 都被更新或失效。  </div>  <div style="flex: 1; padding: 10px;">    如何知道哪些核的 TLB 需要刷掉？通常，操作系统并不直接知道哪些核的 TLB 需要刷掉，因为操作系统无法完全控制 TLB 内容（这些是硬件管理的）。然而，操作系统可以通过以下方式推断哪些 TLB 需要刷掉：上下文切换：当操作系统执行进程上下文切换时，它通常会清除当前进程的 TLB 条目，防止其他进程看到错误的虚拟到物理地址映射。页表更新：如果 OS 更新了某个页表项（比如在 mmap、munmap 等操作中修改了映射），它可能需要通知所有核心刷新 TLB。  </div></div><h3 id="SV39分页机制"><a href="#SV39分页机制" class="headerlink" title="SV39分页机制"></a>SV39分页机制</h3><p><img src="https://img.picgo.net/2024/11/12/SV39d1cbebb4e34d8809.png" alt="SV39"></p><p>使用64位虚拟地址的低39位，高25位未使用，每一页占用4KB内存，页内使用虚拟地址低12位寻址，虚拟地址高27位分为三级页号，每一级都有512个可用页号。</p><p>如果每级页表项8字节，且每个4KB页面只能容纳4096&#x2F;512&#x3D;512个页表项，所以每级页表的寻址范围是9位。</p><h4 id="SV39页表项-PTE"><a href="#SV39页表项-PTE" class="headerlink" title="SV39页表项(PTE)"></a>SV39页表项(PTE)</h4><p><img src="https://img.picgo.net/2024/11/12/PTEea3d355b73a8db7d.png" alt="PTE"></p><p>每个PTE包含一个44位的物理页(PPN)和一些标志位，分页硬件使用39位虚拟地址中的高27位作为索引，在页表中周到对应的PTE，然后PTE中的44位地址作为高位(物理页号),虚拟地址中的低12位作为低位(页内偏移量),构造出一个56位的物理地址。</p><p><img src="https://img.picgo.net/2024/11/12/addressd1c9293b99866ebf.png" alt="address"></p><ul><li>v位决定了该页表项的其余部分是否有效(V &#x3D; 1时有效)。若V&#x3D;0，则任何遍历到此页表项的虚拟转换操作都会导致页错误。</li><li>R、W、X位分别表示此页是否可以读取、写入、执行。如果都是0，那么这个页表是指向下一级页表的指针，否则它是也表述的一个叶节点。</li></ul><h3 id="VMA"><a href="#VMA" class="headerlink" title="VMA"></a>VMA</h3><p><strong>VMA（Virtual Memory Area，虚拟内存区域）</strong> 是操作系统中用于管理和描述进程虚拟地址空间的一种结构。在现代操作系统（如 Linux）中，VMA 是虚拟地址空间的基本组成单元，用于划分进程的不同内存区域，且每个 VMA 描述一个连续的虚拟地址范围。</p><blockquote><ol><li><strong>VMA的基本作用</strong></li></ol><ul><li><strong>管理进程虚拟地址空间</strong>：VMA 用来表示进程虚拟地址空间中的一个区域，这个区域通常具有相同的属性，比如是否可读、可写、可执行等。</li><li><strong>内存区域的划分</strong>：操作系统通过 VMA 划分出不同的内存区域，例如代码段、数据段、堆、栈以及共享库等。</li><li><strong>内存映射的管理</strong>：VMA 在进程地址空间内表示的是一块虚拟内存，它可能会映射到物理内存、交换空间，或是磁盘上的文件（例如通过 <code>mmap</code> 系统调用映射的文件）。</li></ul><ol start="2"><li><strong>VMA的组成部分</strong></li></ol><p>每个 VMA 通常包含以下信息：</p><ul><li><strong>虚拟地址范围</strong>：每个 VMA 具有一个起始虚拟地址和一个结束虚拟地址，表示该内存区域的大小和范围。</li><li><strong>内存权限</strong>：描述该区域的访问权限，包括是否可读（<code>PROT_READ</code>）、可写（<code>PROT_WRITE</code>）、可执行（<code>PROT_EXEC</code>）等。</li><li><strong>映射类型</strong>：包括该区域是否映射到文件（如共享库），或者是否是匿名映射（如堆和栈）。</li><li><strong>标志</strong>：标志可以包括是否该区域是共享的（<code>MAP_SHARED</code>）或私有的（<code>MAP_PRIVATE</code>），是否是堆栈区域等。</li><li><strong>偏移量</strong>：对于文件映射，VMA 还可能记录文件在虚拟地址空间中的偏移量，指明文件在内存中的位置。</li></ul><ol start="3"><li><strong>VMA的作用和管理</strong></li></ol><p>VMA 主要用于管理进程的内存区域，它在进程的内存映射和内存管理中扮演了关键角色。具体来说：</p><ul><li><strong>虚拟地址空间的划分</strong>：每个 VMA 对应进程虚拟地址空间的一个逻辑区域（如代码、数据、堆栈等）。操作系统通过维护 VMA 来确保这些区域的内存管理。</li><li><strong>内存分配与回收</strong>：在进程创建、加载程序或执行时，操作系统会使用 VMA 来管理和分配虚拟内存区域，并在进程退出时回收这些内存区域。</li><li><strong>进程上下文切换</strong>：操作系统在进行进程上下文切换时，会利用 VMA 结构来恢复或切换不同的虚拟内存映射。</li></ul><ol start="4"><li><strong>VMA 与其他内存管理结构的关系</strong></li></ol><ul><li><strong>页表（Page Tables）</strong>：VMA 管理虚拟地址的逻辑划分，而页表则负责将这些虚拟地址映射到物理内存。每个 VMA 中的虚拟地址段在页表中都有相应的映射关系。</li><li><strong>内存映射文件（mmap）</strong>：通过 <code>mmap</code> 系统调用，操作系统可以将文件内容映射到进程的虚拟内存中，这个映射关系通常由 VMA 来描述。</li><li><strong>内核虚拟内存（Kernel VMA）</strong>：操作系统内核通常也会维护自己的虚拟地址空间，用于管理内核的代码、数据、堆栈等区域。内核的 VMA 不同于用户空间的 VMA，且不通过用户页表进行管理。</li></ul><ol start="5"><li><strong>VMA 的典型使用场景</strong></li></ol><ul><li><strong>堆和栈</strong>：进程的堆和栈分别是动态分配和管理内存的区域，它们通常是由操作系统通过 VMA 来管理的。例如，堆和栈的增长和收缩是由 VMA 的边界和映射方式来控制的。</li><li><strong>共享内存和文件映射</strong>：通过 <code>mmap</code>，操作系统可以将文件或共享内存区域映射到进程的虚拟地址空间，形成一个 VMA 区域。该 VMA 描述了文件与进程内存之间的映射关系。</li></ul><ol start="6"><li><strong>VMA的例子</strong></li></ol><p>假设一个进程需要加载一个程序，它的虚拟地址空间可能会被划分成以下几个 VMA 区域：</p><ul><li><strong>代码段（Text Segment）</strong>：包含可执行的代码，通常是只读且可执行的区域。</li><li><strong>数据段（Data Segment）</strong>：包含程序的静态数据，通常是可读写的。</li><li><strong>堆（Heap）</strong>：动态分配内存的区域，通常从低地址增长至高地址。</li><li><strong>栈（Stack）</strong>：用于存储函数调用信息的区域，通常从高地址向低地址增长。</li><li><strong>共享库映射</strong>：通过 <code>mmap</code> 映射到虚拟内存中的共享库或文件映射。</li></ul></blockquote><blockquote><p>VMA（虚拟内存区域）是操作系统用于管理进程虚拟地址空间的基本数据结构之一。它帮助操作系统在进程的虚拟内存中划分不同的区域，并描述这些区域的属性和映射关系。VMA 是现代操作系统内存管理的重要组成部分，尤其在虚拟内存管理、内存保护和文件映射等方面发挥着关键作用。</p></blockquote><h3 id="换页"><a href="#换页" class="headerlink" title="换页"></a>换页</h3><p>换页基本思想</p><ul><li>用磁盘作为物理内存的补充，且对上层应用透明</li><li>应用对虚拟内存的使用，不受物理内存大小限制</li></ul><p>如何实现</p><ul><li>磁盘上划分专门的Swap分区，或专门的Swap文件</li><li>在处理缺页异常时，触发物理内存页的换入换出</li></ul><p><img src="https://img.picgo.net/2024/11/12/huanye055de0a104e17b17.png" alt="huanye"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/ISA%E5%92%8CRISC-V/"/>
      <url>/2024/12/08/blog_makedown/ISA%E5%92%8CRISC-V/</url>
      
        <content type="html"><![CDATA[<h1 id="ISA和RISC-V"><a href="#ISA和RISC-V" class="headerlink" title="ISA和RISC-V"></a>ISA和RISC-V</h1><h2 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h2><p>ISA是Instruction Set Architecture(指令集体系架构)缩写，指令集是一个计算机系统支持的所有机器指令的集合，常看作软硬件之间的分界面。<strong>指令集对上限定了软件的基本功能，对下制定了硬件实现的功能目标。</strong></p><blockquote><p>ISA指令集架构是底层硬件电路层面向上层软件程序提供的一层接口规范。<br>定义了： 基本数据类型、寄存器、指令、寻址模式、异常或者中断的处理方式</p></blockquote><p>ISA的宽度指的是CPU中的通用寄存器的宽度，这决定了寻址范围的大小、以及数据运行运算的能力。ISA的宽度和指令编码长度无关<br>ISA可分为CISC和RISC。<strong>CISC是指复杂指令系统计算机，RISC是指精简指令系统计算机。</strong></p><p><strong>CISC</strong>：通过设置一些功能复杂的指令，把一些原来由软件实现的、常用的功能改用硬件指令实现，以此来提高计算机的执行速度。越来越多的复杂指令被加人指令系统中，逐渐形成了一个庞大且复杂的指令集。<br>目标是<strong>强化指令功能，减少程序的指令条数，达到提高性能的目的。</strong><br>X86是现存唯一的CISC指令集。</p><p><strong>RISC</strong>：尽量简化计算机指令功能，只保留那些功能简单、能在一个节拍内执行完成的指令，而把较复杂的功能用段子程序来实现。 <strong>RISC通过减少指令种类、规范指令格式和简化寻址方式等方法，</strong>方便处理器内部的并行处理，提高超大规模集成电路(VLSI)器件的使用效率，从而大幅度地提高处理器的性能。<br> RISC 指令系统仅包含最常用的简单指令，因此可以通过硬件优化设计，把时钟频率提得很高，从而实现整个系统的高性能。同时，RISC 技术在 CPU 芯片上设置大量寄存器，用来保存常用的数据，以大大减少对存储器的访问，用高速的寄存器访问取代低速的存储器访问，从而提高系统整体性能。</p><p> RISC-V是一种基于RISC原则开源的ISA。<br> 特点：简单、清晰的分层设计、模块化、稳定、社区化<br> ISA命令格式:RV[##][abc..xyz]<br> RV是指用于标识RISC-V体系架构的前缀，[##]标识处理器的宽度，[abc..xyz]支持什么模块。<br> 模块化ISA：由一个基础整数指令集+多个可选的扩展指令集。</p><table><thead><tr><th>基本指令集</th><th>描述</th></tr></thead><tbody><tr><td>RV32I</td><td>32位整数指令集</td></tr><tr><td>RV32E</td><td>RV32I的子集，用于小型的嵌入式场景</td></tr><tr><td>RV64I</td><td>64位整数指令集，兼容RV32I</td></tr><tr><td>RV128I</td><td>128整数指令集，兼容RV64I和RV32I</td></tr></tbody></table><table><thead><tr><th>扩展指令集</th><th>描述</th></tr></thead><tbody><tr><td>M</td><td>整数乘法与除法指令集</td></tr><tr><td>A</td><td>存储器原子指令集</td></tr><tr><td>F</td><td>单精度(32bit)浮点指令集</td></tr><tr><td>D</td><td>双精度(64bit)浮点指令兼容F</td></tr><tr><td>C</td><td>压缩(Compressed)指令集</td></tr><tr><td>……</td><td>其他标准化和为标准化的指令集</td></tr></tbody></table><p>特定组合IMAFD被称为通用组合用字母G表示。<br>HART：指令执行流。</p><h2 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h2><p>RISC-V的特权级别(Privileged Specification)定义了三个特权级别(privilege level)<br>machine级别是最高的级别，所有的实现都需要支持。</p><table><thead><tr><th>level</th><th>Encoding</th><th>Name</th><th>Abbreviation</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>User&#x2F;Application</td><td>U</td></tr><tr><td>1</td><td>01</td><td>Supervisor</td><td>S</td></tr><tr><td>2</td><td>10</td><td>Reserved</td><td></td></tr><tr><td>3</td><td>11</td><td>Machine</td><td>M</td></tr><tr><td>不同的特权级别下时分别对应各自的一套Register(CSR),用于控制和获取对应level下的处理器工作状态。高级别的特权级别可以访问低级别的CSR，反之不行。</td><td></td><td></td><td></td></tr></tbody></table><h3 id="内存管理保护"><a href="#内存管理保护" class="headerlink" title="内存管理保护"></a>内存管理保护</h3><p>物理内存保护允许M模式指定u模式可以访问内存地址，支持R&#x2F;W&#x2F;X以及Lock。</p><h1 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><table><thead><tr><th>常用选项</th><th>含义</th></tr></thead><tbody><tr><td>-E</td><td>只做预处理</td></tr><tr><td>-c</td><td>只编译不链接，生产目标文件’.o’’</td></tr><tr><td>-S</td><td>生成汇编代码</td></tr><tr><td>-o file</td><td>把输出生成到由file指定文件名的文件中</td></tr><tr><td>-g</td><td>在输出的文件中加入支持调试的信息</td></tr><tr><td>-v</td><td>显示输出详细的命令执行过程信息</td></tr></tbody></table><p>编译：预处理指处理源文件中的#开头的预处理指令，编译则针对预处理的结果进行一系列的词汇分析、语法分析、语义分析，优化后生成的汇编指令，存放在.o为后缀的目标文件中。</p><p>汇编：汇编器将汇编语言转为机器可以执行的命令。</p><p>链接：链接器将汇编器生成的目标文件和一些标准库(譬如libc)文件组合，形成最终可执行的应用程序。</p><h2 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h2><p>ELF是一种Unix-like系统上的二进制文件格式标准。</p><p>ELF标准中定义的采用ELF格式分四类：</p><blockquote><p>可重定位文件：内容包含了代码和数据，可以被链接成可执行文件或共享目标文件。（Linux上的.o文件）</p><p>可执行文件：可以直接执行的程序（Linux上的a.out）</p><p>共享目标文件：内容包含了代码和数据，可以作为链接器的输入，在链接阶段和其他的Relocatable File或者Shared Object File 一起链接成新的Object File，或者运行阶段作为动态链接器的输入，和Executable File结合，作为进程的一部分来运行（Linux上的.so）</p><p>核心存储文件：进程意外终止时，系统可以将该进程的部分内容和终止时的其他状态信息保存到该文件中以供调试分析。（Linux上的core文件）</p></blockquote><p>ELF文件处理相关工具：Binutils（<a href="http://www.gnu.org/software/binutils/%EF%BC%89">http://www.gnu.org/software/binutils/）</a></p><blockquote><p>ar：归档文件，将多个文件打包成一个大文件。<br>as：被gcc调用，输入汇编文件，输出目标文件供链接器Id链接<br>Id：GNU链接器。被gcc调用，它把目标文件和各种库文件结合在一起，重定位数据，并链接符号引用。<br>objcopy：执行文件格式转换。<br>objdump：显示ELF文件的信息。<br>readelf：显示更多EFL格式文件的信息</p></blockquote><p><img src="https://img.picgo.net/2024/11/08/elff8c6577557cb7657.png" alt="elf"></p><p>读取一个hello_world.o的文件头信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello_world -o</span><br><span class="line">readelf -h hello_world.o</span><br></pre></td></tr></table></figure><h3 id="RISC-V架构常见gcc编译选项"><a href="#RISC-V架构常见gcc编译选项" class="headerlink" title="RISC-V架构常见gcc编译选项"></a>RISC-V架构常见gcc编译选项</h3><p>1.-march&#x3D;RISCV_ARCH</p><ul><li>用于告诉编译器目标芯片的架构情况，生成对应的二进制代码</li><li>比如：-march&#x3D;rv32im<ul><li>rv32：告诉编译器生成的代码实在RISC-V架构的32位芯片上运行，就不会使用ld和sd命令，而使用lw和sw</li><li>im：芯片支持i指令集和m指令集</li></ul></li></ul><p>2.-mabi&#x3D;RISC_ABI</p><table><thead><tr><th>数据类型</th><th>int</th><th>long</th><th>指针</th></tr></thead><tbody><tr><td>ilp32&#x2F;ilp32f&#x2F;ilp32d</td><td>32bit</td><td>32bit</td><td>32bit</td></tr><tr><td>lp64&#x2F;lp64f&#x2F;lp64d</td><td>32bit</td><td>64bit</td><td>64bit</td></tr></tbody></table><table><thead><tr><th>浮点数传参规则</th><th>需要支持的浮点指令扩展</th><th>float参数</th><th>double参数</th></tr></thead><tbody><tr><td>ilp32&#x2F;lp64</td><td>不需要</td><td>通过整数寄存器（a0-a1）传递</td><td>通过整数寄存器（a0-a3）传递</td></tr><tr><td>ilp32f&#x2F;lp64f</td><td>需要支持F扩展</td><td>通过浮点寄存器（fa0-fa1）传递</td><td>通过整数寄存器（a0-a3）传递</td></tr><tr><td>ilp32d&#x2F;lp64d</td><td>需要支持F和D扩展</td><td>通过浮点寄存器（fa0-fa1）传递</td><td>通过浮点寄存器（fa0-fa1）传递</td></tr></tbody></table><p>-mabi参数用于指定编译目标的adi，RISC-V定义了两个整型abi和三个浮点abi。</p><ul><li><p>两个整型abi</p><p>ilp32：int、long、pointer都是32位，long long是64位，char是8位，short是16位<br>lp64：long、pointer是64位，int是32位，其他类型和ilp32一样</p></li><li><p>三个浮点abi<br>“”空字符：在寄存器中不传递浮点参数<br>f：32位浮点寄存器，需要支持F扩展<br>d：64位浮点寄存器，需要支持F和D扩展</p></li></ul><p>3.-mlittle-endian、-mbig-endian</p><p>4.-mcmodel</p><p>-mcmodel&#x3D;medlow：只能寻址4G，对于32位架构芯片刚好，但是64位的芯片则不能寻址全部空间。</p><p>-mcmodel&#x3D;medany: 寻址范围在当前PC的前后2G范围，PC是不断变化的，可以实现把64位架构芯片地址全部寻址。</p><h3 id="模拟器QEMU"><a href="#模拟器QEMU" class="headerlink" title="模拟器QEMU"></a>模拟器QEMU</h3><p>QEMU是一套以GPL许可证分发源码的计算机系统模拟软件。支持架构：ARM，MIPS，AMD,RISC等等。</p><p>QEMU两种主要模式:user mode和system mode。</p><h4 id="QEMU的下载与安装"><a href="#QEMU的下载与安装" class="headerlink" title="QEMU的下载与安装"></a>QEMU的下载与安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-venv</span><br><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo pip install tomli</span><br><span class="line"></span><br><span class="line">wget https://download.qemu.org/qemu-9.0.1.tar.xz</span><br><span class="line">tar xvJf qemu-9.0.1.tar.xz</span><br><span class="line">cd qemu-9.0.1</span><br><span class="line"></span><br><span class="line">./configure --prefix=/opt/qemu --target-list=riscv64-softmmu,riscv64-linux-user</span><br><span class="line">make -j $(nproc)</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line">添加路径</span><br><span class="line">export PATH=$PATH:/opt/qemu/bin</span><br><span class="line">生效</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install qemu-system-misc</span><br><span class="line">查看版本</span><br><span class="line">riscv@qemu-vm:~/riscv64-linux/qemu-9.0.1$ qemu-system-riscv64 --version</span><br><span class="line">QEMU emulator version 9.0.1</span><br><span class="line">Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure><h4 id="RISCV的工具链下载与安装"><a href="#RISCV的工具链下载与安装" class="headerlink" title="RISCV的工具链下载与安装"></a>RISCV的工具链下载与安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#使用vpn下载更快</span></span></span><br><span class="line">git clone https://github.com/riscv-collab/riscv-gnu-toolchain</span><br><span class="line">cd riscv-gnu-toolchain</span><br><span class="line">git submodule update --init --recursive ##速度很慢</span><br><span class="line">安装依赖库</span><br><span class="line">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \</span><br><span class="line">gawk build-essential bison flex texinfo gperf libtool patchutils bc \</span><br><span class="line">zlib1g-dev libexpat-dev git \</span><br><span class="line">libglib2.0-dev libfdt-dev libpixman-1-dev \</span><br><span class="line">libncurses5-dev libncursesw5-dev</span><br><span class="line">sudo apt install python3 ninja-build</span><br><span class="line">安装路径</span><br><span class="line">./configure --prefix=/opt/riscv64</span><br><span class="line">sudo make linux -j $(nproc)</span><br><span class="line">添加路径</span><br><span class="line">sudo nano /etc/profile</span><br><span class="line">export PATH=$PATH:/opt/riscv64/bin</span><br><span class="line">source /etc/profile</span><br><span class="line">检查路径</span><br><span class="line">echo $PATH</span><br><span class="line">查看版本</span><br><span class="line">riscv64-unknown-linux-gnu-gcc -v</span><br><span class="line">安装riscv gcc gnu工具链</span><br><span class="line">sudo apt install gcc-riscv64-linux-gnu</span><br><span class="line">查看工具链版本</span><br><span class="line">riscv64-linux-gnu-gcc -v</span><br><span class="line">sudo cp /usr/riscv64-linux-gnu/lib/* /lib/</span><br></pre></td></tr></table></figure><h2 id="GDB工具的使用"><a href="#GDB工具的使用" class="headerlink" title="GDB工具的使用"></a>GDB工具的使用</h2><p>GDB的PDF<a href="https://sourceware.org/gdb/download/onlinedocs/gdb.pdf">网址</a></p><p>教程：<a href="https://www.bilibili.com/video/BV1EK411g7Li?vd_source=a29cba237e61c1d3e1d8193673a58e41&spm_id_from=333.788.videopod.episodes&p=5">GDB精简教程_哔哩哔哩_bilibili</a></p><p>使用GDB调试qemu下的riscv64-linux-gnu-gcc编译的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc -g hello.c -o hello</span><br><span class="line">qemu-riscv64 ./hello</span><br><span class="line">riscv64-unknown-linux-gnu-gdb hello</span><br></pre></td></tr></table></figure><h2 id="Linker-Script链接脚本"><a href="#Linker-Script链接脚本" class="headerlink" title="Linker Script链接脚本"></a>Linker Script链接脚本</h2><p>链接器一般都提供多种控制整个链接过程的方法，以用来产生用户所须要的文件。</p><p>一般链接器有如下三种方法:</p><p>使用命令行来给链接器指定参数，ld的-o、-e参数就属于这类。<br>将链接指令存放在目标文件里面，编译器经常会通过这种方法向链接器传递指令。方法也比较常见，只是我们平时很少关注，比如VISUAL C++编译器会把链接参数放在PE目标文件的.drectve段以用来传递参数。<br>使用链接控制脚本。</p><p>绝大部分情况下，我们使用链接器提供的默认链接规则对目标文件进行链接。</p><p><strong>在编译普通的应用程序时，可以使用默认的链接器脚本，但是对于内核程序来说，它本身也是一个.elf文件，这个.elf文件该怎么组织，各个段放到内存中什么地方，这个由于和底层硬件强相关，所以需要我们自己编写相关的链接器脚本。</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b4d12962cd60253b018e622693ea2405.png"></p><blockquote><p>在C代码中直接获取链接器脚本中定义的符号是有一定的限制的。C语言是一种静态编译语言，在编译时会将源代码转换为机器码，并生成可执行文件。链接器脚本用于指导链接器如何组织可执行文件的各个部分，包括代码段、数据段、符号表等。</p><p><strong>代码中的符号表</strong>是编译器在编译过程中使用的数据结构，用于管理程序中的变量、函数和其他标识符的信息。</p><p>在C代码中，无法直接引用链接器脚本中定义的符号的值，因为C编译器并不了解链接器脚本的细节。C编译器只能根据给定的C代码进行编译，将代码转换为机器码，并生成符号表。符号表中包含了在C代码中定义的全局变量、函数等符号及其对应的地址。<br>要在C代码中获取链接器脚本中定义的符号的值，一种常见的做法是通过在C代码中声明外部变量，并使用链接器脚本中定义的符号来初始化这些外部变量。这样，链接器在链接阶段会将外部变量与链接器脚本中定义的符号关联起来，并将符号的值赋给外部变量。然后，C代码就可以通过访问这些外部变量来获取链接器脚本中定义的符号的值。<br>总之，C代码无法直接获取链接器脚本中定义的符号的值，但可以通过声明外部变量并与符号关联来间接获取。这种间接的方式使得C代码能够与链接器脚本进行交互，并共享符号的值。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/README/"/>
      <url>/2024/12/08/blog_makedown/README/</url>
      
        <content type="html"><![CDATA[<h1 id="blog-makedown"><a href="#blog-makedown" class="headerlink" title="blog_makedown"></a>blog_makedown</h1><p>store myblog md file</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/RISC-V%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
      <url>/2024/12/08/blog_makedown/RISC-V%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="RISC-V汇编语言入门"><a href="#RISC-V汇编语言入门" class="headerlink" title="RISC-V汇编语言入门"></a>RISC-V汇编语言入门</h1><p>一个完整的RISC-V汇编程序是多条语句组成。</p><p>一条典型的RISC-V汇编语句由三部分组成：[label:] [operation] [comment]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_start：#可以将_start这个label理解为地址</span><br><span class="line">li x6 ，5</span><br></pre></td></tr></table></figure><p><strong>汇编指令编码格式</strong></p><p>指令长度：ILEN1 &#x3D; 32bits(RV32I)</p><p>指令对齐：IALIGN&#x3D;32bits(RV32I)</p><p>指令在内存中按照<strong>小端序</strong>排列</p><p><strong>机器源码和汇编指令的对应关系</strong></p><p><img src="C:\Users\71027\AppData\Roaming\Typora\typora-user-images\1730710785146.png" alt="1730710785146"></p><p>比如机器源码0110011，每个机器源码是7位，最后2位都是11，[6:5]的是纵坐标，[4:2]的是横坐标，所以对应关系是OP指令</p><p>![](C:\Users\71027\Desktop\笔记文件\屏幕截图 2024-11-04 170738.png)</p><p><strong><a href="https://blog.csdn.net/weixin_40539125/article/details/103058420">补码&#x2F;反码、零扩展和符号位扩展（Zero extension and Sign extension）-CSDN博客</a></strong></p><ol><li>符号扩展（Sign Extension）</li></ol><p>符号扩展用于扩展<strong>有符号数</strong>（例如，有符号的整数）。在扩展时会保持原数值的符号位。</p><ul><li><strong>方法</strong>：在扩展位上填充原数值的符号位。例如，如果原数的最高位是1（负数），那么在高位填充1；如果最高位是0（正数），则填充0。</li><li>举例<ul><li>8位二进制数 <code>1110 0101</code> （表示负数）进行符号扩展到16位：扩展为 <code>1111 1111 1110 0101</code>。</li><li>8位二进制数 <code>0010 1010</code> （表示正数）进行符号扩展到16位：扩展为 <code>0000 0000 0010 1010</code>。</li></ul></li></ul><ol start="2"><li>零扩展（Zero Extension）</li></ol><p>零扩展用于扩展<strong>无符号数</strong>，不会关心符号，直接在高位填充零。</p><ul><li><strong>方法</strong>：在扩展的高位填充0，以保持原始值的数值大小不变。</li><li>举例<ul><li>8位二进制数 <code>1110 0101</code> 进行零扩展到16位：扩展为 <code>0000 0000 1110 0101</code>。</li><li>8位二进制数 <code>0010 1010</code> 进行零扩展到16位：扩展为 <code>0000 0000 0010 1010</code>。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/08/blog_makedown/RISC-V%20Vector%20Extension/"/>
      <url>/2024/12/08/blog_makedown/RISC-V%20Vector%20Extension/</url>
      
        <content type="html"><![CDATA[<h1 id="RISC-V-Vector-Extension"><a href="#RISC-V-Vector-Extension" class="headerlink" title="RISC-V Vector Extension"></a>RISC-V Vector Extension</h1><hr><ul><li><p>RISC-V 向量扩展（RVV, RISC-V Vector Extension）中的指令可以大致分为三大类：<strong>设置向量长度</strong>（<code>setvl</code>）、<strong>加载&#x2F;存储</strong>（<code>load/store</code>）、和 <strong>数学运算</strong>（<code>mathematical operations</code>）。以下是这三类指令的详细描述：</p><p><strong>setvl</strong> 指令</p><p><code>setvl</code> 指令用于设置向量长度，并返回当前向量长度。它是 RVV 中的核心指令，用于动态地控制每条指令处理的向量元素数量。通过设置向量长度寄存器（<code>vl</code>），可以使得后续的指令在处理数据时，按照给定的向量长度来处理。</p><ul><li><p><strong>指令格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setvl  xlen, rs1</span><br></pre></td></tr></table></figure></li><li><p><strong>功能</strong>：</p><ul><li>设置向量长度（<code>vl</code>）。</li><li><code>rs1</code> 寄存器的值决定了目标向量长度（<code>vl</code>）。</li><li>返回的向量长度会被存储在 <code>vlen</code> 寄存器中。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setvl   x0, x1  // 设置向量长度</span><br></pre></td></tr></table></figure></li></ul><p> <strong>加载&#x2F;存储指令</strong>（Load&#x2F;Store）</p><p>加载和存储指令用于将数据从内存加载到向量寄存器中，或者将向量寄存器中的数据存储回内存。这些指令的操作对象是向量寄存器，可以处理多个数据元素。</p><ul><li><p><strong>加载指令（Vector Load）</strong>：</p><ul><li>用于从内存中加载数据到向量寄存器。</li><li>支持不同的访问模式，包括按字节、按字、按双字等。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vlb    vd, (rs1)      // 加载字节数据到向量寄存器</span><br><span class="line">vlh    vd, (rs1)      // 加载半字数据到向量寄存器</span><br><span class="line">vld    vd, (rs1)      // 加载双字数据到向量寄存器</span><br></pre></td></tr></table></figure></li><li><p><strong>存储指令（Vector Store）</strong>：</p><ul><li>用于将向量寄存器的数据存储回内存。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vsb    (rs1), vs      // 将向量寄存器中的字节存储到内存</span><br><span class="line">vsh    (rs1), vs      // 将向量寄存器中的半字存储到内存</span><br><span class="line">vsd    (rs1), vs      // 将向量寄存器中的双字存储到内存</span><br></pre></td></tr></table></figure></li></ul><p><strong>数学运算指令</strong>（Mathematical Operations）</p><p>数学运算指令用于执行向量运算，包括加法、减法、乘法、除法、按元素操作、以及向量间的点积等。这些指令通常操作向量寄存器中的数据。</p><ul><li><p><strong>加法&#x2F;减法指令</strong>：</p><ul><li>用于执行向量元素之间的加法或减法。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vadd   vd, vs, vt   // 向量加法，vd = vs + vt</span><br><span class="line">vsub   vd, vs, vt   // 向量减法，vd = vs - vt</span><br></pre></td></tr></table></figure></li><li><p><strong>乘法&#x2F;除法指令</strong>：</p><ul><li>用于执行向量元素之间的乘法或除法。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmul   vd, vs, vt   // 向量乘法，vd = vs * vt</span><br><span class="line">vdiv   vd, vs, vt   // 向量除法，vd = vs / vt</span><br></pre></td></tr></table></figure></li><li><p><strong>按元素操作</strong>：</p><ul><li>例如按位与、按位或、按位异或等操作。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vand   vd, vs, vt   // 向量按位与</span><br><span class="line">vor    vd, vs, vt   // 向量按位或</span><br><span class="line">vxor   vd, vs, vt   // 向量按位异或</span><br></pre></td></tr></table></figure></li><li><p><strong>归约操作</strong>：</p><ul><li>执行归约操作，如计算向量元素的总和、最小值、最大值等。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vredsum  rd, vs     // 向量元素求和</span><br><span class="line">vredmin  rd, vs     // 向量元素求最小值</span><br><span class="line">vredmax  rd, vs     // 向量元素求最大值</span><br></pre></td></tr></table></figure></li><li><p><strong>比较和掩码操作</strong>：</p><ul><li>用于比较向量元素，生成掩码或标志。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vcmpeq  vd, vs, vt  // 向量元素相等比较</span><br><span class="line">vcmpgt  vd, vs, vt  // 向量元素大于比较</span><br></pre></td></tr></table></figure></li></ul><p>RISC-V 向量扩展（RVV）指令集包括三大类指令：</p><ol><li><strong>setvl</strong>：设置向量长度。</li><li><strong>加载&#x2F;存储</strong>：用于向量数据的加载和存储操作。</li><li><strong>数学运算</strong>：进行加法、减法、乘法、除法、按位运算、比较等操作。</li></ol><p>这些指令的组合使得 RISC-V 向量扩展能够高效地处理并行数据，适用于大规模的数据处理任务，如矩阵计算、科学计算等。</p></li></ul><p>在 RISC-V 向量扩展（RVV）中，<strong>加载&#x2F;存储（load&#x2F;store）指令</strong>按照内存寻址模型（memory addressing model）的不同，可以进一步分为以下三类：</p><hr><h3 id="Unit-Strided-Load-x2F-Store"><a href="#Unit-Strided-Load-x2F-Store" class="headerlink" title="Unit Strided Load&#x2F;Store"></a><strong>Unit Strided Load&#x2F;Store</strong></h3><p><strong>Unit strided</strong> 是最简单的内存寻址模型，数据在内存中是连续存储的，每个元素占据固定的内存字节大小（如字节、半字、字或双字）。这种模型假设内存地址是以固定步幅（stride&#x3D;1）递增的。</p><p>指令格式：</p><ul><li><p><strong>加载指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vle8   vd, (rs1)      // 加载连续的 8-bit 数据到向量寄存器</span><br><span class="line">vle16  vd, (rs1)      // 加载连续的 16-bit 数据到向量寄存器</span><br><span class="line">vle32  vd, (rs1)      // 加载连续的 32-bit 数据到向量寄存器</span><br><span class="line">vle64  vd, (rs1)      // 加载连续的 64-bit 数据到向量寄存器</span><br></pre></td></tr></table></figure></li><li><p><strong>存储指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vse8   (rs1), vd      // 存储向量寄存器中的 8-bit 数据到连续的内存</span><br><span class="line">vse16  (rs1), vd      // 存储 16-bit 数据</span><br><span class="line">vse32  (rs1), vd      // 存储 32-bit 数据</span><br><span class="line">vse64  (rs1), vd      // 存储 64-bit 数据</span><br></pre></td></tr></table></figure></li></ul><p>特点：</p><ul><li>数据在内存中以连续地址存储。</li><li>使用场景：矩阵或向量的逐元素处理，如密集向量运算。</li></ul><p><strong>Strided Load&#x2F;Store</strong></p><p><strong>Strided</strong> 寻址模型允许内存地址以固定步幅（stride）递增。这种模型用于处理间隔存储的数据，例如二维数组中的一行数据。</p><p>指令格式：</p><ul><li><p><strong>加载指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vlse8  vd, (rs1), rs2   // 加载具有固定步幅的 8-bit 数据</span><br><span class="line">vlse16 vd, (rs1), rs2   // 加载 16-bit 数据</span><br><span class="line">vlse32 vd, (rs1), rs2   // 加载 32-bit 数据</span><br><span class="line">vlse64 vd, (rs1), rs2   // 加载 64-bit 数据</span><br></pre></td></tr></table></figure></li><li><p><strong>存储指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vsse8  (rs1), rs2, vd   // 存储 8-bit 数据到具有固定步幅的内存</span><br><span class="line">vsse16 (rs1), rs2, vd   // 存储 16-bit 数据</span><br><span class="line">vsse32 (rs1), rs2, vd   // 存储 32-bit 数据</span><br><span class="line">vsse64 (rs1), rs2, vd   // 存储 64-bit 数据</span><br></pre></td></tr></table></figure></li></ul><p>参数说明：</p><ul><li><code>rs1</code> 是基地址寄存器。</li><li><code>rs2</code> 是步幅寄存器（stride），指定每个元素之间的字节距离。</li></ul><p>特点：</p><ul><li>数据在内存中以固定步幅分布。</li><li>使用场景：处理稀疏矩阵行、二维数组或其他非连续存储的数据。</li></ul><p><strong>Indexed Load&#x2F;Store</strong></p><p><strong>Indexed</strong> 寻址模型允许每个元素的地址由基地址加上一个偏移量（offsets）决定。偏移量可以存储在一个单独的向量寄存器中，使得可以自由访问内存中的任意位置。</p><p>指令格式：</p><ul><li><p><strong>加载指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vluxei8  vd, (rs1), vs2   // 加载 8-bit 数据，地址由索引寄存器决定</span><br><span class="line">vluxei16 vd, (rs1), vs2   // 加载 16-bit 数据</span><br><span class="line">vluxei32 vd, (rs1), vs2   // 加载 32-bit 数据</span><br><span class="line">vluxei64 vd, (rs1), vs2   // 加载 64-bit 数据</span><br></pre></td></tr></table></figure></li><li><p><strong>存储指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vsuxei8  (rs1), vs2, vd   // 存储 8-bit 数据到索引指定的地址</span><br><span class="line">vsuxei16 (rs1), vs2, vd   // 存储 16-bit 数据</span><br><span class="line">vsuxei32 (rs1), vs2, vd   // 存储 32-bit 数据</span><br><span class="line">vsuxei64 (rs1), vs2, vd   // 存储 64-bit 数据</span><br></pre></td></tr></table></figure></li></ul><p>参数说明：</p><ul><li><code>rs1</code> 是基地址寄存器。</li><li><code>vs2</code> 是索引寄存器，存储相对基地址的偏移量。</li></ul><p><strong>特点：</strong></p><ul><li>数据地址可以完全动态控制，适合处理非规则的数据布局。</li><li>使用场景：稀疏矩阵列访问、图处理、或不规则存储数据的加载和存储。</li></ul><table><thead><tr><th><strong>类别</strong></th><th><strong>内存分布</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>Unit Strided</strong></td><td>连续存储</td><td>地址递增步幅为 1</td><td>密集向量运算</td></tr><tr><td><strong>Strided</strong></td><td>固定步幅分布</td><td>地址递增步幅由寄存器 <code>rs2</code> 指定</td><td>稀疏矩阵行处理</td></tr><tr><td><strong>Indexed</strong></td><td>任意分布</td><td>地址偏移由索引向量决定</td><td>稀疏矩阵列、不规则数据处理</td></tr></tbody></table><h2 id="7个CSR-Context-Status-Register-寄存器"><a href="#7个CSR-Context-Status-Register-寄存器" class="headerlink" title="7个CSR(Context Status Register)寄存器"></a>7个CSR(Context Status Register)寄存器</h2><h3 id="Vstart-Vector-Start-寄存器"><a href="#Vstart-Vector-Start-寄存器" class="headerlink" title="Vstart(Vector Start)寄存器"></a>Vstart(Vector Start)寄存器</h3><p>存储向量指令中被执行第一个元素的索引值。</p><p>通常在向量指令执行过程中产生了陷阱被写入，记录了陷阱时向量指令操作元素的索引，以便跳出陷阱之后能够继续执行剩下的元素。当向量指令产生非法指令异常时，vstart寄存器将不会被改写。</p><p>如果vstart数值大于vl的值，说明vstart指向的元素索引已经超过当前所有元素的范围，该指令不会执行，同事寄存器复位0</p><h3 id="Vxsat寄存器"><a href="#Vxsat寄存器" class="headerlink" title="Vxsat寄存器"></a>Vxsat寄存器</h3><p>vxsat为可读可写寄存器，该寄存器不仅有独立的寄存器地址，并且在vcsr寄存器中也有对应的域。该寄存器有效表示输出结果做了饱和截位以适应目的寄存器格式。比如当运算发生正溢出时，保留结果为能取到的最大正值；当运算发生负溢出时，保留结果为负数最小值。</p><h3 id="vxrm寄存器"><a href="#vxrm寄存器" class="headerlink" title="vxrm寄存器"></a>vxrm寄存器</h3><p>vxrm[1:0]为可读可写寄存器，该寄存器不仅有独立的寄存器地址，并且在vcsr寄存器中也有对应的域。该寄存器控制定点舍入模式，一共四种模式，分别是round-to-nearest-up（rnu）、round-to-nearest-even(rne)、round-down(rdn)、round-to-odd(rod)。(问题：可否解释一下定点数在内存中的存放格式)<br>vxrm[1:0]寄存器通过单条csrwi指令写入值。<br>假如源操作数是v，有低d bit数据要被截掉，那么做完rounding-mode之后的最终结果应该是(v&gt;&gt;d)+r，r就是根据不同的rounding mode得到的增量值。<br>rnu：向距离近的方向进行舍入，当距离与两边都相等时，向上舍入。<br>rne：向距离近的方向进行舍入，当距离与两边都相等时，向偶数方向舍入。<br>rdn：向下舍入，直接取移位后的值。<br>rod：舍入到奇数值方向。<br>其中，v[d-1]表示权重位。当v[d-1]&#x3D;0，表示距离舍的方向更近；当v[d-1]&#x3D;1且v[d-2:0]&#x3D;0时，距离舍入两个方向距离均相等；当v[d-1]&#x3D;1，且v[d-2:0] !&#x3D; 0时，表示距离入的方向更近。</p><h3 id="vcsr寄存器"><a href="#vcsr寄存器" class="headerlink" title="vcsr寄存器"></a>vcsr寄存器</h3><p>vcsr[2:0]寄存器为可读可写寄存器，该寄存器由vxrm[1:0]，以及vxsat组成。<br> riscv spec中fflags和frm寄存器也采用的这样的设计。这类状态寄存器，希望方便快速的读写，比如有时候希望一条指令能把这两个寄存器的值同时读出来。又或者写这两个寄存器，如果要同时写，就得先做移位拼接在写，那有的时候只想改变其中一个寄存器的值，也做移位在拼接然后写的操作就比较慢，因此单独写对应的地址就显得尤为方便快速。考虑到适应不同的需求，这类状态寄存器就设计为既有各自单独的寄存器存储空间，又集中在一个寄存集中划分各自的域。</p><h3 id="vtype寄存器"><a href="#vtype寄存器" class="headerlink" title="vtype寄存器"></a>vtype寄存器</h3><p>vtype为只读寄存器，位宽同通用整型架构寄存器位宽（XLEN）。该寄存器提供了默认值用于解析向量寄存器中的内容，并且只能通过vsetvl{i}指令进行更新（这样做的目的是使得维护vtype寄存器的状态简单化）。<br>vtype寄存器用于解析向量寄存器文件中的内容、决定单个向量寄存器中元素的组成以及决定多个向量寄存器是如分组的。<br>vtype寄存器有五个域，分别是vill，vma，vta，vsew[2:0]，vlmul[2:0]。</p><p><img src="https://img.picgo.net/2024/11/22/-2024-11-22-1525179aad71b0c2eb9e83.png" alt="屏幕截图 2024 11 22 152517"></p><h3 id="vl寄存器"><a href="#vl寄存器" class="headerlink" title="vl寄存器"></a>vl寄存器</h3><p>vl寄存器为只读寄存器，该寄存器存储着一个无符号整数，用来规定一条向量指令需要更新多少个元素。<br>该寄存器只能被vsetvli、vsetvl指令以及fault-only-first矢量读取指令的变体进行更新。<br>目的寄存器中元素索引大于等于vl的元素，将不会被修改。如果vstart大于等于vl，那么目的寄存器的任何元素都不会被修改。<br>vl的位宽由最小元素组成的最大向量长度决定。最小的元素位宽至少是8bit，最大的分组设置为LMUL等于8，那么VLMAX&#x3D;LMUL * (VLEN &#x2F; SEW) &#x3D; VLEN。也就是说vl的位宽，直接由VLEN的大小决定。</p><h3 id="vlenb寄存器"><a href="#vlenb寄存器" class="headerlink" title="vlenb寄存器"></a>vlenb寄存器</h3><p>该寄存器为只读寄存器，表示以字节为单位的向量寄存器长度，vlenb&#x3D;VLEN&#x2F;8。vlenb是一个设计时常量，增加这个寄存器是为了减少一些需要直接用到vlenb的程序的额外计算指令的开销。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MLIR</title>
      <link href="/2024/12/08/MLIR/"/>
      <url>/2024/12/08/MLIR/</url>
      
        <content type="html"><![CDATA[<h1 id="方言-Dialect"><a href="#方言-Dialect" class="headerlink" title="方言 Dialect"></a><strong>方言 Dialect</strong></h1><p>MLIR 是一个设计完全可扩展的基础设施，它的可扩展性体现在 IR 的各个元素，包括 <code>operations</code>、<code>types</code> 和 <code>attributes</code> 等都是可以进行扩展的。这种可扩展性是通过方言（dialect）来实现的，方言为 IR 提供了一种通过 <code>namespace</code> 分组的机制，可以赋予操作（operation）新的语义，实现自定义的行为。</p><p>在 IR 中，如果想要为操作赋予新的语义以实现自定义行为，通常需要添加新的属性或者重新定义输入输出。这时，IR 的可扩展性就变得非常重要。</p><p>举例来说，考虑一个 <code>matmul</code> 算子，如果想要为它添加一个属性以进行后端图优化，就需要查看该算子的 <code>attributes</code> 字段是否可扩展，以及 <code>op builder</code> 是否允许传入该属性。只有两者都支持，才能满足需求。否则，通常需要创建一个自定义的 matmul 算子，并将原有的 matmul 算子替换为自定义算子。</p><p>而在 MLIR 中，你可以定义一个特定的方言，比如 toy dialect，然后在该方言中定义一个 matmul 算子，这样就可以获得 <code>toy.matmul</code> 算子。在图优化过程中，可以根据方言的不同对算子进行分层优化，使用不同方言的转换来实现多层次的优化。</p><h2 id="dialect如何工作的？"><a href="#dialect如何工作的？" class="headerlink" title="dialect如何工作的？"></a>dialect如何工作的？</h2><p>dialect 将所有的IR放在了同一个<a href="https://zhida.zhihu.com/search?content_id=217582620&content_type=Article&match_order=1&q=%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4&zhida_source=entity">命名空间</a>中，分别对每个IR定义对应的产生式并绑定相应的操作，从而生成一个MLIR的模型。</p><p>每种语言的 dialect(如tensorflow dialect、HLO dialect、LLVM IR dialect)都是<strong>继承自 mlir::Dialect，并注册了属性、操作和数据类型，也可以使用虚函数来改变一些通用性行为。</strong></p><p>整个的编译过程：从源语言生成 AST（Abstract Syntax Tree，<a href="https://zhida.zhihu.com/search?content_id=217582620&content_type=Article&match_order=1&q=%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91&zhida_source=entity">抽象语法树</a>），借助 dialect 遍历 AST，产生 MLIR 表达式（此处可为多层IR通过 Lowering Pass 依次进行分析），最后经过 MLIR 分析器，生成目标硬件程序。</p><p><img src="https://img.picgo.net/2024/12/02/v2-84ca774231e37e4c20d5fba20c9e06a9_r534aa50973866dea.png" alt="v2 84ca774231e37e4c20d5fba20c9e06a9 r"></p><h2 id="dialect组件"><a href="#dialect组件" class="headerlink" title="dialect组件"></a>dialect组件</h2><p>一个 <strong>Dialect</strong> 主要由以下几个核心组件构成：</p><ul><li><strong>Type</strong>：类型是表示数据的基本方式。每个 Dialect 都可以定义自己特定的类型。例如，标准 Dialect 中的整数类型、浮点类型，或者自定义 Dialect 中的矩阵类型、张量类型等。</li><li><strong>Attribute</strong>：属性是附加到操作上的不可变数据。属性通常用于表示静态数据，如常量值、尺寸、维度等信息。</li><li><strong>Operation</strong>：操作表示具体的计算行为或转换。每个操作都可能有不同的属性、输入和输出类型，并且可以具有限制（Constraints），接口（Interface），特征（Trait）等。操作可以是算术运算、控制流、内存操作等。</li><li><strong>Interface</strong>：接口用于定义操作间的交互方式。它定义了一个操作能够暴露出来的行为，并确保在实现这些操作时满足一定的协议。</li><li><strong>Trait</strong>：特征是附加到操作的元数据或行为描述。它允许我们为操作添加功能性特性，比如支持某种优化策略或特定硬件特性等。</li></ul><h3 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h3><p>与操作定义格式相关的两种描述方式如下：</p><ol><li><strong>ODS描述格式</strong>：用于在 MLIR 中定义操作的完整语法和行为。</li><li><strong>操作签名（Operation Signature）</strong>：是一个更加简化的描述，主要侧重于操作的输入输出以及特性，而不涉及操作的完整定义细节。</li></ol><h4 id="ODS描述格式"><a href="#ODS描述格式" class="headerlink" title="ODS描述格式"></a>ODS描述格式</h4><p>ODS（Operation Definition Schemes）是用于在 MLIR 中定义操作的一种格式，它允许通过特定的语法来描述操作的输入输出、属性、约束、特征等。通过 ODS，操作的细节定义会生成自动化代码。</p><h4 id="示例-ODS-格式："><a href="#示例-ODS-格式：" class="headerlink" title="示例 ODS 格式："></a>示例 ODS 格式：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def AddOp : Arith_Op &#123;</span><br><span class="line">  let summary = <span class="string">&quot;Add two integers&quot;</span>;</span><br><span class="line">  let description = <span class="string">&quot;This operation adds two integer values and returns the result.&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  let arguments = (</span><br><span class="line">    Arg&lt;lhs, i32&gt;,</span><br><span class="line">    Arg&lt;rhs, i32&gt;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  let results = (</span><br><span class="line">    Result&lt;result, i32&gt;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  let attributes = (</span><br><span class="line">    Attr&lt;some_attribute, i32&gt;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  let constraints = [</span><br><span class="line">    lhs.type == rhs.type</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  let traits = [</span><br><span class="line">    <span class="string">&quot;HasSideEffect&quot;</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  let interfaces = [</span><br><span class="line">    <span class="string">&quot;MemoryInterface&quot;</span></span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键元素："><a href="#关键元素：" class="headerlink" title="关键元素："></a>关键元素：</h4><ul><li><strong>summary 和 description</strong>：简要描述操作的功能。</li><li><strong>arguments 和 results</strong>：定义输入和输出的操作数。</li><li><strong>attributes</strong>：定义与操作相关的附加信息。</li><li><strong>constraints</strong>：定义操作数之间的关系和限制条件。</li><li><strong>traits</strong>：标识操作的附加特性，例如副作用等。</li><li><strong>interfaces</strong>：定义操作间的交互方式，例如内存接口。</li></ul><h4 id="操作签名"><a href="#操作签名" class="headerlink" title="操作签名"></a>操作签名</h4><p>与 ODS 定义不同，<strong>操作签名</strong>通常是对操作的简化描述，主要关注于操作的输入输出类型，而不涉及具体的操作细节。这种方式在一些语境中可能用于描述操作的接口或者操作的高层结构。</p><p><strong>示例操作签名：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;inplace = true&#125; : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt; loc(&quot;example/file/path&quot;:12:1)</span><br></pre></td></tr></table></figure><p><strong>关键元素：</strong></p><ul><li><p>**{inplace &#x3D; true}**：操作的特性（例如原地修改输入张量）。</p></li><li><p>**(tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;**：定义输入输出张量的类型（输入是 <code>2x3</code> 形状的 <code>f64</code> 张量，输出是 <code>3x2</code> 形状的 <code>f64</code> 张量）。</p></li><li><p>**loc(“example&#x2F;file&#x2F;path”:12:1)**：指定该操作在源代码中的位置（文件路径和行列号）</p></li></ul><h2 id="ODS和ODDR"><a href="#ODS和ODDR" class="headerlink" title="ODS和ODDR"></a>ODS和ODDR</h2><p>同时存在 ODS 和 DRR 两个重要的模块，这两个模块都是基于 tableGen 模块，<strong>ODS 模块用于定义 operation ，DRR 模块用于实现两个 dialect 之间的 conversion</strong>。</p><p>ODS</p><p>ODS 模块通过描述操作的<strong>属性</strong>、<strong>输入输出类型</strong>、<strong>约束</strong>等信息，自动生成代码，以简化操作的定义和管理。通过这种方式，可以高效地为特定的 Dialect 定义复杂的操作，而不需要手动编写大量的 boilerplate 代码。</p><ul><li><strong>ODS 生成代码</strong>：ODS 基于定义好的描述生成操作的定义、类型检查、构造函数、序列化、反序列化等代码。</li></ul><p>DDR</p><p>ODS 模块通过描述操作的<strong>属性</strong>、<strong>输入输出类型</strong>、<strong>约束</strong>等信息，自动生成代码，以简化操作的定义和管理。通过这种方式，可以高效地为特定的 Dialect 定义复杂的操作，而不需要手动编写大量的 boilerplate 代码。</p><ul><li><strong>ODS 生成代码</strong>：ODS 基于定义好的描述生成操作的定义、类型检查、构造函数、序列化、反序列化等代码。</li></ul><h1 id="定义方言"><a href="#定义方言" class="headerlink" title="定义方言"></a><strong>定义方言</strong></h1><p>方言可以被理解为一组操作（op），因此定义方言就意味着定义操作。操作的定义通常包括以下内容：</p><ul><li>定义操作的静态信息，包括输入输出、属性和类型等，这些信息描述了操作的语义。</li><li>创建操作的构造方法，用于创建一个操作并将其添加到IR中。</li><li>创建操作的实现方法，用于在IR执行时调用。</li></ul><p>MLIR提供了一种领域特定语言（DSL），使得我们可以通过声明的方式描述和定义操作的输入输出、属性、类型和行为。利用MLIR提供的 tablegen 工具（mlir-tblgen），我们可以基于 Operation Definition Specification（ODS）框架自动生成操作类的声明和实现代码。这种声明式的定义风格使得操作的定义更加清晰易懂，我们只需要关注操作的语义定义即可。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">llvm-project/</span><br><span class="line">└── mlir/</span><br><span class="line">    ├── <span class="keyword">include</span>/</span><br><span class="line">    │   └── mlir/</span><br><span class="line">    │       └── Dialect/</span><br><span class="line">    │           └── MyDialect/</span><br><span class="line">    │               ├── IR/</span><br><span class="line">    │               │   ├── MyDialect.h        <span class="comment"># 方言定义</span></span><br><span class="line">    │               │   ├── MyOp.h             <span class="comment"># 操作定义</span></span><br><span class="line">    │               │   ├── MyDialect.td       <span class="comment"># 方言的 TableGen 定义</span></span><br><span class="line">    │               ├── Transforms/             <span class="comment"># 优化定义</span></span><br><span class="line">    │               │   ├── MyTransform.h       <span class="comment"># 优化声明</span></span><br><span class="line">    │               │   └── CMakeLists.txt      <span class="comment"># 优化相关 CMake 文件</span></span><br><span class="line">    │               └── CMakeLists.txt          <span class="comment"># 方言定义相关 CMake 文件</span></span><br><span class="line">    ├── lib/</span><br><span class="line">    │   └── mlir/</span><br><span class="line">    │       └── Dialect/</span><br><span class="line">    │           └── MyDialect/</span><br><span class="line">    │               ├── IR/</span><br><span class="line">    │               │   ├── MyDialect.cpp      <span class="comment"># 方言实现</span></span><br><span class="line">    │               │   ├── MyOp.cpp           <span class="comment"># 操作实现</span></span><br><span class="line">    │               └── Transforms/</span><br><span class="line">    │                   ├── MyTransform.cpp    <span class="comment"># 优化实现</span></span><br><span class="line">    │                   └── CMakeLists.txt     <span class="comment"># 优化实现 CMake 文件</span></span><br><span class="line">    └── CMakeLists.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V汇编语言入门</title>
      <link href="/2024/12/08/RISC-V%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
      <url>/2024/12/08/RISC-V%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>一个完整的RISC-V汇编程序是多条语句组成。</p><p>一条典型的RISC-V汇编语句由三部分组成：[label:] [operation] [comment]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_start：#可以将_start这个label理解为地址</span><br><span class="line">li x6 ，5</span><br></pre></td></tr></table></figure><p><strong>汇编指令编码格式</strong></p><p>指令长度：ILEN1 &#x3D; 32bits(RV32I)</p><p>指令对齐：IALIGN&#x3D;32bits(RV32I)</p><p>指令在内存中按照<strong>小端序</strong>排列</p><p><strong>机器源码和汇编指令的对应关系</strong></p><p><img src="C:\Users\71027\AppData\Roaming\Typora\typora-user-images\1730710785146.png" alt="1730710785146"></p><p>比如机器源码0110011，每个机器源码是7位，最后2位都是11，[6:5]的是纵坐标，[4:2]的是横坐标，所以对应关系是OP指令</p><p>![](C:\Users\71027\Desktop\笔记文件\屏幕截图 2024-11-04 170738.png)</p><p><strong><a href="https://blog.csdn.net/weixin_40539125/article/details/103058420">补码&#x2F;反码、零扩展和符号位扩展（Zero extension and Sign extension）-CSDN博客</a></strong></p><ol><li>符号扩展（Sign Extension）</li></ol><p>符号扩展用于扩展<strong>有符号数</strong>（例如，有符号的整数）。在扩展时会保持原数值的符号位。</p><ul><li><strong>方法</strong>：在扩展位上填充原数值的符号位。例如，如果原数的最高位是1（负数），那么在高位填充1；如果最高位是0（正数），则填充0。</li><li>举例<ul><li>8位二进制数 <code>1110 0101</code> （表示负数）进行符号扩展到16位：扩展为 <code>1111 1111 1110 0101</code>。</li><li>8位二进制数 <code>0010 1010</code> （表示正数）进行符号扩展到16位：扩展为 <code>0000 0000 0010 1010</code>。</li></ul></li></ul><ol start="2"><li>零扩展（Zero Extension）</li></ol><p>零扩展用于扩展<strong>无符号数</strong>，不会关心符号，直接在高位填充零。</p><ul><li><strong>方法</strong>：在扩展的高位填充0，以保持原始值的数值大小不变。</li><li>举例<ul><li>8位二进制数 <code>1110 0101</code> 进行零扩展到16位：扩展为 <code>0000 0000 1110 0101</code>。</li><li>8位二进制数 <code>0010 1010</code> 进行零扩展到16位：扩展为 <code>0000 0000 0010 1010</code>。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RVV Intrinsic</title>
      <link href="/2024/12/04/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E9%93%BE%E7%BC%96%E8%AF%91%E5%8C%85%E5%90%ABRVV-Intrinsic%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2024/12/04/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E9%93%BE%E7%BC%96%E8%AF%91%E5%8C%85%E5%90%ABRVV-Intrinsic%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="RVV向量扩展"><a href="#RVV向量扩展" class="headerlink" title="RVV向量扩展"></a>RVV向量扩展</h1><p><a href="https://www.xrvm.cn/community/post/detail?id=4187650891316269056">向量扩展</a></p><p><a href="https://fprox.substack.com/p/risc-v-vector-programming-in-c-with">使用 Intrinsics 的 C 语言 RISC-V 向量编程</a></p><p>RVV 的灵活性体现在以下几个方面：</p><ol><li><strong>向量长度的可变性</strong>：RVV 提供了灵活的向量长度（VL）设置，使得同一指令可以处理不同数量的数据元素。例如，你可以在同一程序中为不同的操作指定不同的向量长度，以适应硬件的能力或特定的计算任务。一个寄存器可以包含多个数据元素（例如 32 位整数、64 位浮点数等），并根据当前的 <code>vl</code> 设置来决定每个寄存器要处理多少数据元素。因此，向量寄存器组有时可以半满或不满——取决于 <code>vl</code> 设置以及每个操作处理的数据量。</li><li><strong>向量寄存器组的大小</strong>：RISC-V 向量寄存器组通常由多个寄存器组成，每个寄存器的大小是固定的。寄存器的大小和数据类型（如整数或浮点数）是固定的，但由于 <code>vl</code> 是动态可调整的，寄存器的填充率可能会小于其最大容量。例如，假设一个寄存器是 128 位宽，如果你只需要处理 64 位的数据元素，寄存器的 “半满” 情况就可能发生。</li><li><strong>指令和掩码的作用</strong>：在 RVV 中，某些指令可以允许掩码操作（例如，<code>vfmv_v_f_f64m1</code>），这意味着某些元素可能会被忽略或处理为零，而不影响其他寄存器元素的计算。这使得向量寄存器的实际使用情况（如 1&#x2F;2 或更少）变得有可能。</li></ol><h1 id="可行性方案"><a href="#可行性方案" class="headerlink" title="可行性方案"></a>可行性方案</h1><h3 id="工具链的安装"><a href="#工具链的安装" class="headerlink" title="工具链的安装"></a>工具链的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/riscv-collab/riscv-gnu-toolchain</span><br><span class="line">cd riscv-gnu-toolchain</span><br><span class="line">git submodule update --init --recursive##速度很慢</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">../configure --prefix=/opt/riscv64 --enable-multilib --enable-languages=c,c++ --with-arch=rv64gcv --with-abi=lp64 --enable-rvv</span><br><span class="line">make -$(nproc)j</span><br><span class="line">riscv64-unknown-elf-gcc --version</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">riscv64-unknown-elf-gcc (g04696df0963) 14.2.0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Copyright (C) 2024 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><blockquote><p>经过测试以上配置的工具版本只能支持具有riscv前缀的函数如__riscv_vle32_v_i32m2(lhs, vl)</p><p>更高版本对向量指令的处理方式更严格，因此它不再直接解析某些低级别函数，特别是那些没有前缀的 RVV 内建函数。这种变化旨在减少混淆，并统一 LLVM 中的向量扩展处理。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reference: https://pages.dogdog.run/toolchain/riscv_vector_extension.html</span></span><br><span class="line"><span class="comment">// #define __riscv_vector // make VSC happy when reading riscv_vector.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">10</span>], z_real[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vec_add_rvv</span><span class="params">(<span class="type">int</span>* dst, <span class="type">int</span>* lhs, <span class="type">int</span>* rhs, <span class="type">size_t</span> avl)</span> &#123;</span><br><span class="line">    <span class="type">vint32m2_t</span> vlhs, vrhs, vres;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> vl; (vl = __riscv_vsetvl_e32m2(avl));</span><br><span class="line">         avl -= vl, lhs += vl, rhs += vl, dst += vl) &#123;</span><br><span class="line">        vlhs = __riscv_vle32_v_i32m2(lhs, vl);</span><br><span class="line">        vrhs = __riscv_vle32_v_i32m2(rhs, vl);</span><br><span class="line">        vres = __riscv_vadd_vv_i32m2(vlhs, vrhs, vl);</span><br><span class="line">        __riscv_vse32_v_i32m2(dst, vres, vl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vec_add_real</span><span class="params">(<span class="type">int</span>* dest, <span class="type">int</span>* lhs, <span class="type">int</span>* rhs, <span class="type">size_t</span> vlen)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">        dest[i] = lhs[i] + rhs[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_vec</span><span class="params">(<span class="type">int</span>* v, <span class="type">size_t</span> vlen, <span class="type">char</span>* msg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s=&#123; &quot;</span>, msg);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, v[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check RVV support</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __riscv_v_intrinsic</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RVV NOT supported in this compiler\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    vec_add_rvv(z, x, y, <span class="number">10</span>);</span><br><span class="line">    vec_add_real(z_real, x, y, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    print_vec(x, <span class="number">10</span>, <span class="string">&quot;x[10]&quot;</span>);</span><br><span class="line">    print_vec(y, <span class="number">10</span>, <span class="string">&quot;y[10]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z[i] != z_real[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;==========\nTest FAILED: pos %d mismatch\n&quot;</span>, i);</span><br><span class="line">            print_vec(z, <span class="number">10</span>, <span class="string">&quot;z[10]&quot;</span>);</span><br><span class="line">            print_vec(z_real, <span class="number">10</span>, <span class="string">&quot;z_real[10]&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_vec(z, <span class="number">10</span>, <span class="string">&quot;z[10]&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==========\nTest PASSED\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模拟器对于RVV的支持"><a href="#模拟器对于RVV的支持" class="headerlink" title="模拟器对于RVV的支持"></a>模拟器对于RVV的支持</h3><h4 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##编译执行报错，说是不支持rvv扩展，所以采用了spike模拟器</span><br><span class="line">qemu-riscv64 -cpu rv64,v=true,vlen=128,vext_spec=v1.0 ./vadd</span><br><span class="line">qemu-riscv64: can&#x27;t apply global rv64-riscv-cpu.v=true: Property &#x27;rv64-riscv-cpu.v&#x27; not found</span><br></pre></td></tr></table></figure><h4 id="Spike"><a href="#Spike" class="headerlink" title="Spike"></a>Spike</h4><p><strong>安装依赖</strong></p><p>在开始之前，你需要确保你的系统上安装了必要的依赖项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y autoconf automake libtool g++ pkg-config make python3</span><br></pre></td></tr></table></figure><p><strong>克隆 Spike 仓库</strong></p><p>首先克隆 Spike 仓库到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/riscv/riscv-isa-sim.git</span><br><span class="line">cd riscv-isa-sim</span><br></pre></td></tr></table></figure><p><strong>配置和编译 Spike</strong></p><p>配置和编译 Spike，使其支持 RVV 扩展。通过以下步骤来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure --prefix=/opt/riscv --enable-rvv</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>在这里，<code>--enable-rvv</code> 确保 Spike 配置支持 RISC-V 向量扩展 (RVV)。</p><p><strong>配置环境变量</strong></p><p>安装完成后，确保将 <code>/opt/riscv/bin</code> 添加到你的 <code>PATH</code> 环境变量中，以便可以方便地调用 Spike。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi ~./basrch #将一下内容放入最后</span><br><span class="line">export PATH=/opt/riscv/bin:$PATH</span><br></pre></td></tr></table></figure><p>为了让Spike，正确执行成程序需要将RISCV-V Proxy Kernel(pk)。</p><p><strong>安装PK</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/riscv/riscv-pk.git</span><br><span class="line">cd riscv-pk</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line"> ../configure --prefix=/opt/riscv --host=riscv64-unknown-linux-gnu</span><br><span class="line">make </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">报错</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#../machine/flush_icache.c: Assembler messages:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#../machine/flush_icache.c:4: Error: unrecognized opcode fence.i&#x27;, extension ##zifencei&#x27; required</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#make: *** [Makefile:336：flush_icache.o] 错误 1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># vim Makefile</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启用 zifencei 扩展</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 在CFLAGS中添加 -march=rv64imafdc_zifencei</span></span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 验证安装成不成功</span></span></span><br><span class="line">ls /opt/riscv/riscv64-unknown-linux-gnu/lib/riscv-pk</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#看到诸如 libpk.a、libbbl.a、libsoftfloat.a 等文件。</span></span></span><br></pre></td></tr></table></figure><h3 id="gcc编译"><a href="#gcc编译" class="headerlink" title="gcc编译"></a>gcc编译</h3><p><code>spike只能跑静态编译的程序。</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#执行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-unknown-linux-gnu-gcc -march=rv64gcv  -O2 -g -static ./vadd.c -o ./vadd</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#或者</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-unknown-elf-gcc -march=rv64gcv  -O2 -g -static ./vadd.c -o ./vadd</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#执行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">spike --isa=rv64gcv /opt/riscv/riscv64-unknown-linux-gnu/bin/pk ./vadd</span></span><br></pre></td></tr></table></figure><p><strong>clang编译</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang --target=riscv64-unknown-linux-gnu -O2 -g -march=rv64gcv1p0 -menable-experimental-extensions --gcc-toolchain=/opt/riscv64 --sysroot=/opt/riscv64/sysroot -mllvm --riscv-v-vector-bits-min=256 ./vadd.c -o vadd</span></span><br></pre></td></tr></table></figure><p><strong>报错</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">./vadd.c:<span class="number">10</span>:<span class="number">14</span>: warning: implicit declaration of function <span class="string">&#x27;__riscv_vsetvl_e32m1&#x27;</span> is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">        vl = __riscv_vsetvl_e32m1(vlen - i);</span><br><span class="line">             ^</span><br><span class="line">./vadd.c:<span class="number">12</span>:<span class="number">27</span>: warning: implicit declaration of function <span class="string">&#x27;__riscv_vle32_v_f32m1&#x27;</span> is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">        <span class="type">vfloat32m1_t</span> va = __riscv_vle32_v_f32m1(&amp;a[i], vl);</span><br><span class="line">                          ^</span><br><span class="line">./vadd.c:<span class="number">12</span>:<span class="number">22</span>: error: initializing <span class="string">&#x27;vfloat32m1_t&#x27;</span> (aka <span class="string">&#x27;__rvv_float32m1_t&#x27;</span>) with an expression of incompatible type <span class="string">&#x27;int&#x27;</span></span><br><span class="line">        <span class="type">vfloat32m1_t</span> va = __riscv_vle32_v_f32m1(&amp;a[i], vl);</span><br><span class="line">                     ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">./vadd.c:<span class="number">13</span>:<span class="number">22</span>: error: initializing <span class="string">&#x27;vfloat32m1_t&#x27;</span> (aka <span class="string">&#x27;__rvv_float32m1_t&#x27;</span>) with an expression of incompatible type <span class="string">&#x27;int&#x27;</span></span><br><span class="line">        <span class="type">vfloat32m1_t</span> vb = __riscv_vle32_v_f32m1(&amp;b[i], vl);</span><br><span class="line">                     ^    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">./vadd.c:<span class="number">15</span>:<span class="number">29</span>: warning: implicit declaration of function <span class="string">&#x27;__riscv_vfmul_vv_f32m1&#x27;</span> is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">        <span class="type">vfloat32m1_t</span> vres = __riscv_vfmul_vv_f32m1(va, vb, vl);</span><br><span class="line">                            ^</span><br><span class="line">./vadd.c:<span class="number">15</span>:<span class="number">22</span>: error: initializing <span class="string">&#x27;vfloat32m1_t&#x27;</span> (aka <span class="string">&#x27;__rvv_float32m1_t&#x27;</span>) with an expression of incompatible type <span class="string">&#x27;int&#x27;</span></span><br><span class="line">        <span class="type">vfloat32m1_t</span> vres = __riscv_vfmul_vv_f32m1(va, vb, vl);</span><br><span class="line">                     ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">./vadd.c:<span class="number">17</span>:<span class="number">9</span>: warning: implicit declaration of function <span class="string">&#x27;__riscv_vse32_v_f32m1&#x27;</span> is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">        __riscv_vse32_v_f32m1(&amp;dest[i], vres, vl);</span><br><span class="line">        ^</span><br><span class="line">./vadd.c:<span class="number">55</span>:<span class="number">66</span>: warning: format specifies type <span class="string">&#x27;int&#x27;</span> but the argument has type <span class="string">&#x27;size_t&#x27;</span> (aka <span class="string">&#x27;unsigned long&#x27;</span>) [-Wformat]</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;==========\nTest FAILED: pos %d mismatch\n&quot;</span>, i);</span><br><span class="line">                                                 ~~              ^</span><br><span class="line">                                                 %zu</span><br><span class="line"><span class="number">5</span> warnings and <span class="number">3</span> errors generated.</span><br></pre></td></tr></table></figure><h3 id="等待验证方案"><a href="#等待验证方案" class="headerlink" title="等待验证方案"></a>等待验证方案</h3><p>qemu的RVV扩展以及clang为什么编译报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用的qemu是9.0.1的，但是在命令中识别不了vv=<span class="literal">true</span>,</span></span><br></pre></td></tr></table></figure><p>参考链接：[中科院RVV配置Intrinsic](<a href="https://learning.eulixos.com/posts/2024-01/zyx_01_config/">RVV C Intrinsic 配置教程</a>)</p><p>参考报告中的工具链版本是13.2，使用的clang是14.0.6，但是我使用的工具链是最新版的14.2.0，这个更高的版本clang14还支持不了，需要更高的版本才可以对RVV的全面支持。</p><p><img src="https://img.picgo.net/2024/11/15/-2024-11-15-16172237daeb92e2d520cb.png" alt="屏幕截图 2024 11 15 161722"></p><p>使用clang17是可以编译的。</p><p>后续编程实例：</p><p><a href="https://github.com/riscv-non-isa/rvv-intrinsic-doc/blob/v0.11.x/examples/rvv_branch.c">https://github.com/riscv-non-isa/rvv-intrinsic-doc/blob/v0.11.x/examples/rvv_branch.c</a></p><p>函数API为：</p><p><a href="https://dzaima.github.io/intrinsics-viewer/">Intrinsics viewer</a></p><p>qemu关于RVV的编译报错：</p><p><img src="https://img.picgo.net/2024/11/18/QEMU-RVVe6d6b32d2c5c93d7.png" alt="QEMU RVV"></p><p><code>在Ubuntu20.04上可以成功运行。</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISCV内存管理单元</title>
      <link href="/2024/12/01/RISC-V%20Vector%20Extension/"/>
      <url>/2024/12/01/RISC-V%20Vector%20Extension/</url>
      
        <content type="html"><![CDATA[<ul><li><p>RISC-V 向量扩展（RVV, RISC-V Vector Extension）中的指令可以大致分为三大类：<strong>设置向量长度</strong>（<code>setvl</code>）、<strong>加载&#x2F;存储</strong>（<code>load/store</code>）、和 <strong>数学运算</strong>（<code>mathematical operations</code>）。以下是这三类指令的详细描述：</p><p><strong>setvl</strong> 指令</p><p><code>setvl</code> 指令用于设置向量长度，并返回当前向量长度。它是 RVV 中的核心指令，用于动态地控制每条指令处理的向量元素数量。通过设置向量长度寄存器（<code>vl</code>），可以使得后续的指令在处理数据时，按照给定的向量长度来处理。</p><ul><li><p><strong>指令格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setvl  xlen, rs1</span><br></pre></td></tr></table></figure></li><li><p><strong>功能</strong>：</p><ul><li>设置向量长度（<code>vl</code>）。</li><li><code>rs1</code> 寄存器的值决定了目标向量长度（<code>vl</code>）。</li><li>返回的向量长度会被存储在 <code>vlen</code> 寄存器中。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setvl   x0, x1  // 设置向量长度</span><br></pre></td></tr></table></figure></li></ul><p> <strong>加载&#x2F;存储指令</strong>（Load&#x2F;Store）</p><p>加载和存储指令用于将数据从内存加载到向量寄存器中，或者将向量寄存器中的数据存储回内存。这些指令的操作对象是向量寄存器，可以处理多个数据元素。</p><ul><li><p><strong>加载指令（Vector Load）</strong>：</p><ul><li>用于从内存中加载数据到向量寄存器。</li><li>支持不同的访问模式，包括按字节、按字、按双字等。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vlb    vd, (rs1)      // 加载字节数据到向量寄存器</span><br><span class="line">vlh    vd, (rs1)      // 加载半字数据到向量寄存器</span><br><span class="line">vld    vd, (rs1)      // 加载双字数据到向量寄存器</span><br></pre></td></tr></table></figure></li><li><p><strong>存储指令（Vector Store）</strong>：</p><ul><li>用于将向量寄存器的数据存储回内存。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vsb    (rs1), vs      // 将向量寄存器中的字节存储到内存</span><br><span class="line">vsh    (rs1), vs      // 将向量寄存器中的半字存储到内存</span><br><span class="line">vsd    (rs1), vs      // 将向量寄存器中的双字存储到内存</span><br></pre></td></tr></table></figure></li></ul><p><strong>数学运算指令</strong>（Mathematical Operations）</p><p>数学运算指令用于执行向量运算，包括加法、减法、乘法、除法、按元素操作、以及向量间的点积等。这些指令通常操作向量寄存器中的数据。</p><ul><li><p><strong>加法&#x2F;减法指令</strong>：</p><ul><li>用于执行向量元素之间的加法或减法。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vadd   vd, vs, vt   // 向量加法，vd = vs + vt</span><br><span class="line">vsub   vd, vs, vt   // 向量减法，vd = vs - vt</span><br></pre></td></tr></table></figure></li><li><p><strong>乘法&#x2F;除法指令</strong>：</p><ul><li>用于执行向量元素之间的乘法或除法。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmul   vd, vs, vt   // 向量乘法，vd = vs * vt</span><br><span class="line">vdiv   vd, vs, vt   // 向量除法，vd = vs / vt</span><br></pre></td></tr></table></figure></li><li><p><strong>按元素操作</strong>：</p><ul><li>例如按位与、按位或、按位异或等操作。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vand   vd, vs, vt   // 向量按位与</span><br><span class="line">vor    vd, vs, vt   // 向量按位或</span><br><span class="line">vxor   vd, vs, vt   // 向量按位异或</span><br></pre></td></tr></table></figure></li><li><p><strong>归约操作</strong>：</p><ul><li>执行归约操作，如计算向量元素的总和、最小值、最大值等。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vredsum  rd, vs     // 向量元素求和</span><br><span class="line">vredmin  rd, vs     // 向量元素求最小值</span><br><span class="line">vredmax  rd, vs     // 向量元素求最大值</span><br></pre></td></tr></table></figure></li><li><p><strong>比较和掩码操作</strong>：</p><ul><li>用于比较向量元素，生成掩码或标志。</li></ul><p>示例指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vcmpeq  vd, vs, vt  // 向量元素相等比较</span><br><span class="line">vcmpgt  vd, vs, vt  // 向量元素大于比较</span><br></pre></td></tr></table></figure></li></ul><p>RISC-V 向量扩展（RVV）指令集包括三大类指令：</p><ol><li><strong>setvl</strong>：设置向量长度。</li><li><strong>加载&#x2F;存储</strong>：用于向量数据的加载和存储操作。</li><li><strong>数学运算</strong>：进行加法、减法、乘法、除法、按位运算、比较等操作。</li></ol><p>这些指令的组合使得 RISC-V 向量扩展能够高效地处理并行数据，适用于大规模的数据处理任务，如矩阵计算、科学计算等。</p></li></ul><p>在 RISC-V 向量扩展（RVV）中，<strong>加载&#x2F;存储（load&#x2F;store）指令</strong>按照内存寻址模型（memory addressing model）的不同，可以进一步分为以下三类：</p><hr><h3 id="Unit-Strided-Load-x2F-Store"><a href="#Unit-Strided-Load-x2F-Store" class="headerlink" title="Unit Strided Load&#x2F;Store"></a><strong>Unit Strided Load&#x2F;Store</strong></h3><p><strong>Unit strided</strong> 是最简单的内存寻址模型，数据在内存中是连续存储的，每个元素占据固定的内存字节大小（如字节、半字、字或双字）。这种模型假设内存地址是以固定步幅（stride&#x3D;1）递增的。</p><p>指令格式：</p><ul><li><p><strong>加载指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vle8   vd, (rs1)      // 加载连续的 8-bit 数据到向量寄存器</span><br><span class="line">vle16  vd, (rs1)      // 加载连续的 16-bit 数据到向量寄存器</span><br><span class="line">vle32  vd, (rs1)      // 加载连续的 32-bit 数据到向量寄存器</span><br><span class="line">vle64  vd, (rs1)      // 加载连续的 64-bit 数据到向量寄存器</span><br></pre></td></tr></table></figure></li><li><p><strong>存储指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vse8   (rs1), vd      // 存储向量寄存器中的 8-bit 数据到连续的内存</span><br><span class="line">vse16  (rs1), vd      // 存储 16-bit 数据</span><br><span class="line">vse32  (rs1), vd      // 存储 32-bit 数据</span><br><span class="line">vse64  (rs1), vd      // 存储 64-bit 数据</span><br></pre></td></tr></table></figure></li></ul><p>特点：</p><ul><li>数据在内存中以连续地址存储。</li><li>使用场景：矩阵或向量的逐元素处理，如密集向量运算。</li></ul><p><strong>Strided Load&#x2F;Store</strong></p><p><strong>Strided</strong> 寻址模型允许内存地址以固定步幅（stride）递增。这种模型用于处理间隔存储的数据，例如二维数组中的一行数据。</p><p>指令格式：</p><ul><li><p><strong>加载指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vlse8  vd, (rs1), rs2   // 加载具有固定步幅的 8-bit 数据</span><br><span class="line">vlse16 vd, (rs1), rs2   // 加载 16-bit 数据</span><br><span class="line">vlse32 vd, (rs1), rs2   // 加载 32-bit 数据</span><br><span class="line">vlse64 vd, (rs1), rs2   // 加载 64-bit 数据</span><br></pre></td></tr></table></figure></li><li><p><strong>存储指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vsse8  (rs1), rs2, vd   // 存储 8-bit 数据到具有固定步幅的内存</span><br><span class="line">vsse16 (rs1), rs2, vd   // 存储 16-bit 数据</span><br><span class="line">vsse32 (rs1), rs2, vd   // 存储 32-bit 数据</span><br><span class="line">vsse64 (rs1), rs2, vd   // 存储 64-bit 数据</span><br></pre></td></tr></table></figure></li></ul><p>参数说明：</p><ul><li><code>rs1</code> 是基地址寄存器。</li><li><code>rs2</code> 是步幅寄存器（stride），指定每个元素之间的字节距离。</li></ul><p>特点：</p><ul><li>数据在内存中以固定步幅分布。</li><li>使用场景：处理稀疏矩阵行、二维数组或其他非连续存储的数据。</li></ul><p><strong>Indexed Load&#x2F;Store</strong></p><p><strong>Indexed</strong> 寻址模型允许每个元素的地址由基地址加上一个偏移量（offsets）决定。偏移量可以存储在一个单独的向量寄存器中，使得可以自由访问内存中的任意位置。</p><p>指令格式：</p><ul><li><p><strong>加载指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vluxei8  vd, (rs1), vs2   // 加载 8-bit 数据，地址由索引寄存器决定</span><br><span class="line">vluxei16 vd, (rs1), vs2   // 加载 16-bit 数据</span><br><span class="line">vluxei32 vd, (rs1), vs2   // 加载 32-bit 数据</span><br><span class="line">vluxei64 vd, (rs1), vs2   // 加载 64-bit 数据</span><br></pre></td></tr></table></figure></li><li><p><strong>存储指令</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vsuxei8  (rs1), vs2, vd   // 存储 8-bit 数据到索引指定的地址</span><br><span class="line">vsuxei16 (rs1), vs2, vd   // 存储 16-bit 数据</span><br><span class="line">vsuxei32 (rs1), vs2, vd   // 存储 32-bit 数据</span><br><span class="line">vsuxei64 (rs1), vs2, vd   // 存储 64-bit 数据</span><br></pre></td></tr></table></figure></li></ul><p>参数说明：</p><ul><li><code>rs1</code> 是基地址寄存器。</li><li><code>vs2</code> 是索引寄存器，存储相对基地址的偏移量。</li></ul><p><strong>特点：</strong></p><ul><li>数据地址可以完全动态控制，适合处理非规则的数据布局。</li><li>使用场景：稀疏矩阵列访问、图处理、或不规则存储数据的加载和存储。</li></ul><table><thead><tr><th><strong>类别</strong></th><th><strong>内存分布</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>Unit Strided</strong></td><td>连续存储</td><td>地址递增步幅为 1</td><td>密集向量运算</td></tr><tr><td><strong>Strided</strong></td><td>固定步幅分布</td><td>地址递增步幅由寄存器 <code>rs2</code> 指定</td><td>稀疏矩阵行处理</td></tr><tr><td><strong>Indexed</strong></td><td>任意分布</td><td>地址偏移由索引向量决定</td><td>稀疏矩阵列、不规则数据处理</td></tr></tbody></table><h2 id="7个CSR-Context-Status-Register-寄存器"><a href="#7个CSR-Context-Status-Register-寄存器" class="headerlink" title="7个CSR(Context Status Register)寄存器"></a>7个CSR(Context Status Register)寄存器</h2><h3 id="Vstart-Vector-Start-寄存器"><a href="#Vstart-Vector-Start-寄存器" class="headerlink" title="Vstart(Vector Start)寄存器"></a>Vstart(Vector Start)寄存器</h3><p>存储向量指令中被执行第一个元素的索引值。</p><p>通常在向量指令执行过程中产生了陷阱被写入，记录了陷阱时向量指令操作元素的索引，以便跳出陷阱之后能够继续执行剩下的元素。当向量指令产生非法指令异常时，vstart寄存器将不会被改写。</p><p>如果vstart数值大于vl的值，说明vstart指向的元素索引已经超过当前所有元素的范围，该指令不会执行，同事寄存器复位0</p><h3 id="Vxsat寄存器"><a href="#Vxsat寄存器" class="headerlink" title="Vxsat寄存器"></a>Vxsat寄存器</h3><p>vxsat为可读可写寄存器，该寄存器不仅有独立的寄存器地址，并且在vcsr寄存器中也有对应的域。该寄存器有效表示输出结果做了饱和截位以适应目的寄存器格式。比如当运算发生正溢出时，保留结果为能取到的最大正值；当运算发生负溢出时，保留结果为负数最小值。</p><h3 id="vxrm寄存器"><a href="#vxrm寄存器" class="headerlink" title="vxrm寄存器"></a>vxrm寄存器</h3><p>vxrm[1:0]为可读可写寄存器，该寄存器不仅有独立的寄存器地址，并且在vcsr寄存器中也有对应的域。该寄存器控制定点舍入模式，一共四种模式，分别是round-to-nearest-up（rnu）、round-to-nearest-even(rne)、round-down(rdn)、round-to-odd(rod)。(问题：可否解释一下定点数在内存中的存放格式)<br>vxrm[1:0]寄存器通过单条csrwi指令写入值。<br>假如源操作数是v，有低d bit数据要被截掉，那么做完rounding-mode之后的最终结果应该是(v&gt;&gt;d)+r，r就是根据不同的rounding mode得到的增量值。<br>rnu：向距离近的方向进行舍入，当距离与两边都相等时，向上舍入。<br>rne：向距离近的方向进行舍入，当距离与两边都相等时，向偶数方向舍入。<br>rdn：向下舍入，直接取移位后的值。<br>rod：舍入到奇数值方向。<br>其中，v[d-1]表示权重位。当v[d-1]&#x3D;0，表示距离舍的方向更近；当v[d-1]&#x3D;1且v[d-2:0]&#x3D;0时，距离舍入两个方向距离均相等；当v[d-1]&#x3D;1，且v[d-2:0] !&#x3D; 0时，表示距离入的方向更近。</p><h3 id="vcsr寄存器"><a href="#vcsr寄存器" class="headerlink" title="vcsr寄存器"></a>vcsr寄存器</h3><p>vcsr[2:0]寄存器为可读可写寄存器，该寄存器由vxrm[1:0]，以及vxsat组成。<br> riscv spec中fflags和frm寄存器也采用的这样的设计。这类状态寄存器，希望方便快速的读写，比如有时候希望一条指令能把这两个寄存器的值同时读出来。又或者写这两个寄存器，如果要同时写，就得先做移位拼接在写，那有的时候只想改变其中一个寄存器的值，也做移位在拼接然后写的操作就比较慢，因此单独写对应的地址就显得尤为方便快速。考虑到适应不同的需求，这类状态寄存器就设计为既有各自单独的寄存器存储空间，又集中在一个寄存集中划分各自的域。</p><h3 id="vtype寄存器"><a href="#vtype寄存器" class="headerlink" title="vtype寄存器"></a>vtype寄存器</h3><p>vtype为只读寄存器，位宽同通用整型架构寄存器位宽（XLEN）。该寄存器提供了默认值用于解析向量寄存器中的内容，并且只能通过vsetvl{i}指令进行更新（这样做的目的是使得维护vtype寄存器的状态简单化）。<br>vtype寄存器用于解析向量寄存器文件中的内容、决定单个向量寄存器中元素的组成以及决定多个向量寄存器是如分组的。<br>vtype寄存器有五个域，分别是vill，vma，vta，vsew[2:0]，vlmul[2:0]。</p><p><img src="https://img.picgo.net/2024/11/22/-2024-11-22-1525179aad71b0c2eb9e83.png" alt="屏幕截图 2024 11 22 152517"></p><h3 id="vl寄存器"><a href="#vl寄存器" class="headerlink" title="vl寄存器"></a>vl寄存器</h3><p>vl寄存器为只读寄存器，该寄存器存储着一个无符号整数，用来规定一条向量指令需要更新多少个元素。<br>该寄存器只能被vsetvli、vsetvl指令以及fault-only-first矢量读取指令的变体进行更新。<br>目的寄存器中元素索引大于等于vl的元素，将不会被修改。如果vstart大于等于vl，那么目的寄存器的任何元素都不会被修改。<br>vl的位宽由最小元素组成的最大向量长度决定。最小的元素位宽至少是8bit，最大的分组设置为LMUL等于8，那么VLMAX&#x3D;LMUL * (VLEN &#x2F; SEW) &#x3D; VLEN。也就是说vl的位宽，直接由VLEN的大小决定。</p><h3 id="vlenb寄存器"><a href="#vlenb寄存器" class="headerlink" title="vlenb寄存器"></a>vlenb寄存器</h3><p>该寄存器为只读寄存器，表示以字节为单位的向量寄存器长度，vlenb&#x3D;VLEN&#x2F;8。vlenb是一个设计时常量，增加这个寄存器是为了减少一些需要直接用到vlenb的程序的额外计算指令的开销。</p>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RVOS系统</title>
      <link href="/2024/11/30/RVOS%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/11/30/RVOS%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>start.s文件（.s文件是汇编语言源代码文件的扩展，包含了汇编语言代码，直接对应目标处理器的ISA）</p><p>一个典型的.s文件文件包含了以下几个部分：</p><p>数据段：存储程序使用的常量、字符串、数组等数据。</p><p>代码段：存储实际程序指令。</p><p>全局符号和标签：定义程序中的使用的标识符和函数名，供汇编器和链接器使用</p><p><strong>编写一个简单RISC-V的系统</strong></p><p>需要以下几个文件部分：</p><p>platform.h(硬件信息)</p><p>start.s（</p><blockquote><p><strong>初始化堆栈</strong>：为每个 <code>hart</code> 分配堆栈空间，并初始化栈指针 <code>sp</code>。</p><p><strong>挂起非 hart 0 的核心</strong>：通过 <code>wfi</code> 指令将非 <code>hart 0</code> 的核心挂起，直到 <code>hart 0</code> 启动内核。</p><p><strong>设置堆栈对齐</strong>：确保堆栈空间的对齐，以便符合 RISC-V 的 16 字节对齐规则。</p><p><strong>多核心初始化</strong>：通过 <code>hart id</code> 为每个核心分配独立的堆栈空间。）</p></blockquote><p>uart.c(交互显示)</p><blockquote><p>宏定义uart所需要的寄存器。</p><p>uart初始化（打开或者关闭中断，设置串口的数据位、停止位、校验位、禁止波特锁存器)</p><p>定义uart输出函数输入函数</p></blockquote><p>Makefile(编译的构建规则)</p><p>types.h(记录数据类型)</p><p>kernel.c(内核执行文件等同于int main)</p><h2 id="最小RVOS"><a href="#最小RVOS" class="headerlink" title="最小RVOS"></a>最小RVOS</h2><p>platform.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PLATFORM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PLATFORM_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM_CPU 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>start.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;platform.h&quot;</span><br><span class="line">.equ STACK_SIZE ,1024</span><br><span class="line">.global _start</span><br><span class="line">.text</span><br><span class="line">_start:</span><br><span class="line">csrrt0, mhartid# read current hart id</span><br><span class="line">mvtp, t0# keep CPU&#x27;s hartid in its tp for later usage.</span><br><span class="line">bnezt0, park# if we&#x27;re not on the hart 0</span><br><span class="line"># we park the hart</span><br><span class="line"># Setup stacks, the stack grows from bottom to top, so we put the</span><br><span class="line"># stack pointer to the very end of the stack range.</span><br><span class="line">sllit0, t0, 10# shift left the hart id by 1024</span><br><span class="line">lasp, stacks + STACK_SIZE# set the initial stack pointer</span><br><span class="line"># to the end of the first stack space</span><br><span class="line">addsp, sp, t0# move the current hart stack pointer</span><br><span class="line"># to its place in the stack space</span><br><span class="line"></span><br><span class="line">jstart_kernel# hart 0 jump to c</span><br><span class="line"></span><br><span class="line">park:</span><br><span class="line">wfi</span><br><span class="line">jpark</span><br><span class="line"></span><br><span class="line"># In the standard RISC-V calling convention, the stack pointer sp</span><br><span class="line"># is always 16-byte aligned.</span><br><span class="line">.balign 16</span><br><span class="line">stacks:</span><br><span class="line">.skipSTACK_SIZE * MAXNUM_CPU # allocate space for all the harts stacks</span><br><span class="line"></span><br><span class="line">.end# End of file</span><br></pre></td></tr></table></figure><p>uart.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;platform.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_REG(reg) ((volatile uint8_t *)(UART0 + reg))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * UART control registers map. see [1] &quot;PROGRAMMING TABLE&quot;</span></span><br><span class="line"><span class="comment"> * note some are reused by multiple functions</span></span><br><span class="line"><span class="comment"> * 0 (write mode): THR/DLL</span></span><br><span class="line"><span class="comment"> * 1 (write mode): IER/DLM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RHR 0<span class="comment">// Receive Holding Register (read mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THR 0<span class="comment">// Transmit Holding Register (write mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL 0<span class="comment">// LSB of Divisor Latch (write mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER 1<span class="comment">// Interrupt Enable Register (write mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLM 1<span class="comment">// MSB of Divisor Latch (write mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR 2<span class="comment">// FIFO Control Register (write mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR 2<span class="comment">// Interrupt Status Register (read mode)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR 3<span class="comment">// Line Control Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCR 4<span class="comment">// Modem Control Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5<span class="comment">// Line Status Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSR 6<span class="comment">// Modem Status Register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPR 7<span class="comment">// ScratchPad Register</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * POWER UP DEFAULTS</span></span><br><span class="line"><span class="comment"> * IER = 0: TX/RX holding register interrupts are both disabled</span></span><br><span class="line"><span class="comment"> * ISR = 1: no interrupt penting</span></span><br><span class="line"><span class="comment"> * LCR = 0</span></span><br><span class="line"><span class="comment"> * MCR = 0</span></span><br><span class="line"><span class="comment"> * LSR = 60 HEX</span></span><br><span class="line"><span class="comment"> * MSR = BITS 0-3 = 0, BITS 4-7 = inputs</span></span><br><span class="line"><span class="comment"> * FCR = 0</span></span><br><span class="line"><span class="comment"> * TX = High</span></span><br><span class="line"><span class="comment"> * OP1 = High</span></span><br><span class="line"><span class="comment"> * OP2 = High</span></span><br><span class="line"><span class="comment"> * RTS = High</span></span><br><span class="line"><span class="comment"> * DTR = High</span></span><br><span class="line"><span class="comment"> * RXRDY = High</span></span><br><span class="line"><span class="comment"> * TXRDY = Low</span></span><br><span class="line"><span class="comment"> * INT = Low</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LINE STATUS REGISTER (LSR)</span></span><br><span class="line"><span class="comment"> * LSR BIT 0:</span></span><br><span class="line"><span class="comment"> * 0 = no data in receive holding register or FIFO.</span></span><br><span class="line"><span class="comment"> * 1 = data has been receive and saved in the receive holding register or FIFO.</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> * LSR BIT 5:</span></span><br><span class="line"><span class="comment"> * 0 = transmit holding register is full. 16550 will not accept any data for transmission.</span></span><br><span class="line"><span class="comment"> * 1 = transmitter hold register (or FIFO) is empty. CPU can load the next character.</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE  (1&lt;&lt;5)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* disable interrupts. */</span></span><br><span class="line">uart_write_reg(IER, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setting baud rate. Just a demo here if we care about the divisor,</span></span><br><span class="line"><span class="comment"> * but for our purpose [QEMU-virt], this doesn&#x27;t really do anything.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notice that the divisor register DLL (divisor latch least) and DLM (divisor</span></span><br><span class="line"><span class="comment"> * latch most) have the same base address as the receiver/transmitter and the</span></span><br><span class="line"><span class="comment"> * interrupt enable register. To change what the base address points to, we</span></span><br><span class="line"><span class="comment"> * open the &quot;divisor latch&quot; by writing 1 into the Divisor Latch Access Bit</span></span><br><span class="line"><span class="comment"> * (DLAB), which is bit index 7 of the Line Control Register (LCR).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Regarding the baud rate value, see [1] &quot;BAUD RATE GENERATOR PROGRAMMING TABLE&quot;.</span></span><br><span class="line"><span class="comment"> * We use 38.4K when 1.8432 MHZ crystal, so the corresponding value is 3.</span></span><br><span class="line"><span class="comment"> * And due to the divisor register is two bytes (16 bits), so we need to</span></span><br><span class="line"><span class="comment"> * split the value of 3(0x0003) into two bytes, DLL stores the low byte,</span></span><br><span class="line"><span class="comment"> * DLM stores the high byte.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> lcr = uart_read_reg(LCR);</span><br><span class="line">uart_write_reg(LCR, lcr | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>));</span><br><span class="line">uart_write_reg(DLL, <span class="number">0x03</span>);</span><br><span class="line">uart_write_reg(DLM, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Continue setting the asynchronous data communication format.</span></span><br><span class="line"><span class="comment"> * - number of the word length: 8 bits</span></span><br><span class="line"><span class="comment"> * - number of stop bits：1 bit when word length is 8 bits</span></span><br><span class="line"><span class="comment"> * - no parity</span></span><br><span class="line"><span class="comment"> * - no break control</span></span><br><span class="line"><span class="comment"> * - disabled baud latch</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">lcr = <span class="number">0</span>;</span><br><span class="line">uart_write_reg(LCR, lcr | (<span class="number">3</span> &lt;&lt; <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_putc</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> ((uart_read_reg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> uart_write_reg(THR, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_puts</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (*s) &#123;</span><br><span class="line">uart_putc(*s++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_getc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((uart_read_reg(LSR) &amp; LSR_RX_READY) ==<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="type">char</span>)uart_read_reg(RHR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_gets</span><span class="params">(<span class="type">char</span> *buffer)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;  <span class="comment">// 初始化变量</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; BUFFER_SIZE - <span class="number">1</span>) &#123;  <span class="comment">// 防止缓冲区溢出</span></span><br><span class="line">        ch = uart_getc();  <span class="comment">// 获取一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span> || ch == <span class="string">&#x27;\r&#x27;</span>) &#123;  <span class="comment">// 如果是换行或回车</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 结束输入</span></span><br><span class="line">        &#125;</span><br><span class="line">        buffer[i++] = ch;  <span class="comment">// 将字符存入缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    buffer[i] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 确保字符串以 &#x27;\0&#x27; 结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>types.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TYPES_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TYPES_H__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>kernel.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">uart_puts</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">uart_gets</span><span class="params">(<span class="type">char</span> *buffer)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> chr[<span class="number">100</span>];</span><br><span class="line">uart_init();</span><br><span class="line">uart_puts(<span class="string">&quot;Hello, RVOS!\n&quot;</span>);</span><br><span class="line">uart_gets(chr);</span><br><span class="line">uart_puts(<span class="string">&quot;Echo:&quot;</span>);</span><br><span class="line">uart_puts(chr);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125; <span class="comment">// stop here!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存管理分类：</p><p>自动管理内存-Stack</p><p>静态内存-全局变量&#x2F;静态变量</p><p>动态管理内存-堆(heap)</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/751178c88f2dfa909fbe84702fcdb331.png"></p><p>总体流程如下：</p><ol><li><p><strong>内存初始化</strong>：启动时划分内存区域，生成管理结构（链表或位图）。</p></li><li><p><strong>内存分配</strong>：根据算法分配内存块，并在需要时拆分大块。</p></li><li><p><strong>内存释放</strong>：释放后合并相邻块以减少碎片。</p></li><li><p><strong>内存碎片整理</strong>：定期合并空闲块，防止碎片化。</p></li><li><p><strong>内存保护</strong>：使用 MMU&#x2F;MPU 实现任务间内存隔离。</p></li><li><p><strong>监控与调试</strong>：提供工具查看内存使用状况，调试内存管理问题</p><p>更多资料：<a href="https://cloud.tencent.com/developer/article/2337435">从零手写操作系统之RVOS内存管理模块简单实现-02-腾讯云开发者社区-腾讯云</a></p></li></ol><h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><p>异常是同步的，由所执行指令触发的，中断是异步的，是由外部设备的事件触发的。中断与被中断的指令及进程无直接关联，异常关联被中断的指令与进程，异常的处理可能会<code>阻塞杀死</code>本进程.</p><p><strong>中断分类：</strong></p><ol><li>软中断</li><li>定时中断</li><li>外部中断</li></ol><p><strong>中断采用的寄存器(RISCV)：</strong></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/67d898ccd0d873c9ba7931d2430807e8.png"></p><p><img src="https://img.picgo.net/2024/11/08/8f7dc42c83e3fb91bfeeb01a7abc625abcfcae5e8be8adef.png" alt="中断"></p><p>更多中断详细资料可看：<a href="https://cloud.tencent.com/developer/article/2337437">从零手写操作系统之RVOS外设中断实现-04-腾讯云开发者社区-腾讯云</a></p><p>中断信号转换和汇聚由<strong>PILC</strong>（中断平台控制器，<code>Platform-Level Interrupt Controller</code>）完成。</p><p><strong>PILC是RISCV架构中特有的存在。</strong></p><blockquote><p>在其他架构上，中断控制器的实现有所不同。例如：</p><ul><li><strong>ARM架构</strong>：使用 GIC（Generic Interrupt Controller，通用中断控制器）。</li><li><strong>x86架构</strong>：使用 APIC（Advanced Programmable Interrupt Controller，高级可编程中断控制器）或传统的 PIC（Programmable Interrupt Controller）。</li><li><strong>MIPS架构</strong>：有自己的中断控制机制。</li></ul></blockquote><p>每个 PLIC 包含 2 个 32 位的 Pending 寄存器，每一个 bit 对应一个中断源，如果为 1 表示该中断源上发生了中断（进入Pending 状态），有待 hart 处理，否则表示该中断源上当前无中断发生。<br>Pending 寄存器中断的 Pending 状态可以通过 claim 方式清除。<br>第一个 Pending 寄存器的第 0 位对应不存在的 0 号中断源，其值永远为 0。</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/c011ea8939e708b07b8edb7c89c75ec5.png"></p><h3 id="uart中断"><a href="#uart中断" class="headerlink" title="uart中断"></a>uart中断</h3><p>Linux系统上，<strong>UART的中断机制通常支持接收中断、数据寄存器空、发送完成中断</strong>。</p><ol><li><strong>接收完成中断（Receive Complete Interrupt）</strong></li></ol><ul><li><strong>作用</strong>：当 UART 接收到一个字节的数据并存储在接收数据寄存器中时，会触发接收完成中断。操作系统可以通过这个中断来读取数据。</li><li><strong>硬件寄存器</strong>：接收完成中断通常基于 UART 接收数据寄存器（如 <code>RXD</code>）中的数据填充，硬件会设置一个标志位（如 <code>RXC</code>）表示接收到新数据。</li><li><strong>Linux 驱动</strong>：在 Linux 中，串口驱动通常会监听这个中断，当接收到数据时，通过 <code>tty</code> 驱动将数据从接收寄存器读取到内核缓冲区。</li><li>会在每接收到一个字节后触发一次，直到所有字节都读完，关于多字节的处理，可以采用DMA或者中断合并机制来减少中断次数，可中断一次处理多个字节数据。或者某平台提供接收FIFO缓冲区，这种情况下接收中断会在FIFO缓冲区满时候触发中断。</li></ul><ol start="2"><li><strong>数据寄存器空中断（Data Register Empty Interrupt）</strong></li></ol><ul><li><strong>作用</strong>：当 UART 的发送数据寄存器空闲时，会触发数据寄存器空中断。通常情况下，硬件会根据 <code>TXD</code> 寄存器的状态设置一个标志（如 <code>TXE</code>）来表示发送缓冲区为空。</li><li><strong>硬件寄存器</strong>：当发送数据寄存器为空时，硬件会通过设置 <code>TXE</code>（Transmit Empty）标志来触发中断。驱动程序可以通过这个中断写入新的数据到发送寄存器。</li><li><strong>Linux 驱动</strong>：Linux 串口驱动通过 <code>uart</code> 驱动程序监听此中断，一旦发送寄存器空，驱动会将缓冲区中的数据写入发送寄存器，继续数据发送。</li></ul><ol start="3"><li><strong>发送完成中断（Transmit Complete Interrupt）</strong></li></ol><ul><li><strong>作用</strong>：当 UART 完成数据的发送（即所有数据已从发送数据寄存器传输到硬件并已送出）时，会触发发送完成中断。通常，这是一个可选的中断，取决于硬件设计。</li><li><strong>硬件寄存器</strong>：发送完成中断可能通过 <code>TXC</code>（Transmit Complete）标志来触发，表示所有数据已经发送完毕。</li><li><strong>Linux 驱动</strong>：这个中断常用于确认所有数据已经成功发送并清空相关状态，驱动程序通常会通过中断来完成后续任务，如通知应用程序或管理发送队列。</li></ul><h2 id="多任务切换"><a href="#多任务切换" class="headerlink" title="多任务切换"></a>多任务切换</h2><p>参考资料：</p><p><a href="https://cloud.tencent.com/developer/article/2337436">从零手写操作系统之RVOS协作式多任务切换实现-03-腾讯云开发者社区-腾讯云</a></p><p><a href="https://cloud.tencent.com/developer/article/2337439">从零手写操作系统之RVOS抢占式多任务实现-06-腾讯云开发者社区-腾讯云</a></p><p>多任务切换机制分为以下几种：</p><blockquote><p>1.协作式多任务切换（Cooperative Multitasking）</p><p>在协作式多任务切换中，任务需要<strong>主动让出 CPU</strong>，即任务自身在某个执行点上调用“让出 CPU”的指令（例如 <code>yield()</code>），切换到其他任务。任务切换通常发生在任务完成一个工作单元或者进入等待状态的时候。</p><ul><li><strong>实现方式</strong>：任务执行到安全点时调用让出函数，触发上下文切换。</li><li><strong>优点</strong>：实现简单，适合嵌入式系统，任务可以控制自己的切换点。</li><li><strong>缺点</strong>：如果某个任务没有主动让出 CPU，其他任务会处于“饥饿”状态。</li></ul><ol start="2"><li>抢占式多任务切换（Preemptive Multitasking）</li></ol><p>在抢占式多任务切换中，系统通过<strong>定时器中断</strong>等硬件机制强制让任务让出 CPU，确保各任务可以在固定的时间片内执行，保证调度公平性。</p><ul><li><strong>实现方式</strong>：通过定时器中断周期性触发任务切换，当前任务的状态被保存，切换到下一个任务。</li><li><strong>优点</strong>：公平性强，任务不需要主动让出 CPU，因此不会出现某个任务长期占用 CPU 的情况。</li><li><strong>缺点</strong>：实现较为复杂，通常需要硬件支持。</li></ul><ol start="3"><li>时间片轮转调度（Round-Robin Scheduling）</li></ol><p>时间片轮转调度是一种基于<strong>时间片</strong>的抢占式调度。每个任务按照顺序在 CPU 上执行一个固定的时间片，到期后切换到下一个任务。</p><ul><li><strong>实现方式</strong>：为每个任务分配一个时间片，到期时通过定时器中断切换到下一个任务。</li><li><strong>优点</strong>：简单公平，所有任务轮流执行，避免任务饥饿。</li><li><strong>缺点</strong>：对于短任务，可能会出现较高的切换开销。</li></ul><ol start="4"><li>优先级调度（Priority-Based Scheduling）</li></ol><p>在优先级调度中，系统根据任务的优先级来选择执行的任务。通常由抢占式机制实现，高优先级任务可以<strong>中断低优先级任务</strong>来获得 CPU 资源。（可以是抢占的或者非抢占的）</p><ul><li><strong>实现方式</strong>：任务被分配优先级，当新的高优先级任务需要执行时，中断当前任务。</li><li><strong>优点</strong>：高优先级任务能及时得到执行，适合实时系统。</li><li><strong>缺点</strong>：可能导致“优先级反转”或“低优先级任务饥饿”。</li></ul><ol start="5"><li>实时调度（Real-Time Scheduling）</li></ol><p>实时调度是一种基于任务的<strong>时间约束</strong>的调度方法。分为<strong>硬实时</strong>和<strong>软实时</strong>两类：</p><ul><li><strong>硬实时</strong>：必须在严格的时间内完成任务，否则可能会导致系统失败。</li><li><strong>软实时</strong>：尽量在一定时间内完成任务，但允许一定的延迟。</li><li><strong>实现方式</strong>：基于优先级或时间片调度，结合任务的时间约束来决定切换。</li></ul><ol start="6"><li>分时调度（Time-Sharing Scheduling）</li></ol><p>分时调度让多个用户或任务<strong>共享 CPU 时间</strong>。每个任务得到的时间片较长，适合交互式操作，让用户感到系统始终在响应。</p><ul><li><strong>实现方式</strong>：为每个任务分配较长的时间片，在时间片到期后切换任务。</li><li><strong>优点</strong>：用户感到操作流畅，适合交互式系统。</li><li><strong>缺点</strong>：不能保证实时性，不适合对响应时间要求严格的应用。</li></ul><ol start="7"><li>双核或多核系统的任务切换（Multicore Scheduling）</li></ol><p>在双核或多核系统中，任务切换不仅发生在单个 CPU 内核上，还可以跨多个内核调度。调度器需决定任务在各个内核之间的分配和切换，通常实现更复杂的并行调度机制。</p><ul><li><strong>实现方式</strong>：分布式调度，多个内核各自执行任务切换，或者统一调度器分配任务到各个内核。</li><li><strong>优点</strong>：高效利用多核资源，提升系统并发能力。</li><li><strong>缺点</strong>：任务在多个内核间切换有开销，需考虑负载均衡和内核间通信。</li></ul></blockquote><table><thead><tr><th>特点</th><th>协作式任务切换中的 trap handler</th><th>抢占式任务切换中的 trap handler</th></tr></thead><tbody><tr><td><strong>触发方式</strong></td><td>由任务主动调用（如 <code>yield()</code>）</td><td>由定时器中断强制触发</td></tr><tr><td><strong>trap handler 的使用频率</strong></td><td>取决于任务调用频率，任务在特定点自愿放弃 CPU</td><td>频率固定，由定时器中断控制</td></tr><tr><td><strong>上下文切换时机</strong></td><td>当任务执行到 <code>yield()</code> 或自愿让出 CPU 时</td><td>时间片到期强制切换</td></tr><tr><td><strong>任务切换的控制权</strong></td><td>任务自身控制，让出 CPU</td><td>系统控制，定时器到期强制切换</td></tr><tr><td><strong>可靠性和实时性</strong></td><td>较低，可能出现长时间占用 CPU 的任务</td><td>较高，任务被固定时间片切换，保证实时性</td></tr></tbody></table><p>在RISC-V架构中，Trap Handler的定位是通过一系列的硬件寄存器来实现的。当发生异常（exception）或中断（interrupt）时，CPU会自动跳转到一个预定义的地址，这个地址是通过机器模式的控制和状态寄存器（CSRs）中的MTVEC（Machine Trap Base Address）寄存器来配置的。当Trap发生时，CPU会读取MTVEC寄存器中的值作为中断服务例程（ISR）的入口点，并跳转到该处执行相应的中断处理逻辑。</p><p>此外，为了能够处理不同类型的中断和异常，RISC-V提供了MCause（Machine Cause）寄存器来指示触发Trap的具体原因，以及MEPC（Machine Exception Program Counter）寄存器来记录导致Trap的指令地址。这些机制确保了操作系统能够准确地响应和处理各种硬件和软件引起的中断事件。</p><p><strong>Trap Handler的工作机制</strong></p><p>当 RISC-V CPU 遇到异常或中断时，会自动跳转到 trap handler 执行。以下是详细的执行步骤：</p><p><strong>1.检测和保存当前状态</strong></p><ul><li><p><strong>触发 trap</strong>：当硬件中断、软件中断、异常或系统调用发生时，CPU 会触发 trap，并自动切换到 Machine Mode（M 模式）。</p></li><li><p><strong>保存程序计数器</strong>：CPU 会将触发 trap 的指令地址保存到 <code>mepc</code> 寄存器中，以便在完成处理后能够恢复到正确的执行位置。</p></li><li><p>记录 trap 原因</p><p>：CPU 将 trap 的具体原因记录到 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mcause</span><br></pre></td></tr></table></figure><p> 寄存器中。该寄存器的值分为两部分：</p><ul><li>最高位：0 表示异常，1 表示中断。</li><li>低位：表示异常或中断的具体类型，例如指令地址错误、非法指令或定时器中断等。</li></ul></li><li><p><strong>存储 trap 值</strong>：在某些异常中，CPU 会将 trap 相关的附加信息存储到 <code>mtval</code> 寄存器中（如发生地址错误时，存储异常的具体地址）。</p></li></ul><p><strong>2.定位 trap handler 地址</strong></p><ul><li><strong>读取 mtvec 寄存器</strong>：<code>mtvec</code> 寄存器存储了 trap handler 的入口地址。它有两种模式：直接模式和向量模式。<ul><li><strong>直接模式（Direct Mode）</strong>：所有 trap 都会跳转到 <code>mtvec</code> 指定的单一地址（通常是操作系统的通用 trap handler 地址）。</li><li><strong>向量模式（Vectored Mode）</strong>：不同的中断类型跳转到不同的地址，即 <code>mtvec</code> 基地址加上中断类型编号偏移量，从而实现更高效的 trap 处理。</li></ul></li><li><strong>跳转到 trap handler</strong>：根据 <code>mtvec</code> 中的地址，CPU 跳转到相应的 trap handler，开始执行具体的处理逻辑。</li><li><strong>3.执行 trap handler</strong></li></ul><p>在 trap handler 中，操作系统会根据 trap 的具体类型执行不同的操作：</p><ul><li><p><strong>保存当前上下文</strong>：trap handler 会将当前任务的 CPU 状态（包括通用寄存器）保存到内核栈中。保存上下文的操作通常会通过汇编完成，以确保在被打断的任务恢复后可以继续执行。</p></li><li><p>判断 trap 类型</p><p>：操作系统读取 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mcause</span><br></pre></td></tr></table></figure><p> 寄存器来判断 trap 的类型，以执行适当的处理。</p><ul><li><strong>时钟中断</strong>：用于周期性触发任务调度器，进行任务切换。</li><li><strong>外部中断</strong>（如 I&#x2F;O 中断）：用于处理来自外部设备的请求。</li><li><strong>系统调用</strong>：trap handler 识别出系统调用后，会根据调用编号来执行相应的操作（如文件读写、内存分配）。</li><li><strong>异常处理</strong>：如果是非法指令或地址错误等异常，操作系统可能会终止任务或记录错误信息。</li></ul></li><li><p><strong>执行特定处理逻辑</strong>：根据 trap 类型，调用相应的处理函数。对于中断，可能是完成 I&#x2F;O 操作；对于时钟中断，可能是触发任务调度；对于系统调用，执行用户进程请求的系统服务。</p></li></ul><p><strong>4.恢复上下文</strong></p><p>在完成 trap 处理后，trap handler 会恢复被打断的任务上下文：</p><ul><li><strong>恢复通用寄存器</strong>：trap handler 从内核栈中将保存的寄存器值恢复到通用寄存器。</li><li><strong>恢复程序计数器</strong>：将 <code>mepc</code> 中保存的地址恢复到 <code>PC</code>，确保任务能够从中断或异常发生的位置继续执行。</li></ul><p><strong>5.返回到用户模式（或被打断的权限模式）</strong></p><ul><li><p>关闭 Machine Mode 并返回</p><p>：在恢复完上下文后，trap handler 使用 <code>mret</code> 指令（Machine Mode Return）从 Machine Mode 返回到之前的执行模式（通常是用户模式）。</p><ul><li><code>mret</code> 指令会将 <code>mepc</code> 中的地址载入 <code>PC</code>，从而让被打断的程序继续执行。</li><li>如果任务处于用户模式，则会回到用户模式继续执行。</li></ul></li></ul><p>关键寄存器在 trap handler 中的作用总结</p><table><thead><tr><th>寄存器</th><th>作用</th></tr></thead><tbody><tr><td><code>mstatus</code></td><td>保存和恢复 CPU 状态、管理中断使能</td></tr><tr><td><code>mtvec</code></td><td>指定 trap handler 的入口地址</td></tr><tr><td><code>mepc</code></td><td>保存被打断指令的地址</td></tr><tr><td><code>mcause</code></td><td>记录 trap 的原因（中断或异常类型）</td></tr><tr><td><code>mtval</code></td><td>存储与异常相关的具体信息</td></tr><tr><td><code>mie/mip</code></td><td>管理中断的使能和挂起状态</td></tr></tbody></table><h2 id="软件定时器和硬件定时器"><a href="#软件定时器和硬件定时器" class="headerlink" title="软件定时器和硬件定时器"></a>软件定时器和硬件定时器</h2><p>tick是计算机系统中的一个基本时间单位，尤其常见于操作系统的时间管理和任务调度。每一个tick代表一个固定的时间间隔。</p><p>硬件定时是指利用硬件定时器（硬件晶振来提供时钟周期）来精确地控制和测量时间。提供高精度的时间测量与控制。</p><p>CLINT（Core Local Interruptor，核心本地中断控制器）是RISCV架构中的另一个中断控制器负责处理核心本地中断，包括软件中断和定时器中断。</p><p><code>mtimecmp</code>（Machine Timer Compare Register）</p><p><code>mtimecmp</code> 是一个定时器比较寄存器，用于定时器中断。每个内核都有一个 <code>mtimecmp</code> 寄存器，通过设置它的值可以控制定时器中断的触发时刻。</p><ul><li><strong>作用</strong>：当 <code>mtime</code> 的值大于或等于 <code>mtimecmp</code> 时，将触发定时器中断。要取消定时器中断，可以将 <code>mtimecmp</code> 设置为一个大于 <code>mtime</code> 的值。</li></ul><p> <code>mtime</code>（Machine Time Register）</p><p><code>mtime</code> 是机器时间寄存器，保存着系统自启动以来的时间计数值（通常以周期计时）。<code>mtime</code> 会不断递增，通常由一个外部时钟源驱动。</p><ul><li><strong>作用</strong>：保存系统当前时间计数值，单位为时钟周期。<code>mtime</code> 是只读的。</li></ul><h3 id="硬件定时流程"><a href="#硬件定时流程" class="headerlink" title="硬件定时流程"></a>硬件定时流程</h3><p><img src="https://img.picgo.net/2024/11/08/0a9e2df33a8db24915751d3e7e5f32c2f068be6623416e0d.png" alt="硬件定时"></p><p>软件中断</p><p>软件定时器的设计流程：</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/d83ed6635e98a81480e1fa3bdba9a407.png"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>RISCV支持三种模式：simple embedded systems，secure embedded systems ，systems running Unix-like operating systems。</p><p>系统模式：用户态和内核态，想让系统开始跑在用户态就要设置对应的寄存器。</p><p>首先在之前.s启动文件中，设置了mstatus的寄存器MPP位和MPIE为1</p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/3fbbd0b142bb0b1679d7632ae6282f6e.png"></p><p>mstatus寄存器不进行设置就是0，所以进入用户态就是MPP位不设置。</p><p>RISC-V处于安全考虑，不允许用户态程序直接执行部分特权指令，因此只能采用间接的方式进行访问，也就是通过系统调用的方式进行特权资源访问。</p><p><strong>所谓系统调用，就是通过一条特殊的ecall指令，帮助我们从用户态切换到内核态执行，然后通过一条eret指令，从内核态再切换回用户态执行:</strong></p><p><strong>系统调用执行流程</strong></p><p><img src="https://developer.qcloudimg.com/http-save/yehe-8271427/16b817365142f6c92a132a1fdcd05e52.png"></p><h2 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h2><h3 id="加电自检"><a href="#加电自检" class="headerlink" title="加电自检"></a>加电自检</h3><p>初始化BIOS</p><p>检查CPU</p><p>寄存器</p><p>检查BIOS代码的完整性</p><p>检查DMA、timer、interrupt controller</p><p>检查系统内存</p><p>检查总线和外部设备</p><p><strong>RISCV开发板Linux启动流程</strong></p><p>-板子上电后，CPU从固定地址运行ROM中的代码</p><p>-ROM包含简单的设备驱动，从flash或者SD卡加载bootloader</p><p>-再由bootloader加载内核、initramfs等到内存，跳转到Linux内核启动</p><p><img src="https://img.picgo.net/2024/11/11/-173d63b3e456e669b.png" alt="药品养护流程图 (1)"></p><p><a href="https://tinylab.org/riscv-uefi-part1/">RISC-V UEFI 架构支持详解，第 1 部分 - OpenSBI&#x2F;U-Boot&#x2F;UEFI 简介 - 泰晓科技</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISCV Vector test</title>
      <link href="/2024/11/24/RVV%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/11/24/RVV%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="进行数组上的数据相加合并"><a href="#进行数组上的数据相加合并" class="headerlink" title="进行数组上的数据相加合并"></a>进行数组上的数据相加合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常的数组相加函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_add_normal</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> <span class="type">float</span> *a, <span class="type">const</span> <span class="type">float</span> *b, <span class="type">float</span> *c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        c[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 RVV 向量化的数组相加函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_add_rvv</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> <span class="type">float</span> *a, <span class="type">const</span> <span class="type">float</span> *b, <span class="type">float</span> *c)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> l;</span><br><span class="line">    <span class="type">vfloat32m8_t</span> va, vb, vc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n -= l) &#123;</span><br><span class="line">        l = __riscv_vsetvl_e32m8(n);  <span class="comment">// 设置向量长度</span></span><br><span class="line">        va = __riscv_vle32_v_f32m8(a, l);  <span class="comment">// 加载 a</span></span><br><span class="line">        vb = __riscv_vle32_v_f32m8(b, l);  <span class="comment">// 加载 b</span></span><br><span class="line">        vc = __riscv_vfadd_vv_f32m8(va, vb, l);  <span class="comment">// 向量加法</span></span><br><span class="line">        __riscv_vse32_v_f32m8(c, vc, l);  <span class="comment">// 存回 c</span></span><br><span class="line">        a += l;</span><br><span class="line">        b += l;</span><br><span class="line">        c += l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> N = <span class="number">1024</span>;  <span class="comment">// 数组大小</span></span><br><span class="line">    <span class="type">float</span> *a, *b, *c, *d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存，确保数据对齐</span></span><br><span class="line">    posix_memalign((<span class="type">void</span>**)&amp;a, <span class="number">32</span>, N * <span class="keyword">sizeof</span>(<span class="type">float</span>));  </span><br><span class="line">    posix_memalign((<span class="type">void</span>**)&amp;b, <span class="number">32</span>, N * <span class="keyword">sizeof</span>(<span class="type">float</span>));  </span><br><span class="line">    posix_memalign((<span class="type">void</span>**)&amp;c, <span class="number">32</span>, N * <span class="keyword">sizeof</span>(<span class="type">float</span>));  </span><br><span class="line">    posix_memalign((<span class="type">void</span>**)&amp;d, <span class="number">32</span>, N * <span class="keyword">sizeof</span>(<span class="type">float</span>));  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] = i * <span class="number">1.0f</span>;</span><br><span class="line">        b[i] = i * <span class="number">2.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用正常的数组加法</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line">    array_add_normal(N, a, b, c);</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line">    <span class="type">long</span> seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">    <span class="type">long</span> nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">    <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">        --seconds;</span><br><span class="line">        nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time for normal add: %ld.%09ld seconds\n&quot;</span>, seconds, nanoseconds);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 RVV 向量化的加法</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line">    array_add_rvv(N, a, b, d);</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line">    seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">    nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">    <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">        --seconds;</span><br><span class="line">        nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time for RVV add: %ld.%09ld seconds\n&quot;</span>, seconds, nanoseconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在这里打印部分结果，验证两种方法是否一致</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c[0]: %f, d[0]: %f\n&quot;</span>, c[<span class="number">0</span>], d[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    <span class="built_in">free</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="qemu测试结果"><a href="#qemu测试结果" class="headerlink" title="qemu测试结果"></a>qemu测试结果</h3><table><thead><tr><th></th><th>-O</th><th>-O1</th><th>-O2</th><th>-O3</th></tr></thead><tbody><tr><td>normal add</td><td>0.000056136 seconds</td><td>0.000057337 seconds</td><td>0.000139442 seconds</td><td>0.000212970 seconds</td></tr><tr><td>RVV add</td><td>0.000126027 seconds</td><td>0.000147346 seconds</td><td>0.000139222 seconds</td><td>0.000095841 seconds</td></tr></tbody></table><h3 id="实机测试结果"><a href="#实机测试结果" class="headerlink" title="实机测试结果"></a>实机测试结果</h3><table><thead><tr><th></th><th>-O</th><th>-O1</th><th>-O2</th><th>-O3</th></tr></thead><tbody><tr><td>normal add</td><td>0.000000500 seconds</td><td>0.000000500 seconds</td><td>0.000012375</td><td>0.000008125</td></tr><tr><td>RVV add</td><td>0.000007459 seconds</td><td>0.0006959 seconds</td><td>0.000000833</td><td>0.000000667</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单加减法上，qemu上编译器优化会增加常规函数的运行时间（因为qemu对向量指令开销大），数据量不大时候常规未经优化标量的运行时间比优化后的RVV还要快。</p><h2 id="线性运算"><a href="#线性运算" class="headerlink" title="线性运算"></a>线性运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 31</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> input[N] = &#123;<span class="number">-0.4325648115282207</span>, <span class="number">-1.6655843782380970</span>, <span class="number">0.1253323064748307</span>,</span><br><span class="line">                  <span class="number">0.2876764203585489</span>,  <span class="number">-1.1464713506814637</span>, <span class="number">1.1909154656429988</span>,</span><br><span class="line">                  <span class="number">1.1891642016521031</span>,  <span class="number">-0.0376332765933176</span>, <span class="number">0.3272923614086541</span>,</span><br><span class="line">                  <span class="number">0.1746391428209245</span>,  <span class="number">-0.1867085776814394</span>, <span class="number">0.7257905482933027</span>,</span><br><span class="line">                  <span class="number">-0.5883165430141887</span>, <span class="number">2.1831858181971011</span>,  <span class="number">-0.1363958830865957</span>,</span><br><span class="line">                  <span class="number">0.1139313135208096</span>,  <span class="number">1.0667682113591888</span>,  <span class="number">0.0592814605236053</span>,</span><br><span class="line">                  <span class="number">-0.0956484054836690</span>, <span class="number">-0.8323494636500225</span>, <span class="number">0.2944108163926404</span>,</span><br><span class="line">                  <span class="number">-1.3361818579378040</span>, <span class="number">0.7143245518189522</span>,  <span class="number">1.6235620644462707</span>,</span><br><span class="line">                  <span class="number">-0.6917757017022868</span>, <span class="number">0.8579966728282626</span>,  <span class="number">1.2540014216025324</span>,</span><br><span class="line">                  <span class="number">-1.5937295764474768</span>, <span class="number">-1.4409644319010200</span>, <span class="number">0.5711476236581780</span>,</span><br><span class="line">                  <span class="number">-0.3998855777153632</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> output_golden[N] = &#123;</span><br><span class="line">    <span class="number">1.7491401329284098</span>,  <span class="number">0.1325982188803279</span>,  <span class="number">0.3252281811989881</span>,</span><br><span class="line">    <span class="number">-0.7938091410349637</span>, <span class="number">0.3149236145048914</span>,  <span class="number">-0.5272704888029532</span>,</span><br><span class="line">    <span class="number">0.9322666565031119</span>,  <span class="number">1.1646643544607362</span>,  <span class="number">-2.0456694357357357</span>,</span><br><span class="line">    <span class="number">-0.6443728590041911</span>, <span class="number">1.7410657940825480</span>,  <span class="number">0.4867684246821860</span>,</span><br><span class="line">    <span class="number">1.0488288293660140</span>,  <span class="number">1.4885752747099299</span>,  <span class="number">1.2705014969484090</span>,</span><br><span class="line">    <span class="number">-1.8561241921210170</span>, <span class="number">2.1343209047321410</span>,  <span class="number">1.4358467535865909</span>,</span><br><span class="line">    <span class="number">-0.9173023332875400</span>, <span class="number">-1.1060770780029008</span>, <span class="number">0.8105708062681296</span>,</span><br><span class="line">    <span class="number">0.6985430696369063</span>,  <span class="number">-0.4015827425012831</span>, <span class="number">1.2687512030669628</span>,</span><br><span class="line">    <span class="number">-0.7836083053674872</span>, <span class="number">0.2132664971465569</span>,  <span class="number">0.7878984786088954</span>,</span><br><span class="line">    <span class="number">0.8966819356782295</span>,  <span class="number">-0.1869172943544062</span>, <span class="number">1.0131816724341454</span>,</span><br><span class="line">    <span class="number">0.2484350696132857</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> output[N] = &#123;</span><br><span class="line">    <span class="number">1.7491401329284098</span>,  <span class="number">0.1325982188803279</span>,  <span class="number">0.3252281811989881</span>,</span><br><span class="line">    <span class="number">-0.7938091410349637</span>, <span class="number">0.3149236145048914</span>,  <span class="number">-0.5272704888029532</span>,</span><br><span class="line">    <span class="number">0.9322666565031119</span>,  <span class="number">1.1646643544607362</span>,  <span class="number">-2.0456694357357357</span>,</span><br><span class="line">    <span class="number">-0.6443728590041911</span>, <span class="number">1.7410657940825480</span>,  <span class="number">0.4867684246821860</span>,</span><br><span class="line">    <span class="number">1.0488288293660140</span>,  <span class="number">1.4885752747099299</span>,  <span class="number">1.2705014969484090</span>,</span><br><span class="line">    <span class="number">-1.8561241921210170</span>, <span class="number">2.1343209047321410</span>,  <span class="number">1.4358467535865909</span>,</span><br><span class="line">    <span class="number">-0.9173023332875400</span>, <span class="number">-1.1060770780029008</span>, <span class="number">0.8105708062681296</span>,</span><br><span class="line">    <span class="number">0.6985430696369063</span>,  <span class="number">-0.4015827425012831</span>, <span class="number">1.2687512030669628</span>,</span><br><span class="line">    <span class="number">-0.7836083053674872</span>, <span class="number">0.2132664971465569</span>,  <span class="number">0.7878984786088954</span>,</span><br><span class="line">    <span class="number">0.8966819356782295</span>,  <span class="number">-0.1869172943544062</span>, <span class="number">1.0131816724341454</span>,</span><br><span class="line">    <span class="number">0.2484350696132857</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saxpy_golden</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> <span class="type">float</span> a, <span class="type">const</span> <span class="type">float</span> *x, <span class="type">float</span> *y)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    y[i] = a * x[i] + y[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference https://github.com/riscv/riscv-v-spec/blob/master/example/saxpy.s</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">saxpy_vec</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> <span class="type">float</span> a, <span class="type">const</span> <span class="type">float</span> *x, <span class="type">float</span> *y)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> l;</span><br><span class="line"></span><br><span class="line">  <span class="type">vfloat32m8_t</span> vx, vy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n -= l) &#123;</span><br><span class="line">    l = __riscv_vsetvl_e32m8(n);</span><br><span class="line">    vx = __riscv_vle32_v_f32m8(x, l);</span><br><span class="line">    x += l;</span><br><span class="line">    vy = __riscv_vle32_v_f32m8(y, l);</span><br><span class="line">    vy = __riscv_vfmacc_vf_f32m8(vy, a, vx, l);</span><br><span class="line">    __riscv_vse32_v_f32m8 (y, vy, l);</span><br><span class="line">    y += l;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fp_eq</span><span class="params">(<span class="type">float</span> reference, <span class="type">float</span> actual, <span class="type">float</span> relErr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// if near zero, do absolute error instead.</span></span><br><span class="line">  <span class="type">float</span> absErr = relErr * ((fabsf(reference) &gt; relErr) ? fabsf(reference) : relErr);</span><br><span class="line">  <span class="keyword">return</span> fabsf(actual - reference) &lt; absErr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line">    saxpy_golden(N, <span class="number">55.66</span>, input, output_golden);</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line">    <span class="type">long</span> seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">    <span class="type">long</span> nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">    <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">        --seconds;</span><br><span class="line">        nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time for normal add: %ld.%09ld seconds\n&quot;</span>, seconds, nanoseconds);</span><br><span class="line">    </span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line">    saxpy_vec(N, <span class="number">55.66</span>, input, output);</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line">    seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">    nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">    <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">        --seconds;</span><br><span class="line">        nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Elapsed time for    RVV add: %ld.%09ld seconds\n&quot;</span>, seconds, nanoseconds);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> pass = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fp_eq(output_golden[i], output[i], <span class="number">1e-6</span>)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;failed, %f=!%f\n&quot;</span>, output_golden[i], output[i]);</span><br><span class="line">      pass = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pass)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;passed\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (pass == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="qemu测试结果-1"><a href="#qemu测试结果-1" class="headerlink" title="qemu测试结果"></a>qemu测试结果</h3><table><thead><tr><th>RVV</th><th>-O</th><th>-O1</th><th>-O2</th><th>-O3</th></tr></thead><tbody><tr><td>1</td><td>0.000066337 seconds</td><td>0.000063587 seconds</td><td>0.000053899 seconds</td><td>0.000044271 seconds</td></tr><tr><td>2</td><td>0.000063456 seconds</td><td>0.000076642 seconds</td><td>0.000063870 seconds</td><td>0.000059106 seconds</td></tr><tr><td>3</td><td>0.000071483 seconds</td><td>0.000076432 seconds</td><td>0.000051195 seconds</td><td>0.000044282 seconds</td></tr><tr><td>4</td><td>0.000065239 seconds</td><td>0.000072144 seconds</td><td>0.000046892 seconds</td><td>0.000049881 seconds</td></tr></tbody></table><table><thead><tr><th><strong>normal</strong></th><th>-O</th><th>-O1</th><th>-O2</th><th>-O3</th></tr></thead><tbody><tr><td>1</td><td>0.000061757 seconds</td><td>0.000055580 seconds</td><td>0.000141593 seconds</td><td>0.000122429 seconds</td></tr><tr><td>2</td><td>0.000055796 seconds</td><td>0.000055420 seconds</td><td>0.000138452 seconds</td><td>0.000122429 seconds</td></tr></tbody></table><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>线性运算上，通过编译器的优化，发现RVV运行时间是有优化的,优化后的RVV比常规函数运行时间少，运行时间少20~28%。</p><h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_array_2d</span><span class="params">(<span class="type">double</span> **<span class="built_in">array</span>, <span class="type">int</span> rows)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>[i]); <span class="comment">// 释放每一行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(<span class="built_in">array</span>); <span class="comment">// 释放指向行指针的数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵乘法的黄金实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">matmul_golden</span><span class="params">(<span class="type">double</span> **a, <span class="type">double</span> **b, <span class="type">double</span> **c, <span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> o)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      c[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; o; ++k)</span><br><span class="line">        c[i][j] += a[i][k] * b[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 RISC-V 向量扩展优化的矩阵乘法实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">matmul</span><span class="params">(<span class="type">double</span> **a, <span class="type">double</span> **b, <span class="type">double</span> **c, <span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> o)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> vlmax = __riscv_vsetvlmax_e64m1();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      <span class="type">double</span> *ptr_a = &amp;a[i][<span class="number">0</span>];</span><br><span class="line">      <span class="type">double</span> *ptr_b = &amp;b[j][<span class="number">0</span>];</span><br><span class="line">      <span class="type">int</span> k = o;</span><br><span class="line">      <span class="type">vfloat64m1_t</span> vec_s = __riscv_vfmv_v_f_f64m1(<span class="number">0</span>, vlmax);</span><br><span class="line">      <span class="type">vfloat64m1_t</span> vec_zero = __riscv_vfmv_v_f_f64m1(<span class="number">0</span>, vlmax);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> vl; k &gt; <span class="number">0</span>; k -= vl, ptr_a += vl, ptr_b += vl) &#123;</span><br><span class="line">        vl = __riscv_vsetvl_e64m1(k);</span><br><span class="line"></span><br><span class="line">        <span class="type">vfloat64m1_t</span> vec_a = __riscv_vle64_v_f64m1(ptr_a, vl);</span><br><span class="line">        <span class="type">vfloat64m1_t</span> vec_b = __riscv_vle64_v_f64m1(ptr_b, vl);</span><br><span class="line"></span><br><span class="line">        vec_s = __riscv_vfmacc_vv_f64m1(vec_s, vec_a, vec_b, vl);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">vfloat64m1_t</span> vec_sum;</span><br><span class="line">      vec_sum = __riscv_vfredusum_vs_f64m1_f64m1(vec_s, vec_zero, vlmax);</span><br><span class="line">      <span class="type">double</span> sum = __riscv_vfmv_f_s_f64m1_f64(vec_sum);</span><br><span class="line">      c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算时间差的辅助函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">calc_elapsed_time</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *label, <span class="keyword">struct</span> timespec start, <span class="keyword">struct</span> timespec end)</span> &#123;</span><br><span class="line">  <span class="type">long</span> seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">  <span class="type">long</span> nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">  <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">    --seconds;</span><br><span class="line">    nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s elapsed time: %ld.%09ld seconds\n&quot;</span>, label, seconds, nanoseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">512</span>; <span class="comment">// 矩阵 A 的行数</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> M = <span class="number">512</span>; <span class="comment">// 矩阵 B 的行数（等于 C 的列数）</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> O = <span class="number">512</span>; <span class="comment">// 矩阵 A 的列数（等于 B 的列数）</span></span><br><span class="line">  <span class="type">uint32_t</span> seed = <span class="number">0xdeadbeef</span>;</span><br><span class="line">  srand(seed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配内存并生成随机数据</span></span><br><span class="line">  <span class="type">double</span> **A = alloc_array_2d(N, O);</span><br><span class="line">  <span class="type">double</span> **B = alloc_array_2d(M, O);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;start);</span><br><span class="line">  gen_rand_2d(A, N, O);</span><br><span class="line">  gen_rand_2d(B, M, O);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;end);</span><br><span class="line"></span><br><span class="line">  calc_elapsed_time(<span class="string">&quot;Data generation&quot;</span>, start, end);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配内存用于存储结果</span></span><br><span class="line">  <span class="type">double</span> **golden = alloc_array_2d(N, M);</span><br><span class="line">  <span class="type">double</span> **actual = alloc_array_2d(N, M);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行黄金实现</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start1</span>, <span class="title">end1</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;start1);</span><br><span class="line">  matmul_golden(A, B, golden, N, M, O);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;end1);</span><br><span class="line">  calc_elapsed_time(<span class="string">&quot;Golden implementation&quot;</span>, start1, end1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行优化实现</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start2</span>, <span class="title">end2</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;start2);</span><br><span class="line">  matmul(A, B, actual, N, M, O);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;end2);</span><br><span class="line">  calc_elapsed_time(<span class="string">&quot;Vector implementation&quot;</span>, start2, end2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较结果</span></span><br><span class="line">  <span class="built_in">puts</span>(compare_2d(golden, actual, N, M) ? <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;fail&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放内存</span></span><br><span class="line">  free_array_2d(A, N);</span><br><span class="line">  free_array_2d(B, M);</span><br><span class="line">  free_array_2d(golden, N);</span><br><span class="line">  free_array_2d(actual, N);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际机器测试结果"><a href="#实际机器测试结果" class="headerlink" title="实际机器测试结果"></a>实际机器测试结果</h3><table><thead><tr><th></th><th>-O</th><th>-O1</th><th>-O2</th><th>-O3</th></tr></thead><tbody><tr><td>normal</td><td>0.58</td><td>0.66</td><td>0.46</td><td>0.45</td></tr><tr><td>rvv</td><td>0.33</td><td>0.34</td><td>0.34</td><td>0.33</td></tr></tbody></table><p>qemu可以执行RVV的指令，但是开销很大，实机的运行效率更高。 </p><p>目前自动向量化的效率在矩阵运算上慢与手动向量化Intrinsic。编译器的自动向量化对于程序的运行效率是有提升的。</p><table><thead><tr><th>-O2</th><th>strcpy</th><th>strncpy</th><th>strlen</th></tr></thead><tbody><tr><td>常量</td><td>0.000002333</td><td>0.000003750</td><td>0.000000959</td></tr><tr><td>向量</td><td>0.000010833</td><td>0.000001125</td><td>0.000007666</td></tr></tbody></table><blockquote><p><strong>总结</strong>：编译器GCC或者LLVM可以对程序进行自动向量化的优化，但是因为目前的编译器版本对自动向量化的支持还不完善，通过测试结果可看到实际机器上跑Intrinsic的向量化优化的效率要比编译器的优化更高。</p></blockquote><h2 id="性能影响因素"><a href="#性能影响因素" class="headerlink" title="性能影响因素"></a>性能影响因素</h2><p>内存对齐：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10 <span class="comment">// 矩阵的维度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用RVV实现未对齐的矩阵加法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">matrix_add_unaligned</span><span class="params">(<span class="type">const</span> <span class="type">int32_t</span>* matA, <span class="type">const</span> <span class="type">int32_t</span>* matB, <span class="type">int32_t</span>* matC)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> vl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; N; j += vl) &#123;</span><br><span class="line">            vl = __riscv_vsetvl_e32m1(N - j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非对齐加载</span></span><br><span class="line">            <span class="type">vint32m1_t</span> vecA = __riscv_vle32_v_i32m1(matA + i * N + j, vl);</span><br><span class="line">            <span class="type">vint32m1_t</span> vecB = __riscv_vle32_v_i32m1(matB + i * N + j, vl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 元素加法</span></span><br><span class="line">            <span class="type">vint32m1_t</span> vecC = __riscv_vadd_vv_i32m1(vecA, vecB, vl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存结果</span></span><br><span class="line">            __riscv_vse32_v_i32m1(matC + i * N + j, vecC, vl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用RVV实现对齐的矩阵加法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">matrix_add_aligned</span><span class="params">(<span class="type">const</span> <span class="type">int32_t</span>* matA, <span class="type">const</span> <span class="type">int32_t</span>* matB, <span class="type">int32_t</span>* matC)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> vl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; N; j += vl) &#123;</span><br><span class="line">            vl = __riscv_vsetvl_e32m1(N - j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对齐加载</span></span><br><span class="line">            <span class="type">vint32m1_t</span> vecA = __riscv_vle32_v_i32m1((<span class="type">int32_t</span>*)__builtin_assume_aligned(matA + i * N + j, <span class="number">4</span>), vl);</span><br><span class="line">            <span class="type">vint32m1_t</span> vecB = __riscv_vle32_v_i32m1((<span class="type">int32_t</span>*)__builtin_assume_aligned(matB + i * N + j, <span class="number">4</span>), vl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 元素加法</span></span><br><span class="line">            <span class="type">vint32m1_t</span> vecC = __riscv_vadd_vv_i32m1(vecA, vecB, vl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存结果</span></span><br><span class="line">            __riscv_vse32_v_i32m1((<span class="type">int32_t</span>*)__builtin_assume_aligned(matC + i * N + j, <span class="number">4</span>), vecC, vl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> matA[N][N] __attribute__((aligned(<span class="number">4</span>))) = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int32_t</span> matB[N][N] __attribute__((aligned(<span class="number">4</span>))) = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int32_t</span> matC_unaligned[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int32_t</span> matC_aligned[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化矩阵数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            matA[i][j] = i + j;</span><br><span class="line">            matB[i][j] = i - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试未对齐加法</span></span><br><span class="line">    <span class="type">clock_t</span> start_unaligned = clock();</span><br><span class="line">    matrix_add_unaligned(&amp;matA[<span class="number">0</span>][<span class="number">0</span>], &amp;matB[<span class="number">0</span>][<span class="number">0</span>], &amp;matC_unaligned[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="type">clock_t</span> end_unaligned = clock();</span><br><span class="line">    <span class="type">double</span> time_unaligned = (<span class="type">double</span>)(end_unaligned - start_unaligned) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试对齐加法</span></span><br><span class="line">    <span class="type">clock_t</span> start_aligned = clock();</span><br><span class="line">    matrix_add_aligned(&amp;matA[<span class="number">0</span>][<span class="number">0</span>], &amp;matB[<span class="number">0</span>][<span class="number">0</span>], &amp;matC_aligned[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="type">clock_t</span> end_aligned = clock();</span><br><span class="line">    <span class="type">double</span> time_aligned = (<span class="type">double</span>)(end_aligned - start_aligned) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印未对齐结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未对齐计算结果:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matC_unaligned[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印对齐结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n对齐计算结果:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matC_aligned[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印时间比较</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n未对齐计算时间: %.6f 秒\n&quot;</span>, time_unaligned);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;对齐计算时间: %.6f 秒\n&quot;</span>, time_aligned);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.picgo.net/2024/11/25/-2024-11-25-151948f556dc8fc85bc92e.png" alt="屏幕截图 2024 11 25 151948"></p>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISCV Vector</title>
      <link href="/2024/11/23/RVV%E5%90%91%E9%87%8F%E5%8C%96/"/>
      <url>/2024/11/23/RVV%E5%90%91%E9%87%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><blockquote><p>首先硬件可能支持不同版本的向量扩展，这之间不同版本互不兼容。</p><p>qemu上虽然可以跑RVV程序，但是开销比标量运算还大，所以只能做程序验证，实际运行效率要上实际的riscvgv的机器上才行。</p><p>ubuntu22.04尽管使用qemu但是也不支持rvv，因为kernel内核中的mstatus寄存器（机器模式下的状态寄存器）未初始化，当mstatus.vs域值被写0时候，试图执行向量指令或访问向量寄存器均会引发非法指令异常。</p></blockquote><h1 id="自动向量化和手动向量化"><a href="#自动向量化和手动向量化" class="headerlink" title="自动向量化和手动向量化"></a>自动向量化和手动向量化</h1><blockquote><p><strong>关于向量化：</strong></p><ol><li><strong>对GCC或者LLVM进行开发（自动向量化）</strong></li></ol><p>​    **前端编译扩展 Target Transform Info (TTI)**：</p><ul><li>定义目标架构的向量化能力（RVV 支持可扩展向量）。</li><li>例如为 RISC-V 增强 <code>getRegisterBitWidth</code> 和 <code>getTypeLegalizationCost</code> 方法。</li></ul><p>​    <strong>修改 Loop 和 SLP Vectorizer</strong>：</p><ul><li>添加对 RVV 动态向量寄存器的支持。</li><li>修改默认的向量化策略以生成动态向量类型。</li></ul><p>​    <strong>支持 RVV 的 IR 到目标代码映射</strong>：</p><ul><li>在后端的 <code>SelectionDAG</code> 或 <code>GlobalISel</code> 中实现 RVV 指令的生成逻辑。</li></ul><ol start="2"><li><strong>Intrinsic函数的开发（手动向量化）</strong><ul><li>本质上跳过了自动向量化的逻辑，不需要向量化Pass介入。</li><li>直接提供了向量化代码的“翻译规则”，编译器无需再生成向量化逻辑或 IR，代码中调用的 Intrinsic 已经指定了目标平台指令。</li></ul></li><li><strong>自动向量化与显式使用 Intrinsic 的关系</strong><ul><li>显式调用 Intrinsic：<ul><li>开发者直接编写 Intrinsic，相当于手动向量化。</li><li>编译器只负责将这些 Intrinsic 映射到硬件指令，而不会尝试进行进一步优化。</li><li>优点：避免冗余优化，无需等待编译器的进一步支持。</li><li>缺点：增加了维护成本。</li></ul></li><li>自动向量化：<ul><li>开发者编写标量代码，向量化 Pass 根据硬件平台的能力和代码逻辑，自动生成调用 Intrinsic 的 IR。</li><li>编译器根据向量化 Pass 生成的规则，优化代码并映射到目标平台指令。</li></ul></li></ul></li></ol></blockquote><h2 id="向量扩展"><a href="#向量扩展" class="headerlink" title="向量扩展"></a>向量扩展</h2><p>RISC-V 向量扩展（RVV）是一种灵活的矢量处理架构，允许程序在运行时动态调整向量长度（VL），以适应不同硬件实现的特性（例如矢量寄存器大小）。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>1. 向量寄存器</strong></p><p>RVV 定义了一组 <strong>向量寄存器（Vector Registers, VRs）</strong>：</p><ul><li>寄存器名：<code>v0</code> 至 <code>v31</code>，共 32 个。</li><li><strong>每个寄存器的实际宽度（VLEN</strong>，以位为单位）由硬件实现决定。例如，硬件可能支持 128 位、256 位或 512 位寄存器。</li><li><strong>基本元素宽度（SEW，Standard Element Width）</strong>：表示每个向量元素的大小，例如 <code>8-bit</code>, <code>16-bit</code>, <code>32-bit</code>, <code>64-bit</code>。</li><li>每个寄存器可以存储的最大元素个数为 <code>VLEN / SEW</code>，称为 <strong>最大向量长度（VLmax）</strong>。</li></ul><blockquote><p>补充：<strong>一个向量元素的最大位宽为ELEN（&lt;VLEN）</strong></p><p>本文的位宽都是2的次幂</p></blockquote><p><strong>2.LMUL（Vector register group multiplier)</strong></p><p>当一个向量寄存器不够用，就将多个寄存器组进行合并叫做LMUL（(合并寄存器组数量），有合并就有拆解，可以分份：1&#x2F;2，1&#x2F;4，1&#x2F;8 （小数表示一个向量寄存器的被使用的位宽）<br>$$<br>LMUL &gt;&#x3D; \frac{SEW}{ELEN}<br>$$</p><p><strong>向量长度（VL）</strong></p><ul><li><strong>动态向量长度（VL）</strong> 是指当前有效的向量长度（单位：元素个数），由程序通过指令动态设置。</li><li>动态设置使得程序可以在剩余数据不足时调整向量长度，从而避免浪费计算资源。</li></ul><h3 id="设置向量长度"><a href="#设置向量长度" class="headerlink" title="设置向量长度"></a><strong>设置向量长度</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> vl = __riscv_vsetvl_e32m8(n);</span><br></pre></td></tr></table></figure><p>例如这个函数：获取32位数据(SEW)，并且8倍寄存器宽度倍数(LMUL)的数据长度，如果硬件支持的矢量寄存器长度位VLEN是128位，那么根据公式<br>$$<br>元素数目 &#x3D; ( \frac{\text{VLEN}}{\text{SEW}} \times \text{LMUL} &#x3D; \frac{128}{32} \times 8 &#x3D; 32 )<br>$$<br>因此这个函数是说明一次性处理32个32位数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> vl = __riscv_vsetvl_e16m1(n);</span><br></pre></td></tr></table></figure><p>还假设VLEN &#x3D; 128，这个函数将设置一次性处理8个16位数据。</p><p><strong>如何计算最终的 VL</strong></p><p>对于每次向量指令的实际运行，向量长度（<code>VL</code>）取决于待处理数据的个数 <code>n</code> 和硬件寄存器的处理能力 <code>VLmax</code>（即硬件最大能处理的数据量）。通常 <code>VL</code> 取以下值：<br>$$<br>VL &#x3D; \min(n, \frac{VLEN}{SEW} \times LMUL)<br>$$</p><p>即从待处理元素数 <code>n</code> 和硬件支持的最大向量长度 <code>VLmax</code> 中选择较小的那个值。</p><ul><li><strong>vsetvl_e32m8</strong>：假设有 100 个 32 位数据，硬件支持最大处理 32 个 32 位数据，那么： VL&#x3D;min⁡(100,32)&#x3D;32VL &#x3D; \min(100, 32) &#x3D; 32VL&#x3D;min(100,32)&#x3D;32</li><li><strong>vsetvl_e16m1</strong>：假设有 10 个 16 位数据，硬件支持最大处理 8 个 16 位数据，那么： VL&#x3D;min⁡(10,8)&#x3D;8VL &#x3D; \min(10, 8) &#x3D; 8VL&#x3D;min(10,8)&#x3D;8</li></ul><p>这种动态调整向量长度的方式使得 RVV 架构能够灵活适应不同大小的数据处理，优化性能。</p><h2 id="通用Intrinsic编程-手动向量化"><a href="#通用Intrinsic编程-手动向量化" class="headerlink" title="通用Intrinsic编程(手动向量化)"></a>通用Intrinsic编程(手动向量化)</h2><ol><li>使用适当的向量长度设置函数</li><li>采用合适数据加载存储函数</li><li>通过向量操作（乘法、加法等）实习复杂运算</li><li>逐步迭代处理数据</li></ol><h3 id="IntrinsicAPI函数解析"><a href="#IntrinsicAPI函数解析" class="headerlink" title="IntrinsicAPI函数解析"></a>IntrinsicAPI函数解析</h3><p>Intrinsic 命名遵循着以下通用规则：</p><p><img src="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1ebb6245-255e-454c-85bc-ec2df76607cd_727x424.png"></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__riscv_vle8_v_i8mf4</span><br></pre></td></tr></table></figure><p>构成为：__riscv_前缀，在最新的版本中这个前缀不能省略。</p><p>执行操作常用的有：vadd加法，vmul乘法，vle向量加载，vse向量存储，vsetvl设置向量长度。</p><p>数据类型：</p><ul><li><p>u32：无符号32整形</p></li><li><p>f64:    64位浮点型</p></li></ul><p>操作对象是向量还是标量，通过后缀区分，以下为常用操作：</p><ul><li><code>vv</code>：两个向量操作</li><li><code>vx</code>：向量与标量操作</li><li><code>vi</code>：向量与立即数操作</li><li><code>v</code>:针对向量的</li></ul><p>LMUL表示向量寄存器逻辑长度是基础寄存器长度的倍数，即VLEN的倍数，例如：</p><ul><li><p><strong>LMUL &#x3D; 1</strong>: 一个逻辑向量寄存器等于一个物理向量寄存器。</p></li><li><p><strong>LMUL &#x3D; 2</strong>: 一个逻辑向量寄存器需要两个物理向量寄存器。</p></li><li><p><strong>LMUL &#x3D; 1&#x2F;2 或 1&#x2F;4</strong>: 一个物理向量寄存器被划分为多个逻辑寄存器</p></li></ul><p>_tumu是操作掩码</p><p>在执行时会参考一个布尔掩码向量（类型通常是 <code>vboolN_t</code>）。掩码决定了哪些向量元素参与计算：</p><ul><li><strong>掩码值为 1</strong>（<code>true</code>）：参与计算。</li><li><strong>掩码值为 0</strong>（<code>false</code>）：跳过计算，通常保留原值或设置为零，具体行为由指令定义。</li></ul><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vint32m1_t</span> __riscv_vadd_vv_i32m1_m(<span class="type">vbool32_t</span> mask, <span class="type">vint32m1_t</span> dest, <span class="type">vint32m1_t</span> op1, <span class="type">vint32m1_t</span> op2);</span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><strong>mask</strong>: 掩码向量，类型为 <code>vbool32_t</code>，控制哪些元素参与运算。</li><li><strong>dest</strong>: 原目标向量，对于未参与计算的元素，将保留此向量中的对应值。</li><li><strong>op1, op2</strong>: 输入向量，表示两个操作数。</li></ul><p><strong>输入</strong>:</p><ul><li><code>op1 = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</code></li><li><code>op2 = &#123;8, 7, 6, 5, 4, 3, 2, 1&#125;</code></li><li><code>mask = &#123;1, 0, 1, 1, 0, 0, 1, 0&#125;</code></li></ul><p><strong>结果</strong>:</p><ul><li>按掩码启用元素计算：<code>&#123;(1+8), 0, (3+6), (4+5), 0, 0, (7+2), 0&#125;</code></li><li>最终结果：<code>&#123;9, 0, 9, 9, 0, 0, 9, 0&#125;</code></li></ul><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">vint32m1_t</span> va, vb, vc;  </span><br><span class="line">        <span class="type">size_t</span> vlmax = __riscv_vsetvlmax_e32m1();</span><br><span class="line">                       </span><br><span class="line">        <span class="type">int32_t</span> ia[N] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int32_t</span> ib[N] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int32_t</span> ic[N] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        va = __riscv_vle32_v_i32m1(ia, N);</span><br><span class="line">        vb = __riscv_vle32_v_i32m1(ib, N);</span><br><span class="line">        vc = __riscv_vadd_vv_i32m1(va, vb, N);</span><br><span class="line">        __riscv_vse32_v_i32m1(ic, vc, N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">unsigned</span> i=<span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ic[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><p>在实际应用中，选择 SEW 时需要综合考虑以下因素：</p><ol><li>数据类型（决定了基本的 SEW）。</li><li>精度要求（高精度需要 64 位，性能优先则选择 32 位）。</li><li>硬件资源（寄存器长度和支持的 SEW）。</li><li>并行性能（更小的 SEW 提高并行性，但可能导致精度不足）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;riscv_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算时间差的辅助函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">calc_elapsed_time</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *label, <span class="keyword">struct</span> timespec start, <span class="keyword">struct</span> timespec end)</span> &#123;</span><br><span class="line">  <span class="type">long</span> seconds = end.tv_sec - start.tv_sec;</span><br><span class="line">  <span class="type">long</span> nanoseconds = end.tv_nsec - start.tv_nsec;</span><br><span class="line">  <span class="keyword">if</span> (start.tv_nsec &gt; end.tv_nsec) &#123;</span><br><span class="line">    --seconds;</span><br><span class="line">    nanoseconds += <span class="number">1000000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s elapsed time: %ld.%09ld seconds\n&quot;</span>, label, seconds, nanoseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index arithmetic</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">index_golden</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = b[i] + (<span class="type">double</span>)i * c[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">index_</span><span class="params">(<span class="type">double</span> *a, <span class="type">double</span> *b, <span class="type">double</span> *c, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> vlmax = __riscv_vsetvlmax_e32m1();</span><br><span class="line">  <span class="type">vuint32m1_t</span> vec_i = __riscv_vid_v_u32m1(vlmax);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> vl; n &gt; <span class="number">0</span>; n -= vl, a += vl, b += vl, c += vl) &#123;</span><br><span class="line">    vl = __riscv_vsetvl_e64m2(n);</span><br><span class="line"></span><br><span class="line">    <span class="type">vfloat64m2_t</span> vec_i_double = __riscv_vfwcvt_f_xu_v_f64m2(vec_i, vl);</span><br><span class="line"></span><br><span class="line">    <span class="type">vfloat64m2_t</span> vec_b = __riscv_vle64_v_f64m2(b, vl);</span><br><span class="line">    <span class="type">vfloat64m2_t</span> vec_c = __riscv_vle64_v_f64m2(c, vl);</span><br><span class="line"></span><br><span class="line">    <span class="type">vfloat64m2_t</span> vec_a =</span><br><span class="line">        __riscv_vfadd_vv_f64m2(vec_b, __riscv_vfmul_vv_f64m2(vec_c, vec_i_double, vl), vl);</span><br><span class="line">    __riscv_vse64_v_f64m2(a, vec_a, vl);</span><br><span class="line"></span><br><span class="line">    vec_i = __riscv_vadd_vx_u32m1(vec_i, vl, vl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N = <span class="number">31</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> seed = <span class="number">0xdeadbeef</span>;</span><br><span class="line">  srand(seed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// data gen</span></span><br><span class="line">  <span class="type">double</span> B[N], C[N];</span><br><span class="line">  gen_rand_1d(B, N);</span><br><span class="line">  gen_rand_1d(C, N);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compute</span></span><br><span class="line">  <span class="type">double</span> golden[N], actual[N];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行黄金实现</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start1</span>, <span class="title">end1</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;start1);</span><br><span class="line">  index_golden(golden, B, C, N);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;end1);</span><br><span class="line">  calc_elapsed_time(<span class="string">&quot;Golden implementation&quot;</span>, start1, end1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行优化实现</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start2</span>, <span class="title">end2</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;start2);</span><br><span class="line">  index_(actual, B, C, N);</span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;end2);</span><br><span class="line">  calc_elapsed_time(<span class="string">&quot;Vector implementation&quot;</span>, start2, end2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compare</span></span><br><span class="line">  <span class="built_in">puts</span>(compare_1d(golden, actual, N) ? <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;fail&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[^为什么仍需要循环？]: 为什么仍需要循环？向量寄存器长度有限,向量寄存器（例如 RVV 中的 VLEN）有固定的硬件限制。例如，VLEN 是 128、256 或 512 位等。每次操作能处理的元素数量取决于：数据类型的大小 (SEW: Scalar Element Width)。当前配置的 LMUL 倍数。如果数据量 <code>n</code> 超过硬件支持的向量长度，就必须分块处理，循环每次操作一个向量块。<strong>数据长度不一定是向量寄存器的倍数</strong> 数据长度 <code>n</code> 通常不是向量寄存器所能处理的元素数（<code>VLEN / SEW</code>）的整数倍，因此需要动态调整向量长度 (VL) 并处理剩余的尾部数据。<strong>循环有助于动态优化</strong> 向量化可以动态调整每次处理的元素数，利用循环灵活适配各种数据量。</p><h2 id="向量化优化影响要素"><a href="#向量化优化影响要素" class="headerlink" title="向量化优化影响要素"></a>向量化优化影响要素</h2><p><strong>1. 数据对齐 (Data Alignment)</strong></p><p>向量指令通常要求数据在内存中是对齐的（aligned），以便更高效地加载和存储：</p><ul><li><strong>对齐数据</strong>（如 64 位数据按 8 字节对齐）可以显著提高加载&#x2F;存储性能。</li><li><strong>未对齐数据</strong>需要额外处理（例如使用 <code>vle64ff</code> 等指令），可能导致性能下降。</li></ul><p><strong>优化建议</strong>：尽量确保输入数据地址是对齐的，尤其在加载和存储时。</p><p><strong>2. 数据大小与边界处理</strong></p><p>向量化时，处理的数据大小往往不是向量寄存器长度的整数倍：</p><ul><li><strong>完整向量操作</strong>：在主要循环中可以使用完整的向量寄存器。</li><li><strong>尾部处理</strong>：剩余的元素（小于寄存器宽度）需要额外的标量代码或专用尾处理逻辑。RVV 中可以用 <code>vl</code> 动态调整处理的元素数量。</li></ul><p><strong>优化建议</strong>：</p><ul><li>利用 RVV 的动态向量长度特性，通过调整 <code>vl</code> 来处理剩余数据，无需显式的标量处理代码。</li></ul><p><strong>3. 数据依赖 (Data Dependency)</strong></p><ul><li>如果当前迭代的计算依赖于前一迭代的结果（循环相关性），会限制向量化的潜力。</li><li>RVV 提供的<strong>掩码操作</strong>（masking）可以处理部分依赖问题，但性能可能下降。</li></ul><p><strong>优化建议</strong>：尝试重写算法，减少循环相关性或数据依赖。</p><p><strong>4. 向量化指令集的特性</strong></p><ul><li><strong>RVV 的灵活性</strong>：RVV 支持可变长度向量和 SEW，这使得编程灵活性更高，但需要仔细设计循环逻辑以充分利用硬件。</li><li><strong>向量扩展指令</strong>（例如 <code>vfwcvt</code>）：将低精度数据扩展为高精度时会引入额外开销。</li><li><strong>掩码（Mask）操作</strong>：对部分元素操作时使用掩码，但这会降低性能，因为部分元素的计算会被跳过。</li></ul><p><strong>5. 分支与条件判断</strong></p><p>在向量化代码中，分支和条件判断可能导致性能下降：</p><ul><li>RVV 中可以通过掩码指令（masking）处理条件分支，但仍会产生一些冗余操作。</li><li>如果分支逻辑复杂且数据不均匀，可能需要拆分数据进行分别处理。</li></ul><p><strong>优化建议</strong>：</p><ul><li>尽量减少分支逻辑，或将分支替换为掩码操作。</li><li>优化数据布局，使条件判断逻辑更简单。</li></ul><p><strong>6. 向量长度和 LMUL 配置</strong></p><ul><li><p>RVV 的向量寄存器长度（VLEN）和宽度配置（LMUL）会影响并行性能：</p><ul><li><strong>LMUL 增大</strong>（如 <code>m4</code>、<code>m8</code>）：更多寄存器组合，处理更多数据，性能更高，但资源消耗增加。</li><li><strong>LMUL 减小</strong>（如 <code>mf2</code>、<code>mf4</code>）：每次操作处理的元素少，功耗低，但并行度下降。</li></ul></li></ul><p><strong>优化建议</strong>：选择合适的 <code>LMUL</code>，在寄存器使用率和并行度之间找到平衡。</p><p><strong>7. 循环展开 (Loop Unrolling)</strong></p><ul><li>手动展开循环可以减少循环开销（如分支和索引计算），提高性能。</li><li>但循环展开会增加代码复杂度，可能需要调整以适应不同 <code>VLEN</code>。</li></ul><p><strong>优化建议</strong>：根据具体硬件配置展开循环，以充分利用寄存器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISCV内存管理单元</title>
      <link href="/2024/11/23/RISCV%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83/"/>
      <url>/2024/11/23/RISCV%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.picgo.net/2024/11/12/mmu63423688102025c3.webp" alt="mmu"></p><p><img src="https://img.picgo.net/2024/11/12/-2024-11-12-111925e80e2ddbe0cc53d7.png" alt="屏幕截图 2024 11 12 111925"></p><h1 id="MMU-内存管理单元"><a href="#MMU-内存管理单元" class="headerlink" title="MMU(内存管理单元)"></a>MMU(内存管理单元)</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>在用户的视角里，每个进程都有自己独立的地址空间，A进程的4GB和B进程4GB是完全独立不相关的，他们看到的都是操作系统虚拟出来的地址空间。但是呢，虚拟地址最终还是要落在实际内存的物理地址上进行操作的。操作系统就会通过页表的机制来实现进程的虚拟地址到物理地址的翻译工作。其中每一页的大小都是固定的。页表管理有两个关键点，分别是页面大小和页表级数。</p><h2 id="页表级数"><a href="#页表级数" class="headerlink" title="页表级数"></a>页表级数</h2><p>页表级数越少，虚拟地址到物理地址的映射就会越快，但是需要管理的页表项会越多，能支持的地址空间也有限，相反页表的级数越多，需要的存储的页表数据就会越少，而且能支持到比较大的地址空间，但是虚拟地址到物理地址的映射就会越慢。</p><p><img src="https://img.picgo.net/2024/11/12/cfa0c8d0de1d9db011f57ad8d1e5ba76d3f6bd720ddc60ff.png" alt="cfa0c8d0de1d9db011f57ad8d1e5ba76"></p><blockquote><p>PGD：Page Global Directory，页全局目录，它是多级页表的顶层，包含指向下一级页表的基地址。</p><p>PUD：Page Upper Directory， 页上级目录，位于PGD之下，包含了指向PMD的基地址。</p><p>PMD：Page Middle Directory，页中级目录，位于PUD之下，包含了指向PTE的及地址。</p><p>PTE：Page Table Entry，页表项，位于PMD之下，包含了虚拟地址到物理地址的具体映射信息。</p></blockquote><h2 id="RISCV内存管理机制"><a href="#RISCV内存管理机制" class="headerlink" title="RISCV内存管理机制"></a>RISCV内存管理机制</h2><p><strong>RV32（32 位地址空间）</strong>：主要用于嵌入式系统和资源受限的设备。虚拟和物理地址都限制为 32 位，通常采用两级页表，支持的页大小为 4KB、2MB 或 1GB。RV32 并没有 39 位地址管理。</p><p><strong>RV39（39 位虚拟地址空间）</strong>：主要用于中小型系统，比如一般的操作系统环境。虚拟地址为 39 位，物理地址宽度则可以根据硬件实际支持的位宽（通常在 36-40 位之间）进行设置。RV39 使用三级页表，支持的页大小同样是 4KB、2MB 或 1GB。</p><p><strong>RV48（48 位虚拟地址空间）</strong>：适合高性能计算或服务器系统。虚拟地址为 48 位，物理地址宽度可以支持 44-52 位，具体取决于硬件配置。RV48 使用四级页表，允许更大的虚拟地址空间，支持的页大小为 4KB、2MB 和 1GB。</p><p><strong>RV64（64 位虚拟地址空间）</strong>：理论上支持 64 位虚拟地址，但实际上限制在 RV48，适合未来超大规模系统。不过在目前的 RISC-V 实现中，64 位的地址空间通常没有完全实现，因为绝大多数系统的虚拟地址需求并未达到如此高的级别。</p><p>Riscv使用<strong>satp寄存器</strong>来保存MMU的映射表的根地址。</p><p><img src="https://img.picgo.net/2024/11/12/stapea79c558971c617f.png" alt="stap"></p><blockquote><p><strong>MODE（位 63 到位 60）</strong>：</p><ul><li>用于表示虚拟内存的模式。不同的模式代表不同的页表格式，RISC-V 支持多个页表层级。常见的模式如下：<ul><li><code>0b0000</code>：禁用虚拟地址翻译。</li><li><code>0b0001</code>：SV32（2级页表）。</li><li><code>0b0010</code>：SV39（3级页表）。</li><li><code>0b0011</code>：SV48（4级页表）。</li><li><code>0b0100</code>：SV57（5级页表）。</li><li><code>0b0101</code>：SV64（6级页表）。</li></ul></li></ul><p><strong>ASID（位 59 到位 38）</strong>：</p><ul><li>地址空间标识符（Address Space Identifier），用于区分不同进程的虚拟地址空间。ASID 的作用是避免进程间的虚拟地址映射冲突。</li></ul><p><strong>PPN（位 37 到位 0）</strong>：</p><ul><li>页表的物理页号（Physical Page Number），指示当前页表的物理地址基址。页表基址会用该值来进行虚拟地址到物理地址的映射。它以4KB的页面大小为单位。</li></ul></blockquote><p>页表是一个很庞大的数据结构且储存在内存中，直接由MMU访问内存中的页表从而得到物理地址会产生非常大的开销，进而影响CPU的运行效率。为了解决这一问题，利用局域性原理，通常会在内存与MMU之间增加一级缓存，该缓存有一个特殊的名称，即TLB（Translation Look-aside Buffer），用于缓存近期经常使用的页表项（Page Table Entry）。为了减小TLB的缺失率，通常TLB为全相联的结构。</p><p><img src="https://img.picgo.net/2024/11/12/TLB20dea606ed02565e1.png" alt="TLB2"></p><p>在<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=1&q=%E7%8E%84%E9%93%81C910&zhida_source=entity">玄铁C910</a>中TLB被分为了两级，第一级称为UTLB，且UTLB被分为了ITLB与DTLB，ITLB储存由IFU请求的指令虚拟地址（即指令PC）对应的虚实地址转换的页表项，DTLB储存由LSU中Load&#x2F;Store指令访存的虚拟地址对应的虚实地址转换的页表项。ITLB和DTLB均为全相联结构。第二级TLB称为JTLB，为四路组相联结构，页表项信息储存在SRAM中，访问JTLB需要一个周期得到结构。</p><p><img src="https://img.picgo.net/2024/11/12/TLB934b1cbc096bb55f.png" alt="TLB"><img src="https://img.picgo.net/2024/11/12/PPNe4a4095ca50d08ea.png" alt="PPN"></p><p>当IFU或LSU发送请求<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=3&q=%E8%99%9A%E5%AE%9E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2&zhida_source=entity">虚实地址转换</a>的请求时，会首先访问ITLB或DTLB，若命中UTLB，经过物理内存保护单元（Physical Memory Protection）检查相应地址范围的权限后，若检查未通过，将产生访问异常（Access Error Exception）。若检查通过，经过转换得到的物理地址将根据需要发送到<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=1&q=%E6%8C%87%E4%BB%A4%E7%BC%93%E5%AD%98&zhida_source=entity">指令缓存</a>或者数据缓存用于缓存命中的判断。若第一级TLB访问缺失，将会访问第二级的JTLB，若JTLB进一步失配，则MMU会启动Hardware Page Table Walk，访问内存得到最终的地址转换结果。在UTLB、JTLB或从PTW模块中找到虚拟地址对应的页表项后，还需判断该页的属性，比如该页是否为可执行，可读，可写，是否有效（在内存中是否存在）等等，若访存操作违反页面属性的规定，会产生<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=1&q=%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8&zhida_source=entity">缺页异常</a>（Page Fault Exception），代表CPU无法获取该页的数据。由于CPU没有数据就无法进行计算，CPU罢工了用户进程也就出现了<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=1&q=%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD&zhida_source=entity">缺页中断</a>，进程会从用户态切换到<a href="https://zhida.zhihu.com/search?content_id=232264149&content_type=Article&match_order=1&q=%E5%86%85%E6%A0%B8%E6%80%81&zhida_source=entity">内核态</a>，并将缺页中断交给内核的Page Fault Handler处理。</p><p>若命中JTLB或内存中的页表且未产生缺页异常，MMU会根据请求JTLB重新填充的来源选择更新ITLB还是DTLB，或者以请求PTW模块的虚拟内存信息为索引更新JTLB。命中JTLB或内存中的页表后物理地址同样要通过物理内存保护单元（PMP）进行检查权限后，才能发送给请求虚实地址转换缓存。</p><p><strong>在多核系统中，当操作系统（OS）修改了页表后，通常需要确保所有核上的 TLB（Translation Lookaside Buffer） 都反映了最新的页表内容。否则，不同核心可能会依然使用旧的页表映射，导致地址转换错误和数据不一致。</strong></p><div style="display: flex;">  <div style="flex: 1; padding: 10px;">    为什么需要刷掉其他核的 TLB？每个 CPU 核心都有自己的 TLB，它们缓存着虚拟地址到物理地址的映射，以提高地址转换的效率。如果操作系统修改了页表（如在上下文切换时更改进程的虚拟地址映射，或者执行了某些系统调用，如 mmap），其他核心可能会继续访问旧的 TLB 条目，导致地址转换错误。为避免这个问题，操作系统需要确保所有核心的 TLB 都被更新或失效。  </div>  <div style="flex: 1; padding: 10px;">    如何知道哪些核的 TLB 需要刷掉？通常，操作系统并不直接知道哪些核的 TLB 需要刷掉，因为操作系统无法完全控制 TLB 内容（这些是硬件管理的）。然而，操作系统可以通过以下方式推断哪些 TLB 需要刷掉：上下文切换：当操作系统执行进程上下文切换时，它通常会清除当前进程的 TLB 条目，防止其他进程看到错误的虚拟到物理地址映射。页表更新：如果 OS 更新了某个页表项（比如在 mmap、munmap 等操作中修改了映射），它可能需要通知所有核心刷新 TLB。  </div></div><h3 id="SV39分页机制"><a href="#SV39分页机制" class="headerlink" title="SV39分页机制"></a>SV39分页机制</h3><p><img src="https://img.picgo.net/2024/11/12/SV39d1cbebb4e34d8809.png" alt="SV39"></p><p>使用64位虚拟地址的低39位，高25位未使用，每一页占用4KB内存，页内使用虚拟地址低12位寻址，虚拟地址高27位分为三级页号，每一级都有512个可用页号。</p><p>如果每级页表项8字节，且每个4KB页面只能容纳4096&#x2F;512&#x3D;512个页表项，所以每级页表的寻址范围是9位。</p><h4 id="SV39页表项-PTE"><a href="#SV39页表项-PTE" class="headerlink" title="SV39页表项(PTE)"></a>SV39页表项(PTE)</h4><p><img src="https://img.picgo.net/2024/11/12/PTEea3d355b73a8db7d.png" alt="PTE"></p><p>每个PTE包含一个44位的物理页(PPN)和一些标志位，分页硬件使用39位虚拟地址中的高27位作为索引，在页表中周到对应的PTE，然后PTE中的44位地址作为高位(物理页号),虚拟地址中的低12位作为低位(页内偏移量),构造出一个56位的物理地址。</p><p><img src="https://img.picgo.net/2024/11/12/addressd1c9293b99866ebf.png" alt="address"></p><ul><li>v位决定了该页表项的其余部分是否有效(V &#x3D; 1时有效)。若V&#x3D;0，则任何遍历到此页表项的虚拟转换操作都会导致页错误。</li><li>R、W、X位分别表示此页是否可以读取、写入、执行。如果都是0，那么这个页表是指向下一级页表的指针，否则它是也表述的一个叶节点。</li></ul><h3 id="VMA"><a href="#VMA" class="headerlink" title="VMA"></a>VMA</h3><p><strong>VMA（Virtual Memory Area，虚拟内存区域）</strong> 是操作系统中用于管理和描述进程虚拟地址空间的一种结构。在现代操作系统（如 Linux）中，VMA 是虚拟地址空间的基本组成单元，用于划分进程的不同内存区域，且每个 VMA 描述一个连续的虚拟地址范围。</p><blockquote><ol><li><strong>VMA的基本作用</strong></li></ol><ul><li><strong>管理进程虚拟地址空间</strong>：VMA 用来表示进程虚拟地址空间中的一个区域，这个区域通常具有相同的属性，比如是否可读、可写、可执行等。</li><li><strong>内存区域的划分</strong>：操作系统通过 VMA 划分出不同的内存区域，例如代码段、数据段、堆、栈以及共享库等。</li><li><strong>内存映射的管理</strong>：VMA 在进程地址空间内表示的是一块虚拟内存，它可能会映射到物理内存、交换空间，或是磁盘上的文件（例如通过 <code>mmap</code> 系统调用映射的文件）。</li></ul><ol start="2"><li><strong>VMA的组成部分</strong></li></ol><p>每个 VMA 通常包含以下信息：</p><ul><li><strong>虚拟地址范围</strong>：每个 VMA 具有一个起始虚拟地址和一个结束虚拟地址，表示该内存区域的大小和范围。</li><li><strong>内存权限</strong>：描述该区域的访问权限，包括是否可读（<code>PROT_READ</code>）、可写（<code>PROT_WRITE</code>）、可执行（<code>PROT_EXEC</code>）等。</li><li><strong>映射类型</strong>：包括该区域是否映射到文件（如共享库），或者是否是匿名映射（如堆和栈）。</li><li><strong>标志</strong>：标志可以包括是否该区域是共享的（<code>MAP_SHARED</code>）或私有的（<code>MAP_PRIVATE</code>），是否是堆栈区域等。</li><li><strong>偏移量</strong>：对于文件映射，VMA 还可能记录文件在虚拟地址空间中的偏移量，指明文件在内存中的位置。</li></ul><ol start="3"><li><strong>VMA的作用和管理</strong></li></ol><p>VMA 主要用于管理进程的内存区域，它在进程的内存映射和内存管理中扮演了关键角色。具体来说：</p><ul><li><strong>虚拟地址空间的划分</strong>：每个 VMA 对应进程虚拟地址空间的一个逻辑区域（如代码、数据、堆栈等）。操作系统通过维护 VMA 来确保这些区域的内存管理。</li><li><strong>内存分配与回收</strong>：在进程创建、加载程序或执行时，操作系统会使用 VMA 来管理和分配虚拟内存区域，并在进程退出时回收这些内存区域。</li><li><strong>进程上下文切换</strong>：操作系统在进行进程上下文切换时，会利用 VMA 结构来恢复或切换不同的虚拟内存映射。</li></ul><ol start="4"><li><strong>VMA 与其他内存管理结构的关系</strong></li></ol><ul><li><strong>页表（Page Tables）</strong>：VMA 管理虚拟地址的逻辑划分，而页表则负责将这些虚拟地址映射到物理内存。每个 VMA 中的虚拟地址段在页表中都有相应的映射关系。</li><li><strong>内存映射文件（mmap）</strong>：通过 <code>mmap</code> 系统调用，操作系统可以将文件内容映射到进程的虚拟内存中，这个映射关系通常由 VMA 来描述。</li><li><strong>内核虚拟内存（Kernel VMA）</strong>：操作系统内核通常也会维护自己的虚拟地址空间，用于管理内核的代码、数据、堆栈等区域。内核的 VMA 不同于用户空间的 VMA，且不通过用户页表进行管理。</li></ul><ol start="5"><li><strong>VMA 的典型使用场景</strong></li></ol><ul><li><strong>堆和栈</strong>：进程的堆和栈分别是动态分配和管理内存的区域，它们通常是由操作系统通过 VMA 来管理的。例如，堆和栈的增长和收缩是由 VMA 的边界和映射方式来控制的。</li><li><strong>共享内存和文件映射</strong>：通过 <code>mmap</code>，操作系统可以将文件或共享内存区域映射到进程的虚拟地址空间，形成一个 VMA 区域。该 VMA 描述了文件与进程内存之间的映射关系。</li></ul><ol start="6"><li><strong>VMA的例子</strong></li></ol><p>假设一个进程需要加载一个程序，它的虚拟地址空间可能会被划分成以下几个 VMA 区域：</p><ul><li><strong>代码段（Text Segment）</strong>：包含可执行的代码，通常是只读且可执行的区域。</li><li><strong>数据段（Data Segment）</strong>：包含程序的静态数据，通常是可读写的。</li><li><strong>堆（Heap）</strong>：动态分配内存的区域，通常从低地址增长至高地址。</li><li><strong>栈（Stack）</strong>：用于存储函数调用信息的区域，通常从高地址向低地址增长。</li><li><strong>共享库映射</strong>：通过 <code>mmap</code> 映射到虚拟内存中的共享库或文件映射。</li></ul></blockquote><blockquote><p>VMA（虚拟内存区域）是操作系统用于管理进程虚拟地址空间的基本数据结构之一。它帮助操作系统在进程的虚拟内存中划分不同的区域，并描述这些区域的属性和映射关系。VMA 是现代操作系统内存管理的重要组成部分，尤其在虚拟内存管理、内存保护和文件映射等方面发挥着关键作用。</p></blockquote><h3 id="换页"><a href="#换页" class="headerlink" title="换页"></a>换页</h3><p>换页基本思想</p><ul><li>用磁盘作为物理内存的补充，且对上层应用透明</li><li>应用对虚拟内存的使用，不受物理内存大小限制</li></ul><p>如何实现</p><ul><li>磁盘上划分专门的Swap分区，或专门的Swap文件</li><li>在处理缺页异常时，触发物理内存页的换入换出</li></ul><p><img src="https://img.picgo.net/2024/11/12/huanye055de0a104e17b17.png" alt="huanye"></p>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISA AND RISCV</title>
      <link href="/2024/11/20/ISA%E5%92%8CRISC-V/"/>
      <url>/2024/11/20/ISA%E5%92%8CRISC-V/</url>
      
        <content type="html"><![CDATA[<h1 id="ISA和RISC-V"><a href="#ISA和RISC-V" class="headerlink" title="ISA和RISC-V"></a>ISA和RISC-V</h1><h2 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h2><p>ISA是Instruction Set Architecture(指令集体系架构)缩写，指令集是一个计算机系统支持的所有机器指令的集合，常看作软硬件之间的分界面。<strong>指令集对上限定了软件的基本功能，对下制定了硬件实现的功能目标。</strong></p><blockquote><p>ISA指令集架构是底层硬件电路层面向上层软件程序提供的一层接口规范。<br>定义了： 基本数据类型、寄存器、指令、寻址模式、异常或者中断的处理方式</p></blockquote><p>ISA的宽度指的是CPU中的通用寄存器的宽度，这决定了寻址范围的大小、以及数据运行运算的能力。ISA的宽度和指令编码长度无关<br>ISA可分为CISC和RISC。<strong>CISC是指复杂指令系统计算机，RISC是指精简指令系统计算机。</strong></p><p><strong>CISC</strong>：通过设置一些功能复杂的指令，把一些原来由软件实现的、常用的功能改用硬件指令实现，以此来提高计算机的执行速度。越来越多的复杂指令被加人指令系统中，逐渐形成了一个庞大且复杂的指令集。<br>目标是<strong>强化指令功能，减少程序的指令条数，达到提高性能的目的。</strong><br>X86是现存唯一的CISC指令集。</p><p><strong>RISC</strong>：尽量简化计算机指令功能，只保留那些功能简单、能在一个节拍内执行完成的指令，而把较复杂的功能用段子程序来实现。 <strong>RISC通过减少指令种类、规范指令格式和简化寻址方式等方法，</strong>方便处理器内部的并行处理，提高超大规模集成电路(VLSI)器件的使用效率，从而大幅度地提高处理器的性能。<br> RISC 指令系统仅包含最常用的简单指令，因此可以通过硬件优化设计，把时钟频率提得很高，从而实现整个系统的高性能。同时，RISC 技术在 CPU 芯片上设置大量寄存器，用来保存常用的数据，以大大减少对存储器的访问，用高速的寄存器访问取代低速的存储器访问，从而提高系统整体性能。</p><p> RISC-V是一种基于RISC原则开源的ISA。<br> 特点：简单、清晰的分层设计、模块化、稳定、社区化<br> ISA命令格式:RV[##][abc..xyz]<br> RV是指用于标识RISC-V体系架构的前缀，[##]标识处理器的宽度，[abc..xyz]支持什么模块。<br> 模块化ISA：由一个基础整数指令集+多个可选的扩展指令集。</p><table><thead><tr><th>基本指令集</th><th>描述</th></tr></thead><tbody><tr><td>RV32I</td><td>32位整数指令集</td></tr><tr><td>RV32E</td><td>RV32I的子集，用于小型的嵌入式场景</td></tr><tr><td>RV64I</td><td>64位整数指令集，兼容RV32I</td></tr><tr><td>RV128I</td><td>128整数指令集，兼容RV64I和RV32I</td></tr></tbody></table><table><thead><tr><th>扩展指令集</th><th>描述</th></tr></thead><tbody><tr><td>M</td><td>整数乘法与除法指令集</td></tr><tr><td>A</td><td>存储器原子指令集</td></tr><tr><td>F</td><td>单精度(32bit)浮点指令集</td></tr><tr><td>D</td><td>双精度(64bit)浮点指令兼容F</td></tr><tr><td>C</td><td>压缩(Compressed)指令集</td></tr><tr><td>……</td><td>其他标准化和为标准化的指令集</td></tr></tbody></table><p>特定组合IMAFD被称为通用组合用字母G表示。<br>HART：指令执行流。</p><h2 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h2><p>RISC-V的特权级别(Privileged Specification)定义了三个特权级别(privilege level)<br>machine级别是最高的级别，所有的实现都需要支持。</p><table><thead><tr><th>level</th><th>Encoding</th><th>Name</th><th>Abbreviation</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>User&#x2F;Application</td><td>U</td></tr><tr><td>1</td><td>01</td><td>Supervisor</td><td>S</td></tr><tr><td>2</td><td>10</td><td>Reserved</td><td></td></tr><tr><td>3</td><td>11</td><td>Machine</td><td>M</td></tr><tr><td>不同的特权级别下时分别对应各自的一套Register(CSR),用于控制和获取对应level下的处理器工作状态。高级别的特权级别可以访问低级别的CSR，反之不行。</td><td></td><td></td><td></td></tr></tbody></table><h3 id="内存管理保护"><a href="#内存管理保护" class="headerlink" title="内存管理保护"></a>内存管理保护</h3><p>物理内存保护允许M模式指定u模式可以访问内存地址，支持R&#x2F;W&#x2F;X以及Lock。</p><h1 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><table><thead><tr><th>常用选项</th><th>含义</th></tr></thead><tbody><tr><td>-E</td><td>只做预处理</td></tr><tr><td>-c</td><td>只编译不链接，生产目标文件’.o’’</td></tr><tr><td>-S</td><td>生成汇编代码</td></tr><tr><td>-o file</td><td>把输出生成到由file指定文件名的文件中</td></tr><tr><td>-g</td><td>在输出的文件中加入支持调试的信息</td></tr><tr><td>-v</td><td>显示输出详细的命令执行过程信息</td></tr></tbody></table><p>编译：预处理指处理源文件中的#开头的预处理指令，编译则针对预处理的结果进行一系列的词汇分析、语法分析、语义分析，优化后生成的汇编指令，存放在.o为后缀的目标文件中。</p><p>汇编：汇编器将汇编语言转为机器可以执行的命令。</p><p>链接：链接器将汇编器生成的目标文件和一些标准库(譬如libc)文件组合，形成最终可执行的应用程序。</p><h2 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h2><p>ELF是一种Unix-like系统上的二进制文件格式标准。</p><p>ELF标准中定义的采用ELF格式分四类：</p><blockquote><p>可重定位文件：内容包含了代码和数据，可以被链接成可执行文件或共享目标文件。（Linux上的.o文件）</p><p>可执行文件：可以直接执行的程序（Linux上的a.out）</p><p>共享目标文件：内容包含了代码和数据，可以作为链接器的输入，在链接阶段和其他的Relocatable File或者Shared Object File 一起链接成新的Object File，或者运行阶段作为动态链接器的输入，和Executable File结合，作为进程的一部分来运行（Linux上的.so）</p><p>核心存储文件：进程意外终止时，系统可以将该进程的部分内容和终止时的其他状态信息保存到该文件中以供调试分析。（Linux上的core文件）</p></blockquote><p>ELF文件处理相关工具：Binutils（<a href="http://www.gnu.org/software/binutils/%EF%BC%89">http://www.gnu.org/software/binutils/）</a></p><blockquote><p>ar：归档文件，将多个文件打包成一个大文件。<br>as：被gcc调用，输入汇编文件，输出目标文件供链接器Id链接<br>Id：GNU链接器。被gcc调用，它把目标文件和各种库文件结合在一起，重定位数据，并链接符号引用。<br>objcopy：执行文件格式转换。<br>objdump：显示ELF文件的信息。<br>readelf：显示更多EFL格式文件的信息</p></blockquote><p><img src="https://img.picgo.net/2024/11/08/elff8c6577557cb7657.png" alt="elf"></p><p>读取一个hello_world.o的文件头信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello_world -o</span><br><span class="line">readelf -h hello_world.o</span><br></pre></td></tr></table></figure><h3 id="RISC-V架构常见gcc编译选项"><a href="#RISC-V架构常见gcc编译选项" class="headerlink" title="RISC-V架构常见gcc编译选项"></a>RISC-V架构常见gcc编译选项</h3><p>1.-march&#x3D;RISCV_ARCH</p><ul><li>用于告诉编译器目标芯片的架构情况，生成对应的二进制代码</li><li>比如：-march&#x3D;rv32im<ul><li>rv32：告诉编译器生成的代码实在RISC-V架构的32位芯片上运行，就不会使用ld和sd命令，而使用lw和sw</li><li>im：芯片支持i指令集和m指令集</li></ul></li></ul><p>2.-mabi&#x3D;RISC_ABI</p><table><thead><tr><th>数据类型</th><th>int</th><th>long</th><th>指针</th></tr></thead><tbody><tr><td>ilp32&#x2F;ilp32f&#x2F;ilp32d</td><td>32bit</td><td>32bit</td><td>32bit</td></tr><tr><td>lp64&#x2F;lp64f&#x2F;lp64d</td><td>32bit</td><td>64bit</td><td>64bit</td></tr></tbody></table><table><thead><tr><th>浮点数传参规则</th><th>需要支持的浮点指令扩展</th><th>float参数</th><th>double参数</th></tr></thead><tbody><tr><td>ilp32&#x2F;lp64</td><td>不需要</td><td>通过整数寄存器（a0-a1）传递</td><td>通过整数寄存器（a0-a3）传递</td></tr><tr><td>ilp32f&#x2F;lp64f</td><td>需要支持F扩展</td><td>通过浮点寄存器（fa0-fa1）传递</td><td>通过整数寄存器（a0-a3）传递</td></tr><tr><td>ilp32d&#x2F;lp64d</td><td>需要支持F和D扩展</td><td>通过浮点寄存器（fa0-fa1）传递</td><td>通过浮点寄存器（fa0-fa1）传递</td></tr></tbody></table><p>-mabi参数用于指定编译目标的adi，RISC-V定义了两个整型abi和三个浮点abi。</p><ul><li><p>两个整型abi</p><p>ilp32：int、long、pointer都是32位，long long是64位，char是8位，short是16位<br>lp64：long、pointer是64位，int是32位，其他类型和ilp32一样</p></li><li><p>三个浮点abi<br>“”空字符：在寄存器中不传递浮点参数<br>f：32位浮点寄存器，需要支持F扩展<br>d：64位浮点寄存器，需要支持F和D扩展</p></li></ul><p>3.-mlittle-endian、-mbig-endian</p><p>4.-mcmodel</p><p>-mcmodel&#x3D;medlow：只能寻址4G，对于32位架构芯片刚好，但是64位的芯片则不能寻址全部空间。</p><p>-mcmodel&#x3D;medany: 寻址范围在当前PC的前后2G范围，PC是不断变化的，可以实现把64位架构芯片地址全部寻址。</p><h3 id="模拟器QEMU"><a href="#模拟器QEMU" class="headerlink" title="模拟器QEMU"></a>模拟器QEMU</h3><p>QEMU是一套以GPL许可证分发源码的计算机系统模拟软件。支持架构：ARM，MIPS，AMD,RISC等等。</p><p>QEMU两种主要模式:user mode和system mode。</p><h4 id="QEMU的下载与安装"><a href="#QEMU的下载与安装" class="headerlink" title="QEMU的下载与安装"></a>QEMU的下载与安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-venv</span><br><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo pip install tomli</span><br><span class="line"></span><br><span class="line">wget https://download.qemu.org/qemu-9.0.1.tar.xz</span><br><span class="line">tar xvJf qemu-9.0.1.tar.xz</span><br><span class="line">cd qemu-9.0.1</span><br><span class="line"></span><br><span class="line">./configure --prefix=/opt/qemu --target-list=riscv64-softmmu,riscv64-linux-user</span><br><span class="line">make -j $(nproc)</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line">添加路径</span><br><span class="line">export PATH=$PATH:/opt/qemu/bin</span><br><span class="line">生效</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install qemu-system-misc</span><br><span class="line">查看版本</span><br><span class="line">riscv@qemu-vm:~/riscv64-linux/qemu-9.0.1$ qemu-system-riscv64 --version</span><br><span class="line">QEMU emulator version 9.0.1</span><br><span class="line">Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure><h4 id="RISCV的工具链下载与安装"><a href="#RISCV的工具链下载与安装" class="headerlink" title="RISCV的工具链下载与安装"></a>RISCV的工具链下载与安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#使用vpn下载更快</span></span></span><br><span class="line">git clone https://github.com/riscv-collab/riscv-gnu-toolchain</span><br><span class="line">cd riscv-gnu-toolchain</span><br><span class="line">git submodule update --init --recursive ##速度很慢</span><br><span class="line">安装依赖库</span><br><span class="line">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \</span><br><span class="line">gawk build-essential bison flex texinfo gperf libtool patchutils bc \</span><br><span class="line">zlib1g-dev libexpat-dev git \</span><br><span class="line">libglib2.0-dev libfdt-dev libpixman-1-dev \</span><br><span class="line">libncurses5-dev libncursesw5-dev</span><br><span class="line">sudo apt install python3 ninja-build</span><br><span class="line">安装路径</span><br><span class="line">./configure --prefix=/opt/riscv64</span><br><span class="line">sudo make linux -j $(nproc)</span><br><span class="line">添加路径</span><br><span class="line">sudo nano /etc/profile</span><br><span class="line">export PATH=$PATH:/opt/riscv64/bin</span><br><span class="line">source /etc/profile</span><br><span class="line">检查路径</span><br><span class="line">echo $PATH</span><br><span class="line">查看版本</span><br><span class="line">riscv64-unknown-linux-gnu-gcc -v</span><br><span class="line">安装riscv gcc gnu工具链</span><br><span class="line">sudo apt install gcc-riscv64-linux-gnu</span><br><span class="line">查看工具链版本</span><br><span class="line">riscv64-linux-gnu-gcc -v</span><br><span class="line">sudo cp /usr/riscv64-linux-gnu/lib/* /lib/</span><br></pre></td></tr></table></figure><h2 id="GDB工具的使用"><a href="#GDB工具的使用" class="headerlink" title="GDB工具的使用"></a>GDB工具的使用</h2><p>GDB的PDF<a href="https://sourceware.org/gdb/download/onlinedocs/gdb.pdf">网址</a></p><p>教程：<a href="https://www.bilibili.com/video/BV1EK411g7Li?vd_source=a29cba237e61c1d3e1d8193673a58e41&spm_id_from=333.788.videopod.episodes&p=5">GDB精简教程_哔哩哔哩_bilibili</a></p><p>使用GDB调试qemu下的riscv64-linux-gnu-gcc编译的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc -g hello.c -o hello</span><br><span class="line">qemu-riscv64 ./hello</span><br><span class="line">riscv64-unknown-linux-gnu-gdb hello</span><br></pre></td></tr></table></figure><h2 id="Linker-Script链接脚本"><a href="#Linker-Script链接脚本" class="headerlink" title="Linker Script链接脚本"></a>Linker Script链接脚本</h2><p>链接器一般都提供多种控制整个链接过程的方法，以用来产生用户所须要的文件。</p><p>一般链接器有如下三种方法:</p><p>使用命令行来给链接器指定参数，ld的-o、-e参数就属于这类。<br>将链接指令存放在目标文件里面，编译器经常会通过这种方法向链接器传递指令。方法也比较常见，只是我们平时很少关注，比如VISUAL C++编译器会把链接参数放在PE目标文件的.drectve段以用来传递参数。<br>使用链接控制脚本。</p><p>绝大部分情况下，我们使用链接器提供的默认链接规则对目标文件进行链接。</p><p><strong>在编译普通的应用程序时，可以使用默认的链接器脚本，但是对于内核程序来说，它本身也是一个.elf文件，这个.elf文件该怎么组织，各个段放到内存中什么地方，这个由于和底层硬件强相关，所以需要我们自己编写相关的链接器脚本。</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b4d12962cd60253b018e622693ea2405.png"></p><blockquote><p>在C代码中直接获取链接器脚本中定义的符号是有一定的限制的。C语言是一种静态编译语言，在编译时会将源代码转换为机器码，并生成可执行文件。链接器脚本用于指导链接器如何组织可执行文件的各个部分，包括代码段、数据段、符号表等。</p><p><strong>代码中的符号表</strong>是编译器在编译过程中使用的数据结构，用于管理程序中的变量、函数和其他标识符的信息。</p><p>在C代码中，无法直接引用链接器脚本中定义的符号的值，因为C编译器并不了解链接器脚本的细节。C编译器只能根据给定的C代码进行编译，将代码转换为机器码，并生成符号表。符号表中包含了在C代码中定义的全局变量、函数等符号及其对应的地址。<br>要在C代码中获取链接器脚本中定义的符号的值，一种常见的做法是通过在C代码中声明外部变量，并使用链接器脚本中定义的符号来初始化这些外部变量。这样，链接器在链接阶段会将外部变量与链接器脚本中定义的符号关联起来，并将符号的值赋给外部变量。然后，C代码就可以通过访问这些外部变量来获取链接器脚本中定义的符号的值。<br>总之，C代码无法直接获取链接器脚本中定义的符号的值，但可以通过声明外部变量并与符号关联来间接获取。这种间接的方式使得C代码能够与链接器脚本进行交互，并共享符号的值。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm入门</title>
      <link href="/2024/11/20/llvm/"/>
      <url>/2024/11/20/llvm/</url>
      
        <content type="html"><![CDATA[<h1 id="LLVM概念"><a href="#LLVM概念" class="headerlink" title="LLVM概念"></a>LLVM概念</h1><p>LLVM编译器是基于模块化、可扩展化的设计，将编译器过程分为多个阶段，而gcc编译器则是集成了多个前端和后端的传统编译器，设计更紧密一体化。</p><p>LLVM编译器因具有高度模块化的中间表示IR为基础，具有能实现更细粒度的优化。</p><p>LLVM结构</p><p>前端解析源代码，检查错误，并构建特定语言的抽象语法树(AST)来表示输入代码。AST额可以选择转换为新的表示形式来进行优化。</p><p>优化器负责进行各种转换以尝试提高代码的运行时间，例如消除冗余计算</p><p>后端将代码映射到目标指令集。除了编写正确代码之外，它还负责生成利用受支持架构的不寻常的功能的良好代码。后端常见部分包括指令选择、寄存器分配和指令调度。</p><p><img src="https://img.picgo.net/2024/11/28/-2024-11-28-11415752d6b1a600dbeb82.png" alt="屏幕截图 2024 11 28 114157"></p><h1 id="编译构建LLVM"><a href="#编译构建LLVM" class="headerlink" title="编译构建LLVM"></a>编译构建LLVM</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#git克隆LLVM-project</span></span></span><br><span class="line">git clone --depth 10 https://github.com/llvm/llvm-project.git </span><br><span class="line">git chectout 19.1.3</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;Unix Makefiles&quot; \</span><br><span class="line">    -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">    -DLLVM_ENABLE_PROJECTS=&quot;clang;lld;mlir&quot; \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=/opt/llvm19 \</span><br><span class="line">    /home/riscv/llvm-project/llvm  ##工程下的llvm目录</span><br><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br><span class="line">sudo vi ~/.bashrc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#add</span></span> </span><br><span class="line">  export PATH=$PATH:/opt/llvm19/bin</span><br><span class="line">source ~/.bashrc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># version find</span></span></span><br><span class="line">llvm-config --version</span><br></pre></td></tr></table></figure><h2 id="LLVM常用命令"><a href="#LLVM常用命令" class="headerlink" title="LLVM常用命令"></a>LLVM常用命令</h2><p><img src="https://img.picgo.net/2024/11/28/xiangguanput824ea8c179d62cff.png" alt="xiangguanput"></p><p><code>.ll</code> 文件是 <strong>LLVM汇编语言格式</strong>的源代码文件，它是LLVM中间表示的一种文本格式，通常用于人类阅读和调试。它与机器代码无关，旨在展示程序的逻辑和结构，适用于编译、优化以及生成目标代码的各个阶段。</p><p><code>.bc</code> 文件是 <strong>LLVM Bitcode</strong> 文件，它是LLVM IR的二进制表示格式。<code>.bc</code> 是平台无关的二进制格式，适用于编译过程中的中间步骤。<code>.bc</code> 文件通常用于优化、链接和跨平台处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-as： 将IR文件编译为二进制文件，默认生成后缀名为.bc的文件，也可以使用-o指定输出:</span></span></span><br><span class="line">llvm-as -o hello hello.ll</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-dis 将二进制生成IR文件生成.ll后缀文件</span></span></span><br><span class="line">llvm-dis hello</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llc将.ll或.bc文件编译成汇编文件，输出.s文件</span></span></span><br><span class="line">llc hello.ll</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#将.ll或.bc文件编译为汇编文件,输出后缀名为.s文件</span></span></span><br><span class="line">lli hello.bc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-link将多个LLVM的二进制文件合并为一个二进制文件</span></span></span><br><span class="line">llvm-link -o hello hello.bc bye.bc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-diff对比两个文件的区别,可以用来比较.ll文件和LLVM的二进制文件</span></span></span><br><span class="line">llvm-diff hello1.ll hello2.ll</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-nm:列出LLVM二进制文件或静态库文件的符号表</span></span></span><br><span class="line">llvm-nm hello.a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#llvm-ar:创建静态库,值得注意的是llvm-ar会创建一个新的符号表来统一记录静态库中所有的成员，这有助于提升速度</span></span></span><br><span class="line">llvm-ar r hello.a hello.bc bye.bc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#opt是LLVM的优化器和分析器，输入LLVM源文件，会对其进行优化或分析，然后输出优化文件或分析结果。</span></span></span><br><span class="line">opt [options] &lt;input-file&gt; -o &lt;output-file&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#[options]：指定一个或多个要应用的优化 Pass。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#&lt;input-file&gt;：输入的 LLVM IR 文件（可以是 .bc 或 .ll 格式）。</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#-o &lt;output-file&gt;：指定优化后的输出文件。</span></span></span><br></pre></td></tr></table></figure><h1 id="Clang前端"><a href="#Clang前端" class="headerlink" title="Clang前端"></a>Clang前端</h1><p>目录：<code>llvm-project/clang/</code></p><ul><li>预处理：头文件以及宏的处理</li><li>词法分析：词法分析器的任务是从左向右逐行扫描源程序的字符，识别除哥哥单词并确定单词的类型，将识别出的单词转换成同意的机内表示————词法单元形式。</li><li>语法分析：主要任务是从词法分析器输出的token序列中识别除各类短语，并构造语法分析树(AST)。如果输入字符串的哥哥单词敲好自左至右地站在分析树的各个节点上，那么这个词串就是该语言的一个句子，语法分析树描述了句子的语法结构</li><li>语义分析：收集标识符的属性信息与语义检查。表示符的属性包括种属，类型，存储位置和长度、值、作用域、参数和返回值类型。语义检查包括变量或过程未经声明就是用，重复声明、运算分量类型不匹配、操作符与操作数之间类型不匹配。</li><li>代码生成:将AST转换成相依的LLVM代码。</li></ul><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p><strong>clang提供了现成的工具来直接生成AST</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules - fsyntax-only -Xclang -ast-dump test.cpp</span><br></pre></td></tr></table></figure><ul><li>-fmodules ：允许modules的语言特性</li><li>-fsyntax-only：只解析语法，不进行编译和链接</li><li>-Xclang <arg>：使用Xclang向编译器传递参数</li><li>-ast-dump：构建AST并打印</li></ul><p>抽象语法树(AST)：源代码语法结构的抽象表示。</p><p>以树状形式表现程序语言的语法结构，每个节点都代表源代码中的一种结构。</p><p>抽象：并不会表示出真实语法中的每个细节。</p><p><strong>Clang AST三大核心基本类，每个节点都表示为它们的一个实例。</strong></p><ul><li>Decl:表明，包括很多子类来标识不同声明类型，<a href="https://clang.llvm.org/doxygen/classclang_1_1DeclContext.html">参考链接</a></li><li>Stmt:表明语句，包含很多子类来标识不同语句类型，<a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">参考链接</a></li><li>Type:表示类型，<a href="https://clang.llvm.org/doxygen/classclang_1_1ReferenceType.html">参考链接</a>)</li></ul><h1 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h1><p>高级语言经过Clang等前端解析为平台无关的中间表示(<strong>IR</strong>),使编译器能够在编译、链接以及代码生成的各个阶段忽略语言特性，进行全面优化分析。LLVM的各种pass都是作用在LLVM IR上的，通常设计一门语言就是生成一个语言的编译器前端Clang即可。</p><p>LLVM IR三种表示形式：</p><ul><li><p>内存中的表示形式，如BasicBlock，Instruction这种cpp类；</p></li><li><p>bitcode形式，这是序列化的二进制表示形式</p></li><li><p>LLVM汇编文件形式，也是序列化的表达形式。</p></li></ul><p>IR表达：</p><ul><li>Module类，Module可以理解一个完整的编译单元。一般来说，这个编译单元就是个源码文件，如一个后缀为cpp的源文件</li><li>Function类，对一个函数单元，两种情况分别是函数定义和函数声明。</li><li>BasticBlock类，表示一个基本代码块（就是一段没有控制流逻辑的基本流程）</li><li>Instruction类，指令类就是LLVM中定义的基本操作。</li></ul><h2 id="控制流程图"><a href="#控制流程图" class="headerlink" title="控制流程图"></a>控制流程图</h2><p>在LLVM的编译和优化过程中，控制流图用来描述函数或程序的执行顺序和控制流结构。它帮助LLVM分析每个基本块（Basic Block）之间的跳转关系，从而进行各种优化，如死代码消除、循环展开、常量传播等。</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = foo(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result:%d\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编译器生成LLVM IR</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -emit-llvm program.c -o program.ll</span><br></pre></td></tr></table></figure><p><code>-S</code> 选项表示编译为汇编语言（但这里是LLVM IR汇编格式）。</p><p><code>-emit-llvm</code> 告诉 <code>clang</code> 生成LLVM IR，而不是机器代码。</p><p><code>program.c</code> 是你编写的C源代码文件。</p><p><code>program.ll</code> 是输出的LLVM IR文件。</p><ol start="2"><li>使用llvm-opt 工具查看LLVM IR 控制流的结构图(每个版本的都不一样,使用的是LLVM19.1.4)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opt --dot-regions program.ll</span><br><span class="line"></span><br><span class="line">dot -Tpng program.dot -o program.png</span><br></pre></td></tr></table></figure><blockquote><p>LLVM19.1.4的opt工具是有问题的，生成多个dot图形文件时候都报错，这版的开发工具并不完善。唯一不报错的就是–dot-regions 选项了</p></blockquote><h2 id="中间优化遍"><a href="#中间优化遍" class="headerlink" title="中间优化遍"></a>中间优化遍</h2><p>目录：<code>llvm-project/llvm/lib/Transforms/</code></p><ul><li>Analysis Passes</li><li>Transform Passes</li><li>Unility Passes</li></ul><p><a href="https://llvm.org/docs/Passes.html">https://llvm.org/docs/Passes.html</a></p><h3 id="Pass管理器"><a href="#Pass管理器" class="headerlink" title="Pass管理器"></a>Pass管理器</h3><p><a href="https://llvm.org/docs/NewPassManager.html">https://llvm.org/docs/NewPassManager.html</a></p><h1 id="LLVM后端"><a href="#LLVM后端" class="headerlink" title="LLVM后端"></a>LLVM后端</h1><p>目录位置：<code>llvm-project/llvm/lib/Target/</code></p><p>LLVM后端主要功能是代码生成，所以也叫代码生成器，负责将LLVM IR 转换特定目标架构的机器代码。</p><p>用于实现本机代码生成的各个阶段的目标无关算法。此代码位于lib&#x2F;CodeGen中。</p><p>目标独立JIT组件。LLVM JIT完全独立于目标。</p><p>在代码生成过程中，LLVM 后端会根据目标硬件平台的特性和要求，将 LLVM IR 转换为适合该平台的机器码或汇编语言。这个过程涉及到指令选择（Instruction Selection）、寄存器分配（Register Allocation）、指令调度（Instruction Scheduling）等关键步骤，以确保生成的目标代码在目标平台上能够高效运行。</p><h2 id="LLVM-后端-Pass"><a href="#LLVM-后端-Pass" class="headerlink" title="LLVM 后端 Pass"></a>LLVM 后端 Pass</h2><p>整个后端流水线涉及到四种不同层次的指令表示，包括：</p><ul><li>内存中的 LLVM IR：LLVM 中间表现形式，提供了高级抽象的表示，用于描述程序的指令和数据流。</li><li>SelectionDAG 节点：在编译优化阶段生成的一种抽象的数据结构，用以表示程序的计算过程，帮助优化器进行高效的指令选择和调度。</li><li>Machinelnstr：机器相关的指令格式，用于描述特定目标架构下的指令集和操作码。</li><li>MCInst：机器指令，是具体的目标代码表示，包含了特定架构下的二进制编码指令。</li></ul><p>不是重点操作目标，详情请看<a href="https://www.cnblogs.com/ZOMI/articles/18558930">【AI系统】LLVM 后端代码生成 - ZOMI酱酱 - 博客园</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>前端阶段</li></ol><ul><li>词法分析（Lexical Analysis）：源代码被分解为词法单元，如标识符、关键字和常量。</li><li>语法分析（Syntax Analysis）：词法单元被组织成语法结构，构建抽象语法树（AST）。</li><li>语义分析（Semantic Analysis）：AST 被分析以确保语义的正确性和一致性。</li></ul><ol><li>中间表示（IR）阶段</li></ol><ul><li>将 AST 转化为中间表示（IR），采用 SSA 形式的三地址指令表示代码结构。</li><li>通过多段 pass 进行代码优化，包括常量传播、死代码消除、循环优化等，以提高代码性能和效率。</li><li>IR 进一步转化为 DAG 图，其中每个节点代表一个指令，边表示数据流动。</li></ul><ol><li>后端阶段</li></ol><ul><li>指令选择（Instruction Selection）：根据目标平台特性选择合适的指令。</li><li>寄存器分配（Register Allocation）：分配寄存器以最大程度减少内存访问。</li><li>指令调度（Instruction Scheduling）：优化指令执行顺序以减少延迟。</li></ul><p>最终生成目标代码，用于目标平台的执行。</p><p>Pass 管理：</p><p>在编译器的每个模块和 Pass 均可通过 Pass manager 进行管理，可以动态添加、删除或调整 Pass 来优化编译过程中的各个阶段。</p><h1 id="RVV实现推论"><a href="#RVV实现推论" class="headerlink" title="RVV实现推论"></a>RVV实现推论</h1><p>要将通过 <code>clang</code> 编译生成的 C 语言 IR 转换为 MLIR，并使用自定义方言对其进行优化，整个流程大致可以分为以下几步：</p><ol><li><strong>使用 Clang 编译生成 IR</strong>：将 C 语言代码通过 <code>clang</code> 编译为 LLVM IR。</li><li><strong>将 LLVM IR 转换为 MLIR IR</strong>：使用 MLIR 提供的工具将 LLVM IR 转换为 MLIR IR。</li><li><strong>定义自定义方言及操作</strong>：在 MLIR 中定义新的方言及操作，例如 RISC-V 矢量扩展。</li><li><strong>编写优化 Pass</strong>：针对自定义方言编写优化 Pass。</li><li><strong>应用优化 Pass 并生成新的 IR</strong>：在 MLIR 中应用优化 Pass，将生成的 IR 进行优化。</li></ol><h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><h4 id="1-使用-Clang-编译生成-IR"><a href="#1-使用-Clang-编译生成-IR" class="headerlink" title="1. 使用 Clang 编译生成 IR"></a>1. 使用 Clang 编译生成 IR</h4><p>首先，你需要将 C 语言源代码编译成 LLVM IR，可以使用 <code>clang</code> 工具链中的 <code>-S</code> 和 <code>-emit-llvm</code> 标志来实现这一目标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">clang -S -emit-llvm input.c -o input.ll</span><br></pre></td></tr></table></figure><p>这会将 C 语言源文件 <code>input.c</code> 编译成 LLVM IR 文件 <code>input.ll</code>。</p><h4 id="2-将-LLVM-IR-转换为-MLIR-IR"><a href="#2-将-LLVM-IR-转换为-MLIR-IR" class="headerlink" title="2. 将 LLVM IR 转换为 MLIR IR"></a>2. 将 LLVM IR 转换为 MLIR IR</h4><p>在 MLIR 中，我们通常使用 <code>mlir-translate</code> 工具来将 LLVM IR 转换为 MLIR IR。你可以运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">mlir-translate --mlir-to-llvmir input.ll -o input.mlir</span><br></pre></td></tr></table></figure><p>该命令将 LLVM IR 文件 <code>input.ll</code> 转换为 MLIR 格式，并生成 <code>input.mlir</code> 文件。</p><h4 id="3-定义自定义方言及操作"><a href="#3-定义自定义方言及操作" class="headerlink" title="3. 定义自定义方言及操作"></a>3. 定义自定义方言及操作</h4><p>接下来，您需要在 MLIR 中定义自定义方言及相关操作。假设您已经定义了一个 <code>Simple</code> 方言，它包括一个加法操作 <code>simple.add</code>，您可以在 <code>SimpleDialect</code> 中定义操作并实现方言。</p><p>在方言中定义操作的一般步骤如下：</p><ul><li><strong>定义方言</strong>（例如：<code>SimpleDialect</code>）</li><li><strong>定义操作</strong>（例如：<code>simple.add</code>）</li></ul><p><strong>方言定义（SimpleDialect.h）</strong>：</p><p><strong>操作定义（SimpleOps.h）</strong>：</p><h4 id="4-编写优化-Pass"><a href="#4-编写优化-Pass" class="headerlink" title="4. 编写优化 Pass"></a>4. 编写优化 Pass</h4><p>在 MLIR 中，您可以编写 Pass 来对 IR 进行优化。假设您想对 <code>simple.add</code> 操作执行某些优化（例如，常量折叠），您可以编写一个 Pass 来执行优化。</p><p>这个 Pass 会遍历函数中的所有操作，查找 <code>simple.add</code> 操作，并执行常量折叠优化。</p><h4 id="5-应用优化-Pass-并生成新的-IR"><a href="#5-应用优化-Pass-并生成新的-IR" class="headerlink" title="5. 应用优化 Pass 并生成新的 IR"></a>5. 应用优化 Pass 并生成新的 IR</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mlir-opt input.mlir -pass-name=optimize-add</span><br></pre></td></tr></table></figure><p>在执行优化 Pass 后，您将得到经过优化的 IR。你可以通过命令行进一步将其转换为 LLVM IR 或者机器码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mlir-translate --mlir-to-llvmir input.mlir -o optimized_input.ll</span><br></pre></td></tr></table></figure><p><img src="https://img.picgo.net/2024/12/03/.drawioa1be169a8f70e9e1.png" alt="未命名绘图.drawio"></p>]]></content>
      
      
      
        <tags>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用回顾</title>
      <link href="/2024/11/01/title%EF%BC%9Agit%E4%BD%BF%E7%94%A8%E5%9B%9E%E9%A1%BE/"/>
      <url>/2024/11/01/title%EF%BC%9Agit%E4%BD%BF%E7%94%A8%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="使用ssh建立git仓库连接"><a href="#使用ssh建立git仓库连接" class="headerlink" title="使用ssh建立git仓库连接"></a>使用ssh建立git仓库连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;github@com&quot;</span><br><span class="line">cat ~/.ssh/id_isa.pub</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">内容拷贝到github的ssh设置里</span></span><br></pre></td></tr></table></figure><h2 id="将本地与远程建立连接"><a href="#将本地与远程建立连接" class="headerlink" title="将本地与远程建立连接"></a>将本地与远程建立连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:..... .git</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#初始化</span></span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#获取远程的分支</span></span></span><br><span class="line">git fetch origin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#切换分支</span></span></span><br><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#添加内容</span></span></span><br><span class="line">git add file</span><br><span class="line">git commit -m &quot;information&quot;</span><br><span class="line">git push orgin &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#创立分支</span></span></span><br><span class="line">git checkout -b &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#上传分支</span></span></span><br><span class="line">git push -u origin &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#合并分支</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#获取最新的分支和改变</span></span></span><br><span class="line">git fetch origin</span><br><span class="line">git checkout main</span><br><span class="line">git merge origin/feature-branch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#删除分支</span></span></span><br><span class="line">git branch -d &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#验证</span></span></span><br><span class="line">git branch -r</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泰山派（瑞芯微SDK编译烧录）</title>
      <link href="/2024/07/08/2024-7-8-%E6%B3%B0%E5%B1%B1%E6%B4%BE%EF%BC%88%E7%91%9E%E8%8A%AF%E5%BE%AESDK%E7%BC%96%E8%AF%91%E7%83%A7%E5%BD%95%EF%BC%89/"/>
      <url>/2024/07/08/2024-7-8-%E6%B3%B0%E5%B1%B1%E6%B4%BE%EF%BC%88%E7%91%9E%E8%8A%AF%E5%BE%AESDK%E7%BC%96%E8%AF%91%E7%83%A7%E5%BD%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="瑞芯微RK3566"><a href="#瑞芯微RK3566" class="headerlink" title="瑞芯微RK3566"></a>瑞芯微RK3566</h1><p><a href="https://so.szlcsc.com/global.html?k=LCTSPI-RK3566&hot-key=AD7606BSTZ">立创·泰山派开发板</a>主控采用Rockchip（瑞芯微）的中高端AIOT芯片<a href="https://item.szlcsc.com/3329057.html">RK3566</a> ，4核Cortex-A55的64位CPU，主频高达1.8GHz;集成ARM Mali-G52 GPU，支持4K 60fps解码，1080P 60fps编码，支持8MSP和HDR;内置1Tops算力的AI加速器NPU。</p><h3 id="编译SDK"><a href="#编译SDK" class="headerlink" title="编译SDK"></a>编译SDK</h3><ol><li><p>下载板子的SDK，并解压SDK的压缩包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvzf tspi_linux_sdk_repo_20240131.tar.gz</span><br><span class="line">#提取代码repo的代码</span><br><span class="line">$ .repo/repo/repo sync -l -j88</span><br></pre></td></tr></table></figure></li><li><p>安装配套工具</p><p>安装git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git -y</span><br></pre></td></tr></table></figure><p>安装repo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install repo -y</span><br></pre></td></tr></table></figure><p>安装python2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python2.7</span><br></pre></td></tr></table></figure><p>安装python3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3</span><br></pre></td></tr></table></figure></li><li><p>安装buildroot，这两个压缩包放入一个文件夹中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf buildroot_dl_4c7c9df616fb.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>安装编译工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git ssh make gcc libssl-dev liblz4-tool expect g++ patchelf chrpath gawk texinfo chrpath diffstat binfmt-support qemu-user-static live-build bison flex fakeroot cmake gcc-multilib g++-multilib unzip device-tree-compiler ncurses-dev</span><br></pre></td></tr></table></figure></li><li><p>板级配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh lunch</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/image.png"></p></li><li><p>编译buildroot系统</p><p>选择buildroot 注意每次关闭窗口以后要重新运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export RK_ROOTFS_SYSTEM=buildroot</span><br></pre></td></tr></table></figure><p>运行自动全编译命令，注意：只编译<code>（u-Boot，kernel，Rootfs，Recovery）</code>编译完成以后需要再执⾏<code>./mkfirmware.sh </code>进⾏固件打包，与<code>./build.sh updateimg</code>生成镜像，很多小伙伴出现编译完成但烧录镜像不对都是因为没有执行这两个命令导致的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh all  </span><br></pre></td></tr></table></figure><p>电源选择，选择不对会编译报错，这里大家记住除了VCCIO4和6选1.8V其他都选3V3，如果没有弹电源选择框则需要安装<code>sudo apt install whiptail</code>后在重新编译。</p></li></ol><p>编译成功后出现以下：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/output.png"></p><h3 id="烧录镜像"><a href="#烧录镜像" class="headerlink" title="烧录镜像"></a>烧录镜像</h3><blockquote><p>烧录固件和镜像需要在开发板处于loader模式下才行。</p></blockquote><p>打包固件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mkfirmware.sh</span><br></pre></td></tr></table></figure><p>在目录下rockdev目录下可以找到以下镜像：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-09%20205015.png"></p><p>  使用命令将多个镜像变成一个可烧录的镜像update.img</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh updateimg</span><br></pre></td></tr></table></figure><p>之后将update.img文件移入windows下，使用瑞芯微的下载工具，在升级固件中进行选择烧录。</p><p>或者</p><p>在sdk目录下使用脚本进行下载，这样只用在Ubuntu下操作就行了。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/a06214b7afeb436d99c18b1a0fa29ece.png"></p><h2 id="Ubuntu系统编译"><a href="#Ubuntu系统编译" class="headerlink" title="Ubuntu系统编译"></a>Ubuntu系统编译</h2><p>安装 qemu在 Linux PC 主机上安装模拟器：</p><p>下载和解压 ubuntu-core，选择下载 ubuntu-base-18.04.5-base-arm64.tar.gz 。<br>下载完之后，创建临时文件夹并解压根文件系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu-user-static</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xpf ubuntu-base-18.04.5-basearm64.tar.gz -C temp/</span><br></pre></td></tr></table></figure><p>修改根文件系统，</p><p>进入根文件系统进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -b /etc/resolv.conf temp/etc/resolv.conf</span><br><span class="line">cp /usr/bin/qemu-aarch64-statictemp/usr/bin/</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">vim rootfs-mount.sh</span><br><span class="line">\#!/bin/bash</span><br><span class="line">function mnt() &#123;</span><br><span class="line">echo &quot;MOUNTING&quot;</span><br><span class="line">sudo mount -t proc /proc $&#123;2&#125;/proc</span><br><span class="line">sudo mount -t sysfs /sys $&#123;2&#125;/sys</span><br><span class="line">sudo mount -o bind /dev $&#123;2&#125;/dev</span><br><span class="line">sudo chroot $&#123;2&#125;</span><br><span class="line">&#125; f</span><br><span class="line">unction umnt() &#123;</span><br><span class="line">echo &quot;UNMOUNTING&quot;</span><br><span class="line">sudo umount $&#123;2&#125;/proc</span><br><span class="line">sudo umount $&#123;2&#125;/sys</span><br><span class="line">sudo umount $&#123;2&#125;/dev</span><br><span class="line">&#125; i</span><br><span class="line">f [ &quot;$1&quot; == &quot;-m&quot; ] &amp;&amp; [ -n &quot;$2&quot; ] ;</span><br><span class="line">then</span><br><span class="line">mnt $1 $2</span><br><span class="line">elif [ &quot;$1&quot; == &quot;-u&quot; ] &amp;&amp; [ -n &quot;$2&quot; ];</span><br><span class="line">then</span><br><span class="line">umnt $1 $2</span><br><span class="line">else</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;Either 1&#x27;st, 2&#x27;nd or both parameters were missing&quot;</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;1&#x27;st parameter can be one of these: -m(mount) OR -u(umount)&quot;</span><br><span class="line">echo &quot;2&#x27;nd parameter is the full path of rootfs directory(with trailing &#x27;/&#x27;)&quot;</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;For example: ch-mount -m /media/sdcard/&quot;</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo 1st parameter : $&#123;1&#125;</span><br><span class="line">echo 2nd parameter : $&#123;2&#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>添加权限进入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x rootfs-mount.sh</span><br><span class="line">sudo bash rootfs-mount.sh -m temp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt upgrade</span><br></pre></td></tr></table></figure><p><strong>预制自己需要的功能</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@filex-virtual-machine:/# apt install vim</span><br><span class="line">root@filex-virtual-machine:/# apt install git</span><br><span class="line">apt-get install ssh</span><br><span class="line">apt-get install ethtool</span><br><span class="line">apt-get install rsyslog</span><br><span class="line">apt-get install bash-completion</span><br><span class="line">apt-get install htop</span><br><span class="line">apt-get install net-tools</span><br><span class="line">apt-get install wireless-tools</span><br><span class="line">apt-get install network-manager</span><br><span class="line">apt-get install iputils-ping</span><br><span class="line">--------下面建议必须装---------</span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">语言包</span></span><br><span class="line">apt-get install locales</span><br><span class="line">dpkg-reconfigure locales</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个必须要否则无法生成/etc/network/interfaces配网文件</span></span><br><span class="line">apt-get install ifupdown</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ping</span></span><br><span class="line">apt-get install inetutils-ping</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">串口</span></span><br><span class="line">apt-get install cutecom</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">录音</span></span><br><span class="line">apt-get install audacity</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">摄像头</span></span><br><span class="line">apt-get install v4l-utils</span><br><span class="line">apt-get install cheese</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">浏览器</span></span><br><span class="line">apt-get install chromium-browser</span><br><span class="line">wifi</span><br><span class="line">apt-get install wpasupplicant</span><br></pre></td></tr></table></figure><p><strong>安装界面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install xubuntu-desktop</span><br></pre></td></tr></table></figure><p><strong>配置网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/network/interfaces</span><br><span class="line">source-directory /etc/network/interfaces.d</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以太网</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">wifi</span></span><br><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br><span class="line">wpa-conf /etc/wpa_config.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/resolv.conf</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>添加用户及设置密码</p><p>添加用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -s &#x27;/bin/bash&#x27; -m -G adm,sudo taishan</span><br></pre></td></tr></table></figure><p>给用户设置密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd taishan</span><br></pre></td></tr></table></figure><p>给root用户设置密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd root</span><br></pre></td></tr></table></figure><p>修改完自己的根文件系统就可以退出了。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS2</title>
      <link href="/2024/05/22/2024-5-22-ROS2/"/>
      <url>/2024/05/22/2024-5-22-ROS2/</url>
      
        <content type="html"><![CDATA[<p>ROS2（Robot Operating System 2）是一个用于机器人和自动化系统开发的开源软件平台。</p><h4 id="ROS2的系统架构"><a href="#ROS2的系统架构" class="headerlink" title="ROS2的系统架构"></a>ROS2的系统架构</h4><p><a href="https://postimg.cc/Lh2v1t9Q"><img src="https://i.postimg.cc/L4ZWGDrS/2023-12-20-133615.png" alt="2023-12-20-133615.png"></a></p><p>OS层</p><p>OS层，在ROS2中可以构建在linux上，也可以构建在其它系统上，甚至是没有操作系统的裸机。</p><p>中间层</p><p>ROS1的通信系统基于TCPROS&#x2F;UDPROS，而ROS2的通信系统基于DDS。DDS是一种分布式实时系统中数据发布&#x2F;订阅的标准解决方案。</p><p>应用层</p><p>ROS1依赖于ROS Master，而在ROS2中，节点之间使用一种称为“Discovery”的发现机制来帮助彼此建立连接。</p><h4 id="DDS"><a href="#DDS" class="headerlink" title="DDS"></a>DDS</h4><p>DDS是“Data Distribution Service”的缩写，是一种面向实时和嵌入式系统的标准化、可互操作的消息传递协议。DDS旨在实现在分布式环境中高效且可扩展地交换数据。它通常用于需要高性能、低延迟和可靠性的系统。它提供了一个中间件层，抽象了分布式通信的复杂性，使开发人员更容易构建可扩展和可靠的系统。</p><p>DDS的主要特点包括：</p><ol><li><strong>发布-订阅模型：</strong><ol><li>DDS采用发布-订阅通信模型。数据生产者（发布者）发布信息，数据消费者（订阅者）接收他们感兴趣的信息。</li></ol></li><li><strong>分散式架构：</strong><ol><li>DDS设计为在分散式环境中工作，允许可扩展和容错的系统。没有中央代理，数据直接在发布者和订阅者之间交换。</li></ol></li><li><strong>实时和服务质量（QoS）：</strong><ol><li>DDS支持实时通信，并提供丰富的服务质量（QoS）参数。这些参数允许微调通信特性，如可靠性、持久性和延迟。</li></ol></li><li><strong>动态发现：</strong><ol><li>DDS支持发布者和订阅者的动态发现。这意味着实体可以加入或离开网络，系统会动态地适应这些变化。</li></ol></li><li><strong>数据中心：</strong><ol><li>DDS以数据为中心，侧重于高效交换数据，而不关注底层网络或通信基础设施的详细信息。</li></ol></li><li><strong>语言中立：</strong><ol><li>DDS被设计为语言中立，允许使用不同编程语言编写的应用程序无缝通信。</li></ol></li></ol><blockquote><p>ROS 2中常见的几种通信方式：</p><ol><li><strong>话题（Topics）</strong>：<ol><li>话题是ROS中最常用的通信方式之一。它允许节点以发布者-订阅者的模式进行消息传递。一个节点可以发布消息到一个话题，而其他节点则可以订阅该话题以接收消息。</li></ol></li><li><strong>服务（Services）</strong>：<ol><li>服务是一种ROS中的双向通信方式，它允许节点之间进行请求-响应式的通信。一个节点可以提供一个服务，而其他节点则可以调用该服务来发送请求并接收响应。</li></ol></li><li><strong>参数（Parameters）</strong>：<ol><li>参数是用于配置节点行为和功能的数据。ROS 2中的参数服务器允许节点动态地设置和获取参数值，以调整节点的行为。参数可以在运行时进行更改，并且可以通过参数事件来监视参数的变化。</li></ol></li><li><strong>行为（Actions）</strong>：<ol><li>行为是ROS 2中的高级通信机制，它允许节点执行复杂的、长时间运行的任务。行为通常用于需要一系列连续操作的场景，例如导航、操纵机器人臂等。</li></ol></li></ol></blockquote><h2 id="ros2下编译一个hello-world程序"><a href="#ros2下编译一个hello-world程序" class="headerlink" title="ros2下编译一个hello world程序"></a>ros2下编译一个hello world程序</h2><p>创建工作空间，在终端上创建一个工程文件夹名为hello_ws，并在src目录下创建一个ros包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p hello_ws/src</span><br><span class="line"><span class="built_in">cd</span> hello_ws</span><br><span class="line">colcon build</span><br><span class="line"><span class="built_in">cd</span> /src</span><br><span class="line">ros2 pkg create hello --build-type ament_cmake --dependencies rclcpp </span><br><span class="line"><span class="built_in">cd</span> ~/hello_ws/src/hello_world/src</span><br><span class="line">vi helloworld.cpp</span><br></pre></td></tr></table></figure><p>编辑<code>helloworld.cpp</code>文件，并添加以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rclcpp/rclcpp.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc ,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">        <span class="keyword">auto</span> node = rclcpp::Node :: <span class="built_in">make_shared</span>(<span class="string">&quot;hello_world_node&quot;</span>);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(node-&gt;<span class="built_in">get_logger</span>(),<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt文件加入以下内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello_node src/helloworld.cpp)</span><br><span class="line">ament_target_dependencies(hello_node rclcpp)</span><br><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  hello_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最后，编译ROS包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/hello_ws</span><br><span class="line">colcon build <span class="comment">#编译环境</span></span><br><span class="line"><span class="built_in">source</span> install/setup.bash <span class="comment">#构建环境</span></span><br><span class="line">ros2 run hello helloworld</span><br></pre></td></tr></table></figure><p>现在，就可以在ros2环境下打印出hello world。</p><h2 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h2><h3 id="面向对象的方式编写ROS2节点"><a href="#面向对象的方式编写ROS2节点" class="headerlink" title="面向对象的方式编写ROS2节点"></a>面向对象的方式编写ROS2节点</h3><p>将之前的的程序代码进行改写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;rclcpp/rclcpp.hpp&quot;</span><br><span class="line"></span><br><span class="line">class Node1 : public rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">            Node1() : Node(&quot;node1&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                         RCLCPP_INFO(this-&gt;get_logger(),&quot;上班了&quot;);  </span><br><span class="line">            &#125;</span><br><span class="line">    private:</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    rclcpp::init(argc, argv);</span><br><span class="line">    //产生一个Node1节点</span><br><span class="line">    auto node = std::make_shared&lt;Node1&gt;();</span><br><span class="line">    //运行节点，并检测退出信号</span><br><span class="line">    rclcpp::spin(node);</span><br><span class="line">    rclcpp::shutdown();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ros2节点发现与多机通信"><a href="#ros2节点发现与多机通信" class="headerlink" title="ros2节点发现与多机通信"></a>ros2节点发现与多机通信</h2><p>如其他地方所解释的，ROS 2用于通讯的默认中间件是DDS。在DDS中，不同逻辑网络共享物理网络的主要机制称为域(Domain) ID。同一域上的ROS 2节点可以自由地相互发现并发送消息，而不同域上的ROS 2节点则不能。所有ROS 2节点默认使用域ID为0。为了避免在同一网络上运行ROS 2的不同计算机组之间互相干扰，应为每组设置不同的域ID。</p><blockquote><p><strong>选择域ID短版本</strong>：</p><ul><li>使用命令行界面（CLI）时，可以直接指定短域名称，例如<code>ros2 param set</code>。</li><li>短域名称较为简洁，适合在命令行中快速使用。</li><li>不需要指定完整的命名空间路径，只需提供短域名称即可。</li><li>例如，假设节点名为<code>my_node</code>，参数名为<code>my_parameter</code>，则短版本命令可以是<code>ros2 param set my_node my_parameter 42</code>。</li><li></li><li><strong>选择域ID长版本</strong>：</li><li></li><li>使用编程接口时，需要提供完整的参数名称，包括节点名称和参数名称。</li><li>长版本的参数名称包含节点的全名（包括命名空间），以及参数的名称，用斜杠（<code>/</code>）分隔。</li><li>长版本的参数名称在编程接口中更为直观，方便程序员进行参数操作。</li><li>例如，假设节点名为<code>my_node</code>，参数名为<code>my_parameter</code>，则长版本参数名称为<code>/my_node/my_parameter</code>。</li></ul></blockquote><p>默认情况下，linux内核使用端口32768-60999作为临时端口。这意味着域ID 0-101 和 215-232 可以安全使用，而不会与临时端口发生冲突。临时端口范围可在Linux中通过在 <code>/proc/sys/net/ipv4/ip_local_port_range</code> 中设置自定义值进行配置。如果使用自定义临时端口范围，则可能需要相应地调整上述数字</p><h2 id="ros2-消息"><a href="#ros2-消息" class="headerlink" title="ros2 消息"></a>ros2 消息</h2><p>整体上ros2和ros1的创建是差不多的。</p><p>首先是建立软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p work_ws/src</span><br><span class="line">cd work_ws</span><br><span class="line">colcon build</span><br><span class="line">cd src</span><br><span class="line">ros2 pkg create msg_pkg --build-type ament_cmake --dependencies rclcpp std_msgs</span><br><span class="line">cd msg_pkg/msg</span><br></pre></td></tr></table></figure><p>编写字节的msg消息文件，例如Person.msg这里首字母要大写。</p><p>之后更改msg_pkg包中的CMakeLists.txt文件，加入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(builtin_interfaces REQUIRED) <span class="comment">#iron版本用不到builtin_interfaces包，rolling就需要这个包</span></span><br><span class="line"><span class="keyword">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="string">&quot;msg/Person.msg&quot;</span></span><br><span class="line">  DEPENDENCIES builtin_interfaces <span class="comment">#同上</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>之后更改msg_pkg包中的Package.xml文件，加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</span><br></pre></td></tr></table></figure><p>工作空间目录下进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br></pre></td></tr></table></figure><h2 id="ros2-话题"><a href="#ros2-话题" class="headerlink" title="ros2 话题"></a>ros2 话题</h2><p>跟ros1是一样的，一个节点发布数据到某个话题上，另一个节点就可以通过订阅话题拿到数据，还可以是<code>1对n</code>,<code>n对1</code>,<code>n对n</code>的，或者自己发自己接收。</p><h3 id="ros2下话题发布与订阅"><a href="#ros2下话题发布与订阅" class="headerlink" title="ros2下话题发布与订阅"></a>ros2下话题发布与订阅</h3><p>接着前面的工程文件夹进行编写</p><p>发布文件名字：topic.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopicPublisher01</span> : <span class="keyword">public</span> rclcpp :: Node</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                <span class="built_in">TopicPublisher01</span>() : <span class="built_in">Node</span>(<span class="string">&quot;publisher_node&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),  <span class="string">&quot;启动pulisher&quot;</span>);</span><br><span class="line">                        publisher = <span class="keyword">this</span>-&gt; <span class="built_in">create_publisher</span>&lt;std_msgs::msg::String&gt;(<span class="string">&quot;/chatter&quot;</span>,<span class="number">10</span>);</span><br><span class="line">                        timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>), std::<span class="built_in">bind</span>(&amp;TopicPublisher01::publish_message, <span class="keyword">this</span>));</span><br><span class="line">                        counter_ = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="function"><span class="type">void</span> <span class="title">publish_message</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                    </span>&#123;</span><br><span class="line">                        <span class="keyword">auto</span> message = std_msgs::msg::<span class="built_in">String</span>();</span><br><span class="line">                        message.data = <span class="string">&quot;Hello ROS 2 &quot;</span> + std::<span class="built_in">to_string</span>(counter_);</span><br><span class="line">                        publisher-&gt;<span class="built_in">publish</span>(message);</span><br><span class="line">                        counter_++;</span><br><span class="line">                        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Publishing: &#x27;%s&#x27;&quot;</span>, message.data.<span class="built_in">c_str</span>());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr publisher;</span><br><span class="line">            rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">            <span class="type">size_t</span> counter_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">        <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;TopicPublisher01&gt;();</span><br><span class="line">        rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">        rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅文件名字subscribe</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">message_callback</span><span class="params">(<span class="type">const</span> std_msgs::msg::String::SharedPtr msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;subscriber_node&quot;</span>), <span class="string">&quot;Received message: &#x27;%s&#x27;&quot;</span>, msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = rclcpp::Node::<span class="built_in">make_shared</span>(<span class="string">&quot;subscriber_node&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> subscription = node-&gt;<span class="built_in">create_subscription</span>&lt;std_msgs::msg::String&gt;(<span class="string">&quot;/chatter&quot;</span>, <span class="number">10</span>, message_callback);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">project</span>(example_topic)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CMAKE_COMPILER_IS_GNUCXX <span class="keyword">OR</span> CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;Clang&quot;</span>)</span><br><span class="line">  <span class="keyword">add_compile_options</span>(-Wall -Wextra -Wpedantic)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># find dependencies</span></span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rclcpp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(std_msgs REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_TESTING)</span><br><span class="line">  <span class="keyword">find_package</span>(ament_lint_auto REQUIRED)</span><br><span class="line">  <span class="comment"># the following line skips the linter which checks for copyrights</span></span><br><span class="line">  <span class="comment"># comment the line when a copyright and license is added to all source files</span></span><br><span class="line">  <span class="keyword">set</span>(ament_cmake_copyright_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line">  <span class="comment"># the following line skips cpplint (only works in a git repo)</span></span><br><span class="line">  <span class="comment"># comment the line when this package is in a git repo and when</span></span><br><span class="line">  <span class="comment"># a copyright and license is added to all source files</span></span><br><span class="line">  <span class="keyword">set</span>(ament_cmake_cpplint_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line">  ament_lint_auto_find_test_dependencies()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">ament_package()</span><br><span class="line"><span class="keyword">add_executable</span>(topic_publish src/topic.cpp)</span><br><span class="line">ament_target_dependencies(topic_publish rclcpp std_msgs)</span><br><span class="line"><span class="keyword">add_executable</span>(topic_subscribe src/subscriber.cpp)</span><br><span class="line">ament_target_dependencies(topic_subscribe rclcpp std_msgs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">        topic_publish</span><br><span class="line">        topic_subscribe</span><br><span class="line">        DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>编译后两个终端进行发布订阅：</p><p><img src="https://img2.imgtp.com/2024/04/02/vJ0RyB5d.png" alt="ros.png"></p><h2 id="ROS2实战（1个消息包1个发布订阅包）"><a href="#ROS2实战（1个消息包1个发布订阅包）" class="headerlink" title="ROS2实战（1个消息包1个发布订阅包）"></a>ROS2实战（1个消息包1个发布订阅包）</h2><p>1个软件包存储一个人的信息（名字和年龄），1个软件包负责发布和订阅这个消息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p work_ws/src</span><br><span class="line">colcon build</span><br><span class="line">cd src</span><br><span class="line">ros2 pkg create msg_pkg --build-type ament_cmake --dependencies rclcpp std_msgs</span><br><span class="line">cd msg_pkg/msg</span><br><span class="line">vi Person.msg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##</span></span></span><br><span class="line">//文件内容为</span><br><span class="line">string name</span><br><span class="line">int32 age</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##</span></span></span><br></pre></td></tr></table></figure><p>之后更改msg_pkg包中的CMakeLists.txt文件，加入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(builtin_interfaces REQUIRED) <span class="comment">#iron版本用不到builtin_interfaces包，rolling就需要这个包</span></span><br><span class="line"><span class="keyword">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="string">&quot;msg/Person.msg&quot;</span></span><br><span class="line">  DEPENDENCIES builtin_interfaces <span class="comment">#同上</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>之后更改msg_pkg包中的Package.xml文件，加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后建立第二个软件包来发布订阅这个消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/work_ws/src/</span><br><span class="line">ros2 pkg create publish_subscribe --build-type ament_cmake --dependencies rclcpp std_msgs</span><br><span class="line">cd src</span><br></pre></td></tr></table></figure><p>编写发布文件publisher.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span> <span class="comment">// 包含 ROS 2 的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;msg_pkg/msg/person.hpp&gt;</span> <span class="comment">// 包含自定义消息头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals; <span class="comment">// 使用 C++ 标准库中的 chrono_literals 命名空间，用于处理时间相关操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv); <span class="comment">// 初始化 ROS 2 节点</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;rclcpp::Node&gt;(<span class="string">&quot;person_publisher&quot;</span>); <span class="comment">// 创建 ROS 2 节点</span></span><br><span class="line">    <span class="keyword">auto</span> publisher = node-&gt;<span class="built_in">create_publisher</span>&lt;msg_pkg::msg::Person&gt;(<span class="string">&quot;person_topic&quot;</span>, <span class="number">10</span>); <span class="comment">// 创建发布者，发布自定义消息类型为 Person 的消息，话题名称为 &quot;person_topic&quot;，队列大小为 10</span></span><br><span class="line">    <span class="keyword">auto</span> message = std::<span class="built_in">make_shared</span>&lt;msg_pkg::msg::Person&gt;(); <span class="comment">// 创建消息对象，类型为 Person</span></span><br><span class="line"></span><br><span class="line">    message-&gt;name = <span class="string">&quot;john&quot;</span>; <span class="comment">// 设置消息中的 name 字段为 &quot;john&quot;</span></span><br><span class="line">    message-&gt;age = <span class="number">30</span>; <span class="comment">// 设置消息中的 age 字段为 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rclcpp::<span class="built_in">ok</span>()) &#123; <span class="comment">// 当 ROS 2 节点处于运行状态时</span></span><br><span class="line">        publisher-&gt;<span class="built_in">publish</span>(*message); <span class="comment">// 发布消息</span></span><br><span class="line">        rclcpp::<span class="built_in">spin_some</span>(node); <span class="comment">// 处理回调函数，处理消息</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s); <span class="comment">// 休眠 1 秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>(); <span class="comment">// 关闭 ROS 2 节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0 表示正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写订阅文件subscribe.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span> <span class="comment">// 包含 ROS 2 的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg_pkg/msg/person.hpp&quot;</span> <span class="comment">// 包含自定义消息头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">personCallback</span><span class="params">(<span class="type">const</span> msg_pkg::msg::Person::SharedPtr msg)</span></span>; <span class="comment">// 声明消息回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv); <span class="comment">// 初始化 ROS 2 节点</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;rclcpp::Node&gt;(<span class="string">&quot;subscriber&quot;</span>); <span class="comment">// 创建 ROS 2 节点</span></span><br><span class="line">    <span class="keyword">auto</span> subscription = node-&gt;<span class="built_in">create_subscription</span>&lt;msg_pkg::msg::Person&gt;( <span class="comment">// 创建订阅者，订阅自定义消息类型为 Person 的消息，话题名称为 &quot;person_topic&quot;，队列大小为 10</span></span><br><span class="line">        <span class="string">&quot;person_topic&quot;</span>, <span class="number">10</span>, personCallback);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node); <span class="comment">// 进入循环，处理消息</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>(); <span class="comment">// 关闭 ROS 2 节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0 表示正常退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">personCallback</span><span class="params">(<span class="type">const</span> msg_pkg::msg::Person::SharedPtr msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Received person: %s, %d&quot;</span>, msg-&gt;name.<span class="built_in">c_str</span>(), msg-&gt;age); <span class="comment">// 打印接收到的消息内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后保存后，更改CMakeLists.txt文件，加入以下内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(msg_pkg REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(publisher src/publisher.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(subscriber src/subscribe.cpp)</span><br><span class="line"></span><br><span class="line">ament_target_dependencies(publisher rclcpp msg_pkg)</span><br><span class="line">ament_target_dependencies(subscriber rclcpp msg_pkg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install executables</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  publisher</span><br><span class="line">  subscriber</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br></pre></td></tr></table></figure><p>更改package.xml文件，加入以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>msg_pkg<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后在工作空间下进行编译</p><p><img src="https://img2.imgtp.com/2024/04/08/f4nv9AtB.png" alt="屏幕截图 2024-04-08 173928.png"></p><h2 id="ROS2服务"><a href="#ROS2服务" class="headerlink" title="ROS2服务"></a>ROS2服务</h2><p>首先创建一个工作空间，之后再src下创建一个装载srv消息的软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p service_ws/src</span><br><span class="line">cd service_ws</span><br><span class="line">colcon build</span><br><span class="line">cd src</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建软件包</span></span><br><span class="line">ros2 pkg create service_msgs --build-type ament_cmake --dependencies rclcpp std_msgs</span><br><span class="line">ros2 pkg create server_client --build-type ament_cmake --dependencies rclcpp std_msgs</span><br><span class="line">cd service_msgs</span><br><span class="line">mkdir srv</span><br><span class="line">cd srv</span><br><span class="line">vi Addtwo.srv</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编写msg的信息</span></span><br><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">退出后修改CMakeLists.txt文件加入</span></span><br><span class="line">find_package(rosidl_default_generators REQUIRED)</span><br><span class="line"><span class="meta prompt_">rosidl_generate_interfaces($</span><span class="language-bash">&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  &quot;srv/Addtwo.srv&quot;</span><br><span class="line">  DEPENDENCIES std_msgs</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同样也要修改package.xml文件，加入</span></span><br><span class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</span><br><span class="line">cd ~/service_ws/src/server-client/src</span><br></pre></td></tr></table></figure><p>编写服务器代码：server.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceServer01</span> : <span class="keyword">public</span> rclcpp::Node &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ServiceServer01</span>(std::string name) : <span class="built_in">Node</span>(name) &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;节点已启动：%s.&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;ServiceServer01&gt;(<span class="string">&quot;service_server_01&quot;</span>);</span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写客服端代码：client.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceClient01</span> : <span class="keyword">public</span> rclcpp::Node &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数,有一个参数为节点名称</span></span><br><span class="line">  <span class="built_in">ServiceClient01</span>(std::string name) : <span class="built_in">Node</span>(name) &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;节点已启动：%s.&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  <span class="comment">/*创建对应节点的共享指针对象*/</span></span><br><span class="line">  <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;ServiceClient01&gt;(<span class="string">&quot;service_client_01&quot;</span>);</span><br><span class="line">  <span class="comment">/* 运行节点，并检测退出信号*/</span></span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后编写包内的CMakeLists.txt文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">add_executable(service_client src/client.cpp)</span><br><span class="line">ament_target_dependencies(service_client rclcpp)</span><br><span class="line"></span><br><span class="line">add_executable(service_server src/server.cpp)</span><br><span class="line">ament_target_dependencies(service_server rclcpp)</span><br><span class="line"></span><br><span class="line">install(TARGETS</span><br><span class="line">  service_server</span><br><span class="line">  DESTINATION lib/$&#123;PROJECT_NAME&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">install(TARGETS</span><br><span class="line">  service_client</span><br><span class="line">  DESTINATION lib/$&#123;PROJECT_NAME&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>之后退出编译就成功了。</p><h3 id="服务软件包调用消息包"><a href="#服务软件包调用消息包" class="headerlink" title="服务软件包调用消息包"></a>服务软件包调用消息包</h3><p>在软件包中改写CMakeLists.txt文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#加入</span><br><span class="line">find_package(service_msgs REQUIRED)</span><br><span class="line">#改写</span><br><span class="line">add_executable(service_client src/client.cpp)</span><br><span class="line">ament_target_dependencies(service_client rclcpp service_msgs)</span><br><span class="line"></span><br><span class="line">add_executable(service_server src/service_server_01.cpp)</span><br><span class="line">ament_target_dependencies(service_server rclcpp service_msgs)</span><br></pre></td></tr></table></figure><p>packages.xml文件加入消息包进行依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;depend&gt;example_interfaces&lt;/depend&gt;</span><br></pre></td></tr></table></figure><p>在代码中加入头文件就能调用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;service_msgs/srv/addtwo.hpp&quot;</span><br></pre></td></tr></table></figure><h2 id="ROS2组件"><a href="#ROS2组件" class="headerlink" title="ROS2组件"></a>ROS2组件</h2><p>ROS 2中的组件（比如节点、插件等）可以被动态加载和卸载，这意味着它们可以在运行时进行加载，而无需重新编译整个系统。这种动态加载的机制使得ROS 2更加灵活，可以根据需要动态地修改系统的行为，而无需停机或重新启动。</p><p>组件的流程：</p><p><img src="https://img2.imgtp.com/2024/04/23/uDQE7jJw.png" alt="番茄工作法 1.png"></p><p>pluginlib是一个c + + 库，用于从ROS包中加载和卸载插件。插件是从运行时库加载的动态调用y可加载类 (即共享对象，动态调用y链接库)。使用pluginlib，不必将其应用程序与包含类的库显式链接-相反，pluginlib可以在任何时候打开包含导出类的库，而无需应用程序事先了解该库或包含类定义的头文件。插件可用于扩展&#x2F;修改应用程序行为，而无需应用程序源文件。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-iron-pluginlib</span><br></pre></td></tr></table></figure><p>组件的例程：</p><p><a href="http://dev.ros2.fishros.com/doc/Tutorials/Pluginlib.html#create-the-base-class-package">http://dev.ros2.fishros.com/doc/Tutorials/Pluginlib.html#create-the-base-class-package</a></p><h2 id="ROS2动作（Action）"><a href="#ROS2动作（Action）" class="headerlink" title="ROS2动作（Action）"></a>ROS2动作（Action）</h2><p>Action的三大组成部分目标、反馈和结果。</p><ul><li>目标：即Action客户端告诉服务端要做什么，服务端针对该目标要有响应。解决了不能确认服务端接收并处理目标问题</li><li>反馈：即Action服务端告诉客户端此时做的进度如何（类似与工作汇报）。解决执行过程中没有反馈问题</li><li>结果：即Action服务端最终告诉客户端其执行结果，结果最后返回，用于表示任务最终执行情况。</li></ul><p>参数是由服务构建出来了，而Action是由话题和服务共同构建出来的（一个Action &#x3D; 三个服务+两个话题） 三个服务分别是：1.目标传递服务 2.结果传递服务 3.取消执行服务 两个话题：1.反馈话题（服务发布，客户端订阅） 2.状态话题（服务端发布，客户端订阅）</p><p><img src="https://img2.imgtp.com/2024/04/23/2wyNJ35g.png" alt="番茄工作法 2.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个工作空间</span></span><br><span class="line">mkdir -p chapt_ws/src</span><br><span class="line">cd chapt_ws/src</span><br><span class="line">ros2 pkg create robot_control_interfaces --build-type ament_cmake </span><br><span class="line">cd robot_control_interfaces</span><br><span class="line">mkdir action</span><br><span class="line">vi MoveRobot.action</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Goal:要移动的距离</span></span><br><span class="line">float32 distance</span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Result: 最终的位置</span></span><br><span class="line">float32 pose</span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Feedback:反馈状态</span></span><br><span class="line">float32 pose</span><br><span class="line">uint32 status</span><br><span class="line">uint32 STATUS_MOVEING = 3</span><br><span class="line">uint32 STATUS_STOP = 4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br></pre></td></tr></table></figure><p>修改CMakeLists.txt文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="string">&quot;action/MoveRobot.action&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>修改package.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure><p>回到src目录创立第二个软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/chapt_ws/src</span><br><span class="line">ros2 pkg create example_action_rclcpp --build-type ament_cmake --dependencies rclcpp rclcpp_action robot_control_interfaces</span><br><span class="line">cd example_action_rclcpp/include/example_action_rclcpp</span><br><span class="line">vi robot.h</span><br></pre></td></tr></table></figure><p>编写功能函数的头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_ACTIONI_RCLCPP_ROBOT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ACTIONI_RCLCPP_ROBOT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;robot_control_interfaces/action/move_robot.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> MoveRobot = robot_control_interfaces::action::MoveRobot;</span><br><span class="line">  <span class="built_in">Robot</span>() = <span class="keyword">default</span>;</span><br><span class="line">  ~<span class="built_in">Robot</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">move_step</span><span class="params">()</span></span>; <span class="comment">/*移动一小步，请间隔500ms调用一次*/</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">set_goal</span><span class="params">(<span class="type">float</span> distance)</span></span>; <span class="comment">/*移动一段距离*/</span></span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">get_current_pose</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_status</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">close_goal</span><span class="params">()</span></span>; <span class="comment">/*是否接近目标*/</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stop_move</span><span class="params">()</span></span>;  <span class="comment">/*停止移动*/</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">float</span> current_pose_ = <span class="number">0.0</span>;             <span class="comment">/*声明当前位置*/</span></span><br><span class="line">  <span class="type">float</span> target_pose_ = <span class="number">0.0</span>;              <span class="comment">/*目标距离*/</span></span><br><span class="line">  <span class="type">float</span> move_distance_ = <span class="number">0.0</span>;            <span class="comment">/*目标距离*/</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; cancel_flag_&#123;<span class="literal">false</span>&#125;; <span class="comment">/*取消标志*/</span></span><br><span class="line">  <span class="type">int</span> status_ = MoveRobot::Feedback::STATUS_STOP;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// EXAMPLE_ACTIONI_RCLCPP_ROBOT_H_</span></span></span><br></pre></td></tr></table></figure><p>在软件包下的src进行编写功能文件，客户端文件，服务端文件。</p><p>编写robot.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_action_rclcpp/robot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*移动一小步，请间隔500ms调用一次*/</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Robot::move_step</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> direct = move_distance_ / <span class="built_in">fabs</span>(move_distance_);</span><br><span class="line">  <span class="type">float</span> step = direct * <span class="built_in">fabs</span>(target_pose_ - current_pose_) *</span><br><span class="line">               <span class="number">0.1</span>; <span class="comment">/* 每一步移动当前到目标距离的1/10*/</span></span><br><span class="line">  current_pose_ += step;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;移动了：&quot;</span> &lt;&lt; step &lt;&lt; <span class="string">&quot;当前位置：&quot;</span> &lt;&lt; current_pose_ &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> current_pose_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*移动一段距离*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Robot::set_goal</span><span class="params">(<span class="type">float</span> distance)</span> </span>&#123;</span><br><span class="line">  move_distance_ = distance;</span><br><span class="line">  target_pose_ += move_distance_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 当目标距离和当前距离大于0.01同意向目标移动 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">close_goal</span>()) &#123;</span><br><span class="line">    status_ = MoveRobot::Feedback::STATUS_STOP;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  status_ = MoveRobot::Feedback::STATUS_MOVEING;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Robot::get_current_pose</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> current_pose_; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Robot::get_status</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> status_; &#125;</span><br><span class="line"><span class="comment">/*是否接近目标*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Robot::close_goal</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(target_pose_ - current_pose_) &lt; <span class="number">0.01</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::stop_move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  status_ = MoveRobot::Feedback::STATUS_STOP;</span><br><span class="line">&#125; <span class="comment">/*停止移动*/</span></span><br></pre></td></tr></table></figure><p>编写action_robot_01.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_action_rclcpp/robot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_action/rclcpp_action.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;robot_control_interfaces/action/move_robot.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionRobot01</span> : <span class="keyword">public</span> rclcpp::Node &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> MoveRobot = robot_control_interfaces::action::MoveRobot;</span><br><span class="line">  <span class="keyword">using</span> GoalHandleMoveRobot = rclcpp_action::ServerGoalHandle&lt;MoveRobot&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ActionRobot01</span><span class="params">(std::string name)</span> : Node(name) &#123;</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;节点已启动：%s.&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;  <span class="comment">// NOLINT</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;action_server_ = rclcpp_action::<span class="built_in">create_server</span>&lt;MoveRobot&gt;(</span><br><span class="line">        <span class="keyword">this</span>, <span class="string">&quot;move_robot&quot;</span>,</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ActionRobot01::handle_goal, <span class="keyword">this</span>, _1, _2),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ActionRobot01::handle_cancel, <span class="keyword">this</span>, _1),</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ActionRobot01::handle_accepted, <span class="keyword">this</span>, _1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Robot robot;</span><br><span class="line">  rclcpp_action::Server&lt;MoveRobot&gt;::SharedPtr action_server_;</span><br><span class="line"></span><br><span class="line">  <span class="function">rclcpp_action::GoalResponse <span class="title">handle_goal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> rclcpp_action::GoalUUID&amp; uuid,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::shared_ptr&lt;<span class="type">const</span> MoveRobot::Goal&gt; goal)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Received goal request with distance %f&quot;</span>,</span><br><span class="line">                goal-&gt;distance);</span><br><span class="line">    (<span class="type">void</span>)uuid;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(goal-&gt;distance &gt; <span class="number">100</span>)) &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_WARN</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;目标距离太远了，本机器人表示拒绝！&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> rclcpp_action::GoalResponse::REJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),</span><br><span class="line">                <span class="string">&quot;目标距离%f我可以走到，本机器人接受，准备出发！&quot;</span>,</span><br><span class="line">                goal-&gt;distance);</span><br><span class="line">    <span class="keyword">return</span> rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">rclcpp_action::CancelResponse <span class="title">handle_cancel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::shared_ptr&lt;GoalHandleMoveRobot&gt; goal_handle)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Received request to cancel goal&quot;</span>);</span><br><span class="line">    (<span class="type">void</span>)goal_handle;</span><br><span class="line">    robot.<span class="built_in">stop_move</span>(); <span class="comment">/*认可取消执行，让机器人停下来*/</span></span><br><span class="line">    <span class="keyword">return</span> rclcpp_action::CancelResponse::ACCEPT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute_move</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;GoalHandleMoveRobot&gt; goal_handle)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> goal = goal_handle-&gt;<span class="built_in">get_goal</span>();</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;开始执行移动 %f 。。。&quot;</span>, goal-&gt;distance);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> result = std::<span class="built_in">make_shared</span>&lt;MoveRobot::Result&gt;();</span><br><span class="line">    rclcpp::Rate rate = rclcpp::<span class="built_in">Rate</span>(<span class="number">2</span>);</span><br><span class="line">    robot.<span class="built_in">set_goal</span>(goal-&gt;distance);</span><br><span class="line">    <span class="keyword">while</span> (rclcpp::<span class="built_in">ok</span>() &amp;&amp; !robot.<span class="built_in">close_goal</span>()) &#123;</span><br><span class="line">      robot.<span class="built_in">move_step</span>();</span><br><span class="line">      <span class="keyword">auto</span> feedback = std::<span class="built_in">make_shared</span>&lt;MoveRobot::Feedback&gt;();</span><br><span class="line">      feedback-&gt;pose = robot.<span class="built_in">get_current_pose</span>();</span><br><span class="line">      feedback-&gt;status = robot.<span class="built_in">get_status</span>();</span><br><span class="line">      goal_handle-&gt;<span class="built_in">publish_feedback</span>(feedback);</span><br><span class="line">      <span class="comment">/*检测任务是否被取消*/</span></span><br><span class="line">      <span class="keyword">if</span> (goal_handle-&gt;<span class="built_in">is_canceling</span>()) &#123;</span><br><span class="line">        result-&gt;pose = robot.<span class="built_in">get_current_pose</span>();</span><br><span class="line">        goal_handle-&gt;<span class="built_in">canceled</span>(result);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal Canceled&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Publish Feedback&quot;</span>); <span class="comment">/*Publish feedback*/</span></span><br><span class="line">      rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result-&gt;pose = robot.<span class="built_in">get_current_pose</span>();</span><br><span class="line">    goal_handle-&gt;<span class="built_in">succeed</span>(result);</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal Succeeded&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handle_accepted</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;GoalHandleMoveRobot&gt; goal_handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line">    std::thread&#123;std::<span class="built_in">bind</span>(&amp;ActionRobot01::execute_move, <span class="keyword">this</span>, _1), goal_handle&#125;</span><br><span class="line">        .<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  <span class="keyword">auto</span> action_server = std::<span class="built_in">make_shared</span>&lt;ActionRobot01&gt;(<span class="string">&quot;action_robot_01&quot;</span>);</span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(action_server);</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写action_control_01.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_action/rclcpp_action.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;robot_control_interfaces/action/move_robot.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionControl01</span> : <span class="keyword">public</span> rclcpp::Node &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> MoveRobot = robot_control_interfaces::action::MoveRobot;</span><br><span class="line">  <span class="keyword">using</span> GoalHandleMoveRobot = rclcpp_action::ClientGoalHandle&lt;MoveRobot&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ActionControl01</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      std::string name,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> rclcpp::NodeOptions&amp; node_options = rclcpp::NodeOptions())</span></span></span><br><span class="line"><span class="function">      : Node(name, node_options) &#123;</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;节点已启动：%s.&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;client_ptr_ =</span><br><span class="line">        rclcpp_action::<span class="built_in">create_client</span>&lt;MoveRobot&gt;(<span class="keyword">this</span>, <span class="string">&quot;move_robot&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;timer_ =</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>),</span><br><span class="line">                                std::<span class="built_in">bind</span>(&amp;ActionControl01::send_goal, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send_goal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;timer_-&gt;<span class="built_in">cancel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;client_ptr_-&gt;<span class="built_in">wait_for_action_server</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>))) &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),</span><br><span class="line">                   <span class="string">&quot;Action server not available after waiting&quot;</span>);</span><br><span class="line">      rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> goal_msg = MoveRobot::<span class="built_in">Goal</span>();</span><br><span class="line">    goal_msg.distance = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Sending goal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> send_goal_options =</span><br><span class="line">        rclcpp_action::Client&lt;MoveRobot&gt;::<span class="built_in">SendGoalOptions</span>();</span><br><span class="line">    send_goal_options.goal_response_callback =</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ActionControl01::goal_response_callback, <span class="keyword">this</span>, _1);</span><br><span class="line">    send_goal_options.feedback_callback =</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ActionControl01::feedback_callback, <span class="keyword">this</span>, _1, _2);</span><br><span class="line">    send_goal_options.result_callback =</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ActionControl01::result_callback, <span class="keyword">this</span>, _1);</span><br><span class="line">    <span class="keyword">this</span>-&gt;client_ptr_-&gt;<span class="built_in">async_send_goal</span>(goal_msg, send_goal_options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  rclcpp_action::Client&lt;MoveRobot&gt;::SharedPtr client_ptr_;</span><br><span class="line">  rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">goal_response_callback</span><span class="params">(GoalHandleMoveRobot::SharedPtr goal_handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!goal_handle) &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal was rejected by server&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(),</span><br><span class="line">                  <span class="string">&quot;Goal accepted by server, waiting for result&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">feedback_callback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      GoalHandleMoveRobot::SharedPtr,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> MoveRobot::Feedback&gt; feedback)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Feedback current pose:%f&quot;</span>, feedback-&gt;pose);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">result_callback</span><span class="params">(<span class="type">const</span> GoalHandleMoveRobot::WrappedResult&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (result.code) &#123;</span><br><span class="line">      <span class="keyword">case</span> rclcpp_action::ResultCode::SUCCEEDED:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> rclcpp_action::ResultCode::ABORTED:</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal was aborted&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> rclcpp_action::ResultCode::CANCELED:</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal was canceled&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Unknown result code&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Result received: %f&quot;</span>, result.result-&gt;pose);</span><br><span class="line">    <span class="comment">// rclcpp::shutdown();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  <span class="comment">// class ActionControl01</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;  <span class="comment">// class ActionControl01</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  <span class="keyword">auto</span> action_client = std::<span class="built_in">make_shared</span>&lt;ActionControl01&gt;(<span class="string">&quot;action_robot_cpp&quot;</span>);</span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(action_client);</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写软件包的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(ament_cmake REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rclcpp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(robot_control_interfaces REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(example_interfaces REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rclcpp_action REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># action_robot节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(action_robot_01 </span><br><span class="line">    src/robot.cpp</span><br><span class="line">    src/action_robot_01.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_include_directories</span>(action_robot_01 PUBLIC</span><br><span class="line">  $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">  $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;)</span><br><span class="line"><span class="keyword">target_compile_features</span>(action_robot_01 PUBLIC c_std_99 cxx_std_17)  <span class="comment"># Require C99 and C++17</span></span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  action_robot_01</span><br><span class="line">  <span class="string">&quot;rclcpp&quot;</span></span><br><span class="line">  <span class="string">&quot;rclcpp_action&quot;</span></span><br><span class="line">  <span class="string">&quot;robot_control_interfaces&quot;</span></span><br><span class="line">  <span class="string">&quot;example_interfaces&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS action_robot_01</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># action_control节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(action_control_01 </span><br><span class="line">  src/action_control_01.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_include_directories</span>(action_control_01 PUBLIC</span><br><span class="line">$&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">$&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;)</span><br><span class="line"><span class="keyword">target_compile_features</span>(action_control_01 PUBLIC c_std_99 cxx_std_17)  <span class="comment"># Require C99 and C++17</span></span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  action_control_01</span><br><span class="line">  <span class="string">&quot;rclcpp&quot;</span></span><br><span class="line">  <span class="string">&quot;rclcpp_action&quot;</span></span><br><span class="line">  <span class="string">&quot;robot_control_interfaces&quot;</span></span><br><span class="line">  <span class="string">&quot;example_interfaces&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS action_control_01</span><br><span class="line">DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NVIDIA X AVIER编译内核配置开发环境</title>
      <link href="/2024/03/10/2024-3-10-NVIDIA-X-AVIER%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/03/10/2024-3-10-NVIDIA-X-AVIER%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="使用flash刷机"><a href="#使用flash刷机" class="headerlink" title="使用flash刷机"></a>使用flash刷机</h1><p>使用命令查询自己机器上的版本号，开发相关的root file system、kernel、bootloader需要和机器上烧录的jetpack版本一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 1 /etc/nv_tegra_release</span><br><span class="line"><span class="comment"># R35（release）,REVISION:5.0,GCID:35550180,BOARD:t186ref,EABI:aarch64,DATE:...</span></span><br></pre></td></tr></table></figure><p>前面为大版本 ，后面是小版本号，所以这个版本号是35.5.0</p><p>所以我之后的源码包为这个版本的开发，下载地址为<a href="https://developer.nvidia.com/embedded/jetson-linux-r3550">https://developer.nvidia.com/embedded/jetson-linux-r3550</a></p><p><strong>先安装实例系统包</strong></p><p><img src="https://o3m5o6wo5d.feishu.cn/space/api/box/stream/download/asynccode/?code=OTRiZTMyNmYwNjAzMjA1ZWJkMGFiYTQwZGQyZjk3YjFfQ2hKUmVBTWdQOEJhSU5oM3AxMHdEUHYzQ1ZnNjdHdGhfVG9rZW46SGVSSmJGdnJ6bzhKUkZ4YXMzN2NwbmRXblNmXzE3MTA5NDM4NzE6MTcxMDk0NzQ3MV9WNA" alt="img"></p><p>Jetson_Linux_R35.5.0_aarch64.tbz2</p><p>Tegra_Linux_Sample-Root-Filesystem_R35.5.0_aarch64.tbz2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -xf  Tegra186_Linux_R32.4.4_aarch64.tbz2</span><br><span class="line"><span class="built_in">cd</span> Linux_for_Tegra/rootfs</span><br><span class="line">sudo tar -xpf ../../ Tegra_Linux_Sample-Root-Filesystem_R32.4.4_aarch64.tbz2</span><br><span class="line"><span class="built_in">cd</span> Linux_for_Tegra</span><br><span class="line">sudo ./apply_binaries.sh</span><br><span class="line"><span class="comment">#安装NVIDIA应用库</span></span><br><span class="line">sudo ./flash.sh &lt;board&gt; mmcblk0p1</span><br><span class="line"><span class="comment">#其中 board 为指定目标Jetson设备的配置的名称,根据自己Jetson板卡系列对应的Configuration</span></span><br></pre></td></tr></table></figure><p><img src="https://o3m5o6wo5d.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVmNWQ3NjUxMWUyNGE5NTNhZDRiMDE1ZjE2ZmZkMmZfaklENWxoYWI2WjF0ZnB5OTdrYkJsTXQxZGxsdUFxUkNfVG9rZW46Uk9jbmJhYUNLb1VBUE54STBoRmNxbDQwbm1iXzE3MTA5NDM4NzE6MTcxMDk0NzQ3MV9WNA" alt="img"></p><p><img src="https://o3m5o6wo5d.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjIwOGViMDcxY2Q0NDhiYTI2OTE3NDI0NDVjMTg4NzhfdUVpUXFlNTd2cTZwZmVkQjF2Uk5aMEJxSlEwMGlWZFdfVG9rZW46RFRMcGJZSXV0b3QwR2R4akl3RWMzYXNTbmRiXzE3MTA5NDM4NzE6MTcxMDk0NzQ3MV9WNA" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">系统镜像生成并升级（把机器中的所有内容擦除并刷机，重新制作system.img）</span><br><span class="line"><span class="variable">$sudo</span> ./flash.sh jetson-xavier mmcblk0p1 </span><br><span class="line"><span class="variable">$sudo</span> ./flash.sh jetson-agx-xavier-devkit mmcblk0p1</span><br><span class="line">系统完整升级但不生成system.img镜像（把机器中的所有内容擦除并刷机）</span><br><span class="line"><span class="variable">$sudo</span> ./flash.sh -r jetson-xavier mmcblk0p1 </span><br><span class="line"> </span><br><span class="line">更新DTB 设备树（涉及外设驱动）</span><br><span class="line">将新的DTB文件<span class="string">&quot;tegra194-p2888-0001-p2822-0000.dtb&quot;</span>复制到目录Linux_for_Tegra/kernel/dtb</span><br><span class="line"><span class="variable">$sudo</span> ./flash.sh -r -k kernel-dtb jetson-xavier mmcblk0p1</span><br><span class="line"> </span><br><span class="line">更新内核镜像（kernel/Image 涉及外设驱动）</span><br><span class="line">Xavier检索内核先判断根目录下/boot/Image 文件，此时只需要把新的内核Image文件复制到 Xavier开机后的/boot/ 目录后再重启即可，通过<span class="built_in">uname</span> -a 查看内核信息如日期时间是否为更新的内核</span><br><span class="line"><span class="variable">$sudo</span> ./flash.sh -r -k kernel jetson-xavier mmcblk0p1</span><br><span class="line"> </span><br><span class="line">系统备份（备份Xavier机器中的系统及全部文件至当前目录的backup.img）</span><br><span class="line"><span class="variable">$sudo</span> ./flash.sh -r -k APP -G backup.img jetson-xavier mmcblk0p1</span><br><span class="line">如何恢复使用备份的镜像：</span><br><span class="line">1、上面步骤备份会生出两个文件，把其中的backup.img.raw 重新命名到bootloader/system.img（软件镜像包含用户空间的所有文件信息），backup.img 文件不被使用可以删除掉</span><br><span class="line">2、运行命令重新升级机器：</span><br><span class="line"><span class="variable">$sudo</span> ./flash.sh -r jetson-xavier mmcblk0p1 </span><br></pre></td></tr></table></figure><h1 id="配置硬件的引脚工具"><a href="#配置硬件的引脚工具" class="headerlink" title="配置硬件的引脚工具"></a>配置硬件的引脚工具</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /opt/nvidia/jetson-io/jetson-io.py</span><br></pre></td></tr></table></figure><h1 id="交叉编译工具"><a href="#交叉编译工具" class="headerlink" title="交叉编译工具"></a>交叉编译工具</h1><p>先下载源码包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="variable">$HOME</span>/l4t-gcc</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$HOME</span>/l4t-gcc</span><br><span class="line">$ tar xf &lt;toolchain_archive&gt;源码包的名字</span><br></pre></td></tr></table></figure><h2 id="设置交叉编译的环境变量"><a href="#设置交叉编译的环境变量" class="headerlink" title="设置交叉编译的环境变量"></a>设置交叉编译的环境变量</h2><p>To set <code>CROSS_COMPILE</code> for the aarch64 toolchain, enter the command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$export</span> CROSS_COMPILE=$<span class="variable">$HOME</span>/l4t-gcc/bin/aarch64-buildroot-linux-gnu-</span><br><span class="line"><span class="variable">$aarch64</span>-linux-gnu-gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=aarch64-linux-gnu-gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc-cross/aarch64-linux-gnu/7/lto-wrapper</span><br><span class="line">Target: aarch64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion=<span class="string">&#x27;Ubuntu/Linaro 7.5.0-3ubuntu1~18.04&#x27;</span> --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=<span class="built_in">yes</span> --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libquadmath --disable-libquadmath-support --enable-plugin --enable-default-pie --with-system-zlib --enable-multiarch --enable-fix-cortex-a53-843419 --disable-werror --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=aarch64-linux-gnu --program-prefix=aarch64-linux-gnu- --includedir=/usr/aarch64-linux-gnu/include</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) </span><br></pre></td></tr></table></figure><h1 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h1><h2 id="Build-kernel-source"><a href="#Build-kernel-source" class="headerlink" title="Build kernel source"></a>Build kernel source</h2><ol><li>这时下载内核的源码包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvjf public_sources.tbz2 </span><br><span class="line">$ <span class="built_in">cd</span> Linux_for_Tegra/source/public</span><br><span class="line">$ tar -xvjf kernel_src.tbz2</span><br></pre></td></tr></table></figure><ol><li>在linux操作系统上只使用gcc编译是不够的，还要安装编译程序必须的软件包，使用下面的命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential bc</span><br></pre></td></tr></table></figure><ol><li>构建环境变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在public目录下输入</span></span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE_AARCH64_PATH=/opt/l4t-gcc/</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE_AARCH64=/opt/l4t-gcc/bin/aarch64-buildroot-linux-gnu-</span><br></pre></td></tr></table></figure><ol><li>创建生成镜像和设备树</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> kernel_out</span><br><span class="line">./nvbuild.sh -o /home/zext-ros/nvidia/sources/Linux_for_Tegra/source/public/kernel_out</span><br><span class="line"><span class="comment"># nvbuild.sh文件在kernel_src目录下</span></span><br><span class="line"><span class="comment">#源码目录下执行下面的命令</span></span><br><span class="line">make menuconfig</span><br><span class="line"><span class="comment">#保存.config在kernel_out下</span></span><br><span class="line">./nvbuild.sh -o /home/zext-ros/nvidia/sources/Linux_for_Tegra/source/public/kernel_out</span><br></pre></td></tr></table></figure><p><img src="https://o3m5o6wo5d.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjEyNjM4ODA2OWZjMjk5MTRlMjQwOWRhYmY5ODlhY2RfVXpJcFVLbnkxQlRtNlp5NFJxQ29TYlU0aUN3V2Q3aTRfVG9rZW46UHFDZ2JSZUk2bzFYZVd4QUc2UGNuNTFsbmdiXzE3MTA5NDM4NzE6MTcxMDk0NzQ3MV9WNA" alt="img"></p><ol><li>将生成的对已有的示例做替换。</li></ol><p>将 <code>$kernel_out/drivers/gpu/nvgpu/nvgpu.ko</code> 复制到 <code>Linux_for_Tegra/rootfs/usr/lib/modules/$(uname -r)/kernel/drivers/gpu/nvgpu/nvgpu.ko</code>。</p><p><code>Linux_for_Tegra/kernel/dtb/</code>被kernel_out&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;nvidia&#x2F;替换</p><p>将 <code>$kernel_out/arch/arm64/boot/Image</code> 复制到 <code>Linux_for_Tegra/kernel/Image</code>。</p><h2 id="Externel-module"><a href="#Externel-module" class="headerlink" title="Externel module"></a>Externel module</h2><ol><li>安装依赖项（依赖项是支持make ARCH&#x3D;arm64 O&#x3D;$TEGRA_KERNEL_OUT -j<n> modules_prepare,可能还有别的报错，但是另一个报错是给出了安装的依赖项</li></ol><p>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3-sphinx</span><br></pre></td></tr></table></figure><p>在内核源码5.1.0下面进行操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sudo apt install libncurses5</span><br><span class="line">make menuconfig</span><br><span class="line"><span class="comment">#将config保存在和构建内核输出的目录中</span></span><br><span class="line">make ARCH=arm64 O=/home/zext-ros/nvidia/sources/Linux_for_Tegra/source/public/kernel_out modules_prepare</span><br></pre></td></tr></table></figure><p>进入到自己写的驱动目录中，编写Makefile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">KERNELDIR := /home/zext-ros/nvidia/kernel_out</span><br><span class="line">CURRENT_PATH := $(shell pwd)</span><br><span class="line">obj-m := chrdev.o</span><br><span class="line"></span><br><span class="line">build: kernel_modules</span><br><span class="line"></span><br><span class="line">kernel_modules:</span><br><span class="line">        make ARCH=arm64 -C $(KERNELDIR) M=$(CURRENT_PATH)</span><br></pre></td></tr></table></figure><h1 id="Root-file-system"><a href="#Root-file-system" class="headerlink" title="Root file system"></a>Root file system</h1><p>使用Ubuntu20.04的环境，如果不是可以使用容器来模拟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker.io</span><br><span class="line">$ sudo docker run --privileged -it --<span class="built_in">rm</span> -v &lt;your_L4T_root&gt;/Linux_for_Tegra:/l4t ubuntu:20.04</span><br><span class="line"></span><br><span class="line">(inside of container) $ apt-get update</span><br><span class="line">(inside of container) $ apt-get install -y qemu-user-static wget sudo</span><br><span class="line">(inside of container) $ <span class="built_in">cd</span> /l4t/tools/samplefs</span><br></pre></td></tr></table></figure><p>这段文本描述了如何生成不同类型的根文件系统（root file system）用于 NVIDIA Jetson 开发套件。这些不同类型的根文件系统包括桌面版、最小版和基本版。以下是每种类型的根文件系统的简要描述：</p><ol><li><strong>桌面版（Desktop Flavor）根文件系统：</strong><ol><li>包含 Ubuntu 桌面环境和 OEM 配置。</li><li>使用 <code>nv_build_samplefs.sh</code> 脚本生成，需要指定参数 <code>--abi aarch64 --distro ubuntu --flavor desktop --version focal</code>。</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./nv_build_samplefs.sh --abi aarch64 --distro ubuntu --flavor desktop --version focal</span><br></pre></td></tr></table></figure><ol><li><strong>最小版（Minimal Flavor）根文件系统：</strong><ol><li>一个较小的根文件系统，用于 NVIDIA Jetson 开发套件。</li><li>不提供图形用户界面（GUI），所有操作只能通过 SSH 或 UART 控制台完成。</li><li>不包含 OEM 配置，建议在刷写设备之前创建默认用户。</li><li>使用 <code>nv_build_samplefs.sh</code> 脚本生成，需要指定参数 <code>--abi aarch64 --distro ubuntu --flavor minimal --version focal</code>。</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./nv_build_samplefs.sh --abi aarch64 --distro ubuntu --flavor minimal --version focal</span><br></pre></td></tr></table></figure><ol><li><strong>基本版（Basic Flavor）根文件系统：</strong><ol><li>最小的根文件系统，用于 NVIDIA Jetson 开发套件，包含 BSP 和 NVIDIA Docker 的依赖项。</li><li>终端用户可以安装 NVIDIA Docker 运行 NVIDIA 容器和启动 CUDA 应用程序。</li><li>与最小版根文件系统类似，所有操作只能通过 SSH 或 UART 控制台完成。</li><li>必须在刷写设备之前创建默认用户。</li><li>使用 <code>nv_build_samplefs.sh</code> 脚本生成，需要指定参数 <code>--abi aarch64 --distro ubuntu --flavor basic --version focal</code>。</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./nv_build_samplefs.sh --abi aarch64 --distro ubuntu --flavor basic --version focal</span><br></pre></td></tr></table></figure><h1 id="参考文档索引"><a href="#参考文档索引" class="headerlink" title="参考文档索引"></a>参考文档索引</h1><p><img src="https://o3m5o6wo5d.feishu.cn/space/api/box/stream/download/asynccode/?code=MWI1YWMyYTRhYTI5MDcyZDFlNGM5YzYyOWVkYTllMDJfWTlXcHloa1hVdlBBME9ySWgxaVRhVlk1dEhCZnE1UWlfVG9rZW46S09sNGJGRE56b3VacFR4N1BCdGN1VTdNbmloXzE3MTA5NDM5NDc6MTcxMDk0NzU0N19WNA" alt="img"></p><p>在jetson系统上使用命令查询使用的设备树</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/device-tree/nvidia,dtsfilename</span><br></pre></td></tr></table></figure><p>之后从内核源码中进行搜索找到设备树文件，进行修改的设备树，可以根据型号来修改自己的设备树文件，</p><p>编写内核配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line">-&gt; Networking support  </span><br><span class="line">    -&gt; CAN bus subsystem support   </span><br><span class="line">        -&gt; CAN Device Drivers   </span><br><span class="line">            &lt;*&gt;   Raw CAN Protocol (raw access with CAN-ID filtering)                                 │ │  </span><br><span class="line">            &lt;*&gt;   Broadcast Manager CAN Protocol (with content filtering)  </span><br></pre></td></tr></table></figure><p>保存.config文件在源码生成的镜像的目录kernel_out中，之后使用.nvbuild.sh进行编译。</p><p>最后将生成的镜像和设备树和系统中的进行替换，使用flash进行烧录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./flash.sh jetson-agx-xavier-devkit mmcblk0p1</span><br></pre></td></tr></table></figure><p>刷机成功后，使用nvidia的自带工具进行引脚的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /opt/nvidia/jetson-io/jetson-io.py</span><br></pre></td></tr></table></figure><p><img src="https://o3m5o6wo5d.feishu.cn/space/api/box/stream/download/asynccode/?code=MTNmNzlhOGVmMmUxYmM0MjNjODkzYjg4NTlkMDlhNGFfYmtBeHBOdE92VnpHZ0ZiQ01Mc25CT1pHS2pIZEdCa0FfVG9rZW46SWtYOGJ5ZXJqbzA5ME94MlY3dGN6UVl0bmZkXzE3MTA5NDM5NDc6MTcxMDk0NzU0N19WNA" alt="img"></p><p>进入Configure Jetson 40pin Header来配置想要使用的IO</p><p><img src="https://o3m5o6wo5d.feishu.cn/space/api/box/stream/download/asynccode/?code=N2VhOGUwNjdkMmZkMWRjNjYxOTI5NjlhOThiZmYyOWJfZXpYNzJIMDJOWFZHRGRYNFRBOXB3RU1HeUEwcm5oYW9fVG9rZW46UXBWd2JSZDFOb3Frdk94WVdNdmMyRzFmbmVvXzE3MTA5NDM5NDc6MTcxMDk0NzU0N19WNA" alt="img"><img src="https://o3m5o6wo5d.feishu.cn/space/api/box/stream/download/asynccode/?code=NzhhYTRjZWU5MzgzMzIzNjA1MmZhNTJiNzgzNjliNTJfdzdqZ0lJbzVickhPSlRRS3gzYWNPdjl5bWRjVlRDblZfVG9rZW46UGFmeGJwdmhzb0xvVVJ4cWNxOGNVWVRDbkdkXzE3MTA5NDM5NDc6MTcxMDk0NzU0N19WNA" alt="img"></p><p>之后选择 save pin changes ， save and reboot跟换设备树文件。</p><p>重启之后输入命令ifconfig -a就能看到can 0 can1两个设备</p><p>输入命令来安装工具进行本地回环的can测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install can-utils</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回环测试</span></span><br><span class="line">ifconfig can0 down  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果 can0 已经打开了，先关闭</span> </span><br><span class="line">ip link set can0 type can bitrate 500000 loopback on </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启回环测试</span> </span><br><span class="line">ifconfig can0 up </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新打开</span> </span><br><span class="line">can0 candump can0 &amp; </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">candump 后台接收数据</span> </span><br><span class="line">cansend can0 5A1#11.22.33.44.55.66.77.88 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cansend 发送数据</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NVIDIA X AVIER</title>
      <link href="/2024/03/05/2024-3-05-NVIDIA-X-AVIER/"/>
      <url>/2024/03/05/2024-3-05-NVIDIA-X-AVIER/</url>
      
        <content type="html"><![CDATA[<p>使用的Ubuntu版本为18.04，配置如下：</p><ol><li>13G内存</li><li>80G存储</li></ol><h2 id="安装sdkmanager"><a href="#安装sdkmanager" class="headerlink" title="安装sdkmanager"></a>安装sdkmanager</h2><p>安装地址在<a href="https://developer.nvidia.com/embedded/downloads">https://developer.nvidia.com/embedded/downloads</a></p><p>之后在Ubuntu上安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install sdkmanager_1.9.2-10899_amd64.deb</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装过后使用命令打开</span></span><br><span class="line">sdkmanager</span><br></pre></td></tr></table></figure><p>之后登录发现出现<strong>Authorization flow not allowed - invalid_request</strong>的报错，经过查询为sdk的版本过低，使用命令让sdk进行更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdkmanager --checkforupdates</span><br></pre></td></tr></table></figure><p>按中间和左侧的按钮两秒进入刷机模式</p><ol><li>STEP1 中选择自己的设备XAVIER</li><li>STEP2 选择安装的包<ol><li><img src="https://o3m5o6wo5d.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQzZWYyN2M5ZjkwYjI0NzA1N2U2NWJkMWM4ZDA0ZWNfWHA0dmxTTHZ6RWM0cHVsd3NPSGg3cklmTnRzWnQzM2ZfVG9rZW46RXRGdWI2YnA2b3pwc0F4bGZvTmM4N2lXbm9kXzE3MTA5NDM4Mzg6MTcxMDk0NzQzOF9WNA" alt="img"></li></ol></li><li>STEP3 到安装百分之30多时候，机器连接显示器进行安装系统，之后使用终端命令进行查询IP地址，在下一个部分会用到，</li></ol><p><img src="https://o3m5o6wo5d.feishu.cn/space/api/box/stream/download/asynccode/?code=OTFkOWI4ZWQ2NWNjMzIyNzU0NTdiNmQ0NzdhODE4NGZfWnhhV2ZkWVJ5VEsyYXlWeWxCdHVCWVllaVVqNmJ3NTRfVG9rZW46Wjk3QmJwd3B4b0hqWHh4eXJXdmN1SHRnbkxoXzE3MTA5NDM4Mzg6MTcxMDk0NzQzOF9WNA" alt="img"></p><p>可以选择USB还是网络，USB会有报错，所以使用的网络，这个网络ip地址就是机器连接网络的ip地址（这里要保证ip地址和Ubuntu的地址处在同一个网关），如果机器连接了无线网卡就好办了，如果没有的话也不慌，使用一根网线连接电脑，将电脑网络适配器打开，右键属性找到共享模式，打开wifi的网络共享，之后再虚拟机上桥接这个网线，这样就保障了两个设备是在同一个网关下，并且XAVIER可以上网。</p><ol><li>STEP4 完成</li></ol><p><strong>安装简体中文输入法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y purge thunderbird* </span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="入门开发"><a href="#入门开发" class="headerlink" title="入门开发"></a>入门开发</h1><h2 id="选取板级支持包"><a href="#选取板级支持包" class="headerlink" title="选取板级支持包"></a>选取板级支持包</h2><p>XAVIER的支持包</p><p><a href="https://developer.nvidia.com/embedded/jetson-linux-r3550">https://developer.nvidia.com/embedded/jetson-linux-r3550</a></p><p>开发手册</p><p><a href="https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3261/index.html#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/introduction.html#">https://docs.nvidia.com/jetson/archives/l4t-archived/l4t-3261/index.html#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/introduction.html#</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#罗列jetson平台上使用的系统命令</span></span><br><span class="line"><span class="comment">#查看当前工作模式</span></span><br><span class="line">sudo nvpmodel --query</span><br><span class="line"><span class="comment">#设置当前模式</span></span><br><span class="line">sudo nvpmodel -m 0</span><br><span class="line"><span class="comment">#开启风扇，开启最大时钟</span></span><br><span class="line">jetson_clocks</span><br><span class="line"><span class="comment">#查看clock工作状态</span></span><br><span class="line">jetson_clocks --show</span><br><span class="line"><span class="comment">#查看CPU温度</span></span><br><span class="line">sudo apt install lm-sensors</span><br><span class="line">sensors</span><br><span class="line"><span class="comment">#显示当前目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment">#查看系统环境变量</span></span><br><span class="line"><span class="built_in">env</span></span><br><span class="line"><span class="comment">#查看CPU几核</span></span><br><span class="line"><span class="comment">#这个命令非常有用，在编译时可以加速编译时间</span></span><br><span class="line"><span class="built_in">nproc</span></span><br><span class="line"><span class="comment">#查看设备树</span></span><br><span class="line">/sys/firmware/fdt</span><br><span class="line">/sys/firmware/devicetree</span><br><span class="line">/proc/device-tree</span><br><span class="line"><span class="comment">#列出安装得所有应用</span></span><br><span class="line">dpkg --list</span><br><span class="line"><span class="comment">#清理安装失败的rc应用</span></span><br><span class="line">sudo apt-get purge $(dpkg -l|grep ^rc|awk ‘(<span class="built_in">print</span> <span class="variable">$2</span>)’)</span><br><span class="line"><span class="comment">#卸载指定的包</span></span><br><span class="line">sudo apt-get --purge remove 包名</span><br><span class="line"><span class="comment">#清理不完整的软件包</span></span><br><span class="line">sudo apt autoclean</span><br><span class="line"><span class="comment">#清理apt缓存内容：</span></span><br><span class="line">sudo apt-get clean</span><br><span class="line"><span class="comment">#清理任何未用的依赖项：</span></span><br><span class="line">sudo apt autoremove</span><br><span class="line"><span class="comment">#使用autoremove命令卸载</span></span><br><span class="line">sudo apt autoremove application-name</span><br><span class="line"><span class="comment">#启动jetson-io工具</span></span><br><span class="line">sudo /opt/nvidia/jetson-io/jetson-io.py</span><br><span class="line"><span class="comment">#查看当前jetpack的版本</span></span><br><span class="line"><span class="built_in">cat</span> /etc/nv_tegra_release</span><br><span class="line"><span class="comment">#python相关</span></span><br><span class="line"><span class="comment">#查看当前设备上的python版本</span></span><br><span class="line"><span class="built_in">ls</span> /usr/bin/python*</span><br><span class="line"><span class="comment">#查看替换设置</span></span><br><span class="line">update-alternatives --list python</span><br><span class="line"><span class="comment">#如果没有设置，可用如下命令添加</span></span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2</span><br><span class="line"><span class="comment">#版本切换</span></span><br><span class="line">update-alternatives --config python</span><br><span class="line"><span class="comment">#查看当前默认版本</span></span><br><span class="line">python --version</span><br><span class="line"><span class="comment">#查看jetson的L4T版本号</span></span><br><span class="line"><span class="built_in">head</span> -n 1 /etc/nv_tegra_release</span><br><span class="line"><span class="comment">#一个有用的工具jtop</span></span><br><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo -H pip3 install -U jetson-stats</span><br><span class="line"><span class="comment">#如果第二个命令报错可能是网络问题，可以使用国内的镜像源加速安装</span></span><br></pre></td></tr></table></figure><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><strong>L4T是什么</strong> L4T是Linux for Tegra的缩写，因为jetson系列用的是Tegra架构，因此L4T可以理解为jetson定制的<a href="https://so.csdn.net/so/search?q=Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020">Linux操作系统</a>，具体的来说就是ubuntu定制款。</li><li><strong>如何编译</strong></li></ol><p>NVIDIA给我们提供了每个版本的源码文件。</p><p>首先下载这些源码，然后选择一个平台进行编译。</p><p>具体来说有两种思路：</p><p>1.直接在jetson上编译（也叫目标平台编译，因为我们编译出来的文件是要刷到这个机器上的，所以叫目标平台）</p><p>优点是不跨平台，编译命令简单，缺点是慢，真的慢</p><p>2.交叉编译（就是在一台x86 PC上编译，因为我们是在一个硬件上编译出来给另一个硬件用，相当于跨平台了）</p><p>优点是速度快，不会把目标平台搞乱，缺点是需要进行交叉编译配置</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序上电自启动</title>
      <link href="/2024/02/25/2024-2-25-%E4%B8%8A%E7%94%B5%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AF/"/>
      <url>/2024/02/25/2024-2-25-%E4%B8%8A%E7%94%B5%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%90%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="设备上电自启动服务和程序"><a href="#设备上电自启动服务和程序" class="headerlink" title="设备上电自启动服务和程序"></a>设备上电自启动服务和程序</h1><p>使用设备依旧为AG215S</p><p>开机自启动方式有init.d和systemctl。</p><p>使用命令查询安卓版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br><span class="line"><span class="meta prompt_">202306281416#</span><span class="language-bash">返回的信息</span></span><br></pre></td></tr></table></figure><h3 id="init-d自启动的方法"><a href="#init-d自启动的方法" class="headerlink" title="init.d自启动的方法"></a>init.d自启动的方法</h3><blockquote><p>方法限制条件</p><ul><li><input checked="" disabled="" type="checkbox"> Android设备的<code>init</code>进程支持<code>init.d</code>目录。</li><li><input disabled="" type="checkbox"> 设备已经取得root权限（超级用户权限）。</li></ul></blockquote><p><strong>确认init.d目录是否存在：</strong></p><p>在Android设备上，<code>init.d</code>目录通常位于 <code>/system/etc/init.d/</code>。您可以通过连接到设备的ADB Shell来检查是否存在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ls /system/etc/init.d/</span><br></pre></td></tr></table></figure><p>经过查询，AG215S并不存在。</p><p>目录可手动创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir etc</span><br><span class="line">cd etc</span><br><span class="line">mkdir init.d</span><br></pre></td></tr></table></figure><p><strong>创建自启动脚本</strong></p><ol><li><p>在<code>init.d</code>目录下创建一个Shell脚本文件，例如 <code>start.sh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start qrtr        # 开启qrtr功能</span><br><span class="line">qmi_test_service_test       # 测试qrtr功能   </span><br><span class="line">systemctl start netmgrd</span><br><span class="line">systemctl start QCMAP_ConnectionManagerd</span><br><span class="line">systemctl start cv2x-launcher    # 开启cv2x</span><br><span class="line">cv2x-config --get-v2x-status     # 获取cv2x状态</span><br></pre></td></tr></table></figure></li><li><p><strong>重启设备：</strong></p><p>重新启动设备，您创建的脚本应该在开机时自动执行。</p></li></ol><h3 id="systemctl开启自启动服务"><a href="#systemctl开启自启动服务" class="headerlink" title="systemctl开启自启动服务"></a>systemctl开启自启动服务</h3><ol><li><strong>创建服务文件</strong></li></ol><p>创建一个以 <code>.service</code> 为后缀的服务单元文件。例如，假设我们创建一个名为 <code>my_service.service</code> 的文件。</p><p>此为服务文件的模板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=My Custom Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/path/to/your/command_or_script</span><br><span class="line">Restart=always</span><br><span class="line">User=your_username</span><br><span class="line">Group=your_groupname</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure><p>在上述文件中，您需要替换以下内容：</p><ul><li><code>/path/to/your/command_or_script</code>：您希望在启动时运行的命令或脚本的路径。</li><li><code>your_username</code>：服务运行的用户名。</li><li><code>your_groupname</code>：服务运行的用户组名。</li></ul><p>本人使用的内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Start Service</span><br><span class="line">After=multi-user.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/data/hanfeng/start.sh</span><br><span class="line">Restart=always</span><br><span class="line">User=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>重新加载 Systemd 配置：</strong> </p><p>在保存服务单元文件后，使用以下命令重新加载 Systemd 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p><strong>将服务文件复制到&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;目录下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp my_service.service /etc/systemd/system/</span><br></pre></td></tr></table></figure></li><li><p><strong>启用服务：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable my_service.service</span><br></pre></td></tr></table></figure><p>这将在系统启动时启用该服务。</p></li><li><p><strong>检查服务状态：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status my_service.service</span><br></pre></td></tr></table></figure><p>这将显示服务的当前状态和相关信息。</p></li></ol><p>现在，您的服务应该已经配置为在系统启动时自动启动。请注意，此方法假设您有足够的权限来执行上述步骤。</p><h3 id="yocto系统的自启动服务"><a href="#yocto系统的自启动服务" class="headerlink" title="yocto系统的自启动服务"></a>yocto系统的自启动服务</h3>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v2v的调试</title>
      <link href="/2024/02/20/2024-2-20-%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9/"/>
      <url>/2024/02/20/2024-2-20-%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h1><p>通过一周学习到了一些新的知识并对嵌入式的应用层开发进行了技术栈的补充，新知识例如自动驾驶的cv2x，以及正在做的V2V部分。<br>主要是编译了固件来支持应用层的开发，学习了使用工具adb来进行调试内核，烧录文件，并且通过设备对于V2V来进行相互通信。</p><h2 id="1-固件编译"><a href="#1-固件编译" class="headerlink" title="1.固件编译"></a>1.固件编译</h2><p>固件编译部分跟之前没有太大的不同，差异点主要在需要在Linux搭载代理服务来进行编译，因为芯片是高通的，可能由于一些带宽和信号延时问题，导致会有编译报错，之后可以在自己电脑虚拟机上进行代理设置玩玩，但是clash现在删库了，可能需要寻找新的方法来代替。</p><p>烧录固件使用的软件为QFil，它烧录需要点运气的成分，会出现找不到指定文件的问题还有process fail的问题，解决方法就是下载最新的QPST，并且使用Tools选项来进行烧录固件，可以在烧录固件之前使用QPST Configuration来查询串口的状态是否enable。经过查询发现，这个软件经常使用在给手机进行刷机（刷系统）。</p><p><a href="https://postimg.cc/cK8Sdfjm"><img src="https://i.postimg.cc/Xvs7c8kT/2023-12-21-091223.png" alt="2023-12-21-091223.png"></a></p><h2 id="2-硬件验证"><a href="#2-硬件验证" class="headerlink" title="2.硬件验证"></a>2.硬件验证</h2><p>将固件烧录成功后，使用adb进入调试，并输入命令开启进行验证服务。</p><p>adb 是 Android 调试桥（Android Debug Bridge）的缩写，它是一个用于与连接到计算机的 Android 设备进行通信的命令行工具。adb 提供了一组用于设备管理、应用安装、调试和其他开发任务的命令。</p><h4 id="adb工具的安装以及配置"><a href="#adb工具的安装以及配置" class="headerlink" title="adb工具的安装以及配置"></a>adb工具的安装以及配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install anroid-tools-adb</span><br><span class="line">mkdir ~/.android</span><br><span class="line">echo 0x2c7c &gt; ~/.android/adb_usb.ini</span><br><span class="line">cd /etc/udev/rules.d</span><br><span class="line">sudo vim 51-android.rules</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#内容</span></span></span><br><span class="line">SUBSYSTEM==&quot;usb&quot;, SYSFS&#123;idVendor&#125;==&quot;2c7c&quot;, MODE=&quot;0666&quot;，GROUP=&quot;plugdev&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#其中的2c7c使用lsusb命令通过热插拔来确定</span></span></span><br><span class="line">sudo usermod -a -G plugdev $(id -u -n)</span><br><span class="line">sudo udevadm control --reload-rules</span><br><span class="line">sudo service udev restart</span><br><span class="line">sudo udevadm trigger</span><br><span class="line"></span><br><span class="line">sudo -s#进入调试模式</span><br><span class="line">adb kill-server#取消服务</span><br><span class="line">adb start-server#开启adb服务</span><br><span class="line">exit 0 #回到正常模式</span><br></pre></td></tr></table></figure><p>至此adb已经安装配置完成了。</p><h4 id="adb工具的使用"><a href="#adb工具的使用" class="headerlink" title="adb工具的使用"></a>adb工具的使用</h4><p>这个工具安装完毕就可以在终端使用（无论linux和windows）</p><p>以下是一些常用的 adb 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设备连接与断开：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">连接设备：</span></span><br><span class="line">adb devices</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">断开设备连接：</span></span><br><span class="line">adb disconnect [device]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">应用管理：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装应用：</span></span><br><span class="line">adb install path/to/app.apk</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载应用：</span></span><br><span class="line">adb uninstall package_name</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动应用：</span></span><br><span class="line">adb shell am start -n package_name/activity_name</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件传输：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将文件复制到设备：</span></span><br><span class="line">adb push local_file_path /device/path</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从设备中复制文件：</span></span><br><span class="line">adb pull /device/path local_file_path</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">调试和日志：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看设备日志：</span></span><br><span class="line">adb logcat</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">清除设备日志：</span></span><br><span class="line">adb logcat -c</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Shell 命令：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入设备 shell：</span></span><br><span class="line">adb shell</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行设备上的命令：</span></span><br><span class="line">adb shell [command]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">端口转发：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将设备端口转发到主机：</span></span><br><span class="line">adb forward tcp:8080 tcp:8080</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">系统操作指令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取设备型号</span></span><br><span class="line">adb shell getprop ro.product.model</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取andorid系统版本</span></span><br><span class="line">adb shell getprop ro.build.version.release</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取设备的序列号</span></span><br><span class="line">adb get-serialno</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取设备屏幕分辨率</span></span><br><span class="line">adb shell wm size</span><br></pre></td></tr></table></figure><p><strong>在验证过程中发现问题可以多做正常设备之间的比较，来查找是否有问题，排除法最为好用。</strong></p><p>在使用adb的过程中发现一个问题，adb在虚拟机的重启后，调试设备会显示没有权限，目前的解决方案为将adb的服务重新开启。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo -s#进入调试模式</span><br><span class="line">adb kill-server#取消服务</span><br><span class="line">adb start-server#开启adb服务</span><br><span class="line">exit 0 #回到正常模式</span><br></pre></td></tr></table></figure><h5 id="将命令发送给特定的设备"><a href="#将命令发送给特定的设备" class="headerlink" title="将命令发送给特定的设备"></a>将命令发送给特定的设备</h5><p>如果有多个设备在运行，您在发出 <code>adb</code> 命令时必须指定目标设备。如需指定目标设备，请按以下步骤操作：</p><ol><li>使用 <code>devices</code> 命令获取目标设备的序列号。</li><li>获得序列号后，结合使用<code>-s</code>选项与<code>adb</code>命令，可以将 $ANDROID_SERIAL 环境变量设为包含序列号。<ul><li>如果您要发出很多 <code>adb</code> 命令，可以将 <code>$ANDROID_SERIAL</code> 环境变量设为包含序列号。</li><li>如果您同时使用 <code>-s</code> 和 <code>$ANDROID_SERIAL</code>，<code>-s</code> 会替换 <code>$ANDROID_SERIAL</code>。</li></ul></li></ol><p>以下示例中，先获得了已连接设备的列表，然后使用其中一个设备的序列号在该设备上安装了 <code>helloWorld.apk</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator-5554 device</span><br><span class="line">emulator-5555 device</span><br><span class="line">adb -s emulator-5555 install helloWorld.apk</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：如果您在多个设备可用时发出命令但未指定目标设备，<code>adb</code> 会显示错误。</p></blockquote><h2 id="3-嵌入式应用层的编写"><a href="#3-嵌入式应用层的编写" class="headerlink" title="3.嵌入式应用层的编写"></a>3.嵌入式应用层的编写</h2><p>应用层的编写主要是使用C和C++的语言，主要发送和接收都是基于SDK开发，</p><p>因为收发程序为发送字符缓冲区的字符串，为保证数据发送的稳定，时间戳放入前要注意将数据类型设置为无符号整型变量，而且要注意变量的实际大小，不要溢出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> array&lt;<span class="type">char</span>, G_BUF_LEN&gt; gBuf;       <span class="comment">//用于存储发送的数据</span></span><br><span class="line"><span class="type">uint64_t</span> time1 = <span class="built_in">getCurrentTimestamp</span>();          <span class="comment">//获取时间戳</span></span><br><span class="line">std::string stringValue = std::<span class="built_in">to_string</span>(time1);<span class="comment">//整型转成字符串</span></span><br><span class="line">std::<span class="built_in">strncpy</span>(gBuf.<span class="built_in">data</span>(), stringValue.<span class="built_in">c_str</span>(), G_BUF_LEN);<span class="comment">//将整型变量放入字符缓冲区</span></span><br></pre></td></tr></table></figure><p>要注意环境，可能C++程序编译没bug，但是实际硬件运行的环境不能完全支持。还是C更好一点。</p><p>应用层编写出现的问题：</p><ol><li>在全双工通信时候做收发线程时候发现堵塞，暂时没发现解决方案，换做半双工通信，两个线程作为互斥并加入应答机制，但是在其中发现主机容易堵塞，从机没事，找到其中的区别，是收发线程开启的顺序问题，所以将全双工通信的双线程分时打开，发现问题得到了解决。</li><li>因为必须在程序执行结束后进行退出服务，如果不进行注销退出服务的话不能再次开启程序只能重新启动，为方便调试加入了信号处理机制便于退出，但是因为接收线程使用的接收机制是阻塞接收，在信号处理机制后会阻塞在接收函数中，放入了跳转机制想跳出这个阻塞，会出现线程没有结束的报错总线错误。最后是去掉了跳转，对阻塞接收函数进行超时处理，这样退出时就不会因为没有信号发生进程阻塞。</li><li>发送消息为判断是否丢包，加入发送时候所在的发送次数。在接收时候进行打印，并比较总接收次数完成丢包率的查找。</li><li>V2V使用的是卫星同步源，两端的设备使用的是网络时间同步，会有不同的延迟误差。</li></ol><h2 id="4-时间戳的同步"><a href="#4-时间戳的同步" class="headerlink" title="4.时间戳的同步"></a>4.时间戳的同步</h2><p>时间戳是指<strong>使用数字签名技术对包含原始文件信息、签名参数、签名时间等信息构成的对象进行数字签名而产生的数据，用以证明原始文件在签名时间之前已经存在</strong>。</p><p>多个传感器可能同时工作，或者在同一系统中的多个组件需要协同工作。通过在传感器数据中包含时间戳，可以实现时间同步，确保数据采集的时序是一致的。这对于在后续数据处理或分析中确保时间一致性是很重要的。<br>在v2v中使用接收时间戳减去发送时间戳来得到传输设备之间的传输延迟，所使用的精度越高那么得到的时间戳的精度越高。</p><p>目前了解可使用的时间戳同步为ntp时间同步以及订阅时间同步，可使用命令进行查询时间同步后的系统偏差。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chronyc tracking</span><br><span class="line">chronyc sources -v</span><br></pre></td></tr></table></figure><p>chrony的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开终端。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装chrony</span></span><br><span class="line">sudo apt-get install chrony</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动chrony服务</span></span><br><span class="line">sudo systemctl start chronyd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保chrony在系统启动时自动运行</span></span><br><span class="line">sudo systemctl enable chronyd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查chrony的状态，如果显示为“active（running）”，则表示已成功启动</span></span><br><span class="line">sudo systemctl status chronyd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑chrony配置文件</span></span><br><span class="line">sudo nano /etc/chrony/chrony.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到服务器行注释以下信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pool ntp.ubuntu.com        iburst maxsources 4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pool 0.ubuntu.pool.ntp.org iburst maxsources 1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pool 1.ubuntu.pool.ntp.org iburst maxsources 1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pool 2.ubuntu.pool.ntp.org iburst maxsources 2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用ntp时间服务器：国家授时中心ntp服务器、阿里云ntp服务器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到服务器行并添加您想要同步的NTP服务器地址（可以根据需要添加多个服务器），例如：</span></span><br><span class="line">server ntp1.aliyun.com iburst</span><br><span class="line">server ntp1.aliyun.com minpoll 4 maxpoll 10 iburst</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步更新时间间隔在2的4次幂到2的10次幂秒之间</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存并关闭文件。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启chrony服务以应用更改</span></span><br><span class="line">sudo systemctl restart chronyd。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后，检查时间同步状态。如果显示为“*”或“+”，则表示时间同步正在进行中</span></span><br><span class="line">chronyc tracking</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序中的bug解决</title>
      <link href="/2024/01/30/2024-1-30-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84bug%E8%A7%A3%E5%86%B3/"/>
      <url>/2024/01/30/2024-1-30-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84bug%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<ol><li>庞大时间节点分析，可以在程序中加入log书写程序来进行编写，将数据到出到文件，通过excel进行分析。</li></ol><p>log编写的方法：</p><blockquote><p>编写C++的容器（不断写入容器，再关闭时候一次放入）<br>双线程的log（一面主线程工作，一面线程用来记录log）<br><a href="https://gitee.com/hanfengdyh/code/blob/master/cv2xrxapp.cpp">log的编写思想</a></p></blockquote><ol start="2"><li><p>AG215S的通信可以用作全双工通信，双线程通信时候发生堵塞。</p><p>解决过程：将整个通信的程序做成半双工的主从机应答程序，在解决时候发现主机总会堵塞，从机没有问题，主机是发送线程开启在前无延迟，从机是接收线程开启再后中间有延迟函数，由此判断可能是延迟的问题。<br>结论： 将两个接收线程开启之间添入延时函数，这样才不会堵塞，必须错时开启。</p></li><li><p>两台设备如果服务开启失败，AG18的license过期了。<br>解决方案：沟通移远的工程师要一个，用QFlash进行烧录。</p></li><li><p>三个线程一个线程tcp发送，一个线程加锁从tcp接收线程copy数据，一个线程tcp读取，测试过程中总会出现一些丢包的情况。<br>解决过程是将代码进行分块测试，发现加锁的逻辑代码并不会造成丢包，各个线程挨个屏蔽测试发现并无影响，最后在第三个线程中发现从v2v的接收函数和tcp的发送放入一个线程会造成丢包的情况。<br>​      解决方法:将v2v和tcp四个收发部分进行分为四个线程。</p></li><li><p>将整个v2v的东西做成传输的黑盒，20ms的tcp进入黑盒，tcp发出去，经过测试v2v在4ms的周期具有最短的传输延迟，数据在经过ROS端设备到v2v的一条，从v2v另一端出来是5条数据，用结构体进行解析这个缓冲区char类型的数据，经过判别id后发出去，保证是一条数据，但是ROS端设备接收数据发现总有相同的数据被接受到。<br> 解决过程：使用正常数据经过测试发现判别逻辑没有问题，测试发现ROS端设备程序的数据结构体占240字节，在v2v的结构体将ROS::time用uint64_t进行替换后，测试为248字节，而且id信息是结构体的第三位，所以怀疑是数据ID解析出现问题。<br> 解决方法：将ROS端程序数据结构体的ID放到第一位，并且在v2v端数据传输时候将char类型数据强制转换为int类型，使用指针指向地址提取ID信息来解析，之后判别后发出程序。</p></li><li><p>实际测试过程中发现在传输字节数不变的情况下，传输间隔减小，小到超过了一个传输最优的界限时候，传输的延迟会增大。这大概率是系统频繁调度造成的一个延迟增大，还有可能是无线传输需要建立连接，短时间内的建立连接次数增大导致了时间增多。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS</title>
      <link href="/2024/01/22/2023-12-22-ROS/"/>
      <url>/2024/01/22/2023-12-22-ROS/</url>
      
        <content type="html"><![CDATA[<h2 id="ROS简介"><a href="#ROS简介" class="headerlink" title="ROS简介"></a>ROS简介</h2><p>参考教程：<a href="https://wiki.ros.org/cn">cn - ROS Wiki</a></p><p><a href="https://postimg.cc/zHFVGmLX"><img src="https://i.postimg.cc/T1ZmQffm/2024-04-01-112959.png" alt="2024-04-01-112959.png"></a></p><p>ros下编译一个hello world程序</p><p>创建工作空间，在终端上创建一个工程文件夹名为hello_ws，并在src目录下创建一个ros包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p hello_ws/src</span><br><span class="line"><span class="built_in">cd</span> hello_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">cd</span> /src</span><br><span class="line">catkin_create_pkg hello_world roscpp std_msgs</span><br></pre></td></tr></table></figure><p>roscpp和std_msgs是hello_world的依赖项。</p><p>进入<code>hello_world包的目录，并创建一个名为</code>hello.cpp&#96;的C++源文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/hello_ws/src/hello_world/src</span><br><span class="line">vi hello.cpp</span><br></pre></td></tr></table></figure><p>编辑<code>hello.cpp</code>文件，并添加以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，将这包中的源文件添加到hello_world包中的<code>CMakeLists.txt</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(hello_node src/hello.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(hello_node $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p>最后，编译ROS包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/hello_ws</span><br><span class="line">catkin_make                <span class="comment">#编译</span></span><br><span class="line"><span class="built_in">source</span> devel/setup.bash <span class="comment">#构建环境</span></span><br></pre></td></tr></table></figure><p>在另一个终端中启动ROS核心：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore <span class="comment">#主节点</span></span><br></pre></td></tr></table></figure><p>在之前的终端中运行发布者节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun hello_world hello_node</span><br></pre></td></tr></table></figure><p>现在，就可以在ros环境下打印出hello world。</p><blockquote><p><u>以下是一个工作空间的正常目录</u>：</p></blockquote><p><img src="https://img2.imgtp.com/2024/04/01/PNYTfFyO.png" alt="屏幕截图 2024-04-01 154108.png"></p><p>话题和服务的区别</p><p><img src="https://img2.imgtp.com/2024/04/01/qiH0hJXW.png" alt="屏幕截图 2024-04-01 152042.png"></p><p>服务</p><p>在ROS中，服务（Service）用于实现节点之间的请求-响应通信模式。服务允许一个节点向另一个节点发送请求，并等待该节点的响应。服务通常用于执行一些计算密集型或耗时的任务，或者获取节点的状态信息。</p><blockquote><p><u>在ROS中创建并使用服务（Service）</u></p></blockquote><p><strong>创建服务文件：</strong></p><p>   在ROS软件包中创建<code>srv</code>目录，并在其中创建服务文件。服务文件使用<code>.srv</code>扩展名。例如，创建一个名为<code>MyService.srv</code>的服务文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir srv</span><br><span class="line">vi MyService.srv</span><br></pre></td></tr></table></figure><p><strong>定义服务消息结构</strong>：</p><ol><li>打开您服务文件<code>MyService.srv</code>，并在其中定义服务消息结构。服务消息结构由请求和响应组成。请求和响应。这两部分用一条<code>---</code>线隔开，例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure><p><strong>编辑</strong><code>**CMakeLists.txt**</code><strong>文件</strong>：</p><ol><li>在您的ROS软件包目录中，打开<code>CMakeLists.txt</code>文件，并确保它包含了正确的服务生成器指令。将以下行添加到<code>CMakeLists.txt</code>文件中：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_service_files(</span><br><span class="line">  FILES</span><br><span class="line">  MyService.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>构建您的软件包</strong>：</p><ol><li>返回到您的工作空间目录，并运行<code>catkin_make</code>来构建您的软件包。这将编译并生成您的服务代码。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p><strong>使用服务</strong>：</p><ol><li>在您的ROS节点中，您可以使用<code>rospy</code>或<code>roscpp</code>等库来编写服务的客户端和服务器端。首先，确保您的节点依赖于生成的消息包。然后，在您的节点代码中导入所需的服务消息，并编写客户端和服务器端的逻辑。</li></ol><p><strong>服务器端</strong>：</p><p>创建一个ROS节点来处理服务请求，</p><ul><li><strong>客户端</strong>：</li></ul><p>在另一个节点中，创建一个服务客户端来发送请求，并处理响应。</p><h3 id="ros下创建服务端和客户端"><a href="#ros下创建服务端和客户端" class="headerlink" title="ros下创建服务端和客户端"></a>ros下创建服务端和客户端</h3><p>以下为写两个数相加的客服端和服务端代码</p><p>创建一个软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg  beginner_tutorials std_msgs rospy roscpp</span><br></pre></td></tr></table></figure><p>同理在软件包下面创建srv文件夹，里面写srv的文件，命名AddTwoInts.srv</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure><p>在src文件夹下编写服务器端文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端代码 server.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;beginner_tutorials/AddTwoInts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(beginner_tutorials::AddTwoInts::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         beginner_tutorials::AddTwoInts::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  res.sum = req.a + req.b;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;request: x=%ld, y=%ld&quot;</span>, (<span class="type">long</span> <span class="type">int</span>)req.a, (<span class="type">long</span> <span class="type">int</span>)req.b);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;sending back response: [%ld]&quot;</span>, (<span class="type">long</span> <span class="type">int</span>)res.sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_two_ints_server&quot;</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  ros::ServiceServer service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;add_two_ints&quot;</span>, add);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to add two ints.&quot;</span>);</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客服端文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码 client.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;beginner_tutorials/AddTwoInts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_two_ints_client&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;usage: add_two_ints_client X Y&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  ros::ServiceClient client = n.<span class="built_in">serviceClient</span>&lt;beginner_tutorials::AddTwoInts&gt;(<span class="string">&quot;add_two_ints&quot;</span>);</span><br><span class="line">  beginner_tutorials::AddTwoInts srv;</span><br><span class="line">  srv.request.a = <span class="built_in">atoll</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  srv.request.b = <span class="built_in">atoll</span>(argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">if</span> (client.<span class="built_in">call</span>(srv))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Sum: %ld&quot;</span>, (<span class="type">long</span> <span class="type">int</span>)srv.response.sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Failed to call service add_two_ints&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后修改CMakeLists.txt文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(beginner_tutorials)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_service_files(</span><br><span class="line">  FILES</span><br><span class="line">  AddTwoInts.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(add_two_ints_server src/server.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(add_two_ints_server <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(add_two_ints_server <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(add_two_ints_client src/client.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(add_two_ints_client <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(add_two_ints_client <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><h3 id="ros下如何创建消息"><a href="#ros下如何创建消息" class="headerlink" title="ros下如何创建消息"></a>ros下如何创建消息</h3><p>在刚在hello_world的软件包下，创建一个名为<code>msg</code>的文件夹，用于存放自定义消息文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir msg</span><br></pre></td></tr></table></figure><p>创建一个名为<code>MyMessage.msg</code>的文件，并在其中定义消息结构。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string data</span><br><span class="line">int32 value</span><br></pre></td></tr></table></figure><p>在软件包目录中，打开<code>CMakeLists.txt</code>文件将以下行添加到<code>CMakeLists.txt</code>文件中：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  MyMessage.msg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>之后退出编译后，生成的.h文件会出现在devel&#x2F;include目录下。</p><h3 id="ROS中订阅节点和发布节点"><a href="#ROS中订阅节点和发布节点" class="headerlink" title="ROS中订阅节点和发布节点"></a>ROS中订阅节点和发布节点</h3><blockquote><p>ros节点间进行通信的主要机制是发送和接收消息，不同的消息分门别类的组织起来，组织结构被成为话题，节点可以将消息发布到特定的话题，也可以订阅话题从而获取接收消息。</p></blockquote><p><strong>节点是执行某些动作的进程，节点发布消息，并由其他节点接收消息，这些发布的消息，在ros中称为话题。</strong></p><p>以下是如何使用C++编写一个ROS程序，其中包括一个发布者节点和一个订阅者节点，用于发送和接收”Hello, World!”消息。</p><p>首先，确保您已经创建了一个ROS工作空间（如果没有，请先创建）。</p><p>创建一个名为<code>catkin_ws</code>的工程文件夹以及一个<code>hello_world</code>ROS包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg hello_world roscpp std_msgs</span><br></pre></td></tr></table></figure><p>进入<code>hello_world</code>包下的src目录，并创建一个名为<code>hello_publisher.cpp</code>的C++源文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/hello_world/src</span><br><span class="line">vi hello_publisher.cpp</span><br></pre></td></tr></table></figure><p>编辑<code>hello_publisher.cpp</code>文件，并添加以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;hello_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建节点句柄</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个Publisher，发布名为 &quot;hello_topic&quot; 的String消息</span></span><br><span class="line">  ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;hello_topic&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置发布频率为1Hz</span></span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 创建一个String类型的消息</span></span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    msg.data = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">    pub.<span class="built_in">publish</span>(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印发布的消息</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publishing: %s&quot;</span>, msg.data.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照指定的频率休眠</span></span><br><span class="line">    rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个名为<code>hello_subscriber.cpp</code>的C++源文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi hello_subscriber.cpp</span><br></pre></td></tr></table></figure><p>编辑<code>hello_subscriber.cpp</code>文件，并添加以下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数，用于处理收到的消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chatterCallback</span><span class="params">(<span class="type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Received: [%s]&quot;</span>, msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;hello_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建节点句柄</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个Subscriber，订阅名为 &quot;hello_topic&quot; 的String消息，当有消息到来时，调用回调函数chatterCallback</span></span><br><span class="line">  ros::Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;hello_topic&quot;</span>, <span class="number">10</span>, chatterCallback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入事件循环</span></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这两个源文件添加包中的<code>CMakeLists.txt</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_executable(hello_publisher src/hello_publisher.cpp)</span><br><span class="line">add_executable(hello_subscriber src/hello_subscriber.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(hello_publisher $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">target_link_libraries(hello_subscriber $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p>最后，编译ROS包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>在一个终端中启动ROS核心：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>在另一个终端中运行发布者节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line">rosrun hello_world_cpp hello_publisher</span><br></pre></td></tr></table></figure><p>在第三个终端中运行订阅者节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line">rosrun hello_world_cpp hello_subscriber</span><br></pre></td></tr></table></figure><p>现在，您应该能够在订阅者节点的终端中看到打印出的消息：”Received: Hello, World!”。这样就完成了一个简单的ROS节点的创建和通信。</p><p><a href="https://postimg.cc/YLMrJKLM"><img src="https://i.postimg.cc/sxZMG3VQ/123.png" alt="123.png"></a></p><h2 id="ROS下多个节点执行"><a href="#ROS下多个节点执行" class="headerlink" title="ROS下多个节点执行"></a>ROS下多个节点执行</h2><p>假如我的文件构造结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">|-- src/</span><br><span class="line">|   |-- package1/</span><br><span class="line">|   |   |-- CMakeLists.txt</span><br><span class="line">|   |   |-- package.xml</span><br><span class="line">|   |   |-- src/</span><br><span class="line">|   |       |-- node1.cpp</span><br><span class="line">|   |       |-- node2.cpp</span><br><span class="line">|   |-- package2/</span><br><span class="line">|       |-- CMakeLists.txt</span><br><span class="line">|       |-- package.xml</span><br><span class="line">|       |-- src/</span><br><span class="line">|           |-- node3.cpp</span><br><span class="line">|           |-- node4.cpp</span><br><span class="line">|-- launch/</span><br><span class="line">|   |-- all_nodes.launch</span><br></pre></td></tr></table></figure><p>将多个包的多个节点放入到all_nodes.launch文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">  &lt;!-- 启动 package1 中的节点 --&gt;</span><br><span class="line">  &lt;node pkg=&quot;package1&quot; type=&quot;node1&quot; name=&quot;node1&quot; output=&quot;screen&quot;/&gt;</span><br><span class="line">  &lt;node pkg=&quot;package1&quot; type=&quot;node2&quot; name=&quot;node2&quot; output=&quot;screen&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 启动 package2 中的节点 --&gt;</span><br><span class="line">  &lt;node pkg=&quot;package2&quot; type=&quot;node3&quot; name=&quot;node3&quot; output=&quot;screen&quot;/&gt;</span><br><span class="line">  &lt;node pkg=&quot;package2&quot; type=&quot;node4&quot; name=&quot;node4&quot; output=&quot;screen&quot;/&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p>之后在工作空间的目录下进行编译后执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source devel/setup.bash</span><br><span class="line">catkin_make</span><br><span class="line">roslaunch launch/my_launch_file.launch</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP</title>
      <link href="/2024/01/05/2024-1-5-tcp/"/>
      <url>/2024/01/05/2024-1-5-tcp/</url>
      
        <content type="html"><![CDATA[<h1 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h1><p>TCP（传输控制协议，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的通信协议。它是互联网协议套件（TCP&#x2F;IP协议栈）的一部分，用于在网络上可靠地传输数据。</p><p>以下是 TCP 协议的主要特点和介绍：</p><ol><li><p><strong>可靠性：</strong> TCP 提供可靠的、面向连接的通信。通过使用确认机制和超时重传机制，确保数据的可靠性传输。如果数据包在传输过程中丢失或损坏，TCP 会负责重新发送丢失的数据。</p></li><li><p><strong>面向连接：</strong> 在进行数据传输之前，TCP 首先在通信的两端建立连接。这个连接是全双工的，双方可以同时进行数据的收发。连接的建立、维护和释放是由 TCP 协议负责的。</p></li><li><p><strong>流控制：</strong> TCP 使用流控制机制来防止发送方发送过多的数据导致接收方无法处理。通过窗口大小的动态调整，TCP 可以在发送和接收之间实现平衡。</p></li><li><p><strong>拥塞控制：</strong> TCP 通过拥塞控制机制来适应网络的变化。它通过监测网络的拥塞状况来调整数据的传输速率，以避免过多的数据导致网络拥塞。</p></li><li><p><strong>字节流传输：</strong> TCP 将数据看作是字节流，而不是分割成独立的消息。这意味着发送的数据可以按照任意大小的块进行划分，而接收方会将它们重新组装成完整的字节流。</p></li><li><p><strong>面向字节流而非报文：</strong> TCP 将数据看作是一连串的字节而非报文。这使得它更加灵活，但也需要应用层协议来确定消息的边界。</p><p><a href="https://postimg.cc/5QjGgpk2"><img src="https://i.postimg.cc/8cbS10RM/2024-01-04-113024.png" alt="2024-01-04-113024.png"></a></p></li></ol><h3 id="tcp服务端"><a href="#tcp服务端" class="headerlink" title="tcp服务端"></a>tcp服务端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex coutMutex;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">GetCurrentTimestamp</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> time_point = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;time_point), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleClient</span><span class="params">(<span class="type">int</span> clientSocket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    std::<span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="comment">// 启动接收消息的线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">receiveThread</span><span class="params">([&amp;]() </span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span>(<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 读取客户端发送的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">ssize_t</span> bytesRead = recv(clientSocket, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span>(bytesRead &lt;= <span class="number">0</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; GetCurrentTimestamp() &lt;&lt; <span class="string">&quot;] Error reading from client\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;<span class="keyword">else</span>&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                </span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock(coutMutex);</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; GetCurrentTimestamp() &lt;&lt; <span class="string">&quot;] Received from client: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="comment">// 发送响应给客户端</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">char</span>* response = <span class="string">&quot;Hello from server!&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">ssize_t</span> bytesSent = send(clientSocket, response, std::strlen(response), <span class="number">0</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span>(bytesSent &lt;= <span class="number">0</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">                &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; GetCurrentTimestamp() &lt;&lt; <span class="string">&quot;] Error sending response to client\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 清空缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">            std::memset(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动发送消息的线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">sendThread</span><span class="params">([&amp;]() </span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::string message;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; GetCurrentTimestamp() &lt;&lt; <span class="string">&quot;] Enter message to send (or &#x27;exit&#x27; to quit): &quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::getline(std::cin, message);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 发送消息到客户端</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">ssize_t</span> bytesSent = send(clientSocket, message.c_str(), message.length(), <span class="number">0</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (bytesSent &lt;= <span class="number">0</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; GetCurrentTimestamp() &lt;&lt; <span class="string">&quot;] Error sending message to client\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (message == <span class="string">&quot;exit&quot;</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; GetCurrentTimestamp() &lt;&lt; <span class="string">&quot;] Exiting...\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    receiveThread.<span class="built_in">join</span>();</span><br><span class="line">    sendThread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// 关闭客户端套接字</span></span><br><span class="line">    <span class="built_in">close</span>(clientSocket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="type">int</span> serverSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serverSocket == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Error creating socket\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(serverSocket, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="built_in">sizeof</span>(reuse)) == <span class="number">-1</span>)  &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Error setting socket options\n&quot;</span>;</span><br><span class="line">        <span class="built_in">close</span>(serverSocket);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置服务器地址和端口</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddress;</span><br><span class="line">    std::<span class="built_in">memset</span>(&amp;serverAddress, <span class="number">0</span>, <span class="built_in">sizeof</span>(serverAddress));</span><br><span class="line">    serverAddress.sin_family = AF_INET;</span><br><span class="line">    serverAddress.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 绑定到所有可用的接口</span></span><br><span class="line">    serverAddress.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serverSocket, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr*&gt;(&amp;serverAddress), <span class="built_in">sizeof</span>(serverAddress)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Error binding address\n&quot;</span>;</span><br><span class="line">        <span class="built_in">close</span>(serverSocket);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serverSocket, <span class="number">5</span>) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Error listening for connections\n&quot;</span>;</span><br><span class="line">        <span class="built_in">close</span>(serverSocket);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Server listening on port 8888\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientAddress;</span><br><span class="line">        <span class="type">socklen_t</span> clientAddressLength = <span class="built_in">sizeof</span>(clientAddress);</span><br><span class="line">        <span class="type">int</span> clientSocket = <span class="built_in">accept</span>(serverSocket, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr*&gt;(&amp;clientAddress), &amp;clientAddressLength);</span><br><span class="line">        <span class="keyword">if</span>(clientSocket == <span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Error accepting connection\n&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在新线程中处理客户端</span></span><br><span class="line">        std::<span class="built_in">thread</span>(HandleClient, clientSocket).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭服务器套接字</span></span><br><span class="line">    <span class="built_in">close</span>(serverSocket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tcp客户端"><a href="#tcp客户端" class="headerlink" title="tcp客户端"></a>tcp客户端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex coutMutex;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">GetCurrentTimestamp</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> time_point = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;time_point), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReceiveMessages</span><span class="params">(<span class="type">int</span> clientSocket)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    std::<span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取服务器发送的数据</span></span><br><span class="line">        <span class="type">ssize_t</span> bytesRead = <span class="built_in">recv</span>(clientSocket, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(bytesRead &lt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Error reading from server\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(coutMutex);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Received from server: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清空缓冲区</span></span><br><span class="line">        std::<span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendMessages</span><span class="params">(<span class="type">int</span> clientSocket)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">std::string message;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Enter message to send (or &#x27;exit&#x27; to quit): &quot;</span>;</span><br><span class="line">        std::<span class="built_in">getline</span>(std::cin, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息到服务器</span></span><br><span class="line">        <span class="type">ssize_t</span> bytesSent = <span class="built_in">send</span>(clientSocket, message.<span class="built_in">c_str</span>(), message.<span class="built_in">length</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(bytesSent &lt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Error sending message to server\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(message == <span class="string">&quot;exit&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Exiting...\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="type">int</span> clientSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientSocket == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Error creating socket\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址和端口</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddress;</span><br><span class="line">    std::<span class="built_in">memset</span>(&amp;serverAddress, <span class="number">0</span>, <span class="built_in">sizeof</span>(serverAddress));</span><br><span class="line">    serverAddress.sin_family = AF_INET;</span><br><span class="line">    serverAddress.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serverAddress.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(clientSocket, <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">struct</span> sockaddr*&gt;(&amp;serverAddress), <span class="built_in">sizeof</span>(serverAddress)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">GetCurrentTimestamp</span>() &lt;&lt; <span class="string">&quot;] Error connecting to server\n&quot;</span>;</span><br><span class="line">        <span class="built_in">close</span>(clientSocket);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动接收消息的线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">receiveThread</span><span class="params">(ReceiveMessages, clientSocket)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动发送消息的线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">sendThread</span><span class="params">(SendMessages, clientSocket)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    receiveThread.<span class="built_in">join</span>();</span><br><span class="line">    sendThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    <span class="built_in">close</span>(clientSocket);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>socket函数</strong></p><p>套接字初始化，根据需求设置套接字，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int socket(int __domain, int __type, int __[protocol])</span><br><span class="line">/*__domain 协议族，如IPV4，IPV6</span><br><span class="line">  __type 套接字类型 SOCK_STREAM字节流套接字，SOCK_DGRAM数据报套接字，SOCK_RAW原始套接字</span><br><span class="line">  __protocol 协议编号 IPPROTO_TCPTCP传输协议，IPPROTO_UDPUDP传输协议</span><br><span class="line">  返回新套接字的文件描述符，或-1表示错误，错误可通过errno获得。 </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><strong>bind函数</strong></p><p>函数功能：套接字与端口绑定，即将套接字与地址结构进行绑定，绑定之后，在进行网络程序设计时，套接字所代表IP地址和端口地址及协议类型等参数按绑定值进行操作。<br>将套接字描述符（FD）与本机网络地址ADDR(长度为LEN字节)和端口号绑定在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">bind</span> <span class="params">(<span class="type">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="type">socklen_t</span> __len)</span> __THROW</span>; </span><br><span class="line"><span class="comment">/*1.__fd：套接字描述符</span></span><br><span class="line"><span class="comment">socket()函数创建的文件描述符。</span></span><br><span class="line"><span class="comment">2.__addr：地址（指向特定协议的地址结构的指针）：</span></span><br><span class="line"><span class="comment">包含地址相关信息：名称、端口、IP地址。</span></span><br><span class="line"><span class="comment">（note:需先将地址结构中的数值先设置后才可进行绑定）</span></span><br><span class="line"><span class="comment">3.__len：该地址结构的长度：</span></span><br><span class="line"><span class="comment">可设置为 sizeof(struct sockaddr)。 </span></span><br><span class="line"><span class="comment">返回：0表示成功，-1表示错误，错误可通过errno获得。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>connect函数</strong></p><p>函数功能：连接指定参数的服务器。客户端建立套接字之后，无需进行地址绑定，直接连接服务器。<br>在套接字FD上打开一个连接以对等地址ADDR(长度为LEN字节)。对于无连接套接字类型，只需设置发送到的默认地址和接收传输的唯一地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">connect</span> <span class="params">(<span class="type">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="type">socklen_t</span> __len)</span></span>; </span><br><span class="line"><span class="comment">/*1.__fd：套接字描述符</span></span><br><span class="line"><span class="comment">socket()函数创建的文件描述符。</span></span><br><span class="line"><span class="comment">2.__addr：地址（指向特定协议的地址结构的指针）：</span></span><br><span class="line"><span class="comment">存储远程计算机的IP地址和端口信息的结构。</span></span><br><span class="line"><span class="comment">3.__len：该地址结构的长度</span></span><br><span class="line"><span class="comment">成功返回0，错误返回-1,错误可通过errno获得。 */</span></span><br></pre></td></tr></table></figure><p><strong>listen服务器函数</strong></p><p>函数功能：设置服务器侦听连接，初始化服务器可连接队列，由于服务器需满足多个客户端连接请求，而服务器在某时间仅能处理有限个数的客户端连接请求，故服务器需设置队列长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">listen</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">int</span> __n)</span> __THROW</span>;</span><br><span class="line"><span class="comment">/*1.int __fd:套接字描述符</span></span><br><span class="line"><span class="comment">2.__n:套接字排队的最大连接个数(建议5~10)*/</span></span><br></pre></td></tr></table></figure><p><strong>accept服务器函数</strong></p><p>函数功能：接收客户端连接。当客户端的连接请求到达服务器主机侦听的端口时，此时客户端连接会在队列中等待，直到使用服务器处理接收请求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">accept</span> <span class="params">(<span class="type">int</span> __fd, __SOCKADDR_ARG __addr,<span class="type">socklen_t</span> *__restrict __addr_len)</span></span>;</span><br><span class="line"><span class="comment">/*1.int __fd:套接字描述符</span></span><br><span class="line"><span class="comment">2.__addr：地址（指向特定协议的地址结构的指针）</span></span><br><span class="line"><span class="comment">3.__addr_len:所指内容的长度</span></span><br><span class="line"><span class="comment">成功返回新套接口文件描述符表示客户端连接，客户端连接的信息可通过该描述符获得。</span></span><br><span class="line"><span class="comment">错误返回-1。*/</span></span><br></pre></td></tr></table></figure><p><strong>send()函数与recv()函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">ssize_t</span> <span class="title">send</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">const</span> <span class="type">void</span> *__buf, <span class="type">size_t</span> __n, <span class="type">int</span> __flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">ssize_t</span> <span class="title">recv</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">void</span> *__buf, <span class="type">size_t</span> __n, <span class="type">int</span> __flags)</span></span>; </span><br><span class="line"><span class="comment">/*1.__fd：套接字描述符：</span></span><br><span class="line"><span class="comment">2.__buf：指向想 发送消息/接收消息 数据的缓冲区地址的指针</span></span><br><span class="line"><span class="comment">3. __n：想要 发送消息/接收消息 缓冲区的最大尺寸</span></span><br><span class="line"><span class="comment">4.__flags:发送/接收标记(一般设置0)*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式面试题</title>
      <link href="/2023/11/22/2023-11-22-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/11/22/2023-11-22-%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>memcpy和strcpy的区别？</strong></p><p>1）、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</p><p>2）、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</p><p>3）、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p><p><strong>信号量与互斥锁的区别？</strong></p><p>（1）、互斥锁用于线程的互斥，信号量用于线程的同步。</p><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p><p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p><p>（2）、互斥量值只能为0&#x2F;1，信号量值可以为非负整数。</p><p>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。</p><p>（3）、互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p><p><strong>简述程序编译过程？</strong></p><p>预处理：预处理相当于根据预处理命令组装成新的C程序，不过常以i为扩展名。</p><p>编译： 将得到的i文件翻译成汇编代码.s文件。</p><p>汇编：将汇编文件翻译成机器指令，并打包成可重定位目标程序的O文件。该文件是二进制文件。</p><p>链接：将引用的其他O文件并入到我们程序所在的o文件中，处理得到最终的可执行文件。</p><p><strong>TCP服务器搭建流程？</strong></p><p>Socket套接字就是网络上<a href="https://so.csdn.net/so/search?q=%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1&spm=1001.2101.3001.7020">进程通信</a>的一端，提供了应用层进程利用网络协议交换数据的机制。</p><ul><li>1、创建套接字socket ()</li><li>2、保存服务器信息</li><li>3、套接字绑定</li><li>4、 监听客户端连接请求</li><li>5、 接收客户端连接请求</li><li>6、数据收发</li><li>7、关闭套接字</li></ul><p><strong>socket三次握手四次挥手</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20193938.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-22%20194034.png"></p><p><strong>什么是进程线程？</strong></p><p>进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，</p><p>线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p><p><strong>父进程与子进程的关系和区别？</strong></p><p>fork出子进程后，子进程都会继承父进程以下信息：</p><ul><li>文件描述符</li><li>实际用户ID，实际组ID，有效用户ID，有效组ID</li><li>进程组ID</li><li>添加组ID</li><li>对话期ID</li><li>控制终端</li><li>设置-用户-ID标志和设置-组-ID标志</li><li>当前工作目录</li><li>根目录</li><li>文件方式创建字</li><li>信号屏蔽和排列</li><li>对任意打开文件描述符大的在执行时关闭标志</li><li>环境</li><li>接的共享存储段</li><li>资源限制</li></ul><p><strong>区别</strong>：</p><ul><li>fork的返回值</li><li>进程ID</li><li>不同的父进程ID</li><li>子进程的tms_utime、tms_stime、tms_sutime、tms_ustime设置为0</li><li>父进程设置的锁，子进程不继承</li><li>子进程的未决告警被清除</li><li>子进程的未决信号集设置为空集</li></ul><p><strong>多进程、多线程同步（通讯）的方法？</strong></p><p>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<br>有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。<br>高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。<br>信号量( semophore ) ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br>消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br>信号 ( sinal ) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>共享内存( sharedmemory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。<br>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><p><strong>什么是线程同步和互斥</strong></p><p>线程同步：每个线程之间按预定的先后次序进行运行，协同、协助、互相配合。可以理解成“你说完，我再做”。有了线程同步，每个线程才不是自己做自己的事情，而是协同完成某件大事。</p><p>线程互斥：当有若干个线程访问同一块资源时，规定同一时间只有一个线程可以得到访问权，其它线程需要等占用资源者释放该资源才可以申请访问。线程互斥可以看成是一种特殊的线程同步</p><p><strong>线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？</strong></p><p>同步是个过程，阻塞是线程的一种状态。多个线程操作共享变量时可能会出现竞争。这时需要同步来防止两个以上的线程同时进入临界区，在这个过程中，后进入临界区的线程将阻塞，等待先进入的线程走出临界区。<br>线程同步不一定发生阻塞，线程同步的时候，需要协调推进速度，互相等待和互相唤醒会发生阻塞。</p><p><strong>并发，同步，异步，互斥，阻塞，非阻塞的理解</strong></p><p><strong>并发(concurrency)<strong>：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥。<br>1.<strong>互斥</strong>：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。　　<br>2.<strong>同步</strong>：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的</strong>有序访问</strong>。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。<br>**异步(asynchronous)**：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。</p><p><strong>阻塞</strong>和<strong>非阻塞</strong>是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式。阻塞方式下读取或者写入函数将<strong>一直等待</strong>，而非阻塞方式下，读取或者写入函数会<strong>立即返回</strong>一个状态值。<br>一般来说IO模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。<br><strong>同步阻塞IO</strong> ：用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。<br><strong>同步非阻塞IO</strong> ：用户进程发起一个IO操作以后可返回做其它事情， 但是用户进程需要时<strong>不时的询问</strong> IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。应用发起一个IO操作以后，使用阻塞<strong>select系统调用</strong> 来等待 I&#x2F;O可用的通知。 select 调用非常有趣的是它可以用来为多个IO描述符提供通知，而不仅仅为一个描述符提供通知。<br>异步阻塞IO ：应用发起一个IO操作以后，不等待内核IO操作的完成， 等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别同步必须等待或者主动的去询问IO是否完成。</p><p><strong>孤儿进程、僵尸进程、守护进程的概念</strong></p><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为<strong>孤儿进程</strong>。孤儿进程将被<strong>init进程</strong>所收养，并由init进程对它们完成状态收集工作。<br>一个进程使用<strong>fork创建子进程</strong>，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么<strong>子进程的进程描述符</strong>仍然保存在系统中。这种进程称之为<strong>僵死进程</strong>。</p><p><strong>正确处理僵尸进程的方法</strong></p><p>1.子进程退出时<strong>向父进程发送SIGCHILD信号</strong>，父进程处理SIGCHILD信号。在信号处理函数中<strong>调用wait</strong>进行处理僵尸进程。<br>2.<strong>把父进程杀掉</strong>。父进程死后，僵尸进程成为”孤儿进程”，过继给进程init，init始终会负责清理僵尸进程。它产生的所有僵尸进程也跟着消失。<br><strong>fork两次</strong>，父进程fork一个子进程，然后继续工作，子进程fork一 个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收 还要自己做。<br>两次fork的原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过<strong>init进程可以处理僵尸进程</strong>。</p><p><strong>系统调用作用？</strong></p><p>(1)  系统调用可以为用户空间提供访问硬件资源的统一接口，以至于应用程序不必去关 注具体的硬件访问操作。<br>(2)  系统调用可以对系统进行保护，保证系统的稳定和安全。系统调用的存在规定了用 户进程进入内核的具体方式，</p><p><strong>用户态和内核态的区别</strong>？</p><p>内核态和用户态是操作系统中的两种运行模式。 内核态是操作系统运行在特权级别最高的模式下，具有访问系统资源和执行特权指令的能力。 在内核态下，操作系统拥有完全的控制权，可以直接访问硬件设备和系统资源。 操作系统的内核代码运行在内核态下，可以执行诸如管理进程、内存管理、文件系统等核心功能的操作。 用户态是应用程序运行在较低特权级别下的模式。</p><p><strong>Linux内核同步方式总结</strong>。</p><p><strong>1.per-cpu 变量</strong>：将内核变量声明为per-cpu变量，它的数据结构是数组，系统的每个CPU对应数组中的一个元素，一个CPU只能修改自己对应的元素，不用担心竞争条件。per-cpu只能对来自不同CPU的并发访问提供保护，但对自身的异步函数（中断处理函数和可延迟函数）的访问不提供保护，需要同步原语</p><p><strong>2.原子操作</strong>（linux中有一个专门的atomic_t类型）：操作在芯片级是原子的，原子操作必须以单个指令执行，中间不能中断，且避免其他的CPU访问同一存储器单元。</p><p>**3.优化屏障(optimization barrier)和内存屏障(memory barrier)**：现代编译器可能重新安排汇编语言指令的吮吸，CPU通常并行的执行多条指令，且可能重新安排内存访问，但是，当处理同步时，必须避免指令重新排序，如果放在同步原语之后的一条指令在同步原语之前被执行，就很糟糕！内存屏障：确保在原语之后的操作开始执行之前，原语之前的操作已经完成。mb(), smp_mb();</p><p><strong>4.spin lock</strong>：当内核控制路径必须访问共享数据结构或进入临界区时，需要锁，spin lock的循环指令表示“忙等”，即使等待的内核控制路径无事可做，它也在CPU上保持运行</p><p><strong>5.读写spin lock</strong>：它的引入主要是为了增加内核的并发能力，只要没有内核路径对数据结构进行修改，读写spin lock允许多个内核控制路径同时读同一个数据结构。但是写者需要独占。</p><p><strong>6.顺序锁</strong>：读写spin lock中读者和写着有相同的优先级，当读者多的时候，可能出现一种情况，写着一直得不到服务，可能饥饿。引入顺序锁(seqlock)，它与读写spin lock非常相似，但是它赋予写着较高的优先级。</p><p><strong>7.RCU（read-copy update）</strong>：是为了保护在多数情况下被多个CPU读的数据结构而设计的另一种同步方式。RCU允许多个读者和写者并发执行，而且RCU不使用锁。</p><p><strong>为什么需要BootLoader？</strong></p><p><strong>BootLoader</strong>就是在操作系统运行之前运行的一段小程序。通过这段小程序，<strong>可以初始化硬件设备</strong>，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统做好准备。</p><p><strong>为什么自旋锁不能睡眠 而在拥有信号量时就可以？</strong></p><p>自旋锁自旋锁禁止处理器抢占；而信号量不禁止处理器抢占。</p><p>　　基于这个原因，如果自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其他系统进程将都不能获得CPU而运行，因此不能唤醒睡眠的自旋锁，因此系统将不响应任何操作(除了中断或多核的情况，下面会讨论)。而信号量在临界区睡眠后，其他进程可以用抢占的方式继续运行，从而可以实现内存拷贝等功能而使得睡眠的信号量程序由于获得了等待的资源而被唤醒，从而恢复了正常的代码运行。</p><p><strong>linux下检查内存状态的命令</strong></p><p>top、 free、 cat &#x2F;proc&#x2F;meminfo</p><p><strong>产生死锁的四个必要条件</strong></p><p>① 互斥条件——进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占有。<br>② 请求和保持条件——当进程因请求资源而阻塞时，对已获得的资源保持不放。<br>③ 不剥夺条件——进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。<br>④ 环路等待条件——在发生死锁时必然存在一个“进程—资源”的环形链。</p><p><strong>解决死锁的基本方法（四种）</strong>： </p><p>① 预防死锁——通过设置某些限制条件，以 破坏产生死锁的四个必要条件中的一个或几个 ，来防止发生死锁。<br>② 避免死锁——在资源的动态分配过程中，使用某种方法去 防止系统进入不安全状态 ，从而避免了死锁的发生。</p><p><strong>硬链接和软连接</strong></p><p>软连接可以是任意文件或目录，可以链接不同文件系统的文件，在对符号文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身，这一点类似于 Windows 操作系统下的快捷方式</p><p>在 Linux 中，多个文件名指向同一索引节点是存在的，所以硬连接指通过索引节点来进行的连接，即每一个硬链接都是一个指向对应区域的文件。</p><p><strong>说明总线接口USART、I2C、USB的异同点(串&#x2F;并、速度、全&#x2F;半双工、总线拓扑等)</strong></p><p><a href="https://so.csdn.net/so/search?q=UART&spm=1001.2101.3001.7020">UART</a>：通用异步串行口，速率不快，可全双工，结构上一般由波特率产生器、UART发送器、UART接收器组成，硬件上两线，一收一发。</p><p>I2C：双向、两线、串行、多主控接口标准。速率不快，半双工，同步接口，具有总线仲裁机制，非常适合器件间近距离经常性<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1&spm=1001.2101.3001.7020">数据通信</a>，可实现设备组网。</p><p>SPI：高速同步串行口，高速，可全双工，收发独立，同步接口，可实现多个SPI设备互联，硬件3~4线。</p><p>USB：通用串行总线，高速，半双工，由主机、hub、设备组成。设备可以与下级hub相连构成星型结构</p><p><strong>写出计算机网络五层模型，每一层对应的协议</strong></p><p>计算机网络五层模型如下：<br>物理层：负责物理传输介质上的比特流传输，例如光纤、网线等。常用协议有：RS-232、V.35、10Base-T等。<br>数据链路层：负责将比特流划分为数据帧并进行差错检测和纠正，同时也进行物理寻址和流量控制。常用协议有：以太网、令牌环、HDLC、PPP等。<br>网络层：负责数据的路由选择和分组转发，将数据包发送到目标地址。常用协议有：IP、ICMP、ARP、RIP、OSPF、BGP等。<br>传输层：提供可靠的端到端的数据传输，负责数据的分段、排序、传输错误恢复等。常用协议有：TCP、UDP等。<br>应用层：为用户提供各种网络应用服务，如电子邮件、文件传输、远程登录、Web服务等。常用协议有：HTTP、SMTP、POP3、FTP、Telnet等。</p><p><strong>C／C++程序 内存分布情况 常量所在的区</strong></p><p>C&#x2F;C++程序内存分布情况通常可以分为以下几个区域：  代码区（text segment）：存放程序执行代码的区域，通常是只读的。该区域的内容在程序执行时不能被修改。  数据区（data segment）：存放已经初始化的全局变量和静态变量（包括全局和静态变量的指针）的区域。  BSS区（bss segment）：存放未初始化的全局变量和静态变量的区域，该区域的值默认初始化为0。  栈区（stack segment）：存放函数调用时的局部变量、函数参数和返回地址等信息。栈空间是由操作系统自动分配和回收的，它的大小通常是固定的，不能随意增加。栈空间是向下增长的，也就是说，栈顶的地址是越来越小的。  堆区（heap segment）：存放由程序员手动申请的内存空间，大小可以动态增加或减少。堆空间是由程序员手动管理的，程序员需要负责在使用完毕后将其释放。堆空间是向上增长的，也就是说，堆顶的地址是越来越大的。</p><p><strong>linux7种文件设备类型</strong></p><p>Linux中文件设备类型有7种，分别是：块设备（block）、字符设备（character）、套接字（socket）、符号链接（symbolic link）、FIFO、目录（directory）和文件（regular file）。</p><p><strong>Linux开发板写一个SPI的驱动</strong></p><p><strong>注册SPI驱动</strong></p><ul><li>使用<code>spi_register_driver</code>函数注册SPI驱动，指定驱动的probe和remove函数。</li></ul><p><strong>probe函数</strong></p><ul><li>当系统检测到SPI设备时，会调用probe函数。</li><li>在probe函数中，通常需要完成以下操作：<ul><li>获取SPI设备的相关信息（如速率、模式、片选号等）。</li><li>分配和初始化资源，如内存空间、中断处理等。</li><li>注册SPI设备，使用<code>spi_new_device</code>函数。</li></ul></li></ul><p><strong>remove函数</strong></p><ul><li>当SPI设备被卸载时，会调用remove函数。</li><li>在remove函数中，需要完成资源的释放和清理工作，如注销SPI设备等。</li></ul><p><strong>SPI传输函数</strong></p><ul><li>使用<code>spi_sync</code>或<code>spi_async</code>等函数进行数据传输。</li><li><code>spi_sync</code>函数用于同步传输数据，适合简单的数据交换。</li><li><code>spi_async</code>函数用于异步传输数据，支持更复杂的数据处理需求。</li></ul><p><strong>linux开发板写一个IIC的驱动</strong></p><h4 id="驱动框架过程："><a href="#驱动框架过程：" class="headerlink" title="驱动框架过程："></a>驱动框架过程：</h4><ol><li><strong>注册IIC驱动</strong><ul><li>使用<code>i2c_register_driver</code>函数注册IIC驱动，指定驱动的probe和remove函数。</li></ul></li><li><strong>probe函数</strong><ul><li>当系统检测到IIC设备时，会调用probe函数。</li><li>在probe函数中，通常需要完成以下操作：<ul><li>获取IIC设备的相关信息（如地址、速率等）。</li><li>分配和初始化资源，如内存空间、中断处理等。</li><li>注册IIC设备，使用<code>i2c_new_device</code>函数。</li></ul></li></ul></li><li><strong>remove函数</strong><ul><li>当IIC设备被卸载时，会调用remove函数。</li><li>在remove函数中，需要完成资源的释放和清理工作，如注销IIC设备等。</li></ul></li><li><strong>IIC传输函数</strong><ul><li>使用<code>i2c_transfer</code>函数进行数据传输。</li><li><code>i2c_transfer</code>函数支持主从模式的数据交换，适用于IIC总线上的读写操作。</li></ul></li></ol><p><strong>Linux开发板写一个LED显示的驱动</strong></p><h4 id="驱动框架过程：-1"><a href="#驱动框架过程：-1" class="headerlink" title="驱动框架过程："></a>驱动框架过程：</h4><ol><li><strong>LED设备结构</strong><ul><li>定义LED设备的数据结构，包括LED状态、控制方式等信息。</li></ul></li><li><strong>设备树配置</strong><ul><li>在设备树中描述LED设备的连接信息，如GPIO引脚、控制器等。</li></ul></li><li><strong>probe函数</strong><ul><li>当系统检测到LED设备时，会调用probe函数。</li><li>在probe函数中，通常需要完成以下操作：<ul><li>初始化LED设备，包括配置GPIO引脚或控制器。</li><li>注册LED设备，使其可被系统管理。</li></ul></li></ul></li><li><strong>remove函数</strong><ul><li>当LED设备被卸载时，会调用remove函数。</li><li>在remove函数中，需要完成资源的释放和清理工作，如关闭GPIO引脚等。</li></ul></li></ol><p><strong>生成的可执行文件，其中每个段存在的位置在ROM还是RAM</strong></p><ol><li>当系统上电后根据BOOT的引导配置选择启动方式，默认是Flash启动，这时系统开始把所有的代码段搬到RAM中去运行</li><li>CPU就从内存中（RAM）获取数据和指令，根据相关指令来控制系统运行</li><li>数据存放位置：除了特定IO操作存到EEPROM里面，其他变量的使用全在RAM区，其中就有堆和栈。<strong>堆</strong>是由用户手动分配malloc，在整个程序运行期间都有效除非手动释放free。而<strong>栈</strong>在一个函数体内存在，例如main方法由系统自动创建，如果出现递归创建则很容易导致栈溢出，当系统执行完该函数功能后，栈空间数据也由系统自动销毁。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libusb库</title>
      <link href="/2023/11/06/2023-11-06-libusb%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/11/06/2023-11-06-libusb%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="libusb库学习"><a href="#libusb库学习" class="headerlink" title="libusb库学习"></a>libusb库学习</h2><p>libusb是一个使用C编写的库，它提供USB设备的通用的访问方法。APP通过它，可以方便地访问USB设备，无需编写USB设备驱动程序。</p><h3 id="libusb源码的移植"><a href="#libusb源码的移植" class="headerlink" title="libusb源码的移植"></a>libusb源码的移植</h3><p>通过网址下载源码<a href="https://github.com/libusb/libusb/releases%EF%BC%8C%E4%B9%8B%E5%90%8E%E8%BF%9B%E8%A1%8C%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E3%80%82">https://github.com/libusb/libusb/releases，之后进行交叉编译。</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=arm-linux --disable-udev --prefix=/home/moss/linux/tool/libusb --CC=arm-linux-gnueabihf-gcc</span><br></pre></td></tr></table></figure><p>配置完成后就可以进行编译了，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>之后可以发现生成了libusb.h文件，但是缺少里面调用的usb.h文件，所以需要将usbcompat的源码包进行交叉编译。</p><p>下载usbcompat源码包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=arm-linux --disable-udev --prefix=/home/moss/linux/tool/libusb --CC=arm-linux-gnueabihf-gcc</span><br></pre></td></tr></table></figure><p>配置完以后进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo  -i</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><a href="https://libusb.sourceforge.io/api-1.0/libusb_api.html">libusb： 应用程序编程接口 (sourceforge.io)</a></p><p>libusb封装了更好用的函数，这些函数的使用可以分为5个步骤：</p><blockquote><p>初始化<br>打开设备<br>移除原驱动&#x2F;认领接口<br>传输<br>关闭设备</p></blockquote><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-08%20153621.png"></p><h4 id="设备枚举"><a href="#设备枚举" class="headerlink" title="设备枚举"></a>设备枚举</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">libusb_get_device_list</span> <span class="params">(libusb_context *ctx, libusb_device ***<span class="built_in">list</span>)</span></span><br><span class="line"><span class="comment">//返回当前连接到系统的 USB 设备列表。 这是查找要操作的 USB 设备的入口点。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">libusb_free_device_list</span> <span class="params">(libusb_device **<span class="built_in">list</span>, <span class="type">int</span> unref_devices)</span></span><br><span class="line"><span class="comment">//释放先前使用 libusb_get_device_list() 发现的设备列表。 如果设置了 unref_devices 参数，则列表中每个设备的引用计数减 1。</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">libusb_get_bus_number</span> <span class="params">(libusb_device *dev)</span></span><br><span class="line"><span class="comment">//获取设备连接的总线编号。</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">libusb_get_port_number</span> <span class="params">(libusb_device *dev)</span></span><br><span class="line"><span class="comment">//获取设备连接的端口号。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_get_port_numbers</span> <span class="params">(libusb_device *dev, <span class="type">uint8_t</span> *port_numbers, <span class="type">int</span> port_numbers_len)</span></span><br><span class="line"><span class="comment">//获取指定设备的从根节点开始的所有端口号列表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_get_port_path</span> <span class="params">(libusb_context *ctx, libusb_device *dev, <span class="type">uint8_t</span> *port_numbers, <span class="type">uint8_t</span> port_numbers_len)</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">libusb_get_device_address</span> <span class="params">(libusb_device *dev)</span></span><br><span class="line"><span class="comment">//获取设备在它所连接的总线上的地址。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_get_device_speed</span> <span class="params">(libusb_device *dev)</span></span><br><span class="line"><span class="comment">//获取设备的协商连接速度，返回码见 libusb_speed。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_get_max_packet_size</span> <span class="params">(libusb_device *dev, <span class="type">unsigned</span> <span class="type">char</span> endpoint)</span></span><br><span class="line"><span class="comment">//获取特定端点的 wMaxPacketSize 值。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_get_max_iso_packet_size</span> <span class="params">(libusb_device *dev, <span class="type">unsigned</span> <span class="type">char</span> endpoint)</span></span><br><span class="line"><span class="comment">//基于端点描述符中的 wMaxPacketSize 字段，计算特定端点在 1 个微帧的持续时间内能够发送或接收的最大数据包大小。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">libusb_unref_device</span> <span class="params">(libusb_device *dev)</span></span><br><span class="line"><span class="comment">//减少设备的引用计数。 如果递减操作导致引用计数达到零，则设备将被销毁。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_wrap_sys_device</span> <span class="params">(libusb_context *ctx, <span class="type">intptr_t</span> sys_dev, libusb_device_handle **dev_handle)</span></span><br><span class="line">（不常用，略）</span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_open</span> <span class="params">(libusb_device *dev, libusb_device_handle **dev_handle)</span></span><br><span class="line"><span class="comment">//打开设备并获取设备句柄。 句柄允许您在相关设备上执行 I/O。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">libusb_close</span> <span class="params">(libusb_device_handle *dev_handle)</span></span><br><span class="line"><span class="comment">//关闭设备句柄。 应在应用程序退出之前在所有打开的句柄上调用。</span></span><br><span class="line">libusb_device * <span class="title function_">libusb_get_device</span> <span class="params">(libusb_device_handle *dev_handle)</span></span><br><span class="line"><span class="comment">//获取设备句柄关联的 libusb_device 底层设备。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_get_configuration</span> <span class="params">(libusb_device_handle *dev_handle, <span class="type">int</span> *config)</span></span><br><span class="line"><span class="comment">//确定当前活动配置的 bConfigurationValue。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_set_configuration</span> <span class="params">(libusb_device_handle *dev_handle, <span class="type">int</span> configuration)</span></span><br><span class="line"><span class="comment">//设置设备的活动配置。这在支持多个配置的USB设备中会用到。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_claim_interface</span> <span class="params">(libusb_device_handle *dev_handle, <span class="type">int</span> interface_number)</span></span><br><span class="line"><span class="comment">//在给定的设备句柄上声明一个接口。 您必须先声明要使用的接口，然后才能在其任何端点上执行 I/O。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_release_interface</span> <span class="params">(libusb_device_handle *dev_handle, <span class="type">int</span> interface_number)</span></span><br><span class="line"><span class="comment">//释放先前使用 libusb_claim_interface() 声明的接口。 您应该在关闭设备句柄之前释放所有声明的接口。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_set_interface_alt_setting</span> <span class="params">(libusb_device_handle *dev_handle, <span class="type">int</span> interface_number, <span class="type">int</span> alternate_setting)</span></span><br><span class="line"><span class="comment">//激活接口的备用设置。 该接口必须先前已使用 libusb_claim_interface() 声明。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_clear_halt</span> <span class="params">(libusb_device_handle *dev_handle, <span class="type">unsigned</span> <span class="type">char</span> endpoint)</span></span><br><span class="line"><span class="comment">//清除端点的暂停/停止条件。 处于停止状态的端点无法接收或发送数据，直到停止条件停止。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_reset_device</span> <span class="params">(libusb_device_handle *dev_handle)</span></span><br><span class="line"><span class="comment">//执行 USB 复位以重新初始化设备。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_kernel_driver_active</span> <span class="params">(libusb_device_handle *dev_handle, <span class="type">int</span> interface_number)</span></span><br><span class="line"><span class="comment">//确定内核驱动程序是否在接口上处于活动状态。 如果内核驱动程序处于活动状态，则不能声明该接口，并且 libusb 将无法执行 I/O。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_detach_kernel_driver</span> <span class="params">(libusb_device_handle *dev_handle, <span class="type">int</span> interface_number)</span></span><br><span class="line"><span class="comment">//分离接口和内核驱动程序。 如果成功，您将能够声明接口并执行 I/O。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_attach_kernel_driver</span> <span class="params">(libusb_device_handle *dev_handle, <span class="type">int</span> interface_number)</span></span><br><span class="line"><span class="comment">//重新附加接口的内核驱动程序，该驱动程序之前使用 libusb_detach_kernel_driver() 分离。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_set_auto_detach_kernel_driver</span> <span class="params">(libusb_device_handle *dev_handle, <span class="type">int</span> enable)</span></span><br><span class="line"><span class="comment">//启用/禁用 libusb 的自动内核驱动程序分离。 启用此功能后，libusb 将在声明接口时自动分离接口上的内核驱动程序，并在释放接口时附加它。</span></span><br></pre></td></tr></table></figure><h4 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">libusb_set_debug</span> <span class="params">(libusb_context *ctx, <span class="type">int</span> level)</span></span><br><span class="line"><span class="comment">//设置libusb调试等级，方便查看调试过程和log信息。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">libusb_set_log_cb</span> <span class="params">(libusb_context *ctx, libusb_log_cb cb, <span class="type">int</span> mode)</span></span><br><span class="line"><span class="comment">//设置log处理程序，libusb 会将其日志消息重定向到提供的回调函数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_set_option</span> <span class="params">(libusb_context *ctx, <span class="keyword">enum</span> libusb_option option,...)</span></span><br><span class="line"><span class="comment">//设置库选项，使用此函数可配置库中的特定选项。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_init</span> <span class="params">(libusb_context **context)</span></span><br><span class="line"><span class="comment">//初始化 libusb。 必须在调用任何其他 libusb 函数之前调用此函数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">libusb_exit</span> <span class="params">(libusb_context *ctx)</span></span><br><span class="line"><span class="comment">//取消初始化 libusb。 应在关闭所有打开的设备后和应用程序终止之前调用。</span></span><br></pre></td></tr></table></figure><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> libusb_transfer * <span class="title function_">libusb_alloc_transfer</span><span class="params">(<span class="type">int</span>iso_packets)</span></span><br><span class="line"><span class="comment">/*使用指定数量的常时等量数据包描述符分配 libusb 传输,不用时候使用libusb_free_transfer释放</span></span><br><span class="line"><span class="comment">iso_packets参数为分配时候常时等量数据包描述符的数量，</span></span><br><span class="line"><span class="comment">返回值:分配流数或失败的error码*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">libusb_free_transfer</span><span class="params">(<span class="keyword">struct</span> libusb_transfer *)</span></span><br><span class="line"><span class="comment">/*释放传输结构*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_submit_transfer</span><span class="params">(<span class="keyword">struct</span> libusb_transfer *)</span></span><br><span class="line"><span class="comment">/*触发usb传输，后立即返回</span></span><br><span class="line"><span class="comment">返回值：0成功，不同失败返回不同error码*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_cancel_transfer</span><span class="params">(<span class="keyword">struct</span> libusb_transfer *)</span></span><br><span class="line"><span class="comment">/*异步取消以前提交的传输</span></span><br><span class="line"><span class="comment">返回值：0成功，失败时的LIBUSB_ERROR代码*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">libusb_transfer_get_stream_id</span><span class="params">(<span class="keyword">struct</span> libusb_transfer *)</span></span><br><span class="line"><span class="comment">/*获取传输批量流ID</span></span><br><span class="line"><span class="comment">返回值：传输的流ID*/</span></span><br><span class="line"> *<span class="title function_">libusb_control_transfer_get_data</span><span class="params">(<span class="keyword">struct</span> libusb_transfer *)</span></span><br><span class="line"><span class="comment">/*获取控制传输的数据部分，</span></span><br><span class="line"><span class="comment">返回指：向数据部分的第一个字节的指针*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">libusb_control_transfer_get_setup</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> libusb_transfer *transfer)</span>;</span><br><span class="line"><span class="comment">/*获取控制传输的控制设置数据包*，</span></span><br><span class="line"><span class="comment">返回值：指向传输数据缓冲区开头的强制转换指针*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">libusb_fill_bulk_transfer</span><span class="params">(<span class="keyword">struct</span> libusb_transfer *transfer,</span></span><br><span class="line"><span class="params">                                libusb_device_handle *dev_handle,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">char</span> endpoint,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">char</span> *buffer,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> length,</span></span><br><span class="line"><span class="params">                                libusb_transfer_cb_fn callback,</span></span><br><span class="line"><span class="params">                                <span class="type">void</span> *user_data,</span></span><br><span class="line"><span class="params">                                <span class="type">unsigned</span> <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">/*transfer：指向要填充的 transfer 结构体的指针。</span></span><br><span class="line"><span class="comment">dev_handle：指向已打开设备的设备句柄。</span></span><br><span class="line"><span class="comment">endpoint：要使用的端点地址。</span></span><br><span class="line"><span class="comment">buffer：指向数据缓冲区的指针。</span></span><br><span class="line"><span class="comment">length：要传输的数据长度。</span></span><br><span class="line"><span class="comment">callback：传输完成后要调用的回调函数。</span></span><br><span class="line"><span class="comment">user_data：传递给回调函数的用户数据指针。</span></span><br><span class="line"><span class="comment">timeout：传输超时时间，以毫秒为单位，0 表示无限等待。*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_handle_events_timeout</span><span class="params">(libusb_context *ctx, <span class="keyword">struct</span> timeval *tv)</span></span><br><span class="line"><span class="comment">/*该函数用于处理USB事件，包括设备插拔、传输完成等。该函数会阻塞当前线程，</span></span><br><span class="line"><span class="comment">直到事件处理完成或超时。参数ctx为libusb的上下文，参数tv为超时时间，如果为NULL则表示无限等待。*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">libusb_handle_events</span><span class="params">(libusb_context *ctx)</span></span><br><span class="line"><span class="comment">/*该函数用于处理USB事件，类似于libusb_handle_events_timeout函数，但是没有超时限制，</span></span><br><span class="line"><span class="comment">会一直阻塞当前线程直到事件处理完成。参数ctx为libusb的上下文。*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake的学习</title>
      <link href="/2023/11/04/2023-11-4-cmake/"/>
      <url>/2023/11/04/2023-11-4-cmake/</url>
      
        <content type="html"><![CDATA[<h2 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h2><h3 id="简易工程学习"><a href="#简易工程学习" class="headerlink" title="简易工程学习"></a>简易工程学习</h3><p>cmake 是一个跨平台的自动构建工具 ，用来生成Makefile，不用动手编写Makefile。</p><p>对于一个初始的C语言程序来说使用cmke进行构建。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建CMakeLists.txt文件，CMakeLists.txt文件会被cmake工具解析 ，写入内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(HELLO)<span class="comment">#设置工程名称</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello ./main.c)<span class="comment">#第一个参数生成可执行文件用，空格分开传入的参数，第二个参数表示对应的源文件</span></span><br></pre></td></tr></table></figure><p>执行cmake命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ./</span><br></pre></td></tr></table></figure><p>之后就会生成makefile文件，可以使用make进行编译。</p><p><strong>使用out-of-source方式进行构建</strong>，来将工程生成的文件何源文件分离开。</p><p>然后在工程目录下创建一个 build 目录 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd build/</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>这样 cmake 生成的中间文件以及 make 编译生成的可执行文件就全部在 build 目录下了，如果要清理工程，直接删除 build 目录即可，这样就方便多了。 </p><p>当对应的源文件是多个文件时候，例如main.c hello.c </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello main.c hello.c)</span><br></pre></td></tr></table></figure><p><strong>编译动态库&#x2F;静态库</strong></p><p><code>动态库</code>：以<code>.so</code>作为后缀<br><code>静态库</code>：通常以<code>.a</code>或<code>.la</code>作为后缀。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(libhello SHARED hello.c) <span class="comment">#生成动态库文件</span></span><br><span class="line"><span class="keyword">add_library</span>(libhello STATIC hello.c) <span class="comment">#生成静态库文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello libhello) <span class="comment">#命令为目标指定依赖库</span></span><br></pre></td></tr></table></figure><p>这时生成的库名字是liblibhello.a，可以通过set_target_properties 来修改工程的名字。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(libhello PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过 set_target_properties 命令对 libhello 目标的OUTPUT_NAME 属性进行了设置，将其设置为 hello </p><p><strong>大工程分层存储文件夹</strong></p><p>使用add_subdirectory来添加子目录并构建子目录。</p><p>当前目录为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── build #build 目录</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── libhello</span><br><span class="line">│ ├── CMakeLists.txt</span><br><span class="line">│ ├── hello.c</span><br><span class="line">│ └── hello.h</span><br><span class="line">└── src</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── main.c</span><br></pre></td></tr></table></figure><blockquote><p>顶层 CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(HELLO)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(libhello)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure><p> src 目录下的 CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/libhello)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">add_executable</span>(hello main.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello libhello)</span><br></pre></td></tr></table></figure><p> libhello 目录下的 CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)</span><br><span class="line"><span class="keyword">add_library</span>(libhello hello.c)</span><br><span class="line"><span class="keyword">set_target_properties</span>(libhello PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><p>最终得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── build</span><br><span class="line">│ ├── bin</span><br><span class="line">│ │ └── hello</span><br><span class="line">│ └── lib</span><br><span class="line">│ └── libhello.a</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── libhello</span><br><span class="line">│ ├── CMakeLists.txt</span><br><span class="line">│ ├── hello.c</span><br><span class="line">│ └── hello.h</span><br><span class="line">└─ src</span><br><span class="line">  ├── CMakeLists.txt</span><br><span class="line">  └── main.c</span><br></pre></td></tr></table></figure><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><p>全部命令查看官方文档<a href="https://cmake.org/cmake/help/v3.5/manual/cmake-commands.7.html">https://cmake.org/cmake/help/v3.5/manual/cmake-commands.7.html</a> </p><p>参数间隔用空格</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(&lt;name&gt; source1 source2...) </span><br><span class="line"><span class="comment"># 命令用于添加一个可执行程序目标，并设置目标所需的源文件，可以用绝对路径和相对路径</span></span><br><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE] source1 source2 ...])</span><br><span class="line"><span class="comment"># 命令用于添加一个库文件，并设置所需要的源文件</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir])</span><br><span class="line"><span class="comment"># 命令用于source_dir 指定一个目录， 告诉cmake 去该目录下寻找 CMakeLists.txt文件并执行它</span></span><br><span class="line"><span class="comment"># 参数binary_dir为指定路径，该路径作为子源码（调用 add_subdirectory 命令的源码称为当前源码或父源码，被执行的</span></span><br><span class="line"><span class="comment"># 源码称为子源码）的输出文件（cmake 命令所产生的中间文件） 目录，</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br><span class="line"><span class="comment"># 查找目录中的所有源文件，dir为指定目录，将得到的信息放入到variable中。</span></span><br><span class="line"><span class="keyword">include_directories</span>([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])</span><br><span class="line"><span class="comment"># 命令用于设置头文件的搜索路径，如果使用 SYSTEM 选项，会把指定目录当成系统的搜索目录。</span></span><br><span class="line"><span class="comment"># 添加到列表后面</span></span><br><span class="line"><span class="keyword">include_directories</span>(AFTER <span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 添加到列表前面</span></span><br><span class="line"><span class="keyword">include_directories</span>(BEFORE <span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(directory1 directory2 ...)</span><br><span class="line"><span class="comment"># 命令用于设置库文件的搜索路径</span></span><br><span class="line"><span class="keyword">link_libraries</span>([item1 [item2 [...]]] [[debug|optimized|general] &lt;item&gt;] ...)</span><br><span class="line"><span class="comment"># 会将指定目录添加到库文件搜索列表（可以认为每一个 CMakeLists.txt 源码都有自己的库文件搜索列表）中</span></span><br><span class="line"><span class="comment"># 简写</span></span><br><span class="line"><span class="keyword">link_libraries</span>(hello)</span><br><span class="line"><span class="comment"># 全称</span></span><br><span class="line"><span class="keyword">link_libraries</span>(libhello.so)</span><br><span class="line"><span class="keyword">message</span>([&lt;mode&gt;] <span class="string">&quot;message to display&quot;</span> ...)</span><br><span class="line"><span class="comment"># 命令用于打印、输出信息</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">mode</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">none(无)</td><td align="center">重要信息、普通信息</td></tr><tr><td align="center">STATUS</td><td align="center">附带信息</td></tr><tr><td align="center">WARNING</td><td align="center">CMake警告，继续处理</td></tr><tr><td align="center">AUTHOR_WARNINIG</td><td align="center">CMake警告（开发），继续处理</td></tr><tr><td align="center">SEND_ERROR</td><td align="center">CMake错误，继续处理，但跳过生成</td></tr><tr><td align="center">FALTAL_ERROR</td><td align="center">CMake错误，停止处理和生成</td></tr><tr><td align="center">DEPRECATION</td><td align="center">如 果 变 量 CMAKE_ERROR_DEPRECATED 或CMAKE_WARN_DEPRECATED 分别启用， 则 CMake 弃用错</td></tr><tr><td align="center">误或警告，否则没有消息。</td><td align="center"></td></tr></tbody></table><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置工程名称为 HELLO</span></span><br><span class="line"><span class="keyword">project</span>(HELLO)<span class="comment">#执行这个之后会引入两个变量： HELLO_SOURCE_DIR 和 HELLO_BINARY_DIR</span></span><br><span class="line"><span class="comment">#HELLO_SOURCE_DIR 变量指的是 HELLO 工程源码目录、 HELLO_BINARY_DIR 变量指的是 HELLO 工程源码的输出文件目录</span></span><br><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE])</span><br><span class="line"><span class="comment">#set 命令用于设置变量</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; [SYSTEM] [BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br><span class="line"><span class="comment">#target_include_directories 命令为指定目标设置头文件搜索路径</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br><span class="line"><span class="comment">#target_link_libraries为指定目标设置链接库文件</span></span><br></pre></td></tr></table></figure><p>eg：</p><p>写一个指针的斐波那契数列（非递归指针方式实现）</p><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span> ;</span><br><span class="line"><span class="type">int</span> *ptr1, *ptr2;</span><br><span class="line"></span><br><span class="line">ptr1 = &amp;a;</span><br><span class="line">ptr2 = &amp;b;</span><br><span class="line">feibo_arr( ptr1, ptr2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">feibo_arr</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp ;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = *a + *b;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TEST_H</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">feibo_arr</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree #使用tree输出树状结构</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-05%20184947.png"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#src下的CMakeLists.txt内容</span></span><br><span class="line"><span class="keyword">add_executable</span>(feibo main.c)<span class="comment">#给feibo可执行文件加上源文件</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)<span class="comment">#将可执行文件放到bin文件夹中</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/libfeibo)<span class="comment">#指定头文件目录</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(feibo libfeibo)<span class="comment">#给feibo工程使用libfeibo的库</span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#lib下的CMakeLists.txt内容</span></span><br><span class="line"><span class="keyword">add_library</span>(libfeibo <span class="keyword">function</span>.c)</span><br><span class="line"><span class="keyword">set_target_properties</span>(libfeibo PROPERTIES OUTPUT_NAME <span class="string">&quot;feibo&quot;</span>)<span class="comment">#给lib库重新命名</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)<span class="comment">#设置目录</span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#工程目录下的CMakeLists.txt内容</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(feibo)<span class="comment">#给工厂命名feibo</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src) <span class="comment">#执行src下的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(libfeibo) <span class="comment">#执行lib下的CMakeLists.txt</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB协议学习</title>
      <link href="/2023/10/31/2023-10-31-usb%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/10/31/2023-10-31-usb%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h1><p>USB作为通用串行总线，可以看到这种总线具备<strong>通用性</strong>。它是以主机为主，设备为从的主从通讯模式，</p><p><strong>USB描述符</strong></p><p>所有USB描述符都是存储在USB设备中的。USB描述符有设备描述符、配置描述符、接口描述符、端点描述符、字符串描述符，HID类设备会多出HID描述符、报告描述符、物理描述符三种描述符，描述符架构如下图。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-31%20205759.png"></p><p><strong>USB传输</strong></p><p>USB传输分为<strong>控制传输、同步传输、批量传输、中断传输</strong>四种，其中批量传输、同步传输每次传输需要一个或多个事务，中断传输一次需要一个事务，控制传输包括三个过程（<strong>建立过程、数据过程、状态过程</strong>），建立过程和状态过程分别需要一个事务<strong>，</strong>数据过程则可能包含0个多个事务。看实例协议分析，要知道<strong>transfer是传输</strong>，<strong>transaction为事务</strong>。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-31%20210119.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-31%20210149.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-31%20210240.png"></p><p>控制传输有三种类型，控制写传输、控制读传输、无数据的控制传输三种。控制写传输和控制读传输数据阶段是根据传输情况可有可无，无数据控制传输无数据阶段。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-31%20210344.png"></p><p><strong>USB事务</strong></p><p><strong>事务通常</strong>由两三个包组成：<strong>令牌包</strong>，<strong>数据包</strong>和<strong>握手包</strong>。为什么说是通常呢？因为有一个特例同步传输的事务中没有握手包，只有令牌包和数据包。事务就是完成一件事的意思，完成一个事务需要发送或者接受几包数据。</p><p><strong>USB包</strong></p><p>（packet）是学习USB协议中最最最重要的东西，包（packet）是USB传输的最小单位，所有的东西都是组织成包（packet）发送出去的，包的组成结构，由SOP、SYNC、<strong>Packet Content</strong>、EOP四部分组成，其中<strong>Packet Content</strong>最为核心，<strong>Packet Content</strong>由PID、地址、帧号、数据、CRC组成。</p><p><strong>USB枚举</strong></p><p>通过学习枚举，我们可以了解描述符、传输、事务、包在USB协议中充当的作用以及USB的工作原理。</p><h3 id="USB描述符详解"><a href="#USB描述符详解" class="headerlink" title="USB描述符详解"></a>USB描述符详解</h3><p>设备描述符是USB主机枚举USB设备申请的第1个描述符，每个设备有且仅有一个设备描述符，也就是大家以后看到的任何的USB设备都只有一个<strong>设备描述符</strong>数组，设备描述符的长度是18字节。</p><p>设备描述符为主机提供了许多信息，如设备满足的USB规范，设备支持的协议，供应商标识、产品标识等等。</p><p>一个USB设备至少有一个或者多个配置，这一点可以从设备描述符的最后一项bNumConfigurations得到，但是当前只能选择其中一种配置，每一种配置都对应一个<strong>配置描述符集合</strong>。</p><p>接口描述符不能单独返回给USB主机，主机会请求获得配置描述符集合，配置描述符集合主要由标准配置描述符、接口描述符、端点描述符、HID描述符，报告描述符和物理描述符单独返回给主机。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-04%20202533.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件传输接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WIFI驱动</title>
      <link href="/2023/10/27/2023-10-27-wifi%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/10/27/2023-10-27-wifi%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="wifi驱动的移植"><a href="#wifi驱动的移植" class="headerlink" title="wifi驱动的移植"></a>wifi驱动的移植</h3><p>使用的wifi模块为SDIO WIFI，芯片为RTL8189FTV，这款产品是给驱动的，只需要将其添加到内核编译，就可以使用。</p><p>使用RTL8XXX WIFI 驱动源码-&gt; realtek 将这个目录包放入Linux 内核源码中的 drivers&#x2F;net&#x2F;wireless 目录下，此目<br>录下存放着所有 WIFI 驱动文件 。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-27%20211442.png"></p><p><strong>修改 drivers&#x2F;net&#x2F;wireless&#x2F;Kconfig</strong> </p><p>打开这个文件在最后加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &quot;drivers/net/wireless/realtek/Kconfig&quot;</span><br></pre></td></tr></table></figure><p>添加到 drivers&#x2F;net&#x2F;wireless&#x2F;Kconfig 中的内容 </p><p><strong>修改 drivers&#x2F;net&#x2F;wireless&#x2F;Makefile</strong> </p><p>打开文件在最后加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-y += realtek/</span><br></pre></td></tr></table></figure><p>这样就能在内核菜单中配置它这个选项了。</p><h3 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h3><p>配置wifi</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-27%20211745.png"></p><p>配置支持IEEE802.11</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-27%20211815.png"></p><p>最后编译WIFI驱动</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-27%20212025.png"></p><p>使用sdio wifi，最后保存配置。</p><p>此时将设备启动，使用命令查看网卡</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-27%20212218.png"></p><p>当然最后的wlan0是配好的了，没配好的时候它没有ip地址。</p><p>现在开始移植使用的工具了。</p><h3 id="wireless-tools-工具移植与测试"><a href="#wireless-tools-工具移植与测试" class="headerlink" title="wireless tools 工具移植与测试"></a>wireless tools 工具移植与测试</h3><p>wireless tools 是操作 WIFI 的工具集合，包括一下工具：</p><blockquote><p>①、 iwconfig：设置无线网络相关参数。<br>②、 iwlist：扫描当前无线网络信息，获取 WIFI 热点。<br>③、 iwspy：获取每个节点链接的质量。<br>④、 iwpriv：操作 WirelessExtensions 特定驱动。<br>⑤、 ifrename：基于各种静态标准命名接口。 </p></blockquote><p>下载iwlist_for_visteon-master.tar.bz2源码包，进入到 iwlist_for_visteon-master 文件夹里面，打开Makefile 文件，修改 Makefile 中的 CC、 AR 和 RANLIB 这三个变量 。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC = arm-linux-gnueabihf-gcc</span><br><span class="line">AR = arm-linux-gnueabihf-ar</span><br><span class="line">RANLIB = arm-linux-gnueabihf-ranlib</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译完成以后就会在当前目录下生成 iwlist、 iwconfig、 iwspy、 iwpriv、 ifrename 这 5 个工具，另外还有很重要的 libiw.so.29 这个库文件。将这 5 个工具拷贝到开发板根文件系统下的&#x2F;usr&#x2F;bin 目录中.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp iwlist iwconfig iwspy iwpriv ifrename /home/moss/linux/nfs/rootfs/usr/bin/ -f</span><br><span class="line">sudo cp libiw.so.29 /home/moss/linux/nfs/rootfs/usr/lib/ -f</span><br></pre></td></tr></table></figure><h3 id="wpa-supplicant-移植"><a href="#wpa-supplicant-移植" class="headerlink" title="wpa_supplicant 移植"></a>wpa_supplicant 移植</h3><p>下载源码openssl-1.1.1d.tar.gz，解压并配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -vxzf openssl-1.1.1d.tar.gz</span><br><span class="line">./Configure linux-armv4 shared no-asm --prefix=/home/moss/linux/tool/openssl CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>将 lib 目录下的 libcrypto 和 libssl 库拷贝到开发板根文件系统中的&#x2F;usr&#x2F;lib 目录下 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp libcrypto.so* /home/moss/linux/nfs/rootfs/lib/ -af</span><br><span class="line">sudo cp libssl.so* /home/moss/linux/nfs/rootfs/lib/ -af</span><br></pre></td></tr></table></figure><h3 id="libnl-库移植"><a href="#libnl-库移植" class="headerlink" title="libnl 库移植"></a>libnl 库移植</h3><p>在编译 libnl 之前先安装 biosn 和 flex ,这个在boa服务器里安装过，就是用命令就行，解压后配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -vxzf libnl-3.2.23.tar.gz</span><br><span class="line">。/configure --host=arm-linux-gnueabihf --prefix=/home/moss/linux/tool/libnl/</span><br><span class="line">make -j12 //编译</span><br><span class="line">make install //安装</span><br></pre></td></tr></table></figure><h3 id="wpa-supplicant-移植-1"><a href="#wpa-supplicant-移植-1" class="headerlink" title="wpa_supplicant 移植"></a>wpa_supplicant 移植</h3><p>下载源码并解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxzf wpa_supplicant-2.7.tar.gz</span><br></pre></td></tr></table></figure><p>进入到 wpa_supplicant 目录下，然后进行配置， wpa_supplicant 的配置比较特殊，需要将 wpa_supplicant 下的 defconfig 文件拷贝一份并重命名为.config </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd wpa_supplicant/</span><br><span class="line">cp defconfig .config</span><br></pre></td></tr></table></figure><p>之后更改.config文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CC = arm-linux-gnueabihf-gcc</span><br><span class="line"><span class="comment">#openssl 库和头文件路径</span></span><br><span class="line">CFLAGS += -I/home/zuozhongkai/linux/IMX6ULL/tool/openssl/<span class="keyword">include</span></span><br><span class="line">LIBS += -L/home/zuozhongkai/linux/IMX6ULL/tool/openssl/lib -lssl -lcrypto </span><br><span class="line"><span class="comment">#libnl 库和头文件路径</span></span><br><span class="line">CFLAGS += -I/home/zuozhongkai/linux/IMX6ULL/tool/libnl/<span class="keyword">include</span>/libnl3</span><br><span class="line">LIBS += -L/home/zuozhongkai/linux/IMX6ULL/tool/libnl/lib</span><br></pre></td></tr></table></figure><p>.config 文件配置好以后就可以编译 wpa_supplicant 了，使用如下命令编译 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=/home/zuozhongkai/linux/IMX6ULL/tool/libnl/lib/pkgconfig: $PKG_CONFIG_PATH //指定 libnl 库 pkgconfig 包位置</span><br><span class="line">make -j12 //编译</span><br></pre></td></tr></table></figure><p>将生成的wpa_cli 和 wpa_supplicant 这两个文件拷贝到开发板根文件系统的&#x2F;usr&#x2F;bin目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp wpa_cli wpa_supplicant /home/moss/linux/nfs/rootfs/usr/bin/ -f</span><br></pre></td></tr></table></figure><p>工具移植完了开始使用。</p><h3 id="WIFI-联网测试"><a href="#WIFI-联网测试" class="headerlink" title="WIFI 联网测试"></a>WIFI 联网测试</h3><p>先在开发板根文件系统的&#x2F;etc 目录下创建一个名为“wpa_supplicant.conf”的配置文件，此文件用于配置要连接的 WIFI 热点以及 WIFI 密码。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctrl_interface=/var/run/wpa_supplicant</span><br><span class="line">ap_scan=1</span><br><span class="line">network=&#123;</span><br><span class="line"> ssid=&quot;ZZK&quot;</span><br><span class="line"> psk=&quot;xxxxxxxx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wpa_supplicant.conf 文 件 编 写 好 以 后 再 在 开 发 板 根 文 件 系 统 下 创 建 一 个“&#x2F;var&#x2F;run&#x2F;wpa_supplicant”目录， wpa_supplicant 工具要用到此目录！ </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/run/wpa_supplicant -p</span><br></pre></td></tr></table></figure><p><strong>开始测试</strong></p><p>先是打开网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig wlan0 up</span><br><span class="line">wpa_supplicant -Dnl80211 -c /etc/wpa_supplicant.conf -i wlan0 &amp;#连接wifi</span><br><span class="line">udhcpc -i wlan0#获取IP地址</span><br></pre></td></tr></table></figure><p>正常这里就好使了，可以ping通外网了，但是如果你使用的根文件系统是busybox生成的，那就会出问题，ip地址可以获取但是设置不上，就是你使用命令ifconfig -a，发现你的wlan0网卡没有ip地址，但你的udhcpc没有报错。</p><p>这就是写这篇博客的意义所在，如果你不是这个busybox的根文件系统就没有问题，只能说我每回学东西都踩一个坑，下面是解决方案：</p><p>首先还是下载busybox的源码包，将busybox-1.xx.x&#x2F;examples&#x2F;udhcp&#x2F;目录下的simple.script文件（注意不是sample.script）拷贝到根文件系统的&#x2F;usr&#x2F;share&#x2F;udhcpc&#x2F;目录下，将它重命名为default.script，并且chmod +x default.script加上可执行权限即可。</p><p>重新获取ip地址就可以了联网了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习计划</title>
      <link href="/2023/10/23/2023-10-23-%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2023/10/23/2023-10-23-%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>目前先打算做个规划进行一段时间的复习，并且准备开题报告。复习的主要内容如下：</p><blockquote><p>复习数组和结构体的传输参数，堆栈，内存的概念<br>对于驱动开发的复习<br>每天进行代码的练习<br>高级IO的复习<br>进程、线程的复习</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件传输</title>
      <link href="/2023/10/19/2023-10-19-%E7%A1%AC%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
      <url>/2023/10/19/2023-10-19-%E7%A1%AC%E4%BB%B6%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<p><strong>双闪存模式</strong>，这也是ASPI最常用的接口协议模式之一。</p><p>双闪存模式。即QSPI 使用两个外部四线 SPI Flash（FLASH 1 和 FLASH 2），在每个周期中发送&#x2F;接收 8 位（在 DDR 模式下为16 位），能够有效地将吞吐量和容量扩大一倍。每个 Flash 使用同一个 CLK 并可选择使用同一个 nCS 信号，但其 IO0、IO1、IO2 和 IO3 信号是各自独立的。双闪存模式可与单比特模式、双比特模式以及四比特模式结合使用，也可与 SDR 或 DDR 模式相结合。在双闪存模式下读取 Flash 状态寄存器时，需要读取的字节数是单闪存模式下的 2 倍。在双闪存模式下，FLASH 1 接口信号的行为基本上与正常模式下相同。在指令、地址、交替字节以及空指令周期阶段，FLASH 2 接口信号具有与 FLASH 1 接口信号完全相同的波形。</p><p><strong>IIC协议对接口电平时序的理解</strong>，开始信号：SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据。结束信号：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。应答信号：接收数据的IC在接收到8bit数据后，向发送数据的IC发出特定的低电平脉冲，表示已收到数据。在IIC通信中，起始信号是必须的，结束信号和应答信号都不是必需的。</p><p><strong>USB传输协议</strong></p><p>中断传输是一种轮询的传输方式，是一种单向的传输，HOST通过固定的间隔对中断端点进行查询，若有数据传输或可以接收数据则返回数据或发送数据，否则返回NAK，表示尚未准备好。<br>除高速高带宽中断端点外，一个微帧内仅允许一次中断事务传输，高速高带宽端点最多可以在一个微帧内进行三次中断事务传输。<br>中断传输的延迟有保证，但并非实时传输，它是一种延迟有限的可靠传输，支持错误重传。<br>高速中断传输不得占用超过80%的微帧时间，全速和低速不得超过90%。<br>USB 采用小端字节顺序，在总线上先传输一个字节的最低有效位，最后传输最高有效位，采用NRZI 编码，若遇到连续的6 个1 要求进行为填充，即插入一个0。<br>所有的USB 包都由SYNC 开始，高速包的SYNC 宽度为32bit，全速&#x2F;低速包的SYNC段度为8bit。实际接收到的SYNC 产度由于USB HUB 的关系，可能会小于该值。<br>控制传输：主要用于在设备连接时对设备进行枚举以及其他因设备而已的特定操作。<br>中断传输：用于对延迟要求严格、小量数据的可靠传输，如键盘、游戏手柄等。<br>批量传输：用于对延迟要求宽松，大量数据的可靠传输，如U 盘等。<br>同步传输：用于对可靠性要求不高的实时数据传输，如摄像头、USB 音响等。<br>需要注意的是：中断传输并不意味这传输过程中，设备会先中断HOST，继而通知HOST 启动传输。中断传输也是HOST 发起的传输，采用轮询的方式询问设备是否有数据发送，若有则传输数据，否则NAK 主机。<br>在USB总线上和USB 设备进行通讯。从逻辑上可以分为功能层、设备层和总线接口层。功能层完成功能级的描述、定义和行为。设备层则完成从功能级到传输级的转换，把一次功能级的行为转换为一次一次的基本传输。USB 总线接口层则处理总线上的Bit 流，完成数据传输的物理层实现和总线管理，设备层和设备层之间不可以直接访问数据，需要透过总线接口层。<br>从功能上来说，HUB 必须支持连接行为、电源管理、设备连接&#x2F;移除检测、总线错误检测和恢复、高&#x2F;全&#x2F;低速设备支持。地址分配不在其范围内。</p><p><strong>QSPI</strong></p><p>在QSPI接口应用中，QSPI通过命令和FLASH通讯，命令包括：指令+地址+交替字节+空周期+数据五个阶段，<br>QSPI的传输模式可以设置为：单线SPI模式：BK_IO0即SO,BK_IO1即SI，加上NCS和SCLK，类似于SPI模式。双线SPI模式：BK_IO0和BK_IO1实现数据的双入双出。四线SPI模式：BK_IO0，BK_IO1，BK_IO2，BK_IO3四根线实现数据的传输。无指令传输模式。<br>QSPI 使用 6 个信号连接Flash，分别是四个数据线BK1_IO0~BK1_IO3，一个时钟输出CLK，一个片选输出。相较于SPI ，QSPI增加了两根I&#x2F;O线（SIO2,SIO3），目的是一个时钟内可以传输4个bit。QSPI协议主要通过发送命令来进行通讯，主机需要进行QSPI接口的配置。QSPI 通过命令与 FLASH通信，每条命令包括：指令、地址、交替字节、空指令和数据这五个阶段，任一阶段均可跳过，但至少要包含指令、地址、交替字节或数据阶段之一。<br>在间接模式下，通过写入 QUADSPI 寄存器来触发命令；并通过读写数据寄存器来传输数据，就如同对待其他通信外设那样。<br>若 FMODE &#x3D; 00，则 QUADSPI 处于间接写入模式，字节在数据阶段中发送到 Flash。<br>若 FMODE &#x3D; 01，则 QUADSPI 处于间接读取模式，在数据阶段中从 Flash 接收字节。<br>在间接写入模式下，固件写入数据 时，将在 FIFO 中增加数据。<br>在间接读出模式下，固件写入数据 时，将在 FIFO 中移除数据。<br>信号接口模式可以配置成为SDR模式、DDR模式、双闪存模式。</p><p>指令阶段：此 阶段 通过寄存器的 INSTRUCTION字段指定一个 8位指令发送到FLASH。注意，指令阶段，一般是通过 IO0单线发送，但是也可以配置为双线 &#x2F;四线发送指令。<br>地址阶段：此阶段可以发送 1<del>4字节地址给 FLASH芯片，指示要操作的地址。地址阶段同样可以以单线 &#x2F;双线 &#x2F;四线模式发送。<br>交替字节（复用字节）阶段：此阶段可以发送1</del>4字节数据给 FLASH芯片，一般用于控制操作模式。 交替 字节 同样可以以单线 &#x2F;双线 &#x2F;四线模式发送。<br>空指令周期阶段：在空指令周期阶段，在给定的1~31个周期内不发送或接收任何数据，目的是当采用更高的时钟频率时，给 FLASH芯片留出准备数据阶段的时间。<br>数据阶段：此阶段可以从 FLASH读取 &#x2F;写入任意字节数量的数据。数据阶段同样可以以单线 &#x2F;双线 &#x2F;四线模式发送。</p><p><strong>SDIO接口</strong></p><p>SDIO 总线和 USB 总线类似，SDIO 总线也有两端，其中一端是主机（Host）端，另一端是设备端（Device）。采用Host-Device（主从模式）这样的设计是为了简化 Device 的设计，所有的通信都是由 Host 端发出命令开始的。在 Device 端只要能解析 Host 的命令，就可以同 Host 进行通信了，SDIO 的 Host 可以连接多个 Device（一主多从）。<br>在 SDIO 总线定义中，DAT1 信号线复用为中断线。在 SDIO 的 1BIT 模式下 DAT0 用来传输数据，DAT1 用作中断线。在 SDIO 的 4BIT 模式下 DAT0-DAT3 用来传输数据，其中 DAT1 复用作中断线。<br>SDIO 总线上都是 Host 端发起请求，然后 Device 端回应请求，其中请求和回应中会包含数据信息：</p><ul><li>Command: 用于开始传输的命令，是由 Host 端发往 Device 端的，其中命令是通过 CMD 信号线传送的；</li><li>Response: 回应是 Device 返回的 Host 命令作为 Command 的回应。也是通过 CMD 线传送的；</li><li>Data: 数据是双向的传送的。可以设置为 1 线模式，也可以设置为 4 线模式。数据是通过 DAT0-DAT3 信号线传输的。</li></ul><p>CMD52是由HOST发往DEVICE的，它必须有DEVICE返回来的Response。 CMD52不需要占用DAT线，读写的数据是通过CMD52或者Response来传送。每次CMD52只能读或者写一个byte。<br>同CMD52命令不同的是，CMD53没有返回的命令的，这里判断是否DEVICE设备读写完毕是需要驱动里面自己判断的，一般有2个方法，1.设置相应的读写完毕中断。如果DEVICE设备读写完毕，则对HOST设备发送中断。2.HOST设备主动查询DEVICE设备是否读写完毕，可以通过CMD命令是否有返回来判断是否DEVICE是否读写完毕。</p><p>用来初始化SDIO卡设备的CMD是CMD5，CMD41 是用来初始化SD卡用的。CMD52和CMD53 是用来读写数据的命令。CMD52一次只能读一个字节，CMD53可以一次读取多个字节或者多个块。</p><p><strong>PCIE总线接口</strong></p><p>是一种高速串行计算机扩展总线标准，主要用于扩充计算机系统总线数据吞吐量以及提高设备通信速度。<br>PCIe总线标准比PCI总线有优势，采用双通道传输，全双工模式。<br>PCI总线使用并行总线结构,在同一条总线上的所有外部设备共享总线带宽,而PCIe总线使用了高速差分总线,并采用端到端的连接方式,因此在每一条PCIe链路中只能连接两个设备。这使得PCIe与PCI总线采用的拓扑结构有所不同。PCIe总线除了在连接方式上与PCI总线不同之外,还使用了一些在网络通信中使用的技术,如支持多种数据路由方式,基于多通路的数据传递方式,和基于报文的数据传送方式,并充分考虑了在数据传送中出现服务质量.<br><u>PCIE总线上的峰值带宽计算公式为总线频率 * 数据位宽 * 2</u><br>PCIE总线规范要求所有的设备必须支持Capability结构。在一个PCIE设备中，可能包含有多个Capability结构。每一个Capability结构都有唯一的ID号。每一个Capability寄存器都有一个指针，指向下一个Capability结构。<br>当PCIe设备进入休眠状态，主电源已经停止供电时，PCIe设备使用该信号向处理器系统提交唤醒请求，使处理器系统重新为该PCIe设备提供主电源Vcc。在PCIe总线中，WAKE#信号是可选的，因此使用WAKE#信号唤醒PCIe设备的机制也是可选的。值得注意的是产生该信号的硬件逻辑必须使用辅助电源Vaux供电。WAKE#是一个Open Drain信号，一个处理器的所有PCIe设备可以将WAKE#信号进行线与后，统一发送给处理器系统的电源控制器。当某个PCIe设备需要被唤醒时，该设备首先置WAKE#信号有效，然后在经过一段延时之后，处理器系统开始为该设备提供主电源Vcc，并使用PERST#信号对该设备进行复位操作。此时WAKE#信号需要始终保持为低，当主电源Vcc上电完成之后，PERST#信号也将置为无效并结束复位，WAKE#信号也将随之置为无效，结束整个唤醒过程。<br>物理层是PCIe总线的最底层，将PCIe设备连接在一起。PCIe总线的物理电气特性决定了PCIe链路只能使用端到端的连接方式。PCIe总线的物理层为PCIe设备间的数据通信提供传送介质，为数据传送提供可靠的物理环境。 PCIe总线的物理层还定义了一些专门的“序列”，这些序列用于同步PCIe链路，并进行链路管理。</p><p><strong>单总线技术（单总线接口）</strong></p><p>单总线接口是一种特殊的通信接口，具有简洁且经济的特点，可使用户轻松地组建传感器网络。<br>所有的单总线器件要求采用严格的信号时序，以保证数据的完整性。共有 6种信号类型：复位脉冲、应答脉冲、写 0、写 1、读 0和读 1。所有这些信号，除了应答脉冲以外都由主机发出同步信号。<br>单总线上的所有通信都是以初始化序列开始。主机输出低电平，保持低电平时间至少 480 us，，以产生复位脉冲。接着主机释放总线 ，4.7K的上拉电阻将单 总线拉高，延时 15 60 us并进入接收模式 (Rx)。</p><p><strong>RS485</strong></p><p>RS485使用在点对点网络，线型网络，总线型网络中，不能是星型或者环型网络。<br>由于RS485具有传输距离远、传输速度 快、支持节点多和抗干扰能力更强 等特点，所以RS485有很广泛的应用。在RS485接口设计中，我们通常需要 2个终端匹配电阻，其阻值要求等于传输电缆的特性阻抗。<br>RS485需要 2个终端匹配电阻，其阻值要求等于传输电缆的特性阻抗（一般为 120Ω）。没有特性阻抗的话，当所有的设备都静止或者没有能量的时候就会产生噪 声，而且线移需要双端的电压差。没有终接电阻的话，会使得较快速的发送端产生多个数据信号的边缘，导致数据传输出错。接口电平是物理电气特性，和匹配电阻没关系，扩展节点数和芯片能力相关，和匹配电阻无关。<br>RS485的特点：<br>① 接口电平低，不易损坏芯片。 RS485的电气特性：逻辑“ 1”以两线间的电压差为 +(2<del>6)V表示；逻辑“ 0”以两线 间的电压差为 –(2</del>6)V表示。接口信号电平比 RS232降低了，不易损坏接口电路的芯片，且该电平与 TTL电平兼容，可方便与 TTL 电路连接。<br>② 传输 速率高。 10米时， RS485的数据最高传输速率 可达 35Mbps，在 1200m时，传输速度可达 100Kbps。<br>③ 抗干扰能力强。 RS485接口是采用平衡驱动器和差分接收器的组合，抗共模干扰能力增强，即抗噪声干扰性好。 传输距离远，支持节点多。 RS485总线 最长可以传输 1200m以上（速率≤ 100Kbps<br>④ 一般最大支持 32个节点，如果使用特制的 485芯片，可以达到 128个或者 256个节点，最大的可以支持到 400个节点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 硬件传输接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>boa服务器发布</title>
      <link href="/2023/10/17/2023-10-17-boa%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E5%B8%83/"/>
      <url>/2023/10/17/2023-10-17-boa%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>这个东西配置cgi的路径要一次配置出来，不要安装完再配置，否则容易出现cgi的跳转404的现象。</p><h3 id="Boa介绍"><a href="#Boa介绍" class="headerlink" title="Boa介绍"></a>Boa介绍</h3><p>其可执行代码只有大约60KB左右，Boa是一个单任务的HTTP服务器，Boa只能依次完成用户的请求，而不会fork出新的进程来处理并发连接请求。Boa支持CGI。Boa的设计目标是速度和安全。（CGI只是一个进程，用来提供接口），自动目录生成和自动文件枪支进行拼接。<br>Boa的主要设计目标是速度和安全性。安全性在“不能被恶意用户破坏”的意义上，不是“细粒度访问控制和加密通信”。</p><p>特点：可靠性和可移植性，Boa不是作为功能强大的服务器。<br>开发平台：GNU &#x2F; Linux是目前的开发平台。</p><p>下载源码<a href="http://www.boa.org/">http://www.boa.org/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf boa-0.94.13.tar.gz</span><br><span class="line">cd ./boa-0.94.13/src/</span><br></pre></td></tr></table></figure><p>更改文件</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-17%20164941.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-17%20165211.png"></p><p>在boa-0.94.13&#x2F;src目录下，新建install.mk文件，使用Makefile命令install和uninstall安装和卸载软件及软件配置信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: all install uninstall test</span><br><span class="line"> </span><br><span class="line">SRC_PWD = $(PWD)</span><br><span class="line">SUDO= sudo</span><br><span class="line">MKDIR= mkdir -p</span><br><span class="line">CP= cp -rf</span><br><span class="line">RM= rm -rf </span><br><span class="line"> </span><br><span class="line">BIN_BOA= boa</span><br><span class="line">BIN_INDEX = boa_indexer</span><br><span class="line"> </span><br><span class="line">CONF_FILE = ../boa.conf </span><br><span class="line"> </span><br><span class="line">DIR_CONF= /etc/boa</span><br><span class="line">DIR_LOG= /var/log/boa</span><br><span class="line">DIR_ROOT= /var/wwwBoa</span><br><span class="line">DIR_MAKER= /usr/lib/boa</span><br><span class="line">DIR_CGI= /var/wwwBoa/cgi-bin</span><br><span class="line"> </span><br><span class="line">all:install</span><br><span class="line"> </span><br><span class="line">install:</span><br><span class="line">@echo &quot;Install boa.&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(SUDO) $(MKDIR) $(DIR_CONF) $(DIR_LOG) $(DIR_ROOT) $(DIR_MAKER) $(DIR_CGI) &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">$(SUDO) $(CP) $(SRC_PWD)/$(CONF_FILE) $(DIR_CONF) &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">$(SUDO) $(CP) $(SRC_PWD)/$(BIN_BOA) /usr/bin &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">$(SUDO) $(CP) $(SRC_PWD)/$(BIN_INDEX) $(DIR_MAKER) &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">$(SUDO) $(CP) $(SRC_PWD)/../examples/index.html $(DIR_ROOT)</span></span><br><span class="line"> </span><br><span class="line">uninstall:</span><br><span class="line">@echo &quot;Uninstall boa.&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(SUDO) $(RM) /usr/bin/boa</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(SUDO) $(RM) $(DIR_CONF)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(SUDO) $(RM) $(DIR_LOG)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(SUDO) $(RM) $(DIR_ROOT)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(SUDO) $(RM) $(DIR_MAKER)</span></span><br><span class="line"> </span><br><span class="line">test:</span><br><span class="line">@echo &quot;-------This is a Test.---------&quot;</span><br><span class="line">@echo $(SRC_PWD)</span><br></pre></td></tr></table></figure><p>更改boa.conf文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User 0</span><br><span class="line">Group 0</span><br><span class="line">DocumentRoot /var/www</span><br><span class="line">ScriptAlias /cgi-bin/ /var/www/cgi-bin/</span><br></pre></td></tr></table></figure><p>之后进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">make -f install.mk install</span><br></pre></td></tr></table></figure><p>之后在&#x2F;var&#x2F;www文件夹下面写html网页文件，写的内容就是你显示的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Flyer<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>how are you.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果加上cgi的跳转，请加上一句话</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Flyer<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./cgi-bin/hello.cgi&quot;</span>&gt;</span>cgi int the boa server<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后就要写跳转的cgi文件，cgi就是C语言文件就行编译连接生成.cgi格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content - Type:text/html\n\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;title&gt; cgi &lt;/title&gt; \n &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;h1&gt; hello world! &lt;/h1&gt; \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;p&gt; this is a demo of cgi&#x27;s program in the boa server &lt;/p &gt; \n &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello.cgi</span><br><span class="line">cp hello.cgi /var/www/cgi-bin/</span><br><span class="line">cd</span><br><span class="line">cd boa-0.94.13</span><br><span class="line">sudo boa</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-17%20205247.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-17%20205314.png"></p><p>以上是显示结果，地址为当前主机的ip地址，可以通过使用ifconfig进行查询。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串口应用编程</title>
      <link href="/2023/10/17/2023-10-18-%E4%B8%B2%E5%8F%A3%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/10/17/2023-10-18-%E4%B8%B2%E5%8F%A3%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><p>串口全称叫做串行接口，串行接口指的是数据一个一个的按顺序传输，通信线路简单。使用两条线即可实现双向通信，一条用于发送，一条用于接收。串口通信距离远，但是速度相对会低，串口是一种很常用的工业接口。 </p><h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><p>⚫本地终端： 例如对于我们的个人 PC 机来说， PC 机连接了显示器、键盘以及鼠标等设备，这样的一个显示器&#x2F;键盘组合就是一个本地终端；同样对于开发板来说也是如此，开发板也可以连接一个LCD 显示器、键盘和鼠标等，同样可以构成本地终端。<br>⚫ 用串口连接的远程终端： 对于嵌入式 Linux 开发来说，这是最常见的终端—串口终端。譬如我们的开发板通过串口线连接到一个带有显示器和键盘的 PC 机，在 PC 机通过运行一个终端模拟程序，<br>譬如 Windows 超级终端、 putty、 MobaXterm、 SecureCRT 等来获取并显示开发板通过串口发出的数据、同样还可以通过这些终端模拟程序将用户数据通过串口发送给开发板 Linux 系统，系统接收到数据之后便会进行相应的处理、譬如执行某个命令，这就是一种人机交互！<br>⚫ 基于网络的远程终端： 譬如我们可以通过 ssh、 Telnet 这些协议登录到一个远程主机。 </p><h3 id="终端对应的设备节点"><a href="#终端对应的设备节点" class="headerlink" title="终端对应的设备节点"></a>终端对应的设备节点</h3><p>在 Linux 当中，一切皆是文件。当然，终端也不例外，每一个终端在&#x2F;dev 目录下都有一个对应的设备节点。<br>&#x2F;dev&#x2F;ttyX（X 是一个数字编号，譬如 0、 1、 2、 3 等） 设备节点： ttyX（teletype 的简称）是最令人熟悉的了，在 Linux 中， &#x2F;dev&#x2F;ttyX 代表的都是上述提到的本地终端， 包括&#x2F;dev&#x2F;tty1~&#x2F;dev&#x2F;tty63 一共63 个本地终端， 也就是连接到本机的键盘显示器可以操作的终端。 </p><p>&#x2F;dev&#x2F;pts&#x2F;X（X 是一个数字编号，譬如 0、 1、 2、 3 等）设备节点：这类设备节点是伪终端对应的设备节点，也就是说，伪终端对应的设备节点都在&#x2F;dev&#x2F;pts 目录下、以数字编号命令。 譬如我们通过ssh 或 Telnet 这些远程登录协议登录到开发板主机，那么开发板 Linux 系统会在&#x2F;dev&#x2F;pts 目录下生成一个设备节点，这个设备节点便对应伪终端， </p><p>其实串口的应用编程也很简单，无非就是通过 ioctl()对串口进行配置，调用 read()读取串口的数据、调用 write()向串口写入数据，inux 为上层用户做了一层封装，将这些 ioctl()操作封装成了一套标准的 API，我们就直接使用这一套标准 API 编写自己的串口应用程序即可！ </p><p>串口编程重点为配置和传输读写两个部分。</p><h3 id="配置部分"><a href="#配置部分" class="headerlink" title="配置部分"></a>配置部分</h3><p>用结构体struct termios对其进行表示终端的配置信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">tcflag_t</span> c_iflag;<span class="comment">//输入模式</span></span><br><span class="line">    <span class="type">tcflag_t</span> c_oflag;<span class="comment">//输出模式</span></span><br><span class="line">    <span class="type">tcflag_t</span> c_cflag;<span class="comment">//控制模式</span></span><br><span class="line">    <span class="type">fcflag_t</span> c_lflag;<span class="comment">//本地模式</span></span><br><span class="line">    <span class="type">cc_t</span> c_line; <span class="comment">//线程规划</span></span><br><span class="line">    <span class="type">cc_t</span> c_cc[NCCS]; <span class="comment">//特殊控制字符</span></span><br><span class="line">    <span class="type">speed_t</span> c_ispeed;<span class="comment">//输入速率</span></span><br><span class="line">    <span class="type">speed_t</span> c_ospeed;<span class="comment">//输出速率</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入模式</strong></p><p>输入模式控制输入数据（终端驱动程序从串口或键盘接收到的字符数据）在被传递给应用程序之前的处理方式。 c_iflag成员标志进行控制，这个标志定义为宏定义。</p><p>可用于 c_iflag 成员的宏如下所示：</p><table><thead><tr><th>IGNBRK</th><th>忽略输入终止条件</th></tr></thead><tbody><tr><td>BRKINT</td><td>当检测到输入终止条件时发送 SIGINT 信号</td></tr><tr><td>IGNPAR</td><td>忽略帧错误和奇偶校验错误</td></tr><tr><td>PARMRK</td><td>对奇偶校验错误做出标记</td></tr><tr><td>INPCK</td><td>对接收到的数据执行奇偶校验</td></tr><tr><td>ISTRIP</td><td>将所有接收到的数据裁剪为 7 比特位、也就是去除第八位</td></tr><tr><td>INLCR</td><td>将接收到的 NL（换行符）转换为 CR（回车符）</td></tr><tr><td>IGNCR</td><td>忽略接收到的 CR（回车符）</td></tr><tr><td>ICRNL</td><td>将接收到的 CR（回车符）转换为 NL（换行符）</td></tr><tr><td>IUCLC</td><td>将接收到的大写字符映射为小写字符</td></tr><tr><td>IXON</td><td>启动输出软件流控</td></tr><tr><td>IXOFF</td><td>启动输入软件流控</td></tr></tbody></table><p><strong>输出模式</strong></p><p>输出模式控制输出字符的处理方式，即由应用程序发送出去的字符数据在传递到串口或屏幕之前是如何处理的 。</p><table><thead><tr><th>OPOST</th><th>启用输出处理功能，如果不设置该标志则其他标志都被忽略</th></tr></thead><tbody><tr><td>OLCUC</td><td>将输出字符中的大写字符转换成小写字符</td></tr><tr><td>ONLCR</td><td>将输出中的换行符（NL ‘\n’）转换成回车符（CR ‘\r’）</td></tr><tr><td>OCRNL</td><td>将输出中的回车符（CR ‘\r’）转换成换行符（NL ‘\n’）</td></tr><tr><td>ONOCR</td><td>在第 0 列不输出回车符（CR）</td></tr><tr><td>ONLRET</td><td>不输出回车符</td></tr><tr><td>OFILL</td><td>发送填充字符以提供延时</td></tr><tr><td>OFDEL</td><td>如果设置该标志，则表示填充字符为 DEL 字符，否则为 NULL 字符</td></tr></tbody></table><p><strong>控制模式</strong></p><p>控制模式就是一般我们进行的设置，比如串口的波特率、数据位、校检位、停止位等硬件特性。</p><table><thead><tr><th>CBAUD</th><th>波特率的位掩码</th></tr></thead><tbody><tr><td>B0</td><td>波特率为 0</td></tr><tr><td>……</td><td>……</td></tr><tr><td>B1200</td><td>1200 波特率</td></tr><tr><td>B1800</td><td>1800 波特率</td></tr><tr><td>B2400</td><td>2400 波特率</td></tr><tr><td>B4800</td><td>4800 波特率</td></tr><tr><td>B9600</td><td>9600 波特率</td></tr><tr><td>B19200</td><td>19200 波特率</td></tr><tr><td>B38400</td><td>38400 波特率</td></tr><tr><td>B57600</td><td>57600 波特率</td></tr><tr><td>B115200</td><td>115200 波特率</td></tr><tr><td>B230400</td><td>230400 波特率</td></tr><tr><td>B460800</td><td>460800 波特率</td></tr><tr><td>B500000</td><td>500000 波特率</td></tr><tr><td>B576000</td><td>576000 波特率</td></tr><tr><td>B921600</td><td>921600 波特率</td></tr><tr><td>B1000000</td><td>1000000 波特率</td></tr><tr><td>B1152000</td><td>1152000 波特率</td></tr><tr><td>B1500000</td><td>1500000 波特率</td></tr><tr><td>B2000000</td><td>2000000 波特率</td></tr><tr><td>B2500000</td><td>2500000 波特率</td></tr><tr><td>B3000000</td><td>3000000 波特率</td></tr><tr><td>……</td><td>……</td></tr><tr><td>CSIZE</td><td>数据位的位掩码</td></tr><tr><td>CS5</td><td>5 个数据位</td></tr><tr><td>CS6</td><td>6 个数据位</td></tr><tr><td>CS7</td><td>7 个数据位</td></tr><tr><td>CS8</td><td>8 个数据位</td></tr><tr><td>CSTOPB</td><td>2 个停止位，如果不设置该标志则默认是一个停止位</td></tr><tr><td>CREAD</td><td>接收使能</td></tr><tr><td>PARENB</td><td>使能奇偶校验</td></tr><tr><td>PARODD</td><td>使用奇校验、而不是偶校验</td></tr><tr><td>HUPCL</td><td>关闭时挂断调制解调器</td></tr><tr><td>CLOCAL</td><td>忽略调制解调器控制线</td></tr><tr><td>CRTSCTS</td><td>使能硬件流控</td></tr></tbody></table><p><strong>本地模式</strong></p><p>本地模式用于控制终端的本地数据处理和工作模式。 通过设置 struct termios 结构体中 c_lflag 成员的标志对本地模式进行配置。 </p><table><thead><tr><th>ISIG</th><th>若收到信号字符（INTR、 QUIT 等），则会产生相应的信号</th></tr></thead><tbody><tr><td>ICANON</td><td>启用规范模式</td></tr><tr><td>ECHO</td><td>启用输入字符的本地回显功能。当我们在终端输入字符的时候，字符 会显示出来，这就是回显功能</td></tr><tr><td>ECHOE</td><td>若设置 ICANON，则允许退格操作</td></tr><tr><td>ECHOK</td><td>若设置 ICANON，则 KILL 字符会删除当前行</td></tr><tr><td>ECHONL</td><td>若设置 ICANON，则允许回显换行符</td></tr><tr><td>ECHOCTL</td><td>若设置 ECHO，则控制字符（制表符、换行符等）会显示成“^X”， 其中 X 的 ASCII 码等于给相应控制字符的 ASCII 码加上 0x40。例如， 退格字符（0x08）会显示为“^H”（’H’的 ASCII 码为 0x48）</td></tr><tr><td>ECHOPRT</td><td>若设置 ICANON 和 IECHO，则删除字符（退格符等）和被删除的字 符都会被显示</td></tr><tr><td>ECHOKE</td><td>若设置 ICANON，则允许回显在 ECHOE 和 ECHOPRT 中设定的 KILL 字符</td></tr><tr><td>NOFLSH</td><td>在通常情况下，当接收到 INTR、 QUIT 和 SUSP 控制字符时，会清空 输入和输出队列。如果设置该标志，则所有的队列不会被清空</td></tr><tr><td>TOSTOP</td><td>若一个后台进程试图向它的控制终端进行写操作，则系统向该后台进 程的进程组发送 SIGTTOU 信号。该信号通常终止进程的执行</td></tr><tr><td>IEXTEN</td><td>启用输入处理功能</td></tr></tbody></table><p><strong>特殊控制字符</strong></p><p>特殊控制字符是一些字符组合，如 Ctrl+C、 Ctrl+Z 等， 当用户键入这样的组合键，终端会采取特殊处理方式。 struct termios 结构体中 c_cc 数组将各种特殊字符映射到对应的支持函数。每个字符位置（数组下标）由对应的宏定义的，如下所示<br>⚫ VEOF：文件结尾符 EOF，对应键为 Ctrl+D； 该字符使终端驱动程序将输入行中的全部字符传递给正在读取输入的应用程序。如果文件结尾符是该行的第一个字符，则用户程序中的 read 返回 0，表示文件结束。<br>⚫ VEOL： 附加行结尾符 EOL，对应键为 Carriage return（CR） ； 作用类似于行结束符。<br>⚫ VEOL2： 第二行结尾符 EOL2，对应键为 Line feed（LF） ；<br>⚫ VERASE： 删除操作符 ERASE，对应键为 Backspace（BS） ； 该字符使终端驱动程序删除输入行中的最后一个字符；<br>⚫ VINTR： 中断控制字符 INTR，对应键为 Ctrl+C； 该字符使终端驱动程序向与终端相连的进程发送SIGINT 信号；<br>⚫ VKILL： 删除行符 KILL，对应键为 Ctrl+U， 该字符使终端驱动程序删除整个输入行；<br>⚫ VMIN：在非规范模式下，指定最少读取的字符数 <strong>MIN</strong>；<br>⚫ VQUIT： 退出操作符 QUIT，对应键为 Ctrl+Z； 该字符使终端驱动程序向与终端相连的进程发送SIGQUIT 信号。<br>⚫ VSTART：开始字符 START，对应键为 Ctrl+Q； 重新启动被 STOP 暂停的输出。<br>⚫ VSTOP：停止字符 STOP，对应键为 Ctrl+S； 字符作用“截流”，即阻止向终端的进一步输出。用于支持 XON&#x2F;XOFF 流控。<br>⚫ VSUSP：挂起字符 SUSP，对应键为 Ctrl+Z； 该字符使终端驱动程序向与终端相连的进程发送SIGSUSP 信号，用于挂起当前应用程序。<br>⚫ VTIME：非规范模式下， 指定读取的每个字符之间的超时时间（以分秒为单位） <strong>TIME</strong>。</p><p><strong>终端有3种工作模式，分别为规范模式（canonical mode）、非规范模式（non-canonical mode）和原始模式（raw mode）。</strong>通过在termios结构的c_lflag中设置ICANNON标志来定义终端是以规范模式（设置ICANNON标志）还是以非规范模式（清除ICANNON标志）工作，默认情况为规范模式。</p><p>在规范模式下，所有的输入是基于行进行处理。在用户输入一个行结束符（回车符、EOF等）之前，系统调用read()函数读不到用户输入的任何字符。除了EOF之外的行结束符（回车符等）与普通字符一样会被read()函数读取到缓冲区之中。在规范模式中，行编辑是可行的，而且一次调用read()函数最多只能读取一行数据。如果在read()函数中被请求读取的数据字节数小于当前行可读取的字节数，则read()函数只会读取被请求的字节数，剩下的字节下次再被读取。 </p><p>在非规范模式下，所有的输入是即时有效的，不需要用户另外输入行结束符，而且不可进行行编辑。在非规范模式下，对参数字MIN（c_cc[VMIN]）和TIME（c_cc[VTIME]）的设置决定read()函数的调用方式。设置可以有4种不同的情况。</p><blockquote><p>MIN &#x3D; 0 和 TIME &#x3D; 0： 在这种情况下， read()调用总是会立即返回。若有可读数据，则读取数据并返回被读取的字节数； 否则读取不到任何数据并返回 0。<br>MIN &gt; 0 和 TIME &#x3D; 0：在这种情况下， read()函数会被阻塞， 直到有 MIN 个字符可以读取时才返回，返回值是读取的字符数量。到达文件尾时返回 0。<br> MIN &#x3D; 0 和 TIME &gt; 0：在这种情况下， 只要有数据可读或者经过 TIME 个十分之一秒的时间， read()函数则立即返回，返回值为被读取的字节数。如果超时并且未读到数据，则 read()函数返回 0。<br> MIN &gt; 0 和 TIME &gt; 0：在这种情况下， 当有 MIN 个字节可读或者两个输入字符之间的时间间隔超过 TIME 个十分之一秒时， read()函数才返回。因为在输入第一个字符后系统才会启动定时器，所以，在这种情况下， read()函数至少读取一个字节后才返回。 </p></blockquote><p>使用了串口方式与主机端进行数据交互时候使用原始模式，在这个模式下，终端是不可回显的， 并且禁用终端输入和输出字符的所有特殊处理。 在我们的应用程序中，可以通过调用 cfmakeraw()函数将终端设置为原始模式。 </p><h3 id="打开终端"><a href="#打开终端" class="headerlink" title="打开终端"></a>打开终端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd;</span><br><span class="line">fd = open(<span class="string">&quot;/dev/ttymxc2&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &gt; fd) &#123;</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O_NOTTY:该参数不会使打开的文件成为该进程的控制终端。如果没有指定这个标志，那么任何一个 输入都将会影响用户的进程。</p><h3 id="获取终端的配置参数"><a href="#获取终端的配置参数" class="headerlink" title="获取终端的配置参数"></a>获取终端的配置参数</h3><p>获取配置参数进行保存在struct termios结构体的对象中，方便备份数据。获取配置参数使用tcgetattr函数来获取串口终端配置参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcgetattr</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> termios *termios_p)</span>;</span><br></pre></td></tr></table></figure><p>tcgetattr()调用成功后，会将终端当前的配置参数保存到 termios_p 指针所指的对象中。函数调用成功返回 0；失败将返回-1，并且会设置 errno 以告知错误原因。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">old_cfg</span>;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &gt; tcgetattr(fd, &amp;old_cfg)) &#123;</span><br><span class="line"><span class="comment">/* 出错处理 */</span></span><br><span class="line">do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对串口终端进行配置"><a href="#对串口终端进行配置" class="headerlink" title="对串口终端进行配置"></a>对串口终端进行配置</h3><p><strong>配置串口终端为原始模式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">new_cfg</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;new_cfg, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> termios));</span><br><span class="line"><span class="comment">//配置为原始模式</span></span><br><span class="line">cfmakeraw(&amp;new_cfg);</span><br></pre></td></tr></table></figure><p><strong>接收使能</strong></p><p>给c_cflag添加CREAD标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag|=CREAD;<span class="comment">//接收使能</span></span><br></pre></td></tr></table></figure><p><strong>设置串口的波特率</strong></p><p>设置波特率的函数为cfsetispeed()和cfsetospeed()两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfsetispeed(&amp;new_cfg, B115200);</span><br><span class="line">cfsetospeed(&amp;new_cfg, B115200);</span><br></pre></td></tr></table></figure><p><strong>设置数据位大小</strong></p><p>设置数据位通过操作位的置换来设置数据的大小，将c_cflag成员中CSIZE位清零，再设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag &amp;=~CSIZE;</span><br><span class="line">new_cfg.c_cflag |= CS8;</span><br></pre></td></tr></table></figure><p><strong>设置校检位（奇偶）</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-18%20202207.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/奇校验使能</span><br><span class="line">new_cfg.c_cflag |= (PARODD | PARENB);</span><br><span class="line">new_cfg.c_iflag |= INPCK;</span><br><span class="line"><span class="comment">//偶校验使能</span></span><br><span class="line">new_cfg.c_cflag |= PARENB;</span><br><span class="line">new_cfg.c_cflag &amp;= ~PARODD; <span class="comment">/* 清除 PARODD 标志，配置为偶校验 */</span></span><br><span class="line">new_cfg.c_iflag |= INPCK;</span><br><span class="line"><span class="comment">//无校验</span></span><br><span class="line">new_cfg.c_cflag &amp;= ~PARENB;</span><br><span class="line">new_cfg.c_iflag &amp;= ~INPCK;</span><br></pre></td></tr></table></figure><p><strong>设置停止位</strong></p><p>停止位则是通过设置 c_cflag 成员的 CSTOPB 标志而实现的。若停止位为一个比特， 则清除 CSTOPB 标志；若停止位为两个，则添加 CSTOPB 标志即可。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将停止位设置为一个比特</span></span><br><span class="line">new_cfg.c_cflag &amp;= ~CSTOPB;</span><br><span class="line"><span class="comment">// 将停止位设置为 2 个比特</span></span><br><span class="line">new_cfg.c_cflag |= CSTOPB;</span><br></pre></td></tr></table></figure><p><strong>设置 MIN 和 TIME 的值</strong> </p><p>在对接收字符和等待时间没有特别要求的情况下，可以将 MIN 和 TIME 设置为 0， 这样则在任何情况下 read()调用都会立即返回，此时对串口的 read 操作会设置为非阻塞方式， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cc[VTIME] = <span class="number">0</span>;</span><br><span class="line">new_cfg.c_cc[VMIN] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>缓冲区的处理</strong></p><p>处理缓冲区的数据防止对后续进行干扰。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcdrain</span><span class="params">(<span class="type">int</span> fd)</span>;<span class="comment">// tcdrain()函数后会使得应用程序阻塞， 直到串口输出缓冲区中的数据全部发送完毕为止</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcflush</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> queue_selector)</span>;<span class="comment">/*函数会清空输入/输出缓冲区中的数据，具体情况取决于参数</span></span><br><span class="line"><span class="comment">queue_selector，参数 queue_selector 可取值如下：</span></span><br><span class="line"><span class="comment">TCIFLUSH： 对接收到而未被读取的数据进行清空处理；</span></span><br><span class="line"><span class="comment">TCOFLUSH： 对尚未传输成功的输出数据进行清空处理；</span></span><br><span class="line"><span class="comment">TCIOFLUSH： 包括前两种功能，即对尚未处理的输入/输出数据进行清空处理*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcflow</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> action)</span>;<span class="comment">/*tcflow()函数会暂停串口上的数据传输或接收工作，具体情况取决于参数 action，参数 action 可取</span></span><br><span class="line"><span class="comment">值如下：</span></span><br><span class="line"><span class="comment">TCOOFF：暂停数据输出（输出传输）；</span></span><br><span class="line"><span class="comment">TCOON： 重新启动暂停的输出；</span></span><br><span class="line"><span class="comment">TCIOFF： 发送 STOP 字符，停止终端设备向系统发送数据；</span></span><br><span class="line"><span class="comment">TCION： 发送一个 START 字符，启动终端设备向系统发送数据；*/</span></span><br></pre></td></tr></table></figure><h3 id="写入配置、使配置生效"><a href="#写入配置、使配置生效" class="headerlink" title="写入配置、使配置生效"></a>写入配置、使配置生效</h3><p>前面已经完成了对 struct termios 结构体各个成员进行配置，但是配置还未生效，我们需要将配置参数写入到终端设备（串口硬件），使其生效。通过 tcsetattr()函数将配置参数写入到硬件设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcsetattr</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> optional_actions, <span class="type">const</span> <span class="keyword">struct</span> termios *termios_p)</span>;</span><br><span class="line"><span class="comment">//将参数 termios_p 所指 struct termios 对象中的配置参数写入到终端设备中</span></span><br></pre></td></tr></table></figure><p>而参数 optional_actions 可以指定更改何时生效，其取值如下：<br>⚫ TCSANOW：配置立即生效。<br>⚫ TCSADRAIN： 配置在所有写入 fd 的输出都传输完毕之后生效。<br>⚫ TCSAFLUSH： 所有已接收但未读取的输入都将在配置生效之前被丢弃。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-19%20150826.png"></p><p>为了处理同时收发数据，可以使用多线程或异步I&#x2F;O来实现同时收发数据。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>异步 I&#x2F;O 中，当文件描述符上可以执行 I&#x2F;O 操作时，进程可以请求内核为自己发送一个信号。 之后进程就可以执行任何其它的任务直到文件描述符可以执行 I&#x2F;O 操作为止，此时内核会发送信号给进程。 （异步 I&#x2F;O 通常也称为信号驱动 I&#x2F;O ）</p><blockquote><p>要使用异步 I&#x2F;O，程序需要按照如下步骤来执行：<br>通过指定 O_NONBLOCK 标志使能非阻塞 I&#x2F;O。<br>通过指定 O_ASYNC 标志使能异步 I&#x2F;O（O_ASYNC 标志可用于使能文件描述符的异步 I&#x2F;O 事件 ）。<br>设置异步 I&#x2F;O 事件的接收进程。也就是当文件描述符上可执行 I&#x2F;O 操作时会发送信号通知该进程，通常将调用进程设置为异步 I&#x2F;O 事件的接收进程。<br>为内核发送的通知信号注册一个信号处理函数。默认情况下， 异步 I&#x2F;O 的通知信号是 SIGIO，所以内核会给进程发送信号 SIGIO。在 8.2 小节中简单地提到过该信号。<br>以上步骤完成之后，进程就可以执行其它任务了，当 I&#x2F;O 操作就绪时，内核会向进程发送一个 SIGIO信号，当进程接收到信号时，会执行预先注册好的信号处理函数，我们就可以在信号处理函数中进行 I&#x2F;O 操作 </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag;</span><br><span class="line">flag = fcntl(<span class="number">0</span> ,F_GETFL);</span><br><span class="line">flag |= O_ASYNC;</span><br><span class="line">fcntl(fd, F_SETFL, flag);</span><br><span class="line"><span class="comment">/* 设置异步 I/O 的所有者 */</span></span><br><span class="line">fcntl(fd, F_SETOWN, getpid());</span><br><span class="line"><span class="comment">/* 为 SIGIO 信号注册信号处理函数 */</span></span><br><span class="line">signal(SIGIO, sigio_handler);</span><br></pre></td></tr></table></figure><p>默认的异步 I&#x2F;O 通知信号 SIGIO 是非排队信号。 SIGIO 信号是标准信号（非实时信号、不可靠信号），所以它不支持信号排队机制， 譬如当前正在执行 SIGIO 信号的处理函数，此时内核又发送多次 SIGIO 信号给进程，这些信号将会被阻塞，只有当信号处理函数执行完毕之后才会传递给进程，并且只能传递一次，而其它后续的信号都会丢失。 无法得知文件描述符发生了什么事件。 </p><p>所以使用制定实时信号，来作为异步IO通知信号，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(fd, F_SETSIG, SIGRTMIN);<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>当文件描述符 fd 可执行 I&#x2F;O 操作时，内核会发送实时信号 SIGRTMIN 给调用进程。 </p><p><strong>使用 sigaction()函数注册信号处理函数</strong> </p><p>在应用程序当中需要为实时信号注册信号处理函数，使用 sigaction 函数进行注册，并为 sa_flags 参数指定 SA_SIGINFO， 表示使用 sa_sigaction 指向的函数作为信号处理函数，而不使用 sa_handler 指向的函数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);           <span class="comment">// 信号处理函数的地址</span></span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">// 替代 sa_handler，支持更多参数</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;                 <span class="comment">// 设置信号掩码，控制信号处理时的阻塞</span></span><br><span class="line">    <span class="type">int</span> sa_flags;                     <span class="comment">// 标志，控制信号处理行为</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);        <span class="comment">// 仅在一些特定平台上存在，一般不需要设置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sa_handler：指定了用于处理信号的函数的地址，通常是一个函数指针。当信号发生时，系统会调用指定的函数来处理信号。例如，SIGINT 信号的处理函数可以是 SIG_DFL（默认操作）、SIG_IGN（忽略信号）或你自己定义的处理函数。<br>sa_sigaction：这个成员是一个更通用的信号处理函数指针，支持接收更多的参数，包括有关信号源的额外信息。通常，你可以选择使用 sa_handler 或 sa_sigaction 中的一个，而不是两者同时使用。<br>sa_mask：这个成员用于设置信号掩码，即在信号处理函数执行期间将阻塞的信号。这是一个 sigset_t 类型的位掩码，允许你指定哪些信号应在信号处理期间阻塞。这有助于防止嵌套信号处理。<br>sa_flags：这个成员用于指定一些标志，以控制信号处理的行为。例如，SA_RESTART 标志可以用于在系统调用被中断后自动重启它。<br>sa_restorer：这个成员在一些特定平台上存在，通常不需要设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;aio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> serial_port;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> <span class="title">aio</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">aio_handler</span><span class="params">(<span class="type">int</span> signo, <span class="type">siginfo_t</span> *info, <span class="type">void</span> *context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (aio_error(&amp;aio) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *data = (<span class="type">char</span> *)aio.aio_buf;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;接收到的数据: %s\n&quot;</span>, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;异步I/O读取数据时发生错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开串口设备</span></span><br><span class="line">    serial_port = open(<span class="string">&quot;/dev/ttyS0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (serial_port == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;无法打开串口设备&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置串口参数（与前一个示例相同）</span></span><br><span class="line">    <span class="comment">// 配置异步I/O参数</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    aio.aio_fildes = serial_port;</span><br><span class="line">    aio.aio_buf = buffer;</span><br><span class="line">    aio.aio_nbytes = <span class="keyword">sizeof</span>(buffer);</span><br><span class="line">    aio.aio_offset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置异步I/O完成时的信号处理函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    sa.sa_sigaction = aio_handler;</span><br><span class="line">    sa.sa_flags = SA_SIGINFO;</span><br><span class="line">    sigaction(SIGIO, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 启用文件描述符的FASYNC标志，以允许异步I/O</span></span><br><span class="line">    fcntl(serial_port, F_SETOWN, getpid());</span><br><span class="line">    fcntl(serial_port, F_SETFL, FASYNC);</span><br><span class="line">    <span class="comment">// 启动异步I/O读取</span></span><br><span class="line">    aio_read(&amp;aio);</span><br><span class="line">    <span class="comment">// 主线程中发送数据</span></span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;Hello, Serial!&quot;</span>;</span><br><span class="line">    write(serial_port, message, <span class="keyword">sizeof</span>(message));</span><br><span class="line">    <span class="comment">// 主线程等待异步I/O完成</span></span><br><span class="line">    <span class="keyword">while</span> (aio_error(&amp;aio) == EINPROGRESS) &#123;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭串口</span></span><br><span class="line">    close(serial_port);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCD应用层编程</title>
      <link href="/2023/10/11/2023-10-11-LCD%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/10/11/2023-10-11-LCD%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>接下来学一些linux的应用层编程的内容，重点学习一下LCD，Socket，音频等反面的内容。</p><p>之前学习应用编程没有进入提高阶段最近捡一下，已经把TCP&#x2F;IP的一部分知识补充了。</p><h2 id="FrameBuffer"><a href="#FrameBuffer" class="headerlink" title="FrameBuffer"></a>FrameBuffer</h2><p>在LCD驱动章节说过Framebuffer就是帧缓冲，意味着Framebuffer就是一块内存，里面保存着一帧图像。帧缓冲（framebuffer）是 Linux 系统中的一种显示驱动接口，它将显示设备（譬如 LCD） 进行抽象、 屏蔽了不同显示设备硬件的实现，对应用层抽象为一块显示内存（显存），它允许上层应用程序直接对显示缓冲区进行读写操作 。</p><p>LCD是没有显存的，存储在DDR上的一段空间内，显存大小&#x3D;分辨率x色彩精度&#x2F;8。</p><h3 id="使用ioctl函数进行获取信息"><a href="#使用ioctl函数进行获取信息" class="headerlink" title="使用ioctl函数进行获取信息"></a>使用ioctl函数进行获取信息</h3><p>当打开 LCD 设备文件之后，需要先获取到 LCD 屏幕的参数信息，譬如 LCD 的 X 轴分辨率、 Y 轴分辨率以及像素格式等信息，通过这些参数计算出 LCD 显示缓冲区的大小。 </p><p>一般获取FBIOGET_VSCREENINFO（表示获取 FrameBuffer 设备的可变参数信息 ）、FBIOPUT_VSCREENINFO（ 表示设置 FrameBuffer 设备的可变参数信息 ）、FBIOGET_FSCREENINFO（表示获取 FrameBuffer 设备的固定参数信息 ）。</p><p>可变参数信息使用 struct fb_var_screeninfo 结 构 体 来 描 述 ，固定参数信息使用struct fb_fix_screeninfo结构体来描述 。</p><p>上 面 所 提 到 的 三 个 宏 定 义 FBIOGET_VSCREENINFO 、 FBIOPUT_VSCREENINFO 、FBIOGET_FSCREENINFO 以及 2 个数据结构 struct fb_var_screeninfo 和 struct fb_fix_screeninfo 都定义在 &lt;linux&#x2F;fb.h&gt;头文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span>&#123;</span></span><br><span class="line">    __u32 xres; <span class="comment">/* 可视区域，一行有多少个像素点， X 分辨率 */</span></span><br><span class="line">    __u32 yres; <span class="comment">/* 可视区域，一列有多少个像素点， Y 分辨率 */</span></span><br><span class="line">    __u32 xres_virtual; <span class="comment">/* 虚拟区域，一行有多少个像素点 */</span></span><br><span class="line">    __u32 yres_virtual; <span class="comment">/* 虚拟区域，一列有多少个像素点 */</span></span><br><span class="line">    __u32 xoffset; <span class="comment">/* 虚拟到可见屏幕之间的行偏移 */</span></span><br><span class="line">    __u32 yoffset; <span class="comment">/* 虚拟到可见屏幕之间的列偏移 */</span></span><br><span class="line">    __u32 bits_per_pixel; <span class="comment">/* 每个像素点使用多少个 bit 来描述，也就是像素深度 bpp */</span></span><br><span class="line">    __u32 grayscale; <span class="comment">/* =0 表示彩色, =1 表示灰度, &gt;1 表示 FOURCC 颜色 */</span></span><br><span class="line">    <span class="comment">/* 用于描述 R、 G、 B 三种颜色分量分别用多少位来表示以及它们各自的偏移量 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">red</span>;</span> <span class="comment">/* Red 颜色分量色域偏移 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">green</span>;</span> <span class="comment">/* Green 颜色分量色域偏移 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">blue</span>;</span> <span class="comment">/* Blue 颜色分量色域偏移 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">transp</span>;</span> <span class="comment">/* 透明度分量色域偏移 */</span></span><br><span class="line">    __u32 nonstd; <span class="comment">/* nonstd 等于 0，表示标准像素格式；不等于 0 则表示非标准像素格式 */</span></span><br><span class="line">    __u32 activate;</span><br><span class="line">    __u32 height; <span class="comment">/* 用来描述 LCD 屏显示图像的高度（以毫米为单位） */</span></span><br><span class="line">    __u32 width; <span class="comment">/* 用来描述 LCD 屏显示图像的宽度（以毫米为单位） */</span></span><br><span class="line">    __u32 accel_flags;</span><br><span class="line">    <span class="comment">/* 以下这些变量表示时序参数 */</span></span><br><span class="line">    __u32 pixclock; <span class="comment">/* pixel clock in ps (pico seconds) */</span></span><br><span class="line">    __u32 left_margin; <span class="comment">/* time from sync to picture */</span></span><br><span class="line">    __u32 right_margin; <span class="comment">/* time from picture to sync */</span></span><br><span class="line">    __u32 upper_margin; <span class="comment">/* time from sync to picture */</span></span><br><span class="line">    __u32 lower_margin;</span><br><span class="line">    __u32 hsync_len; <span class="comment">/* length of horizontal sync */</span></span><br><span class="line">    __u32 vsync_len; <span class="comment">/* length of vertical sync */</span></span><br><span class="line">    __u32 sync; <span class="comment">/* see FB_SYNC_* */</span></span><br><span class="line">    __u32 vmode; <span class="comment">/* see FB_VMODE_* */</span></span><br><span class="line">    __u32 rotate; <span class="comment">/* angle we rotate counter clockwise */</span></span><br><span class="line">    __u32 colorspace; <span class="comment">/* colorspace for FOURCC-based modes */</span></span><br><span class="line">    __u32 reserved[<span class="number">4</span>]; <span class="comment">/* Reserved for future compatibility */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> &#123;</span></span><br><span class="line">    __u32 offset; <span class="comment">/* 偏移量 */</span></span><br><span class="line">    __u32 length; <span class="comment">/* 长度 */</span></span><br><span class="line">    __u32 msb_right; <span class="comment">/* != 0 : Most significant bit is right </span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> id[<span class="number">16</span>]; <span class="comment">/* 字符串形式的标识符 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> smem_start; <span class="comment">/* 显存的起始地址（物理地址） */</span></span><br><span class="line">    __u32 smem_len; <span class="comment">/* 显存的长度 */</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 type_aux;</span><br><span class="line">    __u32 visual;</span><br><span class="line">    __u16 xpanstep;</span><br><span class="line">    __u16 ypanstep;</span><br><span class="line">    __u16 ywrapstep;</span><br><span class="line">    __u32 line_length; <span class="comment">/* 一行的字节数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmio_start; <span class="comment">/* Start of Memory Mapped I/O(physical address) */</span></span><br><span class="line">    __u32 mmio_len; <span class="comment">/* Length of Memory Mapped I/O */</span></span><br><span class="line">    __u32 accel; <span class="comment">/* Indicate to driver which specific chip/card we have */</span></span><br><span class="line">    __u16 capabilities;</span><br><span class="line">    __u16 reserved[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>smem_start 表示显存的起始地址，这是一个物理地址，当然在应用层无法直接使用； smem_len 表示显存的长度，这个长度并一定等于 LCD 实际的显存大小。 line_length 表示屏幕的一行像素点有多少个字节，通常可以使用 line_length * yres 来得到屏幕显示缓冲区的大小。 </p><p>编写程序获取LCD屏幕信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">fb_fix</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">fb_var</span>;</span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>((fd = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_WRONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ioctl(fd, FBIOGET_VSCREENINFO, &amp;fb_var) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ioctl error\n&quot;</span>);</span><br><span class="line">perror(<span class="string">&quot;ioctl error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ioctl success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ioctl(fd, FBIOGET_FSCREENINFO, &amp;fb_fix) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ioctl error\n&quot;</span>);</span><br><span class="line">perror(<span class="string">&quot;ioctl perror&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ioctl success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分辨率:%d * %d\n&quot;</span></span><br><span class="line">   <span class="string">&quot;像素深度bpp: %d\n&quot;</span></span><br><span class="line">   <span class="string">&quot;一行的字节数：%d\n&quot;</span></span><br><span class="line">   <span class="string">&quot;像素格式:%&lt;%d %d&gt; G&lt;%d %d&gt; B&lt;%d %d&gt;\n&quot;</span>,</span><br><span class="line">   fb_var.xres, fb_var.yres, fb_var.bits_per_pixel,</span><br><span class="line">   fb_fix.line_length,</span><br><span class="line">   fb_var.red.offset, fb_var.red.length,</span><br><span class="line">   fb_var.green.offset, fb_var.green.length,</span><br><span class="line">   fb_var.blue.offset, fb_var.blue.length);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-12%20163437.png"></p><p>第一个数字表示偏移量，第二个参数为长度， 从打印的结果可知， 16bit 颜色值中高 5 位表示 R 颜色通道、中间 6 位表示 G 颜色通道、低 5 位表示 B 颜色通道， 所以这是一个 RGB565 格式的显示设备。 </p><h3 id="lcd屏幕的基础操作（画图形）"><a href="#lcd屏幕的基础操作（画图形）" class="headerlink" title="lcd屏幕的基础操作（画图形）"></a>lcd屏幕的基础操作（画图形）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> argb8888_to_rgb565(color) (&#123; \</span></span><br><span class="line"><span class="meta">unsigned int temp = (color); \</span></span><br><span class="line"><span class="meta">((temp &amp; 0xF80000UL) &gt;&gt; 8) | \</span></span><br><span class="line"><span class="meta">((temp &amp; 0xFC00UL) &gt;&gt; 5) | \</span></span><br><span class="line"><span class="meta">((temp &amp; 0xF8UL) &gt;&gt; 3); \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> width;<span class="comment">//LCD 的X像素也可以说是横着的像素长度</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> height;<span class="comment">//LCD 的Y像素也可以说是竖着的像素长度</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">short</span> *screen_base = <span class="literal">NULL</span>; <span class="comment">//映射后的显存基地址</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">画点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lcd_draw_point</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x, <span class="type">unsigned</span> <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> color)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> rgb565_color = argb8888_to_rgb565(color);<span class="comment">//得到RGB565的颜色数值</span></span><br><span class="line">    <span class="keyword">if</span>( x &gt;= width)</span><br><span class="line">x = width <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>( y &gt;= height)</span><br><span class="line">        y = height <span class="number">-1</span>;<span class="comment">//保证传入的坐标在屏幕中，不要超过屏幕的长宽。</span></span><br><span class="line">    <span class="comment">/* 填充颜色 */</span></span><br><span class="line">screen_base[y * width + x] = rgb565_color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">画线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lcd_draw_line</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x, <span class="type">unsigned</span> <span class="type">int</span> y, <span class="type">int</span> dir, <span class="type">unsigned</span> <span class="type">int</span> length,  <span class="type">unsigned</span> <span class="type">int</span> color)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> rgb565_color = argb8888_to_rgb565(color);<span class="comment">//得到 RGB565 颜色值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> end;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> temp;</span><br><span class="line"><span class="comment">/* 对传入参数的校验 ,跟之前一样*/</span></span><br><span class="line"><span class="keyword">if</span> (x &gt;= width)</span><br><span class="line">x = width - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (y &gt;= height)</span><br><span class="line">y = height - <span class="number">1</span>;</span><br><span class="line">    temp = y * width + x;<span class="comment">//定位到起点</span></span><br><span class="line">    <span class="keyword">if</span> (dir) &#123; <span class="comment">//dir为控制线的横竖方向</span></span><br><span class="line">        <span class="comment">//水平线</span></span><br><span class="line">        end = x + length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= width)</span><br><span class="line">    end = width - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= end; x++, temp++)</span><br><span class="line">    screen_base[temp] = rgb565_color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//垂直线</span></span><br><span class="line">    end = y + length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= height)</span><br><span class="line">    end = height - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; y &lt;= end; y++, temp += width)</span><br><span class="line">    screen_base[temp] = rgb565_color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*画矩形*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lcd_draw_rectangle</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start_x, <span class="type">unsigned</span> <span class="type">int</span> end_x,<span class="type">unsigned</span> <span class="type">int</span> start_y, <span class="type">unsigned</span> <span class="type">int</span> end_y,<span class="type">unsigned</span> <span class="type">int</span> color)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x_len = end_x - start_x + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> y_len = end_y - start_y - <span class="number">1</span>;</span><br><span class="line">    lcd_draw_line(start_x, start_y, <span class="number">1</span>, x_len, color);<span class="comment">//</span></span><br><span class="line">    lcd_draw_line(start_x, end_y, <span class="number">1</span>, x_len, color); <span class="comment">//下边</span></span><br><span class="line">    lcd_draw_line(start_x, start_y + <span class="number">1</span>, <span class="number">0</span>, y_len, color);<span class="comment">//左边</span></span><br><span class="line">    lcd_draw_line(end_x, start_y + <span class="number">1</span>, <span class="number">0</span>, y_len, color);<span class="comment">//右边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*矩形填充*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lcd_fill</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start_x, <span class="type">unsigned</span> <span class="type">int</span> end_x,<span class="type">unsigned</span> <span class="type">int</span> start_y, <span class="type">unsigned</span> <span class="type">int</span> end_y,<span class="type">unsigned</span> <span class="type">int</span> color)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> rgb565_color = argb8888_to_rgb565(color);<span class="comment">//得到 RGB565 颜色值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> temp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x;</span><br><span class="line"><span class="comment">/* 对传入参数的校验 */</span></span><br><span class="line"><span class="keyword">if</span> (end_x &gt;= width)</span><br><span class="line">end_x = width - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (end_y &gt;= height)</span><br><span class="line">end_y = height - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 填充颜色 */</span></span><br><span class="line">    temp = start_y * width; <span class="comment">//定位到起点行首</span></span><br><span class="line">    <span class="keyword">for</span> ( ; start_y &lt;= end_y; start_y++, temp+=width) &#123;</span><br><span class="line">    <span class="keyword">for</span> (x = start_x; x &lt;= end_x; x++)</span><br><span class="line">    screen_base[temp + x] = rgb565_color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">fb_fix</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">fb_var</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> screen_size;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">/* 打开 framebuffer 设备 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &gt; (fd = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR))) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 获取参数信息 */</span></span><br><span class="line">    ioctl(fd, FBIOGET_VSCREENINFO, &amp;fb_var);</span><br><span class="line">    ioctl(fd, FBIOGET_FSCREENINFO, &amp;fb_fix);</span><br><span class="line">    screen_size = fb_fix.line_length * fb_var.yres;</span><br><span class="line">    width = fb_var.xres;</span><br><span class="line">    height = fb_var.yres;</span><br><span class="line">    <span class="comment">/* 将显示缓冲区映射到进程地址空间 */</span></span><br><span class="line">    screen_base = mmap(<span class="literal">NULL</span>, screen_size, PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (MAP_FAILED == (<span class="type">void</span> *)screen_base) &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 画正方形方块 */</span></span><br><span class="line">    <span class="type">int</span> w = height * <span class="number">0.25</span>;<span class="comment">//方块的宽度为 1/4 屏幕高度</span></span><br><span class="line">    lcd_fill(<span class="number">0</span>, width<span class="number">-1</span>, <span class="number">0</span>, height<span class="number">-1</span>, <span class="number">0x0</span>); <span class="comment">//清屏（屏幕显示黑色）</span></span><br><span class="line">    lcd_fill(<span class="number">0</span>, w, <span class="number">0</span>, w, <span class="number">0xFF0000</span>); <span class="comment">//红色方块</span></span><br><span class="line">    lcd_fill(width-w, width<span class="number">-1</span>, <span class="number">0</span>, w, <span class="number">0xFF00</span>); <span class="comment">//绿色方块</span></span><br><span class="line">    lcd_fill(<span class="number">0</span>, w, height-w, height<span class="number">-1</span>, <span class="number">0xFF</span>); <span class="comment">//蓝色方块</span></span><br><span class="line">    lcd_fill(width-w, width<span class="number">-1</span>, height-w, height<span class="number">-1</span>, <span class="number">0xFFFF00</span>);<span class="comment">//黄色方块</span></span><br><span class="line"><span class="comment">/* 退出 */</span></span><br><span class="line">    munmap(screen_base, screen_size); <span class="comment">//取消映射</span></span><br><span class="line">    close(fd); <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS); <span class="comment">//退出进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCD对于jpeg图片的显示"><a href="#LCD对于jpeg图片的显示" class="headerlink" title="LCD对于jpeg图片的显示"></a>LCD对于jpeg图片的显示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jpeglib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bgr888_color</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> red;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> green;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> blue;</span><br><span class="line">&#125; __attribute__ ((packed)) <span class="type">bgr888_t</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> width; <span class="comment">//LCD X 分辨率</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> height; <span class="comment">//LCD Y 分辨率</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">short</span> *screen_base = <span class="literal">NULL</span>; <span class="comment">//映射后的显存基地址</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> line_length; <span class="comment">//LCD 一行的长度（字节为单位）</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> bpp; <span class="comment">//像素深度 bpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">show_jpeg_image</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jpeg_decompress_struct</span> <span class="title">cinfo</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jpeg_error_mgr</span> <span class="title">jerr</span>;</span></span><br><span class="line">FILE *jpeg_file = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">bgr888_t</span> *jpeg_line_buf = <span class="literal">NULL</span>; <span class="comment">//行缓冲区:用于存储从 jpeg 文件中解压出来的一行图像数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *fb_line_buf = <span class="literal">NULL</span>; <span class="comment">//行缓冲区:用于存储写入到 LCD 显存的一行数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> min_h, min_w;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> valid_bytes;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">//绑定默认错误处理函数</span></span><br><span class="line">cinfo.err = jpeg_std_error(&amp;jerr);</span><br><span class="line"><span class="comment">//打开.jpeg/.jpg 图像文件</span></span><br><span class="line">jpeg_file = fopen(path, <span class="string">&quot;r&quot;</span>); <span class="comment">//只读方式打开</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == jpeg_file) &#123;</span><br><span class="line">perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建 JPEG 解码对象</span></span><br><span class="line">jpeg_create_decompress(&amp;cinfo);</span><br><span class="line"><span class="comment">//指定图像文件</span></span><br><span class="line">jpeg_stdio_src(&amp;cinfo, jpeg_file);</span><br><span class="line"><span class="comment">//读取图像信息</span></span><br><span class="line">jpeg_read_header(&amp;cinfo, TRUE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;jpeg 图像大小: %d*%d\n&quot;</span>, cinfo.image_width, cinfo.image_height);</span><br><span class="line"><span class="comment">//设置解码参数</span></span><br><span class="line">cinfo.out_color_space = JCS_RGB;<span class="comment">//默认就是 JCS_RGB</span></span><br><span class="line"><span class="comment">//cinfo.scale_num = 1;/* JPEG 当前仅支持 1/1、 1/2、 1/4、 和 1/8 这几种缩小比例。 默认是 1/1，也就是保持原图大小。*/</span></span><br><span class="line"><span class="comment">//cinfo.scale_denom = 2;</span></span><br><span class="line"><span class="comment">//开始解码图像</span></span><br><span class="line">jpeg_start_decompress(&amp;cinfo);</span><br><span class="line"><span class="comment">//为缓冲区分配内存空间</span></span><br><span class="line">jpeg_line_buf = <span class="built_in">malloc</span>(cinfo.output_components * cinfo.output_width);</span><br><span class="line">fb_line_buf = <span class="built_in">malloc</span>(line_length);</span><br><span class="line"><span class="comment">//判断图像和 LCD 屏那个的分辨率更低</span></span><br><span class="line"><span class="keyword">if</span> (cinfo.output_width &gt; width)</span><br><span class="line">min_w = width;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">min_w = cinfo.output_width;</span><br><span class="line"><span class="keyword">if</span> (cinfo.output_height &gt; height)</span><br><span class="line">min_h = height;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">min_h = cinfo.output_height;</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">valid_bytes = min_w * bpp / <span class="number">8</span>;<span class="comment">//一行的有效字节数 表示真正写入到 LCD 显存的一行数据的大小</span></span><br><span class="line"><span class="keyword">while</span> (cinfo.output_scanline &lt; min_h) &#123;</span><br><span class="line">jpeg_read_scanlines(&amp;cinfo, (<span class="type">unsigned</span> <span class="type">char</span> **)&amp;jpeg_line_buf, <span class="number">1</span>);<span class="comment">//每次读取一行数据,只能支持一次只读 1 行</span></span><br><span class="line"><span class="comment">//将读取到的 BGR888 数据转为 RGB565</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min_w; i++)</span><br><span class="line">fb_line_buf[i] = ((jpeg_line_buf[i].red &amp; <span class="number">0xF8</span>) &lt;&lt; <span class="number">8</span>) |((jpeg_line_buf[i].green &amp; <span class="number">0xFC</span>) &lt;&lt; <span class="number">3</span>) |((jpeg_line_buf[i].blue &amp; <span class="number">0xF8</span>) &gt;&gt; <span class="number">3</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(screen_base, fb_line_buf, valid_bytes);</span><br><span class="line">screen_base += width;<span class="comment">//+width 定位到 LCD 下一行显存地址的起点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解码完成</span></span><br><span class="line">jpeg_finish_decompress(&amp;cinfo); <span class="comment">//完成解码</span></span><br><span class="line"></span><br><span class="line">jpeg_destroy_decompress(&amp;cinfo);<span class="comment">//销毁 JPEG 解码对象、释放资源</span></span><br><span class="line"><span class="comment">//关闭文件、释放内存</span></span><br><span class="line">fclose(jpeg_file);</span><br><span class="line"><span class="built_in">free</span>(fb_line_buf);</span><br><span class="line"><span class="built_in">free</span>(jpeg_line_buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">fb_fix</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">fb_var</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> screen_size;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">/* 传参校验 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> != argc) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;jpeg_file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 打开 framebuffer 设备 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &gt; (fd = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR))) &#123;</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 获取参数信息 */</span></span><br><span class="line">ioctl(fd, FBIOGET_VSCREENINFO, &amp;fb_var);</span><br><span class="line">ioctl(fd, FBIOGET_FSCREENINFO, &amp;fb_fix);</span><br><span class="line">line_length = fb_fix.line_length;</span><br><span class="line">bpp = fb_var.bits_per_pixel;</span><br><span class="line">screen_size = line_length * fb_var.yres;</span><br><span class="line">width = fb_var.xres;</span><br><span class="line">height = fb_var.yres;</span><br><span class="line"><span class="comment">/* 将显示缓冲区映射到进程地址空间 */</span></span><br><span class="line">screen_base = mmap(<span class="literal">NULL</span>, screen_size, PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (MAP_FAILED == (<span class="type">void</span> *)screen_base) &#123;</span><br><span class="line">perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 显示 BMP 图片 */</span></span><br><span class="line"><span class="built_in">memset</span>(screen_base, <span class="number">0xFF</span>, screen_size);</span><br><span class="line">show_jpeg_image(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">/* 退出 */</span></span><br><span class="line">munmap(screen_base, screen_size); <span class="comment">//取消映射</span></span><br><span class="line">close(fd); <span class="comment">//关闭文件</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS); <span class="comment">//退出进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式软件安装合集</title>
      <link href="/2023/10/08/2023-10-7-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2023/10/08/2023-10-7-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>吐槽一下自己，悲催了呀，安装个pycharm引发了一系列惨案，在最新的pycharm的版本上对于16版本的python3.5不支持，卸载之后终端挂了，apt-get install挂了，重新弄一个系统吧，顺便记录一下，嵌入式的软件安装。</p><h2 id="Ubuntu和Windows之间的复制粘贴"><a href="#Ubuntu和Windows之间的复制粘贴" class="headerlink" title="Ubuntu和Windows之间的复制粘贴"></a>Ubuntu和Windows之间的复制粘贴</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove open-vm-tools</span><br><span class="line">sudo apt-get install open-vm-tools</span><br><span class="line">sudo apt-get install open-vm-tools-desktop</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="安装编程工具"><a href="#安装编程工具" class="headerlink" title="安装编程工具"></a>安装编程工具</h2><h3 id="make工具安装"><a href="#make工具安装" class="headerlink" title="make工具安装"></a>make工具安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install make</span><br></pre></td></tr></table></figure><h3 id="vscode工具安装"><a href="#vscode工具安装" class="headerlink" title="vscode工具安装"></a>vscode工具安装</h3><p>官网下载安装包<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p><a href="https://vscode.cdn.azure.cn/stable/e7e037083ff4455cf320e344325dacb480062c3c/code_1.83.0-1696350811_amd64.deb">https://vscode.cdn.azure.cn/stable/e7e037083ff4455cf320e344325dacb480062c3c/code_1.83.0-1696350811_amd64.deb</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i code_1.83.0-1696350811_amd64.deb</span><br></pre></td></tr></table></figure><p>在任意路径的终端命令行下输入code命令，即可打开vscode；</p><h3 id="安装交叉编译工具"><a href="#安装交叉编译工具" class="headerlink" title="安装交叉编译工具"></a>安装交叉编译工具</h3><p><a href="https://releases.linaro.org/components/toolchain/binaries/4.9-2017.01/arm-linux-gnueabihf/">Linaro Releases</a></p><p>安装gcc-arm-linux-gnueabihf 工具以上是官网地址。</p><p>将压缩包放到&#x2F;usr&#x2F;local&#x2F;arm目录下解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/profile #打开/etc/profile 以后，在最后面输入如下所示内容：</span><br><span class="line">export PATH=$PATH:/usr/local/arm/gcc/bin</span><br></pre></td></tr></table></figure><p><strong>安装相关库</strong><br>在使用交叉编译器之前还需要安装一下其它的库，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lsb-core lib32stdc++6 </span><br><span class="line">arm-linux-gnueabihf-gcc -v#重启后使用命令查询</span><br></pre></td></tr></table></figure><h3 id="安装tftp服务"><a href="#安装tftp服务" class="headerlink" title="安装tftp服务"></a>安装tftp服务</h3><p>Ubuntu 主机作为 TFTP 服务器。因此需要在 Ubuntu 上搭建 TFTP 服务器，需要安装 tftp-hpa 和 tftpd-hpa，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tftp-hpa tftpd-hpa</span><br><span class="line">sudo apt-get install xinetd</span><br></pre></td></tr></table></figure><p>和 NFS 一样， TFTP 也需要一个文件夹来存放文件，在用户目录下新建一个目录，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/zuozhongkai/linux/tftpboot</span><br><span class="line">chmod 777 /home/zuozhongkai/linux/tftpboot</span><br></pre></td></tr></table></figure><p>这 样 我 就 在 我 的 电 脑 上 创 建 了 一 个 名 为 tftpboot 的 目 录 ( 文 件 夹 ) ， 路 径 为<br>&#x2F;home&#x2F;moss&#x2F;linux&#x2F;tftpboot。注意！我们要给 tftpboot 文件夹权限，否则的话 uboot 不能从tftpboot 文件夹里面下载文件。<br>最后配置 tftp，安装完成以后新建文件&#x2F;etc&#x2F;xinetd.d&#x2F;tftp， 如果没有&#x2F;etc&#x2F;xinetd.d 目录的话自行创建， 然后在里面输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server tftp</span><br><span class="line">&#123;</span><br><span class="line">socket_type = dgram</span><br><span class="line">protocol = udp</span><br><span class="line">wait = yes</span><br><span class="line">user = root</span><br><span class="line">server = /usr/sbin/in.tftpd</span><br><span class="line">server_args = -s /home/moss/linux/tftpboot/</span><br><span class="line">disable = no</span><br><span class="line">per_source = 11</span><br><span class="line">cps = 100 2</span><br><span class="line">flags = IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完了以后启动 tftp 服务，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service tftpd-hpa start</span><br></pre></td></tr></table></figure><p>打开&#x2F;etc&#x2F;default&#x2F;tftpd-hpa 文件，将其修改为如下所示内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># /etc/default/tftpd-hpa</span><br><span class="line"></span><br><span class="line">TFTP_USERNAME=&quot;tftp&quot;</span><br><span class="line">TFTP_DIRECTORY=&quot;/home/moss/linux/tftpboot&quot;</span><br><span class="line">TFTP_ADDRESS=&quot;:69&quot;</span><br><span class="line">TFTP_OPTIONS=&quot;-l -c -s&quot;</span><br></pre></td></tr></table></figure><p>TFTP_DIRECTORY 就是我们上面创建的 tftp 文件夹目录，以后我们就将所有需要通过TFTP 传输的文件都放到这个文件夹里面，并且要给予这些文件相应的权限。<br>最后输入如下命令， 重启 tftp 服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service tftpd-hpa restart </span><br></pre></td></tr></table></figure><h3 id="安装NFS服务"><a href="#安装NFS服务" class="headerlink" title="安装NFS服务"></a>安装NFS服务</h3><p>进行 Linux 驱动开发的时候需要 NFS 启动，因此要先安装并开启 Ubuntu 中的 NFS 服务，使用如下命令安装 NFS 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server rpcbind </span><br></pre></td></tr></table></figure><p>要先配置 nfs，使用如下命令打开 nfs 配置文件&#x2F;etc&#x2F;exports：sudo vi &#x2F;etc&#x2F;exports </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/exports</span><br></pre></td></tr></table></figure><p>打开&#x2F;etc&#x2F;exports 以后在后面添加如下所示内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/zuozhongkai/linux/nfs *(rw,sync,no_root_squash) </span><br></pre></td></tr></table></figure><p>重启 NFS 服务，使用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure><p>SSH 服务开启<br>开启 Ubuntu 的 SSH 服务以后我们就可以在 Windwos 下使用终端软件登陆到 Ubuntu，比如使用 SecureCRT， Ubuntu 下使用如下命令开启 SSH 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server </span><br></pre></td></tr></table></figure><h3 id="nfs出现的问题"><a href="#nfs出现的问题" class="headerlink" title="nfs出现的问题"></a>nfs出现的问题</h3><p>这个问题会出现在Ubuntu18上，NFS挂载失败 - VFS: Unable to mount root fs on unknown-block(2,0)。提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[  101.168510] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(2,0)</span><br><span class="line">[  101.176792] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(2,0) ]---</span><br></pre></td></tr></table></figure><p>解决方式一：</p><p>改开发板的uboot参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs rw nfsroot=192.168.28.254:/rootfs ip=192.168.28.234:192.168.28.254:192.168.28.1:255.255.255.0::eth0:off&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs rw nfsroot=192.168.28.254:/rootfs,v3,tcp ip=192.168.28.234:192.168.28.254:192.168.28.1:255.255.255.0::eth0:off&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就可以挂载成功。</p><p>方式二：更改ubuntu的NFS配置参数</p><p>上面那种方式是指定bootargs变量，但是如果你移植的uboot和linux内核版本不是很新的话，uboot和内核还不支持NFS-V3版本协议，那么就只能修改ubuntu的NFS配置了。</p><p>问题解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/nfs-kernel-server </span><br></pre></td></tr></table></figure><p>在文件末尾加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPCNFSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot;</span><br></pre></td></tr></table></figure><p>重启NFS：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure><p>这样就能开发板就能挂载上了！<br>都经过了可靠的测试都是好用的。</p><h2 id="tslib-移植与使用"><a href="#tslib-移植与使用" class="headerlink" title="tslib 移植与使用"></a>tslib 移植与使用</h2><p>tslib 是一个开源的第三方库，用于触摸屏性能调试 。</p><p>1、获取 tslib 源码<br>首先肯定是获取 tslib 的源码， git 地址为 <a href="https://github.com/kergoth/tslib%EF%BC%8C">https://github.com/kergoth/tslib，</a><br>2、修改 tslib 源码所属用户<br>修改解压得到的 tslib-1.21 目录所属用户为当前用户，这一步一定要做！否则在稍后的编译中会遇到各种问题。我当前 ubuntu 的登录用户名为“moss”，那么修改命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown moss:moss tslib-1.21 -R</span><br></pre></td></tr></table></figure><p>3、 ubuntu 工具安装<br>编译 tslib 的时候需要先在 ubuntu 中安装一些文件，防止编译 tslib 过程中出错，命令如下<br>所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf</span><br><span class="line">sudo apt-get install automake</span><br><span class="line">sudo apt-get install libtool</span><br></pre></td></tr></table></figure><p>4、编译 tslib<br>首先在 ubuntu 中创建一个名为“tslib”的目录存放编译结果，比如我们创建的 tslib 目录全路径为： &#x2F;home&#x2F;moss&#x2F;linux&#x2F;tool&#x2F;tslib。<br>接下来输入如下命令配置并编译 tslib：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd tslib-1.21/ //进入 tslib 源码目录</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure --host=arm-linux-gnueabihf --prefix=/home/moss/linux/tool/tslib</span><br><span class="line">make //编译</span><br><span class="line">make install //安装</span><br></pre></td></tr></table></figure><p>注意，在使用.&#x2F;configure 配置 tslib 的时候“–host”参数指定编译器，“–prefix”参数指定编译完成以后的 tslib 文件安装到哪里，这里肯定是安装到我们刚刚创建的“tslib”目录下。<br>bin 目录下是可执行文件，包括 tslib 的测试工具。 etc 目录下是 tslib 的配置文件， lib 目录下是相关的库文件。</p><h2 id="Qt软件安装"><a href="#Qt软件安装" class="headerlink" title="Qt软件安装"></a>Qt软件安装</h2><p>进入网址 <a href="http://download.qt.io/archive/qt/5.12/5.12.9/%E4%B8%8B%E8%BD%BD">http://download.qt.io/archive/qt/5.12/5.12.9/下载</a> Qt 5.12.9。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.qt.io/archive/qt/5.12/5.12.9/qt-opensource-linux-x64-5.12.9.run</span><br></pre></td></tr></table></figure><p>下载速度奇慢，建议使用迅雷下载，迅雷下完不愿用再卸载。（安装软件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x qt-opensource-linux-x64-5.12.9.run</span><br><span class="line">sudo ./qt-opensource-linux-x64-5.12.9.run </span><br></pre></td></tr></table></figure><h2 id="扩展分区工具"><a href="#扩展分区工具" class="headerlink" title="扩展分区工具"></a>扩展分区工具</h2><p>使用GParted Partition Editor 软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><h2 id="Pycharm软件安装"><a href="#Pycharm软件安装" class="headerlink" title="Pycharm软件安装"></a>Pycharm软件安装</h2><p>查询自己系统的python3的版本，pycharm不同版本支持不同python版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 --version</span><br></pre></td></tr></table></figure><p>之后去pythcharm官网进行下载对应的版本，进行解压压缩包。将解压的文件移动到&#x2F;opt&#x2F;目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd pycharm-community-2022.3.3 /opt/</span><br></pre></td></tr></table></figure><p>执行&#x2F;bin&#x2F;里面的pycharm.sh文件。</p><h2 id="libjpeg库"><a href="#libjpeg库" class="headerlink" title="libjpeg库"></a>libjpeg库</h2><p>libjpeg 是一个完全用 C 语言编写的函数库，包含了 JPEG 解码（解压缩） 、 JPEG 编码（创建压缩） 和其他的 JPEG 功能的实现。 可以使用 libjpeg 库对.jpg 或.jpeg 压缩文件进行解压或者生成.jpg 或.jpeg 压缩文件。 </p><p>打开 <a href="http://www.ijg.org/files/%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">http://www.ijg.org/files/链接地址</a> ，下载jpegsrc.v9b.tar.gz 源码包 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf jpegsrc.v9b.tar.gz</span><br></pre></td></tr></table></figure><p>先对交叉编译工具的环境进行初始化，使用 source执行交叉编译工具安装目录下的 environment-setup-cortexa7hf-neon-poky-linux-gnueabi 脚本文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source /opt/fsl-imx-x11/4.1.15-2.1.0/environment-setup-cortexa7hf-neon-poky-linux-gnueabi</span><br><span class="line">./configure --host=arm-poky-linux-gnueabi --prefix=/home/moss/linux/tool/jpeg/</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>将bin和lib文件夹下的文件转给根文件系统&#x2F;usr&#x2F;bin和&#x2F;usr&#x2F;lib下。</p><h2 id="SSH库"><a href="#SSH库" class="headerlink" title="SSH库"></a>SSH库</h2><p>主要是用来开启SSH服务</p><p>下载zlib库源码<a href="http://www.zlib.net/fossils/">Index of &#x2F;fossils (zlib.net)</a></p><p>下载openssh源码库<a href="https://fastly.cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/">https://fastly.cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式上的C语言</title>
      <link href="/2023/10/06/2023-10-6-%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8A%E7%9A%84C%E8%AF%AD%E8%A8%80/"/>
      <url>/2023/10/06/2023-10-6-%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8A%E7%9A%84C%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>这篇文章其实更适合在裸机开发操作寄存器之前来学习。</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="为什么需要内存？"><a href="#为什么需要内存？" class="headerlink" title="为什么需要内存？"></a>为什么需要内存？</h2><p>程序&#x3D; 代码 + 数据</p><p>程序运行的目的要么重在数据结果（有返回值），要么重在过程（无返回值），要么即重于结果又重过程。</p><p><strong>计算机程序的运行过程，其实就是程序中很多个函数相继运行的过程。</strong>程序是由很多个函数组成的，程序的本质就是函数，函数的本质就是加工数据的动作。 </p><p>哈佛结构：将程序的代码和数据分开存放的一种结构，但是存放的位置可以是相同的也可以是不同的（ROM&amp;RAM或RAM）,<u>总之只要是分成两个部分单独访问的结构都是哈佛结构。</u></p><p><strong>哈佛结构的特点就是代码和数据单独存放，使之不会互相干扰，进而当程序出 BUG 时，最多只会修改数据的值（因为代码部分是只读的，不可改写），而不会修改程序的执行顺序。因此，这种结构大量应用在嵌入式编程 。</strong></p><p>冯诺依曼结构：将代码和数据统一放在RAM（随机存取存储器）中，数据和代码之间一般是按照程序的执行顺序依次存储。</p><p>这样就会导致一个问题，<strong>如果程序出 BUG，由于程序没有对代码段的读写限定，因此，它将拥有和数据一样的读写操作权限。于是就会很容易的死机</strong>，一旦代码执行出现一点改变就会出现非常严重的错误。但是，冯诺依曼结构的好处是可以充分利用有限的内存空间，并使 CPU 对程序的执行十分的方便，不用来回跑。 </p><h2 id="程序运行为什么需要内存？"><a href="#程序运行为什么需要内存？" class="headerlink" title="程序运行为什么需要内存？"></a>程序运行为什么需要内存？</h2><p>程序运行时要存放代码和数据，代码放在 DRAM 的只读权限代码段，数据放在 DRAM 的可读可写数据段，程序要跑，内存是必要条件 。 </p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>从 OS 角度讲： OS 掌握所有的硬件内存，因为内存很大，所以 OS 把内存分成 1 个 1 个的页面（其实就是分块，一般是 4KB），然后以页面为单位来管理。页面内用更细小的方式来以字节为单位管理。 （只要调用系统的API就能管理内存）</p><p>在没有 OS 时，也就是裸机程序中程序需要直接操作内存，编程者需要自己计算内存的使用和安排。 </p><p>C： C 语言编译器帮我们管理内存地址，我们都是通过编译器通过的变量名来访问内存的，<br>OS 下如果需要大块内存，可以通过 API（mallos、 free）来访问内存。 裸机程序中需要大块内存需要自己定义数组等来解决。<br>C++： C++对内存的使用进一步封装。我们可以用 new 来创建对象（其实就是为对象分配内存），然后使用完了用 delete 来删除对象（其实就是释放内存）。所以 C++比 C 更容易一些。但是 C++中的内存管理还是要靠程序员自己来做，例如需要使用 delete 删除对象释放内存，如果忘记，就会造成内存不能释放，就是所谓的内存泄露 </p><p>从硬件角度：硬件的内存实现本身就是有宽度的，也就是内存条本身就有 8 位、 16 位等。需要注意的是，内存芯片之间可以并联，通过并联后 8 位内存芯片可以做出来 16 位、 32位的硬件内存。 从逻辑角度：内存位宽在逻辑上是任意的，甚至逻辑上内存的位宽可以是 24 位，但没必要。从逻辑角度，不管内存位宽多少，直接操作即可。但因为所有的逻辑操作都是要硬件实现，所以还是要尊重硬件内存位宽。 </p><h2 id="内存编制和寻址、内存对齐"><a href="#内存编制和寻址、内存对齐" class="headerlink" title="内存编制和寻址、内存对齐"></a>内存编制和寻址、内存对齐</h2><p>在程序运行中，CPU实际只认识内存地址，而不关心这个地址所代表的空间在哪里、怎么分布的，因为硬件设计保证了这个地址就能找到这个格子，所以内存单元的两个概念：地址和空间是内存单元的两个概念。<br><strong>内存编制是以字节为单位的。</strong><br><strong>数据类型是用来定义变量的，而这些变量需要在内存中存储和运算。所以数据类型必须和内存相匹配才能获得最好的性能。</strong><br>内存的对齐访问不是逻辑问题， 是硬件问题。从硬件角度来说， 32 位的内存它 0、1、2、3 四个单元本身逻辑上就有相关性，这 4 个字节组合起来当做一个 int，硬件上就是合适的，效率就高。</p><h1 id="C语言操作内存"><a href="#C语言操作内存" class="headerlink" title="C语言操作内存"></a>C语言操作内存</h1><p>变量名即对内存地址的封装。指针即保存这个地址的变量。函数名实质就是一段代码的首地址。 </p><h3 id="C-语言数据类型的本质含义：表示内存格子的个数（每个格子-1-个字节）和解析方法。"><a href="#C-语言数据类型的本质含义：表示内存格子的个数（每个格子-1-个字节）和解析方法。" class="headerlink" title="C 语言数据类型的本质含义：表示内存格子的个数（每个格子 1 个字节）和解析方法。"></a>C 语言数据类型的本质含义：表示内存格子的个数（每个格子 1 个字节）和解析方法。</h3><p>(1)决定内存格子的个数：如果给一个地址 0x30000000，那么这个地址即一个格子。如果int 定义它，这个地址就会扩展为 4 个格子。<br>(2)解析方法：（int） 0x30000000 含义就是从 0x30000000 开始的 4 个格子连起来共同存放的一个 int 型数据。（float） 0x30000000 含义就是从 0x30000000 开始的 4 个格子连起来共同存放的一个 float 型数据。</p><h3 id="用指针来间接访问内存"><a href="#用指针来间接访问内存" class="headerlink" title="用指针来间接访问内存"></a>用指针来间接访问内存</h3><p>C 语言中的指针，全名叫指针变量，指针变量其实很普通变量没有任何区别。譬如 int a 和int *p 其实没有任何区别， a 和 p 都代表一个内存地址（譬如是 0x20000000），但是这个内存地址（0x20000000）的长度和解析方法不同。 a 是 int 型所以 a 的长度是 4 字节，解析方法是按照 int 的规定来的(以 0x20000000 开头的连续的 4 个字节的空间中存了一个 int型的数)； p 是 int *类型，所以长度是 4 字节，解析方法是 int *的规定来的（以 0x20000000开头的连续 4 字节的空间中存储了 1 个地址，这个地址所代表的内存单元中存放的是一个int 类型的数）。在 32 位系统中，指针变量永远占 4 个字节的内存空间。 </p><h3 id="用数组来管理内存"><a href="#用数组来管理内存" class="headerlink" title="用数组来管理内存"></a>用数组来管理内存</h3><p>数组管理内存和变量其实没有本质区别，只是符号的解析方法不用。（普通变量、数组、指针变量其实都没有本质差别，都是对内存地址的解析，只是解析方法不一样）。<br>int a; &#x2F;&#x2F;编译器分配 4 个字节长度给 a，并且把首地址和符号 a 绑定起来。<br>int b[10]; &#x2F;&#x2F;编译器分配 40 个字节长度给 b，并且把首元素的首地址和符号 b绑定起来。<br>数组中第一个元素（b[0]）就称为首元素；每一个元素都是类型都是 int，所以长度都是 4个字节，其中第一个字节的地址就称为首地址；首元素 b[0]的首地址就称为首元素首地址。</p><p>数组的缺陷：（1）数组中元素类型必须相同 （2）数组大小必须在定义时给出，而且一旦给出不能更改 </p><h3 id="内存管理之结构体"><a href="#内存管理之结构体" class="headerlink" title="内存管理之结构体"></a>内存管理之结构体</h3><p><strong>结构体和数组的本质差异还是在于怎么找变量地址的问题。</strong> </p><p>C 语言作为面向过程的语言，可以通过结构体内嵌指针实现面向对象的代码。<br>当然，面向对象的语言更为简单直观。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> age <span class="comment">// 普通变量</span></span><br><span class="line"><span class="type">void</span> (*pFunc)(<span class="type">void</span>); <span class="comment">// 函数指针，指向 void func(void)这类的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用这样的结构体就可以实现面向对象。 </p><h3 id="内存管理之栈"><a href="#内存管理之栈" class="headerlink" title="内存管理之栈"></a>内存管理之栈</h3><p>栈是一种数据结构， <strong>C 语言中使用栈来存放局部变量。</strong> </p><blockquote><p>栈管理内存的特点（小内存、自动化）：<br>先进后出 FILO（First In Last Out） 栈<br>先进先出 FIFO（First In First Out） 队列 </p></blockquote><p>栈的特点是入口即出口，只有一个口，另一个口是堵死的。所以先进去的必须后出来队列的特点是入口和出口都有，必须从入口进，从出口出，所以先进去的必须先出来，否则就堵住后边的。 </p><h4 id="栈的应用举例：局部变量"><a href="#栈的应用举例：局部变量" class="headerlink" title="栈的应用举例：局部变量"></a>栈的应用举例：局部变量</h4><p>C 语言中的局部变量是用栈来实现的。<br>我们在 C 语言中定义一个局部变量时（int a），编译器会在栈中分配一段空间（4 字节）给这个局部变量用（分配时栈顶指针会移动给出空间，给局部变量 a 用的意思就是，将这字节的栈内存的内存地址和我们定义的局部变量名 a 给关联起来），对应栈的操作是入栈。<br>注意：这里栈指针的移动和内存分配都是自动的。<br>然后等我们函数退出时，局部变量就会灭亡。对应栈的操作就是弹栈（出栈）。出栈时也是栈顶指针移动将栈空间中与 a 关联的那 4 个字节空间释放。这个动作也是自动的，不需要写代码干预。<br>栈的优点：入栈和出栈都由 C 语言自动完成。<br>分析一个细节： C 语言中，定义局部变量时如果未初始化，则值是随机的，为什么？<br>定义局部变量，其实就是在栈中通过移动栈指针来给程序提供一个内存空间和这个局部变量名绑定。因为这段内存空间在栈上，而栈内存是反复使用的（脏的，上次用完没清零的），所以说使用栈来实现的局部变量定义时如果不显式初始化，值就是脏的（也就是随机值）。<br>栈的约束：预定栈大小不灵活，怕溢出首先，栈是有大小的。所以栈内存大小不好设置。如果太小怕溢出，太大怕浪费内存。（这个缺点有点像数组）<br>其次，栈的溢出危害很大，一定要避免。所以我们在 C 语言中定义局部变量时不能定义太多或者太大（譬如不能定义局部变量时 int a[10000]; 使用递归来解决问题时一定要注意递归收敛）。</p><h3 id="内存管理之堆"><a href="#内存管理之堆" class="headerlink" title="内存管理之堆"></a>内存管理之堆</h3><p>堆内存管理方式特点就是自由（随时释放申请；大小块随意）。堆内存是OS规划给堆管理器来管理的，之后来给使用的API来使用。</p><p>我们会在需要内存容量比较大，需要反复使用及释放时，会使用堆内存。很多数据结构（譬如链表）的实现都需要使用堆内存。 </p><blockquote><p>特点 1：容量不限（常规使用的需求容量都能满足）。<br>特点 2：申请及释放都需要手工进行，手工进行的含义就是需要写代码明确申请 malloc 和<br>释放 free。如果申请内存并使用后未释放，这段内存就丢失了（在堆管理器的记录中，这<br>段内存仍然属于你这个进程，但是进程自己又以为这段内存已经不用了，再用的时候又会<br>去申请新的内存块，这就叫吃内存。），称为内存泄露 </p></blockquote><p>C 语言操作堆内存的接口（malloc、 free）<br>堆内存释放时最简单，直接调用 free 释放即可。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br></pre></td></tr></table></figure><p>堆内存申请时，有 3 个可选择的类似功能的函数： malloc、 calloc、 realloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>; <span class="comment">//nmemb 个单元，每个单元 size 字节</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>; <span class="comment">//改变原来申请的空间的大小</span></span><br></pre></td></tr></table></figure><p>譬如要申请 10 个 int 元素的内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">40</span>); </span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">10</span>, <span class="number">4</span>); </span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); </span><br></pre></td></tr></table></figure><p><strong>堆内存申请时必须给定大小，然后一旦申请完成大小不能更改，如果要变更，只能通过realloc 接口</strong> </p><h1 id="复杂数据结构"><a href="#复杂数据结构" class="headerlink" title="复杂数据结构"></a>复杂数据结构</h1><h2 id="链表、哈希表（散列表）、二叉树、图等"><a href="#链表、哈希表（散列表）、二叉树、图等" class="headerlink" title="链表、哈希表（散列表）、二叉树、图等"></a>链表、哈希表（散列表）、二叉树、图等</h2><p>链表是最重要的，链表在 Linux 内核中使用非常多，驱动、应用编写很多时候都需要使用链表。所以对链表必须掌握。<strong>掌握到： 会自己定义结构体来实现链表、会写链表的节点插入（前插、后插）、节点删除、节点查找、节点遍历等。</strong></p><p>哈希表不是很常用，一般不需要自己写实现，而直接使用别人实现的哈希表表较多。对我们来说，最重要的是明白哈希表的原理、从而知道哈希表的特点，从而知道什么时候该使用哈希表，当看到别人用了哈希表的时候要明白别人为什么要用哈希表、合适不合适？有<br>没有更好的选择？<br>二叉树、图不用深究。 </p><h1 id="C语言位操作"><a href="#C语言位操作" class="headerlink" title="C语言位操作"></a>C语言位操作</h1><h2 id="位与-amp"><a href="#位与-amp" class="headerlink" title="位与&amp;"></a>位与&amp;</h2><p>(1)注意：位与符号是一个&amp;，两个&amp;&amp;是逻辑与。<br>(2)真值表： 1&amp;0&#x3D;0 1&amp;1&#x3D;1 0&amp;0&#x3D;0 0&amp;1&#x3D;0<br>(3)从真值表可以看出：位与操作的特点是，只有 1 和 1 位于结果为 1，其余全是 0.<br>(4)位与和逻辑与的区别：<strong>位与时两个操作数是按照二进制位彼次对应位相与的，逻辑与是两个操作数作为整体来相与的。</strong>（举例： 0xAA&amp;0xF0&#x3D;0xA0, 0xAA &amp;&amp; 0xF0&#x3D;1）</p><h2 id="位或"><a href="#位或" class="headerlink" title="位或|"></a>位或|</h2><p>(1)注意：位或符号是一个|，两个||是逻辑或。<br>(2)真值表： 1|0&#x3D;1 1|1&#x3D;1 0|0&#x3D;0 0|1&#x3D;1<br>(3)从真值表可以看出：位或操作的特点是：只有 2 个 0 相位或才能得到 0，只要有 1 个 1结果就一定是 1.<br>(4)位或和逻辑或的区别：<strong>位或时两个操作数是按照二进制位彼次对应位相与的，逻辑或是两个操作数作为整体来相或的。</strong></p><h2 id="位取反"><a href="#位取反" class="headerlink" title="位取反~"></a>位取反~</h2><p>(1)注意： C 语言中位取反是~， C 语言中的逻辑取反是!<br>(2)按位取反是将操作数的二进制位逐个按位取反（1 变成 0， 0 变成 1）；而逻辑取反是真（在 C 语言中只要不是 0 的任何数都是真）变成假（在 C 语言中只有 0 表示假）、假变成真。<br>任何非 0 的数被按逻辑取反再取反就会得到 1；<br>任何非 0 的数被按位取反再取反就会得到他自己； </p><h2 id="位异或"><a href="#位异或" class="headerlink" title="位异或^"></a>位异或^</h2><p>(1)位异或真值表： 1^1&#x3D;0 0^0&#x3D;0 1^0&#x3D;1 0^1&#x3D;1<br>(2)位异或的特点： 2 个数如果相等结果为 0，不等结果为 1。记忆方法：异或就是相异就或操作起来。<br>位与、位或、位异或的特点总结：<br>位与：（任何数，其实就是 1 或者 0）与 1 位与无变化，与 0 位与变成 0<br>位或：（任何数，其实就是 1 或者 0）与 1 位或变成 1，与 0 位或无变化<br>位异或：（任何数，其实就是 1 或者 0）与 1 位异或会取反，与 0 位异或无变化 </p><h2 id="左移位-lt-lt-与右移位-gt-gt"><a href="#左移位-lt-lt-与右移位-gt-gt" class="headerlink" title="左移位&lt;&lt; 与右移位&gt;&gt;"></a>左移位&lt;&lt; 与右移位&gt;&gt;</h2><p>C 语言的移位要取决于数据类型。<br>对于无符号数，左移时右侧补 0（相当于逻辑移位）<br>对于无符号数，右移时左侧补 0（相当于逻辑移位）<br>对于有符号数，左移时右侧补 0（叫算术移位，相当于逻辑移位）<br>对于有符号数，右移时左侧补符号位（如果正数就补 0，负数就补 1，叫算术移位）<br><strong>嵌入式中研究的移位，以及使用的移位都是无符号数</strong> </p><h2 id="位与位或位异或在操作寄存器时的特殊作用"><a href="#位与位或位异或在操作寄存器时的特殊作用" class="headerlink" title="位与位或位异或在操作寄存器时的特殊作用"></a>位与位或位异或在操作寄存器时的特殊作用</h2><h3 id="寄存器操作的要求（特定位改变而不影响其他位）"><a href="#寄存器操作的要求（特定位改变而不影响其他位）" class="headerlink" title="寄存器操作的要求（特定位改变而不影响其他位）"></a>寄存器操作的要求（特定位改变而不影响其他位）</h3><p>(1)ARM 是内存与 IO 统一编址的， ARM 中有很多内部外设， SoC 中 CPU 通过向这些内部外设的寄存器写入一些特定的值来操控这个内部外设，进而操控硬件动作。所以可以说：<strong>读写寄存器就是操控硬件</strong>。<br>(2)寄存器的特点是按位进行规划和使用。但是寄存器的读写却是整体 32 位一起进行的（也就是说你只想修改 bit5～ bit7 是不行的，必须整体 32bit 全部写入）<br>(3)寄存器操作要求就是：在设定特定位时不能影响其他位。<br>(4)如何做到？答案是：<strong>读-改-写三部曲。读改写的操作理念</strong>，就是：当我想改变一个寄存器中某些特定位时，我不会直接去给他写，我会先读出寄存器整体原来的值，然后在这个基础上修改我想要修改的特定位，再将修改后的值整体写入寄存器。这样达到的效果是：在不影响其他位原来值的情况下，我关心的位的值已经被修改了。 </p><h3 id="特定位清零用-amp"><a href="#特定位清零用-amp" class="headerlink" title="特定位清零用&amp;"></a>特定位清零用&amp;</h3><p>(1)回顾上节讲的位与操作的特点：（任何数，其实就是 1 或者 0）与 1 位与无变化，与 0位与变成 0<br>(2)如果希望将一个寄存器的某些特定位变成 0 而不影响其他位，可以构造一个合适的 1 和0 组成的数和这个寄存器原来的值进行位与操作，就可以将特定位清零。<br>(3)举例：假设原来 32 位寄存器中的值为： 0xAAAAAAAA，我们希望将 bit8～ bit15 清零而其他位不变，可以将这个数与 0xFFFF00FF 进行位与即可。 </p><h3 id="特定位置-1-用"><a href="#特定位置-1-用" class="headerlink" title="特定位置 1 用|"></a>特定位置 1 用|</h3><p>(1)回顾上节讲的位或操作的特点：任何数，其实就是 1 或者 0）与 1 位或变成 1，与 0 位<br>或无变化<br>(2)操作手法和刚才讲的位与是类似的。我们要构造这样一个数：要置 1 的特定位为 1，其<br>他位为 0，然后将这个数与原来的数进行位或即可。 </p><h3 id="特定位取反用"><a href="#特定位取反用" class="headerlink" title="特定位取反用^"></a>特定位取反用^</h3><p>(1)回顾上节讲的位异或操作的特点：（任何数，其实就是 1 或者 0）与 1 位异或会取反，与 0 位异或无变化<br>(2)操作手法和刚才讲的位与是类似的。我们要构造这样一个数：要取反的特定位为 1，其他位为 0，然后将这个数与原来的数进行位异或即可。 </p><h2 id="如何用位运算构建特定二进制数-1少的用"><a href="#如何用位运算构建特定二进制数-1少的用" class="headerlink" title="如何用位运算构建特定二进制数 (1少的用)"></a>如何用位运算构建特定二进制数 (1少的用)</h2><p>对寄存器特定位进行置 1 或者清 0 或者取反，关键性的难点在于要事先构建一个特别的数，这个数和原来的值进行位与、位或、位异或等操作，即可达到我们对寄存器操作的要求 。</p><h3 id="使用移位获取特定位为-1-的二进制数"><a href="#使用移位获取特定位为-1-的二进制数" class="headerlink" title="使用移位获取特定位为 1 的二进制数"></a>使用移位获取特定位为 1 的二进制数</h3><blockquote><table><thead><tr><th>一个 1</th><th>0x1</th></tr></thead><tbody><tr><td><strong>两个 1</strong></td><td><strong>0x3</strong></td></tr><tr><td><strong>三个1</strong></td><td><strong>0x7</strong></td></tr><tr><td><strong>四个1</strong></td><td><strong>0xf</strong></td></tr><tr><td><strong>五个1</strong></td><td><strong>0x1f</strong></td></tr><tr><td><strong>六个1</strong></td><td><strong>0x3f</strong></td></tr><tr><td><strong>七个1</strong></td><td><strong>0x7f</strong></td></tr><tr><td><strong>八个1</strong></td><td><strong>0xff</strong></td></tr></tbody></table></blockquote><p>(1)最简单的就是用移位来获取一个特定位为 1 的二进制数。譬如我们需要一个 bit3～ bit7为 1（隐含意思就是其他位全部为 0）的二进制数，可以这样： (0x1f&lt;&lt;3)<br>(2)更难一点的要求：获取 bit3～ bit7 为 1，同时 bit23～ bit25 为 1，其余位为 0 的数：((0x1f&lt;&lt;3) | (0x7&lt;&lt;23)) </p><h3 id="再结合位取反获取特定位为-0-的二进制数（1多的用）"><a href="#再结合位取反获取特定位为-0-的二进制数（1多的用）" class="headerlink" title="再结合位取反获取特定位为 0 的二进制数（1多的用）"></a>再结合位取反获取特定位为 0 的二进制数（1多的用）</h3><p>(1)这次我们要获取 bit4～ bit10 为 0，其余位全部为 1 的数。怎么做？<br>(2)利用上面讲的方法就可以： (0xf&lt;&lt;0)|(0x1fffff&lt;&lt;11)<br>但是问题是：连续为 1 的位数太多了，这个数字本身就很难构造，所以这种方法的优势损失掉了。<br>(3)这种特定位（比较少）为 0 而其余位（大部分）为 1 的数，不适合用很多个连续 1 左移的方式来构造，适合左移加位取反的方式来构造。<br>(2)思路是：先试图构造出这个数的位相反数，再取反得到这个数。（譬如本例中要构造的数 bit4～ bit10 为 0 其余位为 1，那我们就先构造一个 bit4～ bit10 为 1，其余位为 0 的数，然后对这个数按位取反即可） ~(0x7f&lt;&lt;4) </p><h3 id="位操作实战"><a href="#位操作实战" class="headerlink" title="位操作实战"></a>位操作实战</h3><p>(1)给定一个整型数 a，设置 a 的 bit3，保证其他位不变。<br>a |&#x3D; (1&lt;&lt;3)<br>(2)给定一个整形数 a，设置 a 的 bit3<del>bit7，保持其他位不变<br>a |&#x3D; (0x1f&lt;&lt;3)<br>(3)给定一个整型数 a，清除 a 的 bit15，保证其他位不变。<br>a &amp;&#x3D; ~(1&lt;&lt;15)<br>(4)给定一个整形数 a，清除 a 的 bit15</del>bit23，保持其他位不变。<br>a &amp;&#x3D; <del>(0x1ff&lt;&lt;15)<br>(5)给定一个整形数 a，取出 a 的 bit3</del>bit8。<br>a &amp;&#x3D; (0x3f&lt;&lt;3)<br>a &gt;&gt;&#x3D; 3<br>(6)给一个寄存器的 bit7～ bit17 赋值 937<br>a &amp;&#x3D; ~(0x7ff&lt;&lt;7)<br>a |&#x3D; (937&lt;&lt;7)<br>(7)给一个寄存器的 bit7～ bit17 中的值加 17<br>b &#x3D; ((a &amp; (0x7ff&lt;&lt;7))&gt;&gt;7 + 17)&lt;&lt;7<br>a &amp;&#x3D; ~(0x7ff&lt;&lt;7)<br>a |&#x3D; b<br>(8)给一个寄存器的 bit7～ bit17 赋值 937，同时给 bit21～ bit25 赋值 17.<br>a &amp;&#x3D; ~((0x7ff&lt;&lt;7) | (0x1f&lt;&lt;21))<br>a |&#x3D; ((937&lt;&lt;7) | (17&lt;&lt;21)) </p><h1 id="C语言指针"><a href="#C语言指针" class="headerlink" title="C语言指针"></a>C语言指针</h1><h2 id="指针变量和普通变量的区别"><a href="#指针变量和普通变量的区别" class="headerlink" title="指针变量和普通变量的区别"></a>指针变量和普通变量的区别</h2><p>首先必须非常明确：指针的实质就是个变量，它跟普通变量没有任何本质区别。指针完整的名字叫指针变量，简称指针。 </p><p><strong>指针的出现是为了实现间接访问</strong>，间接访问（CPU 的间接寻址）是 CPU 设计时决定的 .</p><h2 id="指针使用三部曲：定义指针变量、关联指针变量、解引用"><a href="#指针使用三部曲：定义指针变量、关联指针变量、解引用" class="headerlink" title="指针使用三部曲：定义指针变量、关联指针变量、解引用"></a>指针使用三部曲：定义指针变量、关联指针变量、解引用</h2><p>(1)当我们 int *p 定义一个指针变量 p 时，因为 p 是局部变量，所以也遵循 C 语言局部变量的一般规律（定义局部变量并且未初始化，则值是随机的），所以此时 p 变量中存储的是一个随机的数字。<br>(2)此时如果我们解引用 p，则相当于我们访问了这个随机数字为地址的内存空间。那这个空间到底能不能访问不知道（也许可以也许不行），所以如果直接定义指针变量未绑定有效地址就去解引用几乎必死无疑。<br>(3)定义一个指针变量，不经绑定有效地址就去解引用，就好象拿一个上了镗的枪在四面八方中随意开了一枪。<br>(4)指针绑定的意义就在于：让指针指向一个可以访问、应该访问的地方，指针的解引用是为了间接访问目标变量.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">23</span>;<span class="comment">//a实质就是一个编译器中的符号，但是编译器将符号和一个内存空间联系起来，这个空间代表着变量。</span></span><br><span class="line">    <span class="type">int</span> *p;<span class="comment">//定义指针变量</span></span><br><span class="line">    <span class="type">int</span> *p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x\n&quot;</span>, p);<span class="comment">//%p和%x打印指针，打印出来的数值都是一样的。</span></span><br><span class="line">    <span class="comment">/*绑定指针变量，就是给指针赋值，让这个指针指向另一个变量，当没有绑定指针变量时候，这个指针不能被解引用*/</span></span><br><span class="line">    p = &amp;a;<span class="comment">//让p指向a</span></span><br><span class="line">    p2 = (<span class="type">int</span> *)<span class="number">4</span>;<span class="comment">//让p指向内存地址为4的那个变量</span></span><br><span class="line">    <span class="comment">/*解引用 ，如果没有绑定就解引用，那一定出错*/</span></span><br><span class="line">    *p = <span class="number">555</span>;<span class="comment">//把555放入p指向的变量中。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>星号*<br>(1)C 语言中*****可以表示乘号，也可以表示指针符号。这两个用法是毫无关联的，只是恰好用了同一个符号而已。<br>(2)****<em>在用于指针相关功能的是后续有 2 种用法：第一种是指针定义时， ***** 结合前面的类型用于表明要定义的指针的类型；第二种功能是指针解引用，解引用时</em>p 表示 p 指向的变量本身。<br>3.2.2.取地址符&amp;<br>取地址符使用时直接加在一个变量的前面，然后取地址符和变量加起来构成一个新的符号，这个符号表示这个变量的地址。<br>3.2.3.指针定义并未初始化、与指针定义然后赋值的区别<br>(1)指针定义时可以初始化，指针的初始化其实就是给指针变量初值（跟普通变量的初始化没有任何本质区别）。<br>(2)指针变量定义同时初始化的格式是： int a &#x3D; 32; int *p &#x3D; &amp;a;<br>(3)不初始化时指针变量先定义再赋值： int a &#x3D; 32; int *p; p &#x3D; &amp;a; </p><p>左值与右值<br>(1)放在赋值运算符左边的就叫左值，右边的就叫右值。所以赋值操作其实就是：左值 &#x3D; 右<br>值;<br>(2)当一个变量做左值时，编译器认为这个变量符号的真实含义是这个变量所对应的那个内<br>存空间；当一个变量做右值时，编译器认为这个变量符号的真实含义是这个变量的值，也<br>就是这个变量所对应的内存空间中存储的那个数。</p><h2 id="野指针问题"><a href="#野指针问题" class="headerlink" title="野指针问题"></a>野指针问题</h2><blockquote><p>(1)野指针，就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）<br>(2)野指针很可能触发运行时段错误（Sgmentation fault）<br>(3)因为指针变量在定义时如果未初始化，值也是随机的。指针变量的值其实就是别的变量（指针所指向的那个变量）的地址，所以意味着这个指针指向了一个地址是不确定的变量，这时候去解引用就是去访问这个地址不确定的变量，所以结果是不可知的。<br>(4)野指针因为指向地址是不可预知的。所以有 3 种情况：第一种是指向不可访问（操作系统不允许访问的敏感地址，譬如内核空间）的地址，结果是触发段错误，这种情况算好的了，因为编译器会报错；第二种是指向一个可用的、而且没有什么特别意义的空间（譬如我们曾经使用过但是已经不用的栈空间或堆空间），这时候程序运行不会出错，也不会对当前程序造成损害，这种情况下会掩盖你的程序错误，让你以为程序没问题，其实是有问题的；第三种情况就是指向了一个可用的空间，而且这个空间其实在程序中正在被使用（譬如说是程序的一个变量 x），那么野指针的解引用就会刚好修改这个变量 x 的值，导致这个变量莫名其妙的被改变，程序出现离奇的错误。一般最终都会导致程序崩溃，或者数据被损害。这种危害是最大的。<br>(5)指针变量如果是局部变量，则分配在栈上，本身遵从栈的规律（反复使用，使用完不擦出，所以是脏的，本次在栈上分配到的变量的默认值是上次这个栈空间被使用时余留下来的值），就决定了栈的使用多少会影响这个默认值。因此野指针的值是有一定规律不是完全随机的，但是这个值的规律对我们没意义。因为不管落在上面的野指针是 3 种情况的哪一种，都不是我们想看到的。 </p></blockquote><h2 id="怎么避免野指针？"><a href="#怎么避免野指针？" class="headerlink" title="怎么避免野指针？"></a>怎么避免野指针？</h2><p>(1)野指针的错误来源就是指针定义了以后没有初始化，也没有赋值（总之就是指针没有明<br>确的指向一个可用的内存空间），然后去解引用。<br>(2)知道了野指针产生的原因，避免方法就出来了：在指针的解引用之前，一定确保指针指<br>向一个绝对可用的空间。<br>(3)常规的做法是：</p><blockquote><p>第一点：定义指针时，同时初始化为 NULL<br>第二点：在指针使用之前，将其赋值绑定给一个可用地址空间<br>第三点：在指针解引用之前， 先去判断这个指针是不是 NULL<br>第四点：指针使用完之后，将其赋值为 NULL </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = &amp;a;<span class="comment">//正确使用指针方法，解引用指针前跟一个绝对可用的地址绑定</span></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="literal">NULL</span>;<span class="comment">//使用完指针变量后，记得重新赋值为NULL</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NULL-到底是什么？"><a href="#NULL-到底是什么？" class="headerlink" title="NULL 到底是什么？"></a>NULL 到底是什么？</h3><p>(1)NULL 在 C&#x2F;C++中定义为：<br>#ifdefine _cplusplus &#x2F;&#x2F;定义这个符号就表示当前是 C++环境<br>#define NULL 0 &#x2F;&#x2F;在 C++中 NULL 就是 0<br>#else<br>#define NULL (void *)0 &#x2F;&#x2F;在 C 中 NULL 是强制类型转换为 void *的 0<br>#endif<br>(2)在 C 语言中， int *p，你可以 p &#x3D; (int *)0，但是不可以 p &#x3D; 0，因为类型不同<br>(3)所以 NULL 的实质其实就是地址 0，然后我们给指针赋初值为 NULL，其实就是让指针指向 0 地址处。为什么指向 0 地址处？有 2 点原因：第一层原因是 0 地址处作为一个特殊地址（我们认为指针指向这里就表示指针没有被初始化，就表示野指针）；第二层原因是这个 0 地址在一般的操作系统中都是不可被访问的，如果不按规矩（不检查是否等于 NULL就去解引用）写代码直接去解引用就会触发段错误，编译器会报错嘀。 (指针指向这个敏感地址没有问题，只要不解引用就 ok)</p><h3 id="const-修饰指针的-4-种形式"><a href="#const-修饰指针的-4-种形式" class="headerlink" title="const 修饰指针的 4 种形式"></a>const 修饰指针的 4 种形式</h3><p>(1)const 关键字，在 C 语言中用来修饰变量，表示这个变量是常量。<br>(2)const 修饰指针有 4 种形式，区分清楚这 4 种即可全部理解 const 和指针。<br>第一种： const int *p; &#x2F;&#x2F;const 修饰 p 指向的变量20<br>第二种： int const *p; &#x2F;&#x2F;const 修饰 p 指向的变量<br>第三种： int * const p; &#x2F;&#x2F;const 修饰指针变量 p<br>第四种： const int * const p; &#x2F;&#x2F;const 即修饰 p 指向的变量也修饰指针变量 p<br>(3)关于指针变量的理解，主要涉及到 2 个变量：第一个是指针变量 p 本身，第二个是 p 指向的那个变量(*p)。一个 const 关键字只能修饰一个变量，所以弄清楚这 4 个表达式的关键就是搞清楚 const 放在某个位置是修饰谁。</p><h2 id="深入学习数组"><a href="#深入学习数组" class="headerlink" title="深入学习数组"></a>深入学习数组</h2><h3 id="从内存角度来理解数组"><a href="#从内存角度来理解数组" class="headerlink" title="从内存角度来理解数组"></a>从内存角度来理解数组</h3><p>(1)从内存角度讲，数组变量就是一次分配多个变量，而且这多个变量在内存中的存储单元是依次相连接的。<br>(2)我们分开定义多个变量（譬如 int a, b, c, d）和和一次定义一个数组（int a[4]）这两种定义方法相同点是都定义了 4 个 int 型变量，而且这 4 个变量都是独立的、单个使用的；不同点是单独定义时 a、 b、 c、 d 在内存中的地址不一定相连，但是定义成数组后，数组中的 4 个元素地址肯定是依次相连的。<br>(3)数组中多个变量虽然必须单独访问，但是因为他们的地址彼此相连，因此很适合用指针来操，因此数组和指针天生就有一种羁绊。 </p><p>(1)这 4 个符号搞清楚了，数组相关的很多问题就都有答案了。理解这些符号的时候要和左值右值结合起来，也就是搞清楚每个符号分别做左值和右值时的不同含义。<br>(2)a 就是数组名。 a 做左值表示整个数组所有空间（10*4&#x3D;40 字节）， 但因为 C 语言规定数组操作时要独立单个操作，不能整体操作数组，所以 a 不能做左值； a 做右值表示数组首元素（数组的第 1 个元素，也就是 a[0]）的首地址（首地址就是起始地址，就是 4 个字<br>节中最开始第一个字节的地址）。 a 做右值等于&amp;a[0]。<br>(3)a[0]表示数组的首元素，也就是数组的第 1 个元素。 a[0]做左值时表示首元素对应的内存空间（连续 4 个字节）； a[0]做右值时表示数组第 1 个元素的值（也就是数组第 1 个元素对应的内存空间中存储的那个数）<br>(4)&amp;a 就是数组名 a 取地址，字面意思来看就应该是数组的地址。 &amp;a 不能做左值（&amp;a 实质是一个常量，不是变量，因此不能赋值，所以自然不能做左值。）； &amp;a 做右值时表示整个数组的首地址。<br>(5)&amp;a[0]字面自已就是数组第 1 个元素的首地址（搞清楚[]和&amp;的优先级， []的优先级要高于&amp;，所以 a 先和[]结合再取地址）。 &amp;a[0]不能做左值（&amp;a[0]实质是一个常量，不是变量，因此不能赋值，所以自然不能做左值。）； 做右值时表示数组首元素地址。 &amp;a[0]做右值等于 a。 </p><h2 id="指针和数组的天生羁绊"><a href="#指针和数组的天生羁绊" class="headerlink" title="指针和数组的天生羁绊"></a>指针和数组的天生羁绊</h2><h3 id="以指针方式来访问数组元素"><a href="#以指针方式来访问数组元素" class="headerlink" title="以指针方式来访问数组元素"></a>以指针方式来访问数组元素</h3><p>(1)数组元素使用时不能整体访问，只能单个访问。访问方式有 2 种：数组形式和指针形式。<br>(2)数组格式访问数组元素是：数组名[下标];<br>(3)指针方式访问数组元素是： *(指针+偏移量); *(数组名+偏移量);如果指针是数组首元素地址（a 或者&amp;a[0]），那么偏移量就是下标；指针也可以不是首元素地址而是其他哪个元素的地址，这时候偏移量就要考虑叠加了。<br>(4)数组下标方式和指针方式均可以访问数组元素，两者的实质其实是一样的。在编译器内部都是用指针方式来访问数组元素的，数组下标方式只是编译器提供给编程者一种壳（语法糖）而已。所以用指针方式来访问数组才是本质的方法。 </p><h3 id="指针和数组类型的匹配问题"><a href="#指针和数组类型的匹配问题" class="headerlink" title="指针和数组类型的匹配问题"></a>指针和数组类型的匹配问题</h3><p>(1)int *p; int a[5]; p &#x3D; a; &#x2F;&#x2F;类型匹配， a 相当于&amp;a[0]<br>(2)int *p; int a[5]; p &#x3D; &amp;a; &#x2F;&#x2F;类型不匹配p 是 int *，是 int 指针类型，而&amp;a 是整个数组的指针，也就是数组指针类型，所以不匹配<br>(3)&amp;a 和 a、 &amp;a[0]从数值来看是相等的，但是意义来看就不同了。从意义来看， a 和&amp;a[0]是数组首元素地址，而&amp;a 是整个数组的首地址；从类型来看， a 和&amp;a[0]是元素的指针，也就是 int <em>类型的；而&amp;a 是数组指针，是 int (</em>)[5]类型。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">34</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a;<span class="comment">//p指向数组首地址&amp;a[0]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(p+1) = %d\n&quot;</span>,*(p+<span class="number">1</span>));<span class="comment">//相当于a[1]</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;a = 0x%x\n&quot;</span>, a);<span class="comment">//数组的首元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = 0x%x\n&quot;</span>, &amp;a);<span class="comment">//整个数组的首地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0] = 0x%x\n&quot;</span>, &amp;a[<span class="number">0</span>]);<span class="comment">//数组首地址的地址</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针与强制类型转换"><a href="#指针与强制类型转换" class="headerlink" title="指针与强制类型转换"></a>指针与强制类型转换</h2><h3 id="变量的数据类型的含义"><a href="#变量的数据类型的含义" class="headerlink" title="变量的数据类型的含义"></a>变量的数据类型的含义</h3><p>(1)所有的类型的数据存储在内存中，都是按照二进制格式存储的。所以内存中只知道 1 和0，不知道 int 的还是 float 的还是其他类型。<br>(2)int、 short、 char 等属于整型，他们的存储方式（数转换成二进制往内存中存放的方式）是相同的，只是内存格子大小不同（所以这几种整型就彼此叫二进制兼容格式）；而 float、double 的存储方式彼此不同，和整型更不同。<br>(3)int a &#x3D; 5; 时，编译器给 a 分配 4 字节空间，并且将 5 按照 int 类型的存储方式转换成二进制存到 a 所对应的内存空间中去（a 做左值的）；我们 printf 去打印 a 的时候（a 此时做右值）， printf 内部的 vsprintf 函数会按照格式化字符串（就是 printf 传参的第一个字<br>符串参数中的%d 之类的东西）所代表的类型去解析 a 所对应的内存空间，解析出的值用来输出。也就是说，存进去时是按照这个变量本身的数据类型来存储的（譬如本例中 a 为int 所以按照 int 格式来存储）；但是取出来时是按照 printf 中%d 之类的格式化字符串的格<br>式来提取的。此时虽然 a 所代表的内存空间中的 1010 序列并没有变（内存是没被修改的）但是怎么理解（怎么把这些 1010 转成数字）就不一定了。譬如我们用%d 来解析，那么还是按照 int 格式解析则值自然还是 5；但是如果用%f 来解析，则 printf 就以为 a 对应的内存空间存储的是一个 float 类型的数，会按照 float 类型来解析，值自然是很奇怪的一个数字了。 </p><p>分析几个题目：</p><ul><li>按照 int 类型存却按照 float 类型取 一定会出错</li><li>按照 int 类型存却按照 char 类型取 有可能出错也有可能不出错</li><li>按照 short 类型存却按照 int 类型取 有可能出错也有可能不出错</li><li>按照 float 类型存却按照 double 取 一定会出错</li></ul><h3 id="指针数据类型转换实例分析-1（int-gt-char-）"><a href="#指针数据类型转换实例分析-1（int-gt-char-）" class="headerlink" title="指针数据类型转换实例分析 1（int * -&gt; char *）"></a>指针数据类型转换实例分析 1（int * -&gt; char *）</h3><p>(1)int 和 char 类型都是整型的，类型兼容的。所以互转的时候有可能出错有可能对。<br>(2)int 和 char 的不同在于 char 只有 1 个字节而 int 有 4 个字节，所以 int 的范围比 char大。在 char 所表示的范围之内 int 和 char 是可以互转的不会出错；但是超过了 char 的范围后， char 转成 int 不会错。 </p><h2 id="指针、数组与-sizeof-运算符"><a href="#指针、数组与-sizeof-运算符" class="headerlink" title="指针、数组与 sizeof 运算符"></a>指针、数组与 sizeof 运算符</h2><p>sizeof 运算符<br>(1)sizeof 是 C 语言中的一个运算符（sizeof 不是函数，虽然用法很像函数）， sizeof 的作用是用来返回()里边的变量或者数据类型占用的内存字节数。<br>(2)sizeof 存在的价值？主要是因为在不同平台下各种数据类型所占的字节数不尽相同（譬如 int 在 32 位系统中为 4 字节，在 16 位系统中为 2 字节…）。所以程序中需要使用 sizeof来判断当前变量&#x2F;数据类型在当前环境下占几个字节。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(str) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(str));<span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(str[0]) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(str[<span class="number">0</span>]));<span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;strlen(str) = %d&quot;</span>, <span class="built_in">strlen</span>(str));<span class="comment">//5</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = str;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(p) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(p));<span class="comment">//4 相当于sizeof(char *)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(*p) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(*p));<span class="comment">//1 相当于sizeof( char) </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;strlen(p) = %d\n&quot;</span>, <span class="built_in">strlen</span>(p));<span class="comment">//5相当于strlen(char)</span></span><br></pre></td></tr></table></figure><p>(1)32 位系统中所有指针的长度都是 4，不管是什么类型的指针。<br>(2)strlen 是一个 C 库函数，用来返回一个字符串的长度（注意， 字符串的长度是不计算字符串末尾的’\0’的）。一定要注意 strlen 接收的参数必须是一个字符串（字符串的特征是以’\0’结尾）。 </p><p>void fun(int b[100])<br>{<br>sizeof(b) &#x2F;&#x2F; 4<br>}<br>(1)函数传参，形参可以用数组的<br>(2)函数形参是数组时，实际传递的不是整个数组，而是数组的首元素地址。也就是说函数<br>传参用数组来传，实际相当于传递的是指针（指针指向数组的首元素地址）。</p><h3 id="通过-sizeof-获取数组元素个数的技巧"><a href="#通过-sizeof-获取数组元素个数的技巧" class="headerlink" title="通过 sizeof 获取数组元素个数的技巧"></a>通过 sizeof 获取数组元素个数的技巧</h3><p>int a[56];<br>int b &#x3D; sizeof(a) &#x2F; sizeof(a[0]); &#x2F;&#x2F; 整个数组字节数&#x2F;数组中一个元素的字节数<br>printf(“b &#x3D; %d.\n”, b); &#x2F;&#x2F; 结果应该是数组的元素个数<br>3.8.8. #define 和 typedef 的区别<br>#define dpChar char *<br>typedef char *tpChar;<br>dpChar p1, p2; sizeof(p1) sizeof(p2)<br>tpChar p3, p4; sizeof(p3) sizeof(p4)<br>dpChar p1, p2; &#x2F;&#x2F;展开： char *p1, p2; 相当于 char *p1, char p2;<br>tpChar p3, p4; &#x2F;&#x2F; 等价于： char *p3, char *p4;</p><h2 id="指针与函数传参"><a href="#指针与函数传参" class="headerlink" title="指针与函数传参"></a>指针与函数传参</h2><h3 id="普通变量作为函数形参30"><a href="#普通变量作为函数形参30" class="headerlink" title="普通变量作为函数形参30"></a>普通变量作为函数形参30</h3><p>(1)函数传参时，普通变量作为参数时，形参和实参名字可以相同也可以不同，实际上都是<br>用实参来替代相对应的形参的。<br>(2)在子函数内部，形参的值等于实参。原因是函数调用时把实参的值赋值给了形参。<br>(3)这就是很多书上写的“传值调用”（相当于实参做右值，形参做左值）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p.\n&quot;</span>, &amp;a);</span><br><span class="line">func1(a);</span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d.\n&quot;</span>, b); <span class="comment">// 在函数内部，形参 b 的值等于实参 a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in func1, &amp;b = %p.\n&quot;</span>, &amp;b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&amp;a 和&amp;b 不同，说明 a 和 b 不是同一个变量（在内存中 a 和 b 是独立的 2 个内存空间）</span></span><br><span class="line">但是 a 和 b 是有关联的，实际上 b 是 a 赋值得到的。</span><br></pre></td></tr></table></figure><h3 id="数组作为函数形参"><a href="#数组作为函数形参" class="headerlink" title="数组作为函数形参"></a>数组作为函数形参</h3><p>(1)数组作为形参传参时，实际传递的不是整个数组，而是数组的首元素地址（也就是整个<br>数组的首地址。因为传参时是传值，所以首元素地址和数组的首地址这两个没区别）。所<br>以在子函数内部，传进来的数组名就等于是一个指向数组首元素的指针。所以 sizeof 得到<br>的是 4。<br>(2)在子函数内传参得到的数组首元素首地址，和外面得到的首元素首地址是相同的。很多<br>人把这种特性叫做“传址调用”（所谓的传址调用就是调用子函数时传了地址（也就是指<br>针），此时可以通过传进去的地址来访问实参。）<br>(3)数组作为函数参数时， []里的数组是可有可无的。为什么？因为数组名做形参传递的实<br>际只是个指针，根本没有数组长度这个信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %p.\n&quot;</span>, a);</span><br><span class="line">func2(a);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d.\n&quot;</span>, <span class="keyword">sizeof</span>(a)); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in func2, a = %p.\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针作为函数形参"><a href="#指针作为函数形参" class="headerlink" title="指针作为函数形参"></a>指针作为函数形参</h3><p>和数组作为函数形参是一样的，这就好像指针方式访问数组元素和数组方式访问数组元素<br>的结果一样是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %p.\n&quot;</span>, a);</span><br><span class="line">func3(a);</span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d.\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in func2, a = %p.\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体变量和结构体变量指针作为函数形参"><a href="#结构体变量和结构体变量指针作为函数形参" class="headerlink" title="结构体变量和结构体变量指针作为函数形参"></a>结构体变量和结构体变量指针作为函数形参</h3><p>(1)结构体变量作为函数形参的时候，实际上和普通变量（类似于 int 之类的）传参时的表现是一模一样的。所以说结构体变量其实也是普通变量而已。<br>(2)因为结构体一般都很大，所以如果直接用结构体变量进行传参，那么函数调用效率就会很低。（因为在函数传参时需要将实参赋值给形参，所以当传参的变量越大调用效率就会越低。）怎么解决？思路只有一个那就是不要传变量了，改传变量的指针（地址）进去。<br>(3)结构体因为自身太大，所以传参应该用结构体指针来传 .</p><h3 id="传值调用与传址调用"><a href="#传值调用与传址调用" class="headerlink" title="传值调用与传址调用"></a>传值调用与传址调用</h3><p>(1)传值调用描述的是这样一种现象： x 和 y 作为实参，自己并没有真身进入 swap1 函数内部，而只是拷贝了一份自己的副本（副本具有和自己一样的值，但是是不同的变量）进子函数 swap1，然后我们在子函数 swap1 中交换的实际是副本而不是 x、 y 真身。所以在<br>swap1 内部确实是交换了，但是到外部的 x 和 y 根本没有受影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line">swap1(x, y);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line">tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in swap1, a = %d, b = %d.\n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d.\n&quot;</span>, x, y); <span class="comment">// x=3,y=5，交换失败</span></span><br></pre></td></tr></table></figure><p>(2)在 swap2 中 x 和 y 真的被改变了（但是 x 和 y 真身还是没有进入 swap2 函数内，而是swap2 函数内部跑出来把外面的 x 和 y 真身给改了）。实际上实参 x 和 y 永远无法真身进入子函数内部（进去的只能是一份拷贝），但是在 swap2 我们把 x 和 y 的地址传进去给子<br>函数，于是在子函数内可以通过指针解引用方式从函数内部访问到外部的 x 和 y 真身，从而改变 x 和 y。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line">swap2(&amp;x, &amp;y);</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap2</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line">tmp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = tmp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in swap2, *a = %d, *b = %d.\n&quot;</span>, *a, *b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d.\n&quot;</span>, x, y); <span class="comment">// x=5,y=3，交换成功 </span></span><br></pre></td></tr></table></figure><h4 id="函数传参中使用-const-指针"><a href="#函数传参中使用-const-指针" class="headerlink" title="函数传参中使用 const 指针"></a>函数传参中使用 const 指针</h4><p>(1)const 一般用在函数参数列表中，用法是 const int *p;（意义是指针变量 p 本身是可变的，而 p 所指向的变量是不可变的）<br>(2)const 用来修饰指针做函数传参，作用就在于声明在函数内部不会改变这个指针指向的内容，所以给该函数传一个不可改变的指针（char *p &#x3D; “linux”;这种）不会触发错误，而一个未声明为 const 的指针的函数，你给他传一个不可更改的指针的时候就要小心了。 </p><h3 id="函数需要向外部返回多个值怎么办？"><a href="#函数需要向外部返回多个值怎么办？" class="headerlink" title="函数需要向外部返回多个值怎么办？"></a>函数需要向外部返回多个值怎么办？</h3><p>(1)一般来说，函数的输入部分就是函数参数，输出部分就是返回值。问题是函数的参数可以有很多个，而返回值只能有 1 个。这就造成我们无法一个函数返回多个值。<br>(2)实际编程中，一个函数需要返回多个值是非常普遍的，因此完全依赖于返回值是不靠谱的，通常的做法是用参数来做返回。（在典型 linux 风格函数中，返回值是不用来返回结果的，而是用来返回 0 或者负数来表示查询执行结果是对还是错，是成功还是失败，它是返回给调用它的进程的）。<br>(3)普遍做法，编程中函数的输入和输出都是靠函数参数的，返回值只是用来表示函数执行的结果是对还是错。如果这个参数是用来做输入的，就叫输入型参数；如果这个参数的目的是用来做输出的，就叫输出型参数。<br>(4)输出型参数就是用来让函数内部把数据输出到函数外部的 </p><h2 id="函数指针与-typedef"><a href="#函数指针与-typedef" class="headerlink" title="函数指针与 typedef"></a>函数指针与 typedef</h2><h3 id="函数指针的实质（还是指针变量）"><a href="#函数指针的实质（还是指针变量）" class="headerlink" title="函数指针的实质（还是指针变量）"></a>函数指针的实质（还是指针变量）</h3><p>(1)函数指针的实质还是指针，还是指针变量。本身占 4 字节（在 32 位系统中，所有的指针都是 4 字节）<br>(2)函数指针、结构体指针、数组指针、普通指针之间并没有本质区别，区别在于指针指向的东西是个什么玩意儿。<br>(3)函数的实质是一段代码，这一段代码在内存中是连续分布的（一个函数的大括号括起来的所有语句将来编译出来生成的可执行程序是连续的），所以对于函数来说很关键的就是函数中的第一句代码的地址，这个地址就是所谓的函数地址，在 C 语言中用函数名这个符号来表示。<br>(4)结合函数的实质，函数指针其实就是一个普通变量，这个普通变量的类型是函数指针变量类型，它的值就是某个函数的地址（也就是它的函数名这个符号在编译器中对应的值）。 </p><h3 id="typedef-关键字的用法"><a href="#typedef-关键字的用法" class="headerlink" title="typedef 关键字的用法"></a>typedef 关键字的用法</h3><p>(1)typedef 是 C 语言中的一个关键字，作用是用来定义（或者叫重命名类型）<br>(2)C 语言中的类型一共有 2 种：一种是编译器定义的原生类型（基础数据类型，如 int、double 之类的）；第二种是用户自定义类型，不是语言自带的，是程序员自己定义的（譬如数组类型、结构体类型、函数类型……）。<br>(3)数组指针、指针数组、函数指针等都属于用户自定义类型。<br>(4)有时候自定义类型太长了，用起来不方便，所以用 typedef 给它重命名一个短点的名字。<br>(5)注意： <strong>typedef 是给类型重命名，也就是说 typedef 加工出来的都是类型，而不是变量。</strong> </p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上位机控制激光器</title>
      <link href="/2023/10/05/2023-10-5-%E4%B8%8A%E4%BD%8D%E6%9C%BA%E7%9A%84%E6%BF%80%E5%85%89%E5%99%A8%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/10/05/2023-10-5-%E4%B8%8A%E4%BD%8D%E6%9C%BA%E7%9A%84%E6%BF%80%E5%85%89%E5%99%A8%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>这个工程是假期前完成的，延期更新了。</p><h2 id="激光器的IO"><a href="#激光器的IO" class="headerlink" title="激光器的IO"></a>激光器的IO</h2><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-05%20133328.png"></p><p>所以说需要使用的是PWM，GPIO控制IO口，adc这三个知识点。</p><p>首先是要给设备加上pwm的驱动和adc的驱动。</p><h2 id="pwm驱动"><a href="#pwm驱动" class="headerlink" title="pwm驱动"></a>pwm驱动</h2><p>首先是imx6ull有8路PWM输出，对应这8个PWM的控制器，在设备树下有相对应的8个控制器节点。</p><p>查看手册可以看到：</p><blockquote><p>• 16-bit up-counter with clock source selection<br>• 4 x 16 FIFO to minimize interrupt overhead<br>• 12-bit prescaler for division of clock<br>• Sound and melody generation<br>• Active high or active low configured output<br>• Can be programmed to be active in low-power mode<br>• Can be programmed to be active in debug mode<br>• Interrupts at compare and rollover </p></blockquote><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-05%20140844.png"></p><p>使用GPIO1_IO04(也就是PWM3)来进行完成实验。在imx6ull.dtsi文件中已经有关于pwm3的节点信息了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 pwm3: pwm@02088000 &#123;</span><br><span class="line">2 compatible = &quot;fsl,imx6ul-pwm&quot;, &quot;fsl,imx27-pwm&quot;;</span><br><span class="line">3 reg = &lt;0x02088000 0x4000&gt;;</span><br><span class="line">4 interrupts = &lt;GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">5 clocks = &lt;&amp;clks IMX6UL_CLK_PWM3&gt;,</span><br><span class="line">6 &lt;&amp;clks IMX6UL_CLK_PWM3&gt;;</span><br><span class="line">7 clock-names = &quot;ipg&quot;, &quot;per&quot;;</span><br><span class="line">8 #pwm-cells = &lt;2&gt;;</span><br><span class="line">9 &#125;；</span><br></pre></td></tr></table></figure><p>在自己的设备树文件中进行追加GPIO1_IO04的信息。在iomuxc节点添加引脚信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_pwm3: pwm3grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_GPIO1_IO04__PWM3_OUT 0x110b0</span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在根节点后的追加节点内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;pwm3 &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_pwm3&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_PWM3&gt;,</span><br><span class="line">&lt;&amp;clks IMX6UL_CLK_PWM3&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后保存加载linux内核使能pwm驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">-&gt; Pulse-Width Modulation (PWM) Support</span><br><span class="line">-&gt; &lt;*&gt; i.MX PWM support</span><br></pre></td></tr></table></figure><p>之后打开设备通过串口查看根文件系统里的设备驱动加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /sys/class/pwm</span><br><span class="line">$ ls</span><br><span class="line">pwmchip0 pwmchip1 pwmchip2 pwmchip3 pwmchip4 pwmchip5 pwmchip6 pwmchip7</span><br></pre></td></tr></table></figure><p>pwmchip0<del>pwmchip7 对应 I.MX6ULL 的 PWM1</del>PWM8，所以我们需要用到pwmchip2。 </p><p><strong>调出 pwmchip2 的 pwm0 子目录</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /sys/class/pwm/pwmchip2/export </span><br></pre></td></tr></table></figure><p>执行完成会在 pwmchip2 目录下生成一个名为“pwm0”的子目录 ，这个就是控制PWM3的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$cd pwm0</span><br><span class="line">$echo 1 &gt; /sys/class/pwm/pwmchip2/pwm0/enable#使能pwm</span><br><span class="line">$echo 50000 &gt; /sys/class/pwm/pwmchip2/pwm0/period#设置频率</span><br><span class="line">$echo 10000 &gt; /sys/class/pwm/pwmchip2/pwm0/duty_cycle#设置占空比</span><br></pre></td></tr></table></figure><h2 id="ADC驱动"><a href="#ADC驱动" class="headerlink" title="ADC驱动"></a>ADC驱动</h2><p>使用的是IIO子系统框架来编写adc的传感器驱动，使用的是nxp编写好的ADC驱动，在其基础上添加引脚信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_adc1: adc1grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_GPIO1_IO01__GPIO1_IO01 0xb0</span><br><span class="line">&gt;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>追加adc1节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;adc1 &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_adc1&gt;;</span><br><span class="line">num-channels = &lt;2&gt;;</span><br><span class="line">vref-supply = &lt;&amp;reg_vref_adc&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使能内核自带的adc驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">-&gt; Industrial I/O support</span><br><span class="line">-&gt; Analog to digital converters</span><br><span class="line">-&gt; &lt;*&gt; Freescale vf610 ADC driver //选中</span><br></pre></td></tr></table></figure><p>编译修改后的设备树，然后使用新的设备树启动系统。进入&#x2F;sys&#x2F;bus&#x2F;iio&#x2F;devices 目录下，此目录下就有 ADC 对应的 iio 设备： iio:deviceX </p><p>iio:device0”就是 ADC 设备，因为此时并没有加载其他的 IIO 设备驱动，只有一个 ADC。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-05%20151722.png"></p><p>in_voltage1_raw： ADC1 通道 1 原始值文件。<br>in_voltage_scale： ADC1 比例文件(分辨率)，单位为 mV。实际电压值(mV)&#x3D;in_voltage1_raw*in_voltage_scale </p><p><strong>gpio的控制参考上一篇文章</strong></p><p>最后就是通过QFile来操作文件，mainwindow.h文件如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSpinBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProcess&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QPushButton * start;</span><br><span class="line">    QPushButton *update;</span><br><span class="line">    QSpinBox * p_spinBox;</span><br><span class="line">    QSpinBox *t_spinBox;</span><br><span class="line">    QLabel *p_label;</span><br><span class="line">    QLabel *t_label;</span><br><span class="line">    QProcess *process;</span><br><span class="line">    QFile file;</span><br><span class="line">    QPushButton * uptemper;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushButton_startprogress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_power</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">up_temperature</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p>mainwindow.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProcess&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bytesToInt</span><span class="params">(QByteArray bytes)</span> </span>;</span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    start = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;开启激光器的配置&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    start-&gt;<span class="built_in">setGeometry</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">120</span>, <span class="number">40</span>);</span><br><span class="line">    update = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;控制功率&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    update -&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>, <span class="number">150</span>, <span class="number">80</span>, <span class="number">40</span>);</span><br><span class="line">    uptemper = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;更新温度功率的数据&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    uptemper-&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>, <span class="number">190</span>, <span class="number">160</span>, <span class="number">40</span>);</span><br><span class="line">    file.<span class="built_in">setFileName</span>(<span class="string">&quot;/sys/bus/iio/devices/iio:device0/in_voltage0_raw&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">exists</span>())&#123;</span><br><span class="line">       QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;文件不存在,无法调制功率&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">       label-&gt;<span class="built_in">setGeometry</span>( <span class="number">270</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    QLabel * label_p = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;激光器功率为&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    QLabel * <span class="type">label_t</span> = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;激光器温度为&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    label_p -&gt; <span class="built_in">setGeometry</span>(<span class="number">100</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="type">label_t</span> -&gt; <span class="built_in">setGeometry</span>(<span class="number">100</span>, <span class="number">190</span>, <span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line">    p_spinBox = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    p_spinBox-&gt;<span class="built_in">setGeometry</span>(<span class="number">210</span>, <span class="number">150</span>, <span class="number">60</span>, <span class="number">40</span>);</span><br><span class="line">    p_spinBox-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);                <span class="comment">//设置激光器功率0~100</span></span><br><span class="line">    t_spinBox = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    t_spinBox-&gt;<span class="built_in">setGeometry</span>(<span class="number">210</span>, <span class="number">190</span>, <span class="number">60</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="built_in">connect</span>(uptemper, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">up_temperature</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(start, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButton_startprogress</span>()));<span class="comment">//开启激光器的IO口配置</span></span><br><span class="line">    <span class="built_in">connect</span>(update, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">update_power</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButton_startprogress</span><span class="params">()</span><span class="comment">//初始化激光器完成</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 2 &gt; /sys/class/gpio/export&quot;</span>);      <span class="comment">//gpio1_02的IO口配置</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo out &gt; /sys/class/gpio/gpio2/direction&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 1 &gt; /sys/class/gpio/gpio2/value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 0 &gt; /sys/class/gpio/export&quot;</span>);      <span class="comment">//gpio1_00的IO口配置</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo out &gt; /sys/class/gpio/gpio0/direction&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 1 &gt; /sys/class/gpio/gpio0/value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 0 &gt; /sys/class/pwm/pwmchip2/export&quot;</span>);  <span class="comment">//使能pwm</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 1 &gt; /sys/class/pwm/pwmchip2/pwm0/enable&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 50000 &gt; /sys/class/pwm/pwmchip2/pwm0/period&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;echo 10000 &gt; /sys/class/pwm/pwmchip2/pwm0/duty_cycle&quot;</span>);<span class="comment">//默认占空比是百分之二十</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::update_power</span><span class="params">()</span><span class="comment">//完成</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> current_power = p_spinBox-&gt;<span class="built_in">value</span>();</span><br><span class="line">    <span class="type">int</span> a = current_power * <span class="number">50000</span> / <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; a;</span><br><span class="line">    QFile file1 ;</span><br><span class="line">    file1.<span class="built_in">setFileName</span>(<span class="string">&quot;/sys/class/pwm/pwmchip2/pwm0/duty_cycle&quot;</span>);   <span class="comment">//选择占空比的文件</span></span><br><span class="line">    <span class="comment">//file1.setFileName(&quot;/home/moss/test&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(!file1.<span class="built_in">exists</span>())                  <span class="comment">//判断文件是否存在</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;file.<span class="built_in">errorString</span>();</span><br><span class="line">    <span class="keyword">if</span>(!file1.<span class="built_in">open</span>(QIODevice::ReadWrite))<span class="comment">//文件打开</span></span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;file.<span class="built_in">errorString</span>();</span><br><span class="line">    QString str = QString::<span class="built_in">number</span>(a);   <span class="comment">//整数型变为字符型</span></span><br><span class="line">    file1.<span class="built_in">write</span>(str.<span class="built_in">toUtf8</span>());          <span class="comment">//写入命令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::up_temperature</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QFile file2 ;</span><br><span class="line">    QFile file3 ;</span><br><span class="line">    file2.<span class="built_in">setFileName</span>(<span class="string">&quot;/sys/bus/iio/devices/iio:device0/in_voltage1_raw&quot;</span>);   <span class="comment">//选择adc通道文件</span></span><br><span class="line">    file3.<span class="built_in">setFileName</span>(<span class="string">&quot;/sys/bus/iio/devices/iio:device0/in_voltage_scale&quot;</span>);  <span class="comment">//比例文件</span></span><br><span class="line">    <span class="type">bool</span> isok2 = file2.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">    QByteArray array2;</span><br><span class="line">    QByteArray array3;</span><br><span class="line">    <span class="keyword">if</span>(isok2 == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        array2 =  file2.<span class="built_in">readAll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> isok3 = file3.<span class="built_in">open</span>(QIODevice::ReadOnly);</span><br><span class="line">    <span class="keyword">if</span>(isok3 == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        array3 =  file3.<span class="built_in">readAll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> number = <span class="built_in">bytesToInt</span>(array2) * <span class="built_in">bytesToInt</span>(array3);</span><br><span class="line">    t_spinBox -&gt;<span class="built_in">setValue</span>(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bytesToInt</span><span class="params">(QByteArray bytes)</span><span class="comment">//字符转为整形</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> addr = bytes[<span class="number">0</span>] &amp; <span class="number">0x000000FF</span>;</span><br><span class="line">    addr |= ((bytes[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0x0000FF00</span>);</span><br><span class="line">    addr |= ((bytes[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) &amp; <span class="number">0x00FF0000</span>);</span><br><span class="line">    addr |= ((bytes[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>) &amp; <span class="number">0xFF000000</span>);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，因为没有连接设备，在虚拟机上编译，所以没查到文件。这部分功能完成接下来就是光谱仪的开发了。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-05%20152150.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt控制gpio(sysfs控制gpio)</title>
      <link href="/2023/09/26/2023-9-26-qt%E6%8E%A7%E5%88%B6gpio(sysfs%E6%8E%A7%E5%88%B6gpio)/"/>
      <url>/2023/09/26/2023-9-26-qt%E6%8E%A7%E5%88%B6gpio(sysfs%E6%8E%A7%E5%88%B6gpio)/</url>
      
        <content type="html"><![CDATA[<h2 id="使用sysfs方式控制gpio"><a href="#使用sysfs方式控制gpio" class="headerlink" title="使用sysfs方式控制gpio"></a>使用sysfs方式控制gpio</h2><h3 id="sysfs文件系统"><a href="#sysfs文件系统" class="headerlink" title="sysfs文件系统"></a>sysfs文件系统</h3><p>sysfs 是一个基于内存的文件系统， 同 devfs、 proc 文件系统一样，称为虚拟文件系统； 它的作用是将内核信息以文件的方式提供给应用层使用。 sysfs 文件系统的主要功能便是对系统设备进行管理，它可以产生一个包含所有系统硬件层次的视图。<br>sysfs 文件系统把连接在系统上的设备和总线组织成为一个分级的文件、 展示设备驱动模型中各组件的层次关系。 sysfs 提供了一种机制，可以显式的描述内核对象、对象属性及对象间关系， 用来导出内核对象(kernel object，譬如一个硬件设备)的数据、属性到用户空间，以文件目录结构的形式为用户空间提供对这些数据、属性的访问支持。 </p><p>sysfs 文件系统中的目录，包括 block、 bus、 class、 dev、 devices、firmware、 fs、kernel、modules、 power 等，每个目录下又有许多文件或子目录 。</p><table><thead><tr><th>&#x2F;sys 下的子目录</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;sys&#x2F;devices</td><td>这是系统中所有设备存放的目录，也就是系统中所有设备在sysfs中的呈现、表达，也是sysfs管理设备的最重要的目录结构。</td></tr><tr><td>&#x2F;sys&#x2F;block</td><td>块设备的存放目录，这是一个过时的接口，按照sysfs的设计理念，系统所有的设备都存放在&#x2F;sys&#x2F;devices目录下，所以&#x2F;sys&#x2F;block目录下的文件通常是链接到&#x2F;sys&#x2F;devices目录下的文件。</td></tr><tr><td>&#x2F;sys&#x2F;bus</td><td>这是系统中的所有设备按照总线类型分类放置的目录结构， &#x2F;sys&#x2F;devices 目录下每一种设备都是挂在某种总线下的，譬如 i2c 设备挂在 I2C 总线下。同样， &#x2F;sys&#x2F;bus 目录下的文件通常也是链接到了&#x2F;sys&#x2F;devices 目录。</td></tr><tr><td>&#x2F;sys&#x2F;class</td><td>这是系统中的所有设备按照其功能分类放置的目录结构，同样该目录下的文件也是链接到了&#x2F;sys&#x2F;devices 目录。 按照设备的功能划分组织在&#x2F;sys&#x2F;class 目录下，譬如&#x2F;sys&#x2F;class&#x2F;leds目录中存放了所有的 LED 设备， &#x2F;sys&#x2F;class&#x2F;input 目录中存放了所有的输入类设备。</td></tr><tr><td>&#x2F;sys&#x2F;dev</td><td>这是按照设备号的方式放置的目录结构，同样该目录下的文件也是链接到了&#x2F;sys&#x2F;devices 目录。该目录下有很多以主设备号:次设备号（major:minor）命名的文件，这些文件都是链接文件，链接到&#x2F;sys&#x2F;devices 目录下对应的设备。</td></tr><tr><td>&#x2F;sys&#x2F;firmware</td><td>描述了内核中的固件。</td></tr><tr><td>&#x2F;sys&#x2F;fs</td><td>用于描述系统中所有文件系统，包括文件系统本身和按文件系统分类存放的已挂载点。</td></tr><tr><td>&#x2F;sys&#x2F;kernel</td><td>这里是内核中所有可调参数的位置。</td></tr><tr><td>&#x2F;sys&#x2F;module</td><td>这里有系统中所有模块的信息。</td></tr><tr><td>&#x2F;sys&#x2F;power</td><td>这里是系统中电源选项，有一些属性可以用于控制整个系统的电源状态。</td></tr></tbody></table><p>系统中所有的设备（对象）都会在&#x2F;sys&#x2F;devices 体现出来，是 sysfs 文件系统中最重要的目录结构；而&#x2F;sys&#x2F;bus、 &#x2F;sys&#x2F;class、 &#x2F;sys&#x2F;dev 分别将设备按照挂载的总线类型、功能分类以及设备号的形式将设备组织存放在这些目录中，这些目录下的文件都是链接到了&#x2F;sys&#x2F;devices 中。 </p><h3 id="GPIO部分"><a href="#GPIO部分" class="headerlink" title="GPIO部分"></a>GPIO部分</h3><p>通过 sysfs 方式控制 GPIO，先访问 &#x2F;sys&#x2F;class&#x2F;gpio 目录，向 export 文件写入 GPIO 编号，使得该 GPIO 的操作接口从内核空间暴露到用户空间，GPIO 的操作接口包括 direction 和 value 等，direction 控制 GPIO 方向，而 value 可控制 GPIO 输出或获得 GPIO 输入。文件 IO 方式操作 GPIO，使用到了4个函数 open、close、read、write。</p><p>在系统图形化配置过程中，要加入支持选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers -&gt;</span><br><span class="line">GPIO Support -&gt;</span><br><span class="line">/sysfs/class/gpio/...（sysfs interface）</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-26%20133157.png"></p><p>之后可以看到&#x2F;sys&#x2F;class&#x2F;gpio下有如下文件。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-26%20133324.png"></p><blockquote><p>1、gpio_operation 通过 &#x2F;sys&#x2F; 文件接口操作 IO 端口 GPIO 到文件系统的映射。<br>2、控制 GPIO 的目录位于 &#x2F;sys&#x2F;class&#x2F;gpio。<br>3、&#x2F;sys&#x2F;class&#x2F;gpio&#x2F;export 文件用于通知系统需要导出控制的 GPIO 引脚编号。<br>4、&#x2F;sys&#x2F;class&#x2F;gpio&#x2F;unexport 用于通知系统取消导出。<br>5、&#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpiochipX 目录保存系统中 GPIO 寄存器的信息，包括每个寄存器控制引脚的起始编号 base，寄存器名称，引脚总数。</p></blockquote><h3 id="查询gpio的真实引脚编号"><a href="#查询gpio的真实引脚编号" class="headerlink" title="查询gpio的真实引脚编号"></a>查询gpio的真实引脚编号</h3><p>还是在刚才的目录进入其中一个<strong>gpiochip32</strong>，查询地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat label</span><br><span class="line">20a0000.goio</span><br></pre></td></tr></table></figure><p>之后将得到的地址20a0000放入到设备树的文件中来进行查询。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-26%20141443.png"></p><p>所以gpio2的引脚的基准引脚32</p><p>如果想操作GPIO2_IO3 这个引脚的话，就需要操作gpio32这个控制器并且引脚的编号为32+3&#x3D;35.</p><p><strong>向 &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;export 写入此编号，比如35号引脚，在 shell 中可以通过以下命令实现</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 35 &gt; /sys/class/gpio/export</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-26%20142057.png"></p><p><strong>direction 文件，定义输入输入方向，可以通过下面命令定义为输出。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo out &gt; direction</span><br></pre></td></tr></table></figure><p>direction 接受的参数可以是：in、out、high、low。其中参数 high &#x2F; low 在设置方向为输出的同时，将 value 设置为相应的 1 &#x2F; 0。</p><p>几个简单的例子<br>1、导出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 36 &gt; /sys/class/gpio/export</span><br></pre></td></tr></table></figure><p>2、设置方向</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo out &gt; /sys/class/gpio/gpio36/direction</span><br></pre></td></tr></table></figure><p>3、查看方向</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/class/gpio/gpio36/direction</span><br></pre></td></tr></table></figure><p>4、设置输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/class/gpio/gpio36/value</span><br></pre></td></tr></table></figure><p>5、查看输出值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/class/gpio/gpio36/value</span><br></pre></td></tr></table></figure><p>6、取消导出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 36 &gt; /sys/class/gpio/unexport</span><br></pre></td></tr></table></figure><h3 id="Qt程序"><a href="#Qt程序" class="headerlink" title="Qt程序"></a>Qt程序</h3><p>接下来就很简单了，就是通过QFile来给IO口进行输出数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt控制LED</title>
      <link href="/2023/09/21/2023-9-21-qt-led/"/>
      <url>/2023/09/21/2023-9-21-qt-led/</url>
      
        <content type="html"><![CDATA[<h2 id="Qt控制LED"><a href="#Qt控制LED" class="headerlink" title="Qt控制LED"></a>Qt控制LED</h2><p>自己搭建的根文件系统，要确保加载了LED的驱动，以及系统的设备树也是支持LED的。</p><p>主要关注便是 brightness、 max_brightness 以及 trigger 三个文件，这三个文件都是 LED 设备的属性文件：<br>⚫ brightness： 翻译过来就是亮度的意思， 该属性文件可读可写； 所以这个属性文件是用于设置 LED的亮度等级或者获取当前 LED 的亮度等级，譬如 brightness 等于 0 表示 LED 灭， brightness 为正整数表示 LED 亮，其值越大、 LED 越亮； 对于 PWM 控制的 LED 来说， 这通常是适用的，因为它存在亮度等级的问题，不同的亮度等级对应不同的占空比，自然 LED 的亮度也是不同的； 但对于 GPIO控制（控制 GPIO 输出高低电平）的 LED 来说，通常不存在亮度等级这样的说法，只有 LED 亮（brightness 等于 0）和 LED 灭（brightness 为非 0 值的正整数）两种状态。<br>⚫ max_brightness： 该属性文件只能被读取，不能写，用于获取 LED 设备的最大亮度等级。<br>⚫ trigger： 触发模式，该属性文件可读可写，读表示获取 LED 当前的触发模式，写表示设置 LED 的触发模式。 不同的触发模式其触发条件不同， LED 设备会根据不同的触发条件自动控制其亮、灭状态， 通过 cat 命令查看该属性文件，可获取 LED 支持的所有触发模式以及 LED 当前被设置的触发模式：</p><p>方括号（[heartbeat]）括起来的表示当前 LED 对应的触发模式， none 表示无触发，常用的触发模式包括none（无触发）、 mmc0（当对 mmc0 设备发起读写操作的时候 LED 会闪烁）、 timer（LED 会有规律的一亮一灭，被定时器控制住）、 heartbeat（心跳呼吸模式， LED 模仿人的心跳呼吸那样亮灭变化）。 </p><h4 id="设计qt程序"><a href="#设计qt程序" class="headerlink" title="设计qt程序"></a>设计qt程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 按钮 */</span></span><br><span class="line">QPushButton *pushButton;</span><br><span class="line"><span class="comment">/* 文件 */</span></span><br><span class="line">QFile file;</span><br><span class="line"><span class="comment">/* 设置 lED 的状态 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLedState</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* 获取 lED 的状态 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getLedState</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRect&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 获取屏幕的分辨率， Qt 官方建议使用这</span></span><br><span class="line"><span class="comment">* 种方法获取屏幕分辨率，防上多屏设备导致对应不上</span></span><br><span class="line"><span class="comment">* 注意，这是获取整个桌面系统的分辨率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QList &lt;QScreen *&gt; list_screen = QGuiApplication::<span class="built_in">screens</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果是 ARM 平台，直接设置大小为屏幕的大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __arm__</span></span><br><span class="line"><span class="comment">/* 重设大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(list_screen.<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">geometry</span>().<span class="built_in">width</span>(),</span><br><span class="line">list_screen.<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">geometry</span>().<span class="built_in">height</span>());</span><br><span class="line"><span class="comment">/* 默认是出厂系统的 LED 心跳的触发方式,想要控制 LED，</span></span><br><span class="line"><span class="comment">* 需要改变 LED 的触发方式，改为 none，即无 */</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;echo none &gt; /sys/class/leds/sys-led/trigger&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/* 否则则设置主窗体大小为 800x480 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(<span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 居中显示 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">setMinimumSize</span>(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">pushButton-&gt;<span class="built_in">setGeometry</span>((<span class="keyword">this</span>-&gt;<span class="built_in">width</span>() - pushButton-&gt;<span class="built_in">width</span>()) /<span class="number">2</span> ,(<span class="keyword">this</span>-&gt;<span class="built_in">height</span>() - pushButton-&gt;<span class="built_in">height</span>()) /<span class="number">2</span>,</span><br><span class="line">pushButton-&gt;<span class="built_in">width</span>(), pushButton-&gt;<span class="built_in">height</span>());</span><br><span class="line"><span class="comment">/* 开发板的 LED 控制接口 */</span></span><br><span class="line"></span><br><span class="line">file.<span class="built_in">setFileName</span>(<span class="string">&quot;/sys/devices/platform/leds/leds/sys-led/brightness&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">exists</span>())</span><br><span class="line"><span class="comment">/* 设置按钮的初始化文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;未获取到 LED 设备！ &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取 LED 的状态 */</span></span><br><span class="line"><span class="built_in">getLedState</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号槽连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButtonClicked</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::setLedState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 在设置 LED 状态时先读取 */</span></span><br><span class="line"><span class="type">bool</span> state = <span class="built_in">getLedState</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果文件不存在，则返回 */</span></span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">exists</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!file.<span class="built_in">open</span>(QIODevice::ReadWrite))</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;file.<span class="built_in">errorString</span>();</span><br><span class="line"></span><br><span class="line">QByteArray buf[<span class="number">2</span>] = &#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写 0 或 1 */</span></span><br><span class="line"><span class="keyword">if</span> (state)</span><br><span class="line">file.<span class="built_in">write</span>(buf[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">file.<span class="built_in">write</span>(buf[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭文件 */</span></span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重新获取 LED 的状态 */</span></span><br><span class="line"><span class="built_in">getLedState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::getLedState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 如果文件不存在，则返回 */</span></span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">exists</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!file.<span class="built_in">open</span>(QIODevice::ReadWrite))</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;file.<span class="built_in">errorString</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取文件所有数据 */</span></span><br><span class="line">QString buf = in.<span class="built_in">readLine</span>();</span><br><span class="line"><span class="comment">/* 打印出读出的值 */</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;buf: &quot;</span>&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">if</span> (buf == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;LED 点亮&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;LED 熄灭&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 设置 LED 的状态 */</span></span><br><span class="line"><span class="built_in">setLedState</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>brightness文件缺失问题</strong></p><p>解决这个问题居然绕了一大圈，居然是因为led的引脚在别的引脚占用了，所以才导致的brightness的文件确实，没找到这个的原因主要是之前写的led驱动居然能加载，设备还能使用，导致没想到能出现这个问题，就没有查设备树。大无语了，测了内核，测了硬件，最后才测了设备树。唉。。。</p><h2 id="U盘只读问题的解决"><a href="#U盘只读问题的解决" class="headerlink" title="U盘只读问题的解决"></a>U盘只读问题的解决</h2><p>①插入U盘并用df -h查看U盘信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$df -h</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180412150730888?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUQmlnR29k/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>这里是我的信息,　可以看到U盘文件系统为&#x2F;dev&#x2F;sdb5，挂载点为&#x2F;media&#x2F;zoutao&#x2F;disk</p><p>卸载U盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /media/zoutao/disk</span><br></pre></td></tr></table></figure><p> 卸载之后一定不能拔掉U盘</p><p>修复U盘文件系统故障  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dosfsck -v -a /dev/sdb5</span><br></pre></td></tr></table></figure><p>重新插拔</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支</title>
      <link href="/2023/09/18/2023-9-18-git%E5%88%86%E6%94%AF/"/>
      <url>/2023/09/18/2023-9-18-git%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p><p>当使用 git commit 新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p><p>现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20153420.png"></p><pre><code>                             单个提交对象在仓库中的数据结构</code></pre><p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。</p><h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><p>新建一个分支testing分支，可以使用git branch命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">git branch testing</span></span><br></pre></td></tr></table></figure><p><strong>这会在当前 commit 对象上新建一个分支指针</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20153937.png"></p><p>那么，Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。请注意它和你熟知的许多其他版本控制系统（比如 Subversion 或 CVS）里的 HEAD 概念大不相同。在 Git 中，它是一个指向你正在工作中的本地分支的指针（译注：将 HEAD 想象为当前分支的别名。）。<u>运行 git branch 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作。</u></p><p><strong>要切换到其他分支，可以执行 git checkout 命令。我们现在转换到新建的 testing 分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">git checkout testing</span></span><br></pre></td></tr></table></figure><h4 id="分支的新建和切换"><a href="#分支的新建和切换" class="headerlink" title="分支的新建和切换"></a>分支的新建和切换</h4><p>新建的分支取名为 iss53。要新建并切换到该分支，运行 git checkout 并加上 -b 参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b iss53</span></span><br></pre></td></tr></table></figure><p>相当于执行下面两条命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">git branch iss53</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">git checkout iss53</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20154827.png"></p><p>在提交了若干次更新后，iss53 分支的指针也会随着向前推进，因为它就是当前分支。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20154940.png"></p><p>切换分支前留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &#x27;hotfix&#x27;</span><br><span class="line">Switched to a new branch &quot;hotfix&quot;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &#x27;fixed the broken email address&#x27;</span><br><span class="line">[hotfix]: created 3a0874c: &quot;fixed the broken email address&quot;</span><br><span class="line"> 1 files changed, 0 insertions(+), 1 deletions(-)</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast forward</span><br><span class="line"> README |    1 -</span><br><span class="line"> 1 files changed, 0 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20155947.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>git branch 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>若要查看各个分支最后一个提交对象的信息，运行 git branch -v:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v</span></span><br></pre></td></tr></table></figure><p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 –merge 和 –no-merged 选项（Git 1.5.6 以上版本）。比如用 git branch –merge 查看哪些分支已被并入当前分支（译注::也就是说哪些分支是当前分支的直接上游。）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>另外可以用 git branch –no-merged 查看尚未合并的工作:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --no-merged</span></span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><p>远程分支（ <em>remote branch</em> ）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p><p>eg:</p><p>假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为 origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为 origin&#x2F;master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20161538.png"></p><p>一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin&#x2F;master，并且将它们都指向 origin 上的 master 分支。</p><p>如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的 master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin&#x2F;master 指针仍然保持原位不会移动。</p><p>可以运行 <strong>git fetch origin 来同步远程服务器上的数据到本地</strong>。该命令首先找到 origin 是哪个服务器（本例为 git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin&#x2F;master 的指针移到它最新的位置上。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20161645.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL数据库</title>
      <link href="/2023/09/17/2023-9-17-%E6%95%B0%E6%8D%AE%E5%BA%93sql/"/>
      <url>/2023/09/17/2023-9-17-%E6%95%B0%E6%8D%AE%E5%BA%93sql/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库，是数据的集合，由一张张数据表组成，用来存放数据。</p><p>每一张表都有一个唯一标识，即主键，标识数据的唯一性。表与表之间可以 通过主键来互相联系，就是数据能够对应匹配，称之为联结。</p><h2 id="什么是SQLite"><a href="#什么是SQLite" class="headerlink" title="什么是SQLite"></a>什么是SQLite</h2><p>SQLite是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite是一个增长最快的数据库引擎。</p><p>SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。</p><h2 id="为什么要用SQLite"><a href="#为什么要用SQLite" class="headerlink" title="为什么要用SQLite"></a>为什么要用SQLite</h2><blockquote><p>不需要一个单独的服务器进程或操作的系统（无服务器的）。</p><p>SQLite 不需要配置，这意味着不需要安装或管理。</p><p>一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。</p><p>SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。</p><p>SQLite 是自给自足的，这意味着不需要任何外部的依赖。</p><p>SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</p><p>SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。</p><p>SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。</p><p>SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。</p></blockquote><p>安装sql ，可以先用命令查询自己系统是否安装过sqlite3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sqlite3</span></span><br></pre></td></tr></table></figure><p><a href="https://www.sqlite.org/download.html">SQLite Download Page</a></p><p>解压压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar xvzf sqlite-autoconf-3401502.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> sqlite-autoconf-3401502</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make install</span></span><br></pre></td></tr></table></figure><p>SQLite 注释是附加的注释，可以在 SQLite 代码中添加注释以增加其可读性，他们可以出现在任何空白处，包括在表达式内和其他 SQL 语句的中间，但它们不能嵌套。</p><p>SQL 注释以两个连续的 “-“ 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。</p><h2 id="在Qt中使用SQLite数据库"><a href="#在Qt中使用SQLite数据库" class="headerlink" title="在Qt中使用SQLite数据库"></a>在Qt中使用SQLite数据库</h2><p>要使用SQL的类定义，需要引用相关头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="string">&lt;QSqlQuery&gt;</span></span></span><br></pre></td></tr></table></figure><p>在.pro文件中加入sql模块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT+= core gui sql</span><br></pre></td></tr></table></figure><blockquote><p>查询驱动</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QStringList drivers = QSqlDatabase::<span class="built_in">drivers</span>();</span><br><span class="line">    foreach(QString driver, drivers)</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; driver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>连接数据库</p></blockquote><p>数据库连接使用连接名来定义，而不是使用数据库名，可以向相同的数据库创建多个连接。QSqlDatabase也支持默认连接的概念，默认连接就是一个没有命名的连接。在使用QSqlQuery或者QSqlQueryModel的成员函数时需要指定一个连接名作为参数，如果没有指定，那么就会使用默认连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase database;<span class="comment">//建立了一个QSqlDatabase对象，后续的操作要使用这个对象</span></span><br><span class="line"><span class="keyword">if</span>(QSqlDatabase::<span class="built_in">contains</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>))<span class="comment">//qt_sql_default_connection默认连接</span></span><br><span class="line">&#123;</span><br><span class="line">    database = QSqlDatabase::<span class="built_in">database</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);<span class="comment">//创建连接，并添加数据库QSLITE是SQLite对应的驱动名</span></span><br><span class="line">    database.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;myDataBase.db&quot;</span>);<span class="comment">//数据库名字</span></span><br><span class="line">    database.<span class="built_in">setUserName</span>(<span class="string">&quot;moss&quot;</span>);<span class="comment">//用户名字</span></span><br><span class="line">    database.<span class="built_in">setPassword</span>(<span class="string">&quot;123456&quot;</span>);<span class="comment">//密码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打开数据库</p></blockquote><p>使用open()打开数据库，并判断是否成功。注意，在第一步检查连接是否存在时，如果连接存在，则在返回这个连接的时候，会默认将数据库打开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!database.<span class="built_in">open</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Error: Failed to connect database.&quot;</span> &lt;&lt; database.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关闭数据库</p></blockquote><p>数据库操作完成后，最好关闭。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><blockquote><p>执行sql语句</p></blockquote><p>QSqlQuery类提供了一个接口，用于执行SQL语句和浏览查询的结果集。要执行一个SQL语句，只需要简单的创建一个QSqlQuery对象，然后调用QSqlQuery::exec()函数即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;insert into student (id, name) values (1, &#x27;LI&#x27;)&quot;</span>);插入一条记录</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>处理数据</p></blockquote><p>同一时间插入多条记录，可以使用占位符来完成。Qt支持两种占位符：名称绑定和位置绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//名称绑定</span></span><br><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;insert into student (id, name) values (:id, :name)&quot;</span>);</span><br><span class="line"><span class="type">int</span> idValue = <span class="number">1</span>;</span><br><span class="line">QString nameValue = <span class="string">&quot;Li&quot;</span>;</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:id&quot;</span>, idValue);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:name&quot;</span>, nameValue);</span><br><span class="line">query.<span class="built_in">exec</span>();</span><br><span class="line"><span class="comment">//位置绑定</span></span><br><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;insert into student (id, name) values (?, ?)&quot;</span>);</span><br><span class="line"><span class="type">int</span> idValue = <span class="number">1</span>;</span><br><span class="line">QString nameValue = <span class="string">&quot;Li&quot;</span>;</span><br><span class="line">query.<span class="built_in">addBindValue</span>(idValue);</span><br><span class="line">query.<span class="built_in">addBindValue</span>(nameValue);</span><br><span class="line">query.<span class="built_in">exec</span>();</span><br></pre></td></tr></table></figure><p>当要插入多条记录时，只需要调用QSqlQuery::prepare()一次，然后使用多次bindValue()或者addBindValue()函数来绑定需要的数据，最后调用一次exec()函数就可以了。其实，进行多条数据插入时，还可以使用批处理进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;insert into student (id, name) values (?, ?)&quot;</span>);</span><br><span class="line">QVariantList ids;</span><br><span class="line">ids &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">query.<span class="built_in">addBindValue</span>(ids);</span><br><span class="line">QVariantList names;</span><br><span class="line">names &lt;&lt; <span class="string">&quot;Li&quot;</span> &lt;&lt; <span class="string">&quot;Wang&quot;</span> &lt;&lt; <span class="string">&quot;Liu&quot;</span>;</span><br><span class="line">query.<span class="built_in">addBindValue</span>(names);</span><br><span class="line"><span class="keyword">if</span>(!query.<span class="built_in">execBatch</span>()) </span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; query.<span class="built_in">lastError</span>();</span><br></pre></td></tr></table></figure><p>修改数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QString update_sql = <span class="string">&quot;update student set name = :name where id = :id&quot;</span>;</span><br><span class="line"><span class="comment">//update &lt;table_name&gt; set &lt;f1=value1&gt;, &lt;f2=value2&gt;… where ;</span></span><br><span class="line">sql_query.<span class="built_in">prepare</span>(update_sql);</span><br><span class="line">sql_query.<span class="built_in">bindValue</span>(<span class="string">&quot;:name&quot;</span>, <span class="string">&quot;Qt&quot;</span>);</span><br><span class="line">sql_query.<span class="built_in">bindValue</span>(<span class="string">&quot;:id&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;updated!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分查询数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QString select_sql = <span class="string">&quot;select id, name from student&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>(select_sql))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(sql_query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = sql_query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        QString name = sql_query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">QString</span>(<span class="string">&quot;id:%1    name:%2&quot;</span>).<span class="built_in">arg</span>(id).<span class="built_in">arg</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select , , … from <table_name>;&#x2F;&#x2F;部分查询指令</p><p>查询全部数据</p><p>QSqlQuery提供了对结果集的访问，可以一次访问一条记录。当执行完exec()函数后，QSqlQuery的内部指针会位于第一条记录前面的位置。必须调用一次QSqlQuery::next()函数来使其前进到第一条记录，然后可以重复使用next()函数来访问其他的记录，直到该函数的返回值为false，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(query.<span class="built_in">next</span>())</span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>() &lt;&lt; query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QString select_all_sql = <span class="string">&quot;select * from student&quot;</span>;</span><br><span class="line">sql_query.<span class="built_in">prepare</span>(select_all_sql);</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(sql_query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = sql_query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        QString name = sql_query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">        <span class="type">int</span> age = sql_query.<span class="built_in">value</span>(<span class="number">2</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">QString</span>(<span class="string">&quot;id:%1    name:%2    age:%3&quot;</span>).<span class="built_in">arg</span>(id).<span class="built_in">arg</span>(name).<span class="built_in">arg</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句select * from <table_name>;查询所有数据用 * 表示。</p><p>用while(sql_query.next())用来遍历所有行。同样用value()获得数据。<br>（3）查询最大id</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QString select_max_sql = <span class="string">&quot;select max(id) from student&quot;</span>;</span><br><span class="line"><span class="type">int</span> max_id = <span class="number">0</span>;</span><br><span class="line">sql_query.<span class="built_in">prepare</span>(select_max_sql);</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(sql_query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        max_id = sql_query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;max id:%1&quot;</span>).<span class="built_in">arg</span>(max_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是在语句中用max来获取最大值。</p><p>删除与清空</p><p>（1）删除一条数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QString delete_sql = <span class="string">&quot;delete from student where id = ?&quot;</span>;</span><br><span class="line">sql_query.<span class="built_in">prepare</span>(delete_sql);</span><br><span class="line">sql_query.<span class="built_in">addBindValue</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;deleted!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句delete from <table_name> where &#x3D;<br>delete用于删除条目，用where给出限定条件。例如此处是删除 id &#x3D; 0的条目。<br>（2）清空表格（删除所有）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QString clear_sql = <span class="string">&quot;delete from student&quot;</span>;</span><br><span class="line">sql_query.<span class="built_in">prepare</span>(clear_sql);</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;table cleared&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlTableModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQueryModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGridLayout&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QSqlDatabase sqldatabase;   <span class="comment">//数据连接对象</span></span><br><span class="line">    QSqlQueryModel *sqlQueryModel;<span class="comment">//用于查询数据</span></span><br><span class="line">    QComboBox *comboBox;    <span class="comment">//下拉选择框</span></span><br><span class="line">    <span class="comment">/* 网格布局 */</span></span><br><span class="line">    QGridLayout *gridLayout;</span><br><span class="line">    QSqlTableModel *model;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p>mainwindow.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    QStringList drivers = QSqlDatabase::<span class="built_in">drivers</span>();  <span class="comment">//查看本机可用的数据库</span></span><br><span class="line">    foreach(QString driver, drivers)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;driver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(QSqlDatabase::<span class="built_in">contains</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>))<span class="comment">//查询是否默认连接</span></span><br><span class="line">    &#123;</span><br><span class="line">        sqldatabase = QSqlDatabase::<span class="built_in">database</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sqldatabase = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);<span class="comment">//创建连接，并添加数据库QSLITE是SQLite对应的驱动名</span></span><br><span class="line">        sqldatabase.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;la.db&quot;</span>);<span class="comment">//数据库名字</span></span><br><span class="line">        <span class="comment">//sqldatabase.setUserName(&quot;moss&quot;);//用户名字</span></span><br><span class="line">        <span class="comment">//sqldatabase.setPassword(&quot;123456&quot;);//密码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!sqldatabase.<span class="built_in">open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Error: Failed to connect database.&quot;</span> &lt;&lt; sqldatabase.<span class="built_in">lastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;连接成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    <span class="keyword">if</span>(sqldatabase.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;users&quot;</span>)) &#123;</span><br><span class="line">           <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;table users already exists!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 表格不存在，则创建表格users</span></span><br><span class="line">           <span class="comment">// 创建表格users，1为普通用户，2为管理者</span></span><br><span class="line"></span><br><span class="line">           QString cmd = <span class="string">&quot;create table users(user varchar(50) primary key, pwd varchar(50),phone varchar(50), email varchar(50), identity varchar(20));&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(!query.<span class="built_in">exec</span>(cmd)) &#123;</span><br><span class="line">               <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;create users table error!&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sqldatabase.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;informations&quot;</span>)) &#123;</span><br><span class="line">          <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;table informations already exists!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 表格不存在，则创建表格informations</span></span><br><span class="line">        <span class="keyword">if</span>(!query.<span class="built_in">exec</span>(<span class="string">&quot;create table informations(id int primary key,name varchar(20));&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;create informations table error!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QString cmd = <span class="built_in">QString</span>(<span class="string">&quot;insert into informations values(3, &#x27;qiadu&#x27;)&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; cmd;</span><br><span class="line">    <span class="keyword">if</span>(query.<span class="built_in">exec</span>(cmd)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;insert ok!&quot;</span>;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;insert error!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;select * from informations&quot;</span>);<span class="comment">//选择表的所有信息</span></span><br><span class="line">    <span class="keyword">while</span>(query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>()&lt;&lt; query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    sqldatabase.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-17%20145322.png"></p><h3 id="SQL查询模型QSqlQueryModel"><a href="#SQL查询模型QSqlQueryModel" class="headerlink" title="SQL查询模型QSqlQueryModel"></a>SQL查询模型<code>QSqlQueryModel</code></h3><p>QSqlQueryModel提供了一个基于SQL查询的只读模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QSqlQueryModel *model = <span class="keyword">new</span> <span class="built_in">QSqlQueryModel</span>(<span class="keyword">this</span>);</span><br><span class="line">model-&gt;<span class="built_in">setQuery</span>(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">0</span>, Qt::Horizontal, <span class="built_in">tr</span>(<span class="string">&quot;学号&quot;</span>));</span><br><span class="line">model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">1</span>, Qt::Horizontal, <span class="built_in">tr</span>(<span class="string">&quot;姓名&quot;</span>));</span><br><span class="line">model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">2</span>, Qt::Horizontal, <span class="built_in">tr</span>(<span class="string">&quot;课程&quot;</span>));</span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">setHidden</span>(<span class="literal">true</span>);</span><br><span class="line">ui-&gt;tableView-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(QHeaderView::Stretch);</span><br></pre></td></tr></table></figure><p>这里要注意，其实QSqlQueryModel中存储的是执行完setQuery()函数后的结果集，所以视图中显示的是结果集的内容。QSqlQueryModel中还提供了columnCount()返回一条记录中字段的个数；rowCount()返回结果集中记录的条数；record()返回第n条记录；index()返回指定记录的指定字段的索引；clear()可以清空模型中的结果集。</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//.pro文件</span><br><span class="line">Qt+=core gui sql</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQueryModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlTableModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDataWidgetMapper&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line">    QSqlDatabase sqlDatabase;</span><br><span class="line">    QSqlQueryModel *model;<span class="comment">//SQL查询的只读模型</span></span><br><span class="line">    QDataWidgetMapper *dataWidgetMapper;</span><br><span class="line">    QTableView *tableview;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHeaderView&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">    QStringList drivers = QSqlDatabase::<span class="built_in">drivers</span>();<span class="comment">//查看本机的可用数据库驱动</span></span><br><span class="line">    foreach(QString driver, drivers) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;driver;</span><br><span class="line">    &#125;</span><br><span class="line">    sqlDatabase = QSqlDatabase::<span class="built_in">addDatabase</span>( <span class="string">&quot;QSQLITE&quot;</span>);<span class="comment">//打开QSQLITE的数据库</span></span><br><span class="line">    sqlDatabase.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;excel.db&quot;</span>);</span><br><span class="line">    sqlDatabase.<span class="built_in">setUserName</span>(<span class="string">&quot;moss&quot;</span>);</span><br><span class="line">    sqlDatabase.<span class="built_in">setPassword</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!sqlDatabase.<span class="built_in">open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;连接数据库失败&quot;</span>&lt;&lt;sqlDatabase.<span class="built_in">lastError</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(sqlDatabase)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(sqlDatabase.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;informations&quot;</span>)) &#123;</span><br><span class="line">              <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;table information already exists!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 表格不存在，则创建表格information</span></span><br><span class="line">        <span class="keyword">if</span>(!query.<span class="built_in">exec</span>(<span class="string">&quot;create table informations(str double primary key, dis double));&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;create informations table error!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QString cmd = <span class="built_in">QString</span>(<span class="string">&quot;insert into informations values(32, 2.2)&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; cmd;</span><br><span class="line">    <span class="keyword">if</span>(query.<span class="built_in">exec</span>(cmd)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;insert ok!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;insert error!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;select * from informations&quot;</span>);<span class="comment">//选择表的所有信息</span></span><br><span class="line">    <span class="keyword">while</span>(query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>()&lt;&lt; query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    model = <span class="keyword">new</span> <span class="built_in">QSqlQueryModel</span>(<span class="keyword">this</span>);</span><br><span class="line">    model-&gt;<span class="built_in">setQuery</span>(<span class="string">&quot;select * from informations&quot;</span>);</span><br><span class="line">    model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">0</span>, Qt::Horizontal, <span class="built_in">tr</span>(<span class="string">&quot;强度&quot;</span>));</span><br><span class="line">    model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">1</span>, Qt::Horizontal, <span class="built_in">tr</span>(<span class="string">&quot;位移&quot;</span>));</span><br><span class="line">    QTableView *tableview = <span class="keyword">new</span> QTableView;</span><br><span class="line">    tableview-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line">    tableview-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    sqlDatabase.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SQL表格模型QSqlTableModel"><a href="#SQL表格模型QSqlTableModel" class="headerlink" title="SQL表格模型QSqlTableModel"></a>SQL表格模型<code>QSqlTableModel</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHeaderView&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">    QStringList drivers = QSqlDatabase::<span class="built_in">drivers</span>();<span class="comment">//查看本机的可用数据库驱动</span></span><br><span class="line">    foreach(QString driver, drivers) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;driver;</span><br><span class="line">    &#125;</span><br><span class="line">    sqlDatabase = QSqlDatabase::<span class="built_in">addDatabase</span>( <span class="string">&quot;QSQLITE&quot;</span>);<span class="comment">//打开QSQLITE的数据库</span></span><br><span class="line">    sqlDatabase.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;excel.db&quot;</span>);</span><br><span class="line">    sqlDatabase.<span class="built_in">setUserName</span>(<span class="string">&quot;moss&quot;</span>);</span><br><span class="line">    sqlDatabase.<span class="built_in">setPassword</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!sqlDatabase.<span class="built_in">open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;连接数据库失败&quot;</span>&lt;&lt;sqlDatabase.<span class="built_in">lastError</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;连接成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(sqlDatabase)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(sqlDatabase.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;informations&quot;</span>)) &#123;</span><br><span class="line">              <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;table information already exists!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 表格不存在，则创建表格information</span></span><br><span class="line">        <span class="keyword">if</span>(!query.<span class="built_in">exec</span>(<span class="string">&quot;create table informations(str double primary key, dis double));&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;create informations table error!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QString cmd = <span class="built_in">QString</span>(<span class="string">&quot;insert into informations values(32, 2.2)&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; cmd;</span><br><span class="line">    <span class="keyword">if</span>(query.<span class="built_in">exec</span>(cmd)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;insert ok!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;insert error!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;select * from informations&quot;</span>);<span class="comment">//选择表的所有信息</span></span><br><span class="line">    <span class="keyword">while</span>(query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>()&lt;&lt; query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    QTableView *tableview = <span class="keyword">new</span> QTableView;</span><br><span class="line">    QSqlTableModel * tablemodel = <span class="keyword">new</span> <span class="built_in">QSqlTableModel</span>(<span class="keyword">this</span>);</span><br><span class="line">    tablemodel-&gt;<span class="built_in">setTable</span>(<span class="string">&quot;informations&quot;</span>);</span><br><span class="line">    tablemodel-&gt;<span class="built_in">select</span>();</span><br><span class="line">    tablemodel-&gt;<span class="built_in">setEditStrategy</span>(QSqlTableModel::OnManualSubmit);</span><br><span class="line">    tableview-&gt;<span class="built_in">setModel</span>(tablemodel);</span><br><span class="line">    tableview-&gt;<span class="built_in">verticalHeader</span>()-&gt;<span class="built_in">setHidden</span>(<span class="literal">true</span>);</span><br><span class="line">    tableview-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(QHeaderView::Stretch);</span><br><span class="line">    tableview-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    sqlDatabase.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2023/09/15/2023-9-15-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/09/15/2023-9-15-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>QThread 线程类是实现多线程的核心类。 Qt 有两种多线程的方法，其中一种是继承 QThread的 run()函数，另外一种是把一个继承于 QObject 的类转移到一个 Thread 里。 Qt4.8 之前都是使用继承 QThread 的 run()这种方法，但是 Qt4.8 之后， Qt 官方建议使用第二种方法。两种方法区别不大，用起来都比较方便，但继承 QObject 的方法更加灵活。 所以 Qt 的帮助文档里给的参考是先给继承 QObject 的类，然后再给继承 QThread 的类。<br>另外 Qt 提供了 QMutex、 QMutexLocker、 QReadLocker 和 QWriteLocker 等类用于线程之间的同步，详细可以看 Qt 的帮助文档 </p><h3 id="继承-QThread-的线程"><a href="#继承-QThread-的线程" class="headerlink" title="继承 QThread 的线程"></a>继承 QThread 的线程</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-15%20095404.png"></p><p>run()方法是继承于 QThread 类的方法，用户需要重写这个方法，一般是把耗时的操作写在这个 run()方法里面 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用下面声明的 WorkerThread 线程类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerThread</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 在 MainWindow 类里声明对象 */</span></span><br><span class="line">WorkerThread *workerThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明一个按钮，使用此按钮点击后开启线程 */</span></span><br><span class="line">QPushButton *pushButton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="comment">/* 槽函数，用于接收线程发送的信号 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleResults</span><span class="params">(<span class="type">const</span> QString &amp;result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 点击按钮开启线程 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新建一个 WorkerThread 类继承于 QThread */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerThread</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 用到信号槽即需要此宏定义 */</span></span><br><span class="line"> Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">WorkerThread</span>(QWidget *parent = <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">Q_UNUSED</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重写 run 方法，继承 QThread 的类，只有 run 方法是在新的线程里 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">QString result = <span class="string">&quot;线程开启成功&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里写上比较耗时的操作 */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 延时 2s，把延时 2s 当作耗时操作</span></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* 发送结果准备好的信号 */</span></span><br><span class="line"><span class="function">emit <span class="title">resultReady</span><span class="params">(result)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">signals:</span><br><span class="line"><span class="comment">/* 声明一个信号，译结果准确好的信号 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resultReady</span><span class="params">(<span class="type">const</span> QString &amp;s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* 设置位置与大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"><span class="comment">/* 对象实例化 */</span></span><br><span class="line">pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">workerThread = <span class="keyword">new</span> <span class="built_in">WorkerThread</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/* 按钮设置大小与文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">resize</span>(<span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开启线程&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号槽连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(workerThread, <span class="built_in">SIGNAL</span>(<span class="built_in">resultReady</span>(QString)),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleResults</span>(QString)));</span><br><span class="line"><span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButtonClicked</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()<span class="comment">//析构函数里面退出函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 进程退出，注意本例 run()方法没写循环，此方法需要有循环才生效 */</span></span><br><span class="line">workerThread-&gt;<span class="built_in">quit</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阻塞等待 2000ms 检查一次进程是否已经退出 */</span></span><br><span class="line"><span class="keyword">if</span> (workerThread-&gt;<span class="built_in">wait</span>(<span class="number">2000</span>)) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;线程已经结束！ &quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::handleResults</span><span class="params">(<span class="type">const</span> QString &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 打印出线程发送过来的结果 */</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 检查线程是否在运行，如果没有则开始运行 */</span></span><br><span class="line"><span class="keyword">if</span> (!workerThread-&gt;<span class="built_in">isRunning</span>())</span><br><span class="line">workerThread-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承-QObject-的线程"><a href="#继承-QObject-的线程" class="headerlink" title="继承 QObject 的线程"></a>继承 QObject 的线程</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-15%20100121.png"></p><p>耗时的线程放入QThread线程里面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">ifndef MAINWINDOW_H</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMutexLocker&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMutex&gt;</span></span></span><br><span class="line"><span class="comment">/* 工人类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 开始线程按钮 */</span></span><br><span class="line">QPushButton *pushButton1;</span><br><span class="line"><span class="comment">/* 打断线程按钮 */</span></span><br><span class="line">QPushButton *pushButton2;</span><br><span class="line"><span class="comment">/* 全局线程 */</span></span><br><span class="line">QThread workerThread;</span><br><span class="line"><span class="comment">/* 工人类 */</span></span><br><span class="line">Worker *worker;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="comment">/* 按钮 1 点击开启线程 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButton1Clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* 按钮 2 点击打断线程 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButton2Clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* 用于接收工人是否在工作的信号 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleResults</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line">signals:</span><br><span class="line"><span class="comment">/* 工人开始工作（做些耗时的操作 ） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">startWork</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Worker 类，这个类声明了 doWork1 函数，将整个 Worker 类移至线程 workerThread*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 互斥锁 */</span></span><br><span class="line">QMutex lock;</span><br><span class="line"><span class="comment">/* 标志位 */</span></span><br><span class="line"><span class="type">bool</span> isCanRun;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="comment">/* 耗时的工作都放在槽函数下，工人可以有多份不同的工作，但是每次只能去做一份 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork1</span><span class="params">(<span class="type">const</span> QString &amp;parameter)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 标志位为真 */</span></span><br><span class="line">isCanRun = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* 死循环 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* 此&#123;&#125;作用是 QMutexLocker 与 lock 的作用范围，获取锁后，运行完成后即解锁 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;lock)</span></span>;</span><br><span class="line"><span class="comment">/* 如果标志位不为真 */</span></span><br><span class="line"><span class="keyword">if</span> (!isCanRun) &#123;</span><br><span class="line"><span class="comment">/* 跳出循环 */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用 QThread 里的延时函数，当作一个普通延时 */</span></span><br><span class="line">QThread::<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"><span class="function">emit <span class="title">resultReady</span><span class="params">(parameter + <span class="string">&quot;doWork1 函数&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* doWork1 运行完成，发送信号 */</span></span><br><span class="line"><span class="function">emit <span class="title">resultReady</span><span class="params">(<span class="string">&quot;打断 doWork1 函数&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// void doWork2();...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/* 打断线程（注意此方法不能放在槽函数下） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stopWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;打断线程&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取锁后，运行完成后即解锁 */</span></span><br><span class="line"><span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;lock)</span></span>;</span><br><span class="line">isCanRun = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">signals:</span><br><span class="line"><span class="comment">/* 工人工作函数状态的信号 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resultReady</span><span class="params">(<span class="type">const</span> QString &amp;result)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置显示位置与大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">pushButton1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">pushButton2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/* 设置按钮的位置大小 */</span></span><br><span class="line">pushButton1-&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>, <span class="number">200</span>, <span class="number">80</span>, <span class="number">40</span>);</span><br><span class="line">pushButton2-&gt;<span class="built_in">setGeometry</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">80</span>, <span class="number">40</span>);</span><br><span class="line">* 设置两个按钮的文本 */</span><br><span class="line">pushButton1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开启线程&quot;</span>);</span><br><span class="line">pushButton2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;打断线程&quot;</span>);</span><br><span class="line"><span class="comment">/* 工人类实例化 */</span></span><br><span class="line">worker = <span class="keyword">new</span> Worker;</span><br><span class="line"><span class="comment">/* 将 worker 类移至线程 workerThread */</span></span><br><span class="line">worker-&gt;<span class="built_in">moveToThread</span>(&amp;workerThread);</span><br><span class="line"><span class="comment">/* 信号槽连接 */</span></span><br><span class="line"><span class="comment">/* 线程完成销毁对象 */</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;workerThread, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), worker, <span class="built_in">SLOT</span>(<span class="built_in">deleteLater</span>()));</span><br><span class="line"><span class="built_in">connect</span>(&amp;workerThread, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), &amp;workerThread, <span class="built_in">SLOT</span>(<span class="built_in">deleteLater</span>()));</span><br><span class="line"><span class="comment">/* 发送开始工作的信号，开始工作 */</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">startWork</span>(QString)), worker, <span class="built_in">SLOT</span>(<span class="built_in">doWork1</span>(QString)));</span><br><span class="line"><span class="comment">/* 接收到 worker 发送过来的信号 */</span></span><br><span class="line"><span class="built_in">connect</span>(worker, <span class="built_in">SIGNAL</span>(<span class="built_in">resultReady</span>(QString)),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleResults</span>(QString)));</span><br><span class="line"><span class="comment">/* 点击按钮开始线程 */</span></span><br><span class="line"><span class="built_in">connect</span>(pushButton1, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButton1Clicked</span>()));</span><br><span class="line"><span class="comment">/* 点击按钮打断线程 */</span></span><br><span class="line"><span class="built_in">connect</span>(pushButton2, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButton2Clicked</span>()));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 打断线程再退出 */</span></span><br><span class="line">worker-&gt;<span class="built_in">stopWork</span>();</span><br><span class="line">workerThread.<span class="built_in">quit</span>();</span><br><span class="line"><span class="comment">/* 阻塞线程 2000ms，判断线程是否结束 */</span></span><br><span class="line"><span class="keyword">if</span> (workerThread.<span class="built_in">wait</span>(<span class="number">2000</span>)) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;线程结束&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButton1Clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 字符串常量 */</span></span><br><span class="line"><span class="type">const</span> QString str = <span class="string">&quot;正在运行&quot;</span>;</span><br><span class="line"><span class="comment">/* 判断线程是否在运行 */</span></span><br><span class="line"><span class="keyword">if</span>(!workerThread.<span class="built_in">isRunning</span>()) &#123;</span><br><span class="line"><span class="comment">/* 开启线程 */</span></span><br><span class="line">workerThread.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 发送正在运行的信号，线程收到信号后执行后返回线程耗时函数 + 此字符串 */</span></span><br><span class="line">emit <span class="keyword">this</span>-&gt;<span class="built_in">startWork</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButton2Clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 如果线程在运行 */</span></span><br><span class="line"><span class="keyword">if</span>(workerThread.<span class="built_in">isRunning</span>()) &#123;</span><br><span class="line"><span class="comment">/* 停止耗时工作，跳出耗时工作的循环 */</span></span><br><span class="line">worker-&gt;<span class="built_in">stopWork</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::handleResults</span><span class="params">(<span class="type">const</span> QString &amp; results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 打印线程的状态 */</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;线程的状态： &quot;</span>&lt;&lt;results&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qchart放大缩小曲线图</title>
      <link href="/2023/09/14/2023-9-14-qchart%E7%BC%A9%E6%94%BE%E6%9B%B2%E7%BA%BF/"/>
      <url>/2023/09/14/2023-9-14-qchart%E7%BC%A9%E6%94%BE%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="曲线图绘制"><a href="#曲线图绘制" class="headerlink" title="曲线图绘制"></a>曲线图绘制</h3><p>qt的曲线绘制有三种类，分别是Qcustomplot、QChart、Qwt。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li><p><strong>美观方面：</strong></p><ul><li>Qcustomplot≈Qchart &gt; Qwt</li><li>Qcustomplot界面简洁大方；</li><li>Qchart界面华丽优美，在数据量大的时候会引响鼠标的缩放、移动图表操作；</li><li>Qwt界面老旧，在美观上不如Qcustomplot和Qchart ，并且在使用鼠标移动图表时会产生空白区域。</li></ul></li><li><p><strong>性能方面：</strong></p><ul><li><p>绘制数据性能：Qchart&gt;Qcustomplot &gt; Qwt</p></li><li><p>绘制数据数量：Qcustomplot &gt;Qchart&gt; Qwt</p></li><li><p>绘制1000个数据点时，qcustomplot平均耗时 13.6毫秒，Qwt平均耗时40毫秒，QChart平均耗时12.5毫秒;</p><p>绘制10000个数据点时，qcustomplot平均耗时 21.6毫秒，Qwt平均耗时78毫秒，QChart平均耗时13.5毫秒;</p><p>绘制100000个数据点时，qcustomplot平均耗时22.5毫秒，Qwt平均耗时524毫秒，QChart平均耗时20.7毫秒；</p><p>绘制500000个数据点时，qcustomplot平均耗时43.3毫秒，QChart平均耗时194.25毫秒。</p></li></ul></li><li><p><strong>功能方面：</strong></p><ul><li>QChart、Qwt功能比较齐全，并且可绘制图表种类多；</li><li>qcustomplot在图表种类上、常用功能上较少。</li></ul></li><li><p><strong>使用方面：</strong></p><ul><li>QChart无需配置，主要在安装Qt时勾选就可以，在程序编写时上手较慢，许多功能需要重写；</li><li>Qwt安装配置比较复杂；</li><li>QCustomPlot体积小、简单易用，上手快，并且QCustomPlot只有两个源文件，可直接添加进工程，更容易直接修改源码。</li></ul></li></ul><p><a href="https://sourceforge.net/projects/qwt/files/qwt/">Qwt 下载地址</a></p><p><a href="https://www.qcustomplot.com/index.php/download">Qcustomplot下载地址</a></p><p>QChart不用下载，只需在安装qt时候进行选择组件。</p><p>在这里我使用的是QChart来进行设计的毕设，首先是对.pro文件进行追加代码charts</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QT      += core gui</span><br><span class="line">QT  += charts</span><br></pre></td></tr></table></figure><p>进行编写mainwindow.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QChartView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineSeries&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QChart&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QValueAxis&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGraphicsSimpleTextItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSplineSeries&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_CHARTS_USE_NAMESPACE</span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//实现对于图线的缩放平移，定义的鼠标事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wheelEvent</span><span class="params">(QWheelEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line"></span><br><span class="line">    QPoint m_pointUsed;                             <span class="comment">//保存旧坐标</span></span><br><span class="line">    <span class="type">bool</span> m_isPress;                                 <span class="comment">//是否按下鼠标</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> m_dMinX, m_dMaxX, m_dMinY, m_dMaxY;      <span class="comment">//保存图表轴初始大小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receivedData</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="type">int</span> maxX;</span><br><span class="line">    <span class="type">int</span> maxY;</span><br><span class="line">    QValueAxis *axisY;</span><br><span class="line">    QValueAxis *axisX;</span><br><span class="line">    QList&lt;<span class="type">int</span>&gt;data;</span><br><span class="line">    QSplineSeries *splineSeries;    <span class="comment">//曲线</span></span><br><span class="line">    QChart *chart;</span><br><span class="line">    QChartView *chartView;</span><br><span class="line">    QTimer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mainwindow.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRandomGenerator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolTip&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置最显示位置与大小 */</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    <span class="comment">/* 最大储存 maxSize - 1 个数据 */</span></span><br><span class="line">    maxSize = <span class="number">1000</span><span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* x 轴上的最大值 */</span></span><br><span class="line">    maxX = <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">/* y 轴最大值 */</span></span><br><span class="line">    maxY = <span class="number">64000</span>;</span><br><span class="line">    <span class="comment">/* splineSeries 曲线实例化（折线用 QLineSeries） */</span></span><br><span class="line">    splineSeries = <span class="keyword">new</span> <span class="built_in">QSplineSeries</span>();</span><br><span class="line">    splineSeries-&gt;<span class="built_in">setName</span>(<span class="string">&quot;第一条线&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 图表实例化 */</span></span><br><span class="line">    chart = <span class="keyword">new</span> <span class="built_in">QChart</span>();</span><br><span class="line">    <span class="comment">/* 图表视图实例化 */</span></span><br><span class="line">    chartView = <span class="keyword">new</span> <span class="built_in">QChartView</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 坐标轴 */</span></span><br><span class="line">    axisY = <span class="keyword">new</span> <span class="built_in">QValueAxis</span>();</span><br><span class="line">    axisX = <span class="keyword">new</span> <span class="built_in">QValueAxis</span>();</span><br><span class="line">    <span class="comment">/* 定时器 */</span></span><br><span class="line">    timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* legend 译图例类型，以绘图的颜色区分， 本例设置为隐藏 */</span></span><br><span class="line">    chart-&gt;<span class="built_in">legend</span>()-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="comment">/* chart 设置标题 */</span></span><br><span class="line">    chart-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;拉曼光谱&quot;</span>);</span><br><span class="line">    <span class="comment">/* 添加一条曲线 splineSeries */</span></span><br><span class="line">    chart-&gt;<span class="built_in">addSeries</span>(splineSeries);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置显示格式 */</span></span><br><span class="line">    axisY-&gt;<span class="built_in">setLabelFormat</span>(<span class="string">&quot;%i&quot;</span>);</span><br><span class="line">    <span class="comment">/* y 轴标题 */</span></span><br><span class="line">    axisY-&gt;<span class="built_in">setTitleText</span>(<span class="string">&quot;强度&quot;</span>);</span><br><span class="line">    <span class="comment">/* y 轴标题位置（设置坐标轴的方向） */</span></span><br><span class="line">    chart-&gt;<span class="built_in">addAxis</span>(axisY, Qt::AlignLeft);</span><br><span class="line">    <span class="comment">/* 设置 y 轴范围 */</span></span><br><span class="line">    axisY-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, maxY);</span><br><span class="line">    <span class="comment">/* 将 splineSeries 附加于 y 轴上 */</span></span><br><span class="line">    splineSeries-&gt;<span class="built_in">attachAxis</span>(axisY);</span><br><span class="line">    <span class="comment">/* 设置显示格式 */</span></span><br><span class="line">    axisX-&gt;<span class="built_in">setLabelFormat</span>(<span class="string">&quot;%i&quot;</span>);</span><br><span class="line">    <span class="comment">/* x 轴标题 */</span></span><br><span class="line">    axisX-&gt;<span class="built_in">setTitleText</span>(<span class="string">&quot;拉曼位移(cm-1)&quot;</span>);</span><br><span class="line">    <span class="comment">/* x 轴标题位置（设置坐标轴的方向） */</span></span><br><span class="line">    chart-&gt;<span class="built_in">addAxis</span>(axisX, Qt::AlignBottom);</span><br><span class="line">    <span class="comment">/* 设置 x 轴范围 */</span></span><br><span class="line">    axisX-&gt;<span class="built_in">setRange</span>(<span class="number">-28000</span>, maxX);</span><br><span class="line">    <span class="comment">/* 将 splineSeries 附加于 x 轴上 */</span></span><br><span class="line">    splineSeries-&gt;<span class="built_in">attachAxis</span>(axisX);</span><br><span class="line">    <span class="comment">/* 将图表的内容设置在图表视图上 */</span></span><br><span class="line">    chartView-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line">    <span class="comment">/* 设置抗锯齿 */</span></span><br><span class="line">    chartView-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    <span class="comment">/* 设置为图表视图为中心部件 */</span></span><br><span class="line">    <span class="built_in">setCentralWidget</span>(chartView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用定时器更新数据</span></span><br><span class="line">    timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);                                                  <span class="comment">//初始化定时器</span></span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout,</span><br><span class="line">    [&amp;]()</span><br><span class="line">    &#123;</span><br><span class="line">        QVector&lt;QPointF&gt; <span class="built_in">point</span>(maxSize + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxSize + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            point[i].<span class="built_in">setX</span>(i);</span><br><span class="line">            point[i].<span class="built_in">setY</span>((<span class="type">int</span>)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">1</span>,<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        splineSeries-&gt;<span class="built_in">replace</span>(point);                                                 <span class="comment">//更新数据</span></span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标按下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)                       <span class="comment">//鼠标左键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pointUsed = event-&gt;<span class="built_in">pos</span>();                              <span class="comment">//保存当前坐标</span></span><br><span class="line">        m_isPress = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::MidButton)                    <span class="comment">//鼠标中键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        QLineSeries* l_series = (QLineSeries*)<span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">series</span>().<span class="built_in">at</span>(<span class="number">0</span>);      <span class="comment">//获取序列中的值</span></span><br><span class="line">        QVector&lt;QPointF&gt; l_vpointF = l_series-&gt;<span class="built_in">pointsVector</span>();</span><br><span class="line">        QPointF l_curVal = <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">mapToValue</span>(event-&gt;<span class="built_in">pos</span>());               <span class="comment">//返回鼠标处的值</span></span><br><span class="line">        QPointF l_pointF = l_vpointF.<span class="built_in">at</span>(<span class="built_in">qRound</span>(l_curVal.<span class="built_in">x</span>()));                    <span class="comment">//获取离鼠标的横坐标最近的点</span></span><br><span class="line"></span><br><span class="line">        QString l_strPos = <span class="built_in">QString</span>(<span class="string">&quot;x：%0 y：%1&quot;</span>).<span class="built_in">arg</span>(l_pointF.<span class="built_in">x</span>()).<span class="built_in">arg</span>(l_pointF.<span class="built_in">y</span>());</span><br><span class="line">        QString l_stStyle = <span class="string">&quot;&lt;p style=\&quot;background:#00FFFF; border-radius: 1px 5px;font:12pt &#x27;宋体&#x27;\&quot;&gt;%1&lt;/p&gt;&quot;</span>;</span><br><span class="line">        QToolTip::<span class="built_in">showText</span>(<span class="built_in">cursor</span>().<span class="built_in">pos</span>(), l_stStyle.<span class="built_in">arg</span>(l_strPos), <span class="keyword">this</span>, <span class="built_in">QRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>), <span class="number">10000</span>); <span class="comment">//在点击位置显示提示信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标双击</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::RightButton)                        <span class="comment">//鼠标右键双击恢复最初大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Horizontal).<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">setRange</span>(m_dMinX, m_dMaxX);</span><br><span class="line">        <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Vertical).<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">setRange</span>(m_dMinY, m_dMaxY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_isPress)</span><br><span class="line">    &#123;</span><br><span class="line">        QPoint l_pointDiff = event-&gt;<span class="built_in">pos</span>() - m_pointUsed;              <span class="comment">//当前坐标与按下鼠标处的坐标差</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">scroll</span>(-l_pointDiff.<span class="built_in">x</span>(), l_pointDiff.<span class="built_in">y</span>());     <span class="comment">//移动图表</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_pointUsed = event-&gt;<span class="built_in">pos</span>();                                       <span class="comment">//保存当前坐标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isPress = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标滚轮缩放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::wheelEvent</span><span class="params">(QWheelEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPointF l_curVal = <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">mapToValue</span>(event-&gt;<span class="built_in">pos</span>());               <span class="comment">//返回鼠标处的值</span></span><br><span class="line"></span><br><span class="line">    QValueAxis *l_axisX = (QValueAxis*)<span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Horizontal).<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">double</span> l_fMinX = l_axisX-&gt;<span class="built_in">min</span>();</span><br><span class="line">    <span class="type">double</span> l_fMaxX = l_axisX-&gt;<span class="built_in">max</span>();</span><br><span class="line">    QValueAxis *l_axisY = (QValueAxis*)<span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Vertical).<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">double</span> l_fMinY = l_axisY-&gt;<span class="built_in">min</span>();</span><br><span class="line">    <span class="type">double</span> l_fMaxY = l_axisY-&gt;<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> l_fZoomMinX,l_fZoomMaxX,l_fZoomMinY,l_fZoomMaxY;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">delta</span>() &gt; <span class="number">0</span>)                                                   <span class="comment">//获取放大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        l_fZoomMinX = l_curVal.<span class="built_in">x</span>() - (l_curVal.<span class="built_in">x</span>() - l_fMinX) / <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMaxX = l_curVal.<span class="built_in">x</span>() + (l_fMaxX - l_curVal.<span class="built_in">x</span>()) / <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMinY = l_curVal.<span class="built_in">y</span>() - (l_curVal.<span class="built_in">y</span>() - l_fMinY) / <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMaxY = l_curVal.<span class="built_in">y</span>() + (l_fMaxY - l_curVal.<span class="built_in">y</span>()) / <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                                     <span class="comment">//获取缩小值</span></span><br><span class="line">    &#123;</span><br><span class="line">        l_fZoomMinX = l_curVal.<span class="built_in">x</span>() - (l_curVal.<span class="built_in">x</span>() - l_fMinX) * <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMaxX = l_curVal.<span class="built_in">x</span>() + (l_fMaxX - l_curVal.<span class="built_in">x</span>()) * <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMinY = l_curVal.<span class="built_in">y</span>() - (l_curVal.<span class="built_in">y</span>() - l_fMinY) * <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMaxY = l_curVal.<span class="built_in">y</span>() + (l_fMaxY - l_curVal.<span class="built_in">y</span>()) * <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Vertical).<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">setRange</span>(l_fZoomMinY, l_fZoomMaxY);   <span class="comment">//设置轴范围</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Horizontal).<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">setRange</span>(l_fZoomMinX, l_fZoomMaxX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt容器</title>
      <link href="/2023/09/11/2023-9-10-qt%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/09/11/2023-9-10-qt%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>各个控件的名称依次解释如下。<br>（1） Group Box:组框</p><p>QGroupBox 为构建分组框提供了支持。分组框通常带有一个边<br>框和一个标题栏，作为容器部件来使用，在其中可以布置各种窗口部件。布局时可用作一组控<br>件的容器，但是需要注意的是，内部通常使用布局控件（如 QBoxLayout）进行布局。 </p><p>（2） Scroll Area:滚动区域</p><p>滚动区域用于在框架中显示子部件的内容。如果小<br>部件超过框架的大小，视图就会出现滚动条，以便可以查看子小部件的整个区域。 </p><p>（3） Tool Box:工具箱</p><p>QToolBox 类提供了一列选项卡小部件项。工具箱是一个小部件，<br>它显示一列选项卡在另一列的上面，当前项显示在当前选项卡的下面。 </p><p>（4） Tab Widget:标签小部件</p><p>abWidget 类提供了一组选项卡（多页面）小部件。 QTabWidget<br>主要是用来分页显示的，每一页一个界面，众多界面公用一块区域，节省了界面大小，很方便<br>的为用户显示更多的信息。 </p><p>（5） Stacked WIdget:堆叠小部件</p><p>QStackedWidget 类提供了一个小部件堆栈，其中一次只能<br>看到一个小部件，与 QQ 的设置面板类似。 QStackedWidget 可用于创建类似于 QTabWidget 提<br>供的用户界面。它是构建在 QStackedLayout 类之上的一个方便的布局小部件。 </p><p>（6） Frame:帧<br>（7） Widget:小部件<br>（8） MDI Area:MDI 区域<br>（9） Dock Widget:停靠窗体部件 </p><p>Qt提供了多个基于模板 的容器类，这些容器类可以用于存储指定类型的数据项，容器类是基于模板的类，如常用的容器类QList<T>, T是一个具体的类型，可以是int、float等简单类型，也可以是QString、QDate 等类，但不能是QObject或任何其子类。 T 必须是一个可赋值的类型，即T 必须提供一个缺省的构造函数，一个可复制构造函数和–个赋值运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt;list; //定义一个字符串列表</span><br></pre></td></tr></table></figure><p>Qt的容器类分为有序容器( sequential containers) 和关联容器( associative containers)</p><p>Qt的有序容器类有QList、QLinkedList、 QVector、 QStack 和QQueue。</p><p>Qt 还提供关联容器类QMap、QMultiMap、QHash、 QMultiHash 和QSet。</p><p>QTabWidget 继承 QWidget， QTabWidget 类提供了一组选项卡（多页面）小部件。 QTabWidget 主要是用来分页显示的，每一页一个界面，众多界面公用一块区域，节省了界面大小，很方便的为用户显示更多的信息。类似浏览器的多标签页面，所以这个控件在实际项目中也会经常用到 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget *widget;</span><br><span class="line">    QTabWidget *tabWidget;</span><br><span class="line">    QHBoxLayout *hBoxLayout;</span><br><span class="line">    QLabel *label[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(widget);</span><br><span class="line">    tabWidget = <span class="keyword">new</span> <span class="built_in">QTabWidget</span>();</span><br><span class="line">    hBoxLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    QList&lt;QString&gt;strLabelList;</span><br><span class="line">    strLabelList&lt;&lt;<span class="string">&quot;标签1&quot;</span>&lt;&lt;<span class="string">&quot;标签2&quot;</span>&lt;&lt;<span class="string">&quot;标签3&quot;</span>;</span><br><span class="line">    QList&lt;QString&gt;strTabList;</span><br><span class="line">    strTabList&lt;&lt;<span class="string">&quot;页面1&quot;</span>&lt;&lt;<span class="string">&quot;页面2&quot;</span>&lt;&lt;<span class="string">&quot;页面3&quot;</span>;</span><br><span class="line">    QList &lt;QString&gt;iconList;</span><br><span class="line">    iconList&lt;&lt;<span class="string">&quot;:/icons/icon1&quot;</span>&lt;&lt;<span class="string">&quot;:/icons/icon2&quot;</span>&lt;&lt;<span class="string">&quot;:/icons/icon3&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        label[i] = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">        label[i] -&gt;<span class="built_in">setText</span>(strLabelList[i]);</span><br><span class="line">        label[i] -&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">        tabWidget -&gt; <span class="built_in">addTab</span>(label[i], <span class="built_in">QIcon</span>(iconList[i]), strTabList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    hBoxLayout-&gt;<span class="built_in">addWidget</span>(tabWidget);</span><br><span class="line">    widget-&gt;<span class="built_in">setLayout</span>(hBoxLayout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-10%20151408.png"></p><p>QstackedWidget</p><p>QStackedWidget 继承 QFrame。 QStackedWidget 类提供了一个小部件堆栈，其中一次只能看到一个小部件，与 QQ 的设置面板类似。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStackedWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QListWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget  *widget;</span><br><span class="line">    QHBoxLayout *hBoxLayout;</span><br><span class="line">    QListWidget *listWidget;</span><br><span class="line">    QStackedWidget *stackedWidget;</span><br><span class="line">    QLabel *label[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(widget);</span><br><span class="line">    hBoxLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    stackedWidget = <span class="keyword">new</span> <span class="built_in">QStackedWidget</span>();</span><br><span class="line">    listWidget = <span class="keyword">new</span> <span class="built_in">QListWidget</span>();</span><br><span class="line"></span><br><span class="line">    QList &lt;QString&gt;strListWidgetList;</span><br><span class="line">    strListWidgetList&lt;&lt;<span class="string">&quot;窗口一&quot;</span>&lt;&lt;<span class="string">&quot;窗口二&quot;</span>&lt;&lt;<span class="string">&quot;窗口三&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        listWidget -&gt; <span class="built_in">insertItem</span>(i, strListWidgetList[i] );</span><br><span class="line">    &#125;</span><br><span class="line">    QList&lt;QString&gt;strLabelList;</span><br><span class="line">    strLabelList&lt;&lt;<span class="string">&quot;标签一&quot;</span>&lt;&lt;<span class="string">&quot;标签二&quot;</span>&lt;&lt;<span class="string">&quot;标签三&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        label[i] = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">        label[i] -&gt;<span class="built_in">setText</span>(strLabelList[i]);</span><br><span class="line">        label[i] -&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">        stackedWidget-&gt;<span class="built_in">addWidget</span>(label[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    listWidget-&gt;<span class="built_in">setMaximumWidth</span>(<span class="number">200</span>);</span><br><span class="line">    hBoxLayout-&gt;<span class="built_in">addWidget</span>(listWidget);</span><br><span class="line">    hBoxLayout-&gt;<span class="built_in">addWidget</span>(stackedWidget);</span><br><span class="line">    widget-&gt;<span class="built_in">setLayout</span>(hBoxLayout);</span><br><span class="line">    <span class="built_in">connect</span>(listWidget, <span class="built_in">SIGNAL</span>(<span class="built_in">currentRowChanged</span>(<span class="type">int</span>)),stackedWidget, <span class="built_in">SLOT</span>(<span class="built_in">setCurrentIndex</span>(<span class="type">int</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-10%20164258.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>界面跳转设计</title>
      <link href="/2023/09/11/2023-9-11-%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/09/11/2023-9-11-%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="Qt中的lambda表达式"><a href="#Qt中的lambda表达式" class="headerlink" title="Qt中的lambda表达式"></a>Qt中的lambda表达式</h3><p>跳转界面前先学习一个知识点是lambda表达式。</p><p><strong>Lambda</strong>我们可以将其理解为一个未命名的<a href="https://so.csdn.net/so/search?q=%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">内联函数</a>。<br>与任何函数类似，一个<a href="https://so.csdn.net/so/search?q=lambda&spm=1001.2101.3001.7020">lambda</a>具有一个返回类型，一个参数列表和一个函数体。但与函数不同,lambda可能定义在函数内部。<br>一个lambda表达式具有如下形式：<br><strong>[capture list] (parameter list) -&gt;return type {function body}</strong><br><strong>capture list: 捕获列表，是一个lambda所在函数中定义的局部变量列表（通常为空）</strong><br><strong>parameter list:参数列表</strong><br><strong>return type:返回类型</strong><br><strong>function body:函数体</strong><br><strong>但是与普通函数不同，lambda必须使用尾置返回来指定返回类型</strong><br><strong>我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">QPushButton *pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;开关&quot;</span>， <span class="keyword">this</span>);</span><br><span class="line">pushButton -&gt; <span class="built_in">setGeometry</span>( <span class="number">200</span>, <span class="number">100</span>, <span class="number">40</span> ,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">connect</span>( pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果就是可以点击开关就可以关闭界面。</p><h3 id="设计界面（画图）"><a href="#设计界面（画图）" class="headerlink" title="设计界面（画图）"></a>设计界面（画图）</h3><h4 id="添加资源文件"><a href="#添加资源文件" class="headerlink" title="添加资源文件"></a>添加资源文件</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20155808.png"></p><p>添加一个界面的ui图片。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20155853.png"></p><p>之后还是添加一个文件，这个文件是作为一个下一个界面的文件。要勾选QMainWindow作为基类。<img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20160251.png"></p><p>进行绘图</p><p>在mypage.cpp中编写界面大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mypage.h&quot;</span></span></span><br><span class="line">mypage::<span class="built_in">mypage</span>(QWidget *parent) : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1080</span>, <span class="number">900</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mainwindow.h中添加绘图的函数，因为在MainWindow的构造函数只运行一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPaintEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QPushButton *pushButton;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mainwindow.cpp文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mypage.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>( <span class="number">800</span>, <span class="number">480</span> );</span><br><span class="line">    QPushButton *pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;jump&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    pushButton-&gt;<span class="built_in">setGeometry</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">40</span>, <span class="number">30</span>);</span><br><span class="line">    mypage *scene = <span class="keyword">new</span> mypage;</span><br><span class="line">    <span class="built_in">connect</span>(pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>,[=]()&#123; <span class="comment">//跳转界面</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">        scene-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::paintEvent</span><span class="params">(QPaintEvent *)</span><span class="comment">//ui主界面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/ig.png&quot;</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>(), pixmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击完界面的按钮就能进入下一个界面。</p><p>从新界面点击按钮在返回主界面。</p><p>在mypage.h文件中加入信号，这个信号是为了在次界面点击按钮时候来激发信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signals:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">returnpage</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>修改mypage.cpp文件，加入按钮，并连接槽函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mypage.h&quot;</span></span></span><br><span class="line">mypage::<span class="built_in">mypage</span>(QWidget *parent) : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    pushButton1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;返回&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    pushButton1 -&gt; <span class="built_in">setGeometry</span>( <span class="number">400</span>, <span class="number">300</span>, <span class="number">40</span> ,<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">connect</span>(pushButton1, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">chooseBack</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回修改mainwindow.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mypage.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>( <span class="number">800</span>, <span class="number">480</span> );</span><br><span class="line">    QPushButton *pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;jump&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    pushButton-&gt;<span class="built_in">setGeometry</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">40</span>, <span class="number">30</span>);</span><br><span class="line">    mypage *scene = <span class="keyword">new</span> mypage;</span><br><span class="line">    <span class="built_in">connect</span>(pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">        scene-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(scene, &amp;mypage::chooseBack, <span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        scene-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::paintEvent</span><span class="params">(QPaintEvent *)</span><span class="comment">//ui主界面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/ig.png&quot;</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>(), pixmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20164756.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20164820.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt控件③</title>
      <link href="/2023/09/09/2023-9-9-qt%E6%8E%A7%E4%BB%B63/"/>
      <url>/2023/09/09/2023-9-9-qt%E6%8E%A7%E4%BB%B63/</url>
      
        <content type="html"><![CDATA[<p>QLabel控件</p><p>用来设计UI界面，给界面添加图片。右键项目名称来添加资源文件，选择Add New。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20131129.png"></p><p>填上资源文件的名称（可随意写一个），默认添加项目路径下。后面的步骤默认即可，点击完成。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20131307.png"></p><p>添加 qss 文件。 QSS 文件是使用 Qt 程序相关联的样式表文件。它由 GUI 元素的外观和感觉，包括布局，颜色，鼠标的行为，大小和字体。它的风格，一个可以合并到一个 UI（用户界面）。 与 HTML 的 CSS 类似， Qt 的样式表是纯文本的格式定义，在应用程序运行时可以载入和解析这些样式定义，从而使应用程序的界面呈现不同的效果。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20131456.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel *labelString;</span><br><span class="line">    QLabel *labelImage;</span><br><span class="line">    QPushButton *pushButton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushButtoncheckedchanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/ig.png&quot;</span>)</span></span>;</span><br><span class="line">    labelImage = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    labelImage -&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span> , <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    labelImage -&gt;<span class="built_in">setPixmap</span>(pixmap);</span><br><span class="line">    labelImage-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line">    labelString = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    labelString -&gt;<span class="built_in">setText</span>(<span class="string">&quot;标签演示文本&quot;</span>);</span><br><span class="line">    labelString -&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">    pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;关闭窗口&quot;</span> ,<span class="keyword">this</span>);</span><br><span class="line">    pushButton-&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>,<span class="number">200</span>,<span class="number">80</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButtoncheckedchanged</span>()));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtoncheckedchanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20131652.png"></p><p>QDateEdit和QDateTimeEdit控件</p><p>QDateTimeEdit类提供一个用于编辑日期和时间的小部件，QDateTImeEdit允许用户使用键盘或箭头编辑日期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTimeEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimeEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateEdit&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QDateTimeEdit *dateTimeEdit;</span><br><span class="line">    QTimeEdit *timeEdit;</span><br><span class="line">    QDateEdit *dateEdit;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    dateTimeEdit = <span class="keyword">new</span> <span class="built_in">QDateTimeEdit</span>(QDateTime::<span class="built_in">currentDateTime</span>(), <span class="keyword">this</span>);</span><br><span class="line">    dateTimeEdit -&gt; <span class="built_in">setGeometry</span>( <span class="number">300</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">    timeEdit = <span class="keyword">new</span> <span class="built_in">QTimeEdit</span>(QTime :: <span class="built_in">currentTime</span>(), <span class="keyword">this</span>);</span><br><span class="line">    timeEdit -&gt;<span class="built_in">setGeometry</span>( <span class="number">300</span>, <span class="number">240</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">    dateEdit = <span class="keyword">new</span> <span class="built_in">QDateEdit</span>(QDate::<span class="built_in">currentDate</span>(), <span class="keyword">this</span>);</span><br><span class="line">    dateEdit -&gt;<span class="built_in">setGeometry</span>( <span class="number">300</span>, <span class="number">280</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20132644.png"></p><p>QProgressBar控件</p><p>QProgressBar 继承 QWidget。 QProgressBar 小部件提供了一个水平或垂直的进度条。进度条用于向用户显示操作的进度，并向他们确认应用程序仍在运行。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProgressBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 声明对象 */</span></span><br><span class="line">QProgressBar *progressBar;</span><br><span class="line">QTimer *timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于设置当前 QProgressBar 的值 */</span></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="comment">/* 槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timerTimeOut</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置主窗体位置与大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">progressBar = <span class="keyword">new</span> <span class="built_in">QProgressBar</span>(<span class="keyword">this</span>);</span><br><span class="line">progressBar-&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">60</span>);</span><br><span class="line"><span class="comment">/*样式表设置，常用使用 setStyleSheet 来设置样式（实现界面美化的功能）， * 具体可参考 styleSheet */</span></span><br><span class="line">progressBar-&gt;<span class="built_in">setStyleSheet</span> (</span><br><span class="line"> <span class="string">&quot;QProgressBar&#123;border:8px solid #FFFFFF;&quot;</span></span><br><span class="line"><span class="string">&quot;height:30;&quot;</span></span><br><span class="line"><span class="string">&quot;border-image:url(:/images/battery.png);&quot;</span> <span class="comment">//背景图片</span></span><br><span class="line"><span class="string">&quot;text-align:center;&quot;</span> <span class="comment">// 文字居中</span></span><br><span class="line"><span class="string">&quot;color:rgb(255,0,255);&quot;</span></span><br><span class="line"><span class="string">&quot;font:20px;&quot;</span> <span class="comment">// 字体大小为 20px</span></span><br><span class="line"><span class="string">&quot;border-radius:10px;&#125;&quot;</span></span><br><span class="line"><span class="string">&quot;QProgressBar::chunk&#123;&quot;</span></span><br><span class="line"><span class="string">&quot;border-radius:5px;&quot;</span> <span class="comment">// 斑马线圆角</span></span><br><span class="line"><span class="string">&quot;border:1px solid black;&quot;</span> <span class="comment">// 黑边，默认无边</span></span><br><span class="line"><span class="string">&quot;background-color:skyblue;&quot;</span></span><br><span class="line"><span class="string">&quot;width:10px;margin:1px;&#125;&quot;</span> <span class="comment">// 宽度和间距</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">/* 设置 progressBar 的范围值 */</span></span><br><span class="line">progressBar-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">/* 初始化 value 为 0 */</span></span><br><span class="line">value = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 给 progressBar 设置当前值 */</span></span><br><span class="line">progressBar-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line"><span class="comment">/* 设置当前文本字符串的显示格式 */</span></span><br><span class="line">progressBar-&gt;<span class="built_in">setFormat</span>(<span class="string">&quot;充电中%p%&quot;</span>);</span><br><span class="line"><span class="comment">/* 定时器实例化设置每 100ms 发送一个 timeout 信号 */</span></span><br><span class="line">timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">/* 信号槽连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">timerTimeOut</span>()));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::timerTimeOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 定显示器时间到， value 值自加一 */</span></span><br><span class="line">value ++;</span><br><span class="line">progressBar-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line"><span class="comment">/* 若 value 值大于 100，令 value 再回到 0 */</span></span><br><span class="line"><span class="keyword">if</span>(value&gt;<span class="number">100</span>)</span><br><span class="line">value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QFrame类</p><p>QFrame 继承 QWidget。 QFrame 类是有框架的窗口部件的基类，它绘制框架并且调用一个虚函数 drawContents()来填充这个框架。这个函数是被子类重新实现的。这里至少还有两个有用的函数： drawFrame()和 frameChanged()。</p><p>QPopupMenu 使用这个来把菜单“升高”，高于周围屏幕。 QProgressBar 有“凹陷”的外观。QLabel 有平坦的外观。这些有框架的窗口部件可以被改变。</p><blockquote><p>QFrame::Shape 这个枚举类型定义了 QFrame 的框架所使用的外形。当前定义的效果有：<br>NoFrame - QFrame 不画任何东西<br>Box - QFrame 在它的内容周围画一个框<br>Panel - QFrame 画一个平板使内容看起来凸起或者凹陷<br>WinPanel - 像 Panel，但 QFrame 绘制三维效果的方式和 Microsoft Windows 95（及其它）的一样<br>ToolBarPanel - QFrame 调用 QStyle::drawToolBarPanel()<br>MenuBarPanel - QFrame 调用 QStyle::drawMenuBarPanel()<br>HLine - QFrame 绘制一个水平线，但没有框任何东西（作为分隔是有用的）<br>VLine - QFrame 绘制一个竖直线，但没有框任何东西（作为分隔是有用的）<br>StyledPanel - QFrame 调用 QStyle::drawPanel()<br>PopupPanel - QFrame 调用 QStyle::drawPopupPanel()<br>阴影风格有：<br>Plain 使用调色板的前景颜色绘制（没有任何三维效果）。<br>Raised 使用当前颜色组的亮和暗颜色绘制三维的凸起线。<br>Sunken 使用当前颜色组的亮和暗颜色绘制三维的凹陷线。 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFrame&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 声明对象 */</span></span><br><span class="line">QFrame *hline;</span><br><span class="line">QFrame *vline;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置主窗体的显示位置与大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"><span class="comment">/* 实例化 */</span></span><br><span class="line">hline = <span class="keyword">new</span> <span class="built_in">QFrame</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/* 确定起始点，设置长和宽，绘制距形 */</span></span><br><span class="line">hline-&gt;<span class="built_in">setGeometry</span>(<span class="built_in">QRect</span>(<span class="number">200</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">40</span>));</span><br><span class="line"><span class="comment">/* 设置框架样式为 Hline，水平，可设置为其他样式例如 Box，</span></span><br><span class="line"><span class="comment">* 由于是样式选择 HLine，所以只显示一条水平直线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">hline-&gt;<span class="built_in">setFrameShape</span>(QFrame::HLine);</span><br><span class="line"><span class="comment">/* 绘制阴影 */</span></span><br><span class="line">hline-&gt;<span class="built_in">setFrameShadow</span>(QFrame::Sunken);</span><br><span class="line"><span class="comment">/* 实例化 */</span></span><br><span class="line">vline = <span class="keyword">new</span> <span class="built_in">QFrame</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/* 确定起始点，设置长和宽，绘制距形 */</span></span><br><span class="line">vline-&gt;<span class="built_in">setGeometry</span>(<span class="built_in">QRect</span>(<span class="number">300</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">200</span>));</span><br><span class="line"><span class="comment">/* 设置框架样式为 Vline，垂直，可设置为其他样式例如 Box，</span></span><br><span class="line"><span class="comment">* 由于是样式选择 Vline，所以只显示一条垂直直线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vline-&gt;<span class="built_in">setFrameShape</span>(QFrame::VLine);</span><br><span class="line"><span class="comment">/* 绘制阴影 */</span></span><br><span class="line">vline-&gt;<span class="built_in">setFrameShadow</span>(QFrame::Sunken);</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20134737.png"></p><p>QBoxLayout类</p><p>QBoxLayout 继承 QLayout。 QBoxLayout 类提供水平或垂直地排列子部件。 QBoxLayout 获取从它的父布局或从 parentWidget()中所获得的空间，将其分成一列框，并使每个托管小部件填充一个框。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPushButton *pushButton[<span class="number">6</span>];</span><br><span class="line">    QWidget *hWidget;</span><br><span class="line">    QWidget *vWidget;</span><br><span class="line">    QHBoxLayout *hLayout; </span><br><span class="line">    QVBoxLayout *vLayout;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span> , <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    hWidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    hWidget -&gt; <span class="built_in">setGeometry</span>( <span class="number">0</span> , <span class="number">0</span>, <span class="number">800</span>, <span class="number">240</span>);</span><br><span class="line">    vWidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    vWidget -&gt; <span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">240</span>, <span class="number">800</span>, <span class="number">240</span>);</span><br><span class="line">    hLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    vLayout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">    QList&lt;QString&gt;list; <span class="comment">//list放入字符串</span></span><br><span class="line">    list&lt;&lt;<span class="string">&quot;one&quot;</span>&lt;&lt;<span class="string">&quot;two&quot;</span>&lt;&lt;<span class="string">&quot;three&quot;</span>&lt;&lt;<span class="string">&quot;four&quot;</span>&lt;&lt;<span class="string">&quot;five&quot;</span>&lt;&lt;<span class="string">&quot;six&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pushButton[i] = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">        pushButton[i]-&gt;<span class="built_in">setText</span>(list[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            hLayout-&gt;<span class="built_in">addWidget</span>(pushButton[i]);<span class="comment">//水平放置按钮</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vLayout-&gt;<span class="built_in">addWidget</span>(pushButton[i]);<span class="comment">//垂直放置按钮</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hLayout-&gt;<span class="built_in">setSpacing</span>(<span class="number">50</span>);<span class="comment">//间隔</span></span><br><span class="line">    hWidget-&gt;<span class="built_in">setLayout</span>(hLayout);</span><br><span class="line">    vWidget-&gt;<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20150844.png"></p><p>QFormLayout布局</p><p>QFormLayout 继承 QLayout。 QFormLayout 类管理输入小部件及其关联标签的表单。 QFormLayout 是一个方便的布局类，它以两列的形式布局其子类。左列由标签组成，右列由“字段”小部件(QLineEdit(行编辑器)、 QSpinBox(旋转框等))组成。 </p><p>可以用来规划用户密码登录的界面布局。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFormLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget *fwidget;</span><br><span class="line">    QLineEdit *userLineEdit;</span><br><span class="line">    QLineEdit *passwordLineEdit;</span><br><span class="line">    QFormLayout *formLayout;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    fwidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    fwidget -&gt;<span class="built_in">setGeometry</span>( <span class="number">250</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">200</span> );</span><br><span class="line">    userLineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">    passwordLineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">    formLayout = <span class="keyword">new</span> <span class="built_in">QFormLayout</span>();</span><br><span class="line">    formLayout -&gt;<span class="built_in">addRow</span>(<span class="string">&quot;用户名&quot;</span>,userLineEdit);</span><br><span class="line">    formLayout -&gt;<span class="built_in">addRow</span>(<span class="string">&quot;密码&quot;</span>, passwordLineEdit);</span><br><span class="line">    formLayout-&gt;<span class="built_in">setSpacing</span>(<span class="number">10</span>); <span class="comment">//水平垂直间距</span></span><br><span class="line">    formLayout-&gt;<span class="built_in">setMargin</span>(<span class="number">20</span>); <span class="comment">//布局外框宽度</span></span><br><span class="line">    fwidget-&gt;<span class="built_in">setLayout</span>(formLayout);<span class="comment">//将formLayout布局到fwidget里</span></span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20154712.png"></p><p>QSpacerItem<br>QSpacerItem 继承 QLayoutItem。 QSpacerItem 类在布局中提供空白(空间间隔)。所以 QSpacerItem 是在布局中使用的。 </p><p>可以用来布局一些按钮图标之类的。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20155105.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent  = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QPushButton *bt[<span class="number">4</span>];</span><br><span class="line">QSpacerItem *vSpacer; <span class="comment">//垂直间隔</span></span><br><span class="line">QSpacerItem *hSpacer;<span class="comment">//水平间隔</span></span><br><span class="line">QWidget *widget;<span class="comment">//声明一个weidget来放布局</span></span><br><span class="line">QHBoxLayout *mainLayout;<span class="comment">//主布局</span></span><br><span class="line">QVBoxLayout *vBoxLayout;<span class="comment">//垂直布局</span></span><br><span class="line">QHBxoLayout *hBoxLayout;<span class="comment">//水平布局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">:<span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    </span><br><span class="line">    widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(widget);</span><br><span class="line">    vSpacer = <span class="keyword">new</span> <span class="built_in">QSpacerItem</span>( <span class="number">10</span> , <span class="number">10</span>, QSizePolicy::Minimum, QSizePolicy::Expanding);</span><br><span class="line">    hSpacer = <span class="keyword">new</span> <span class="built_in">QSpacerItem</span>( <span class="number">10</span> , <span class="number">10</span>, QSizePolicy::Expanding, QSizePolicy :: Minimum);</span><br><span class="line">    </span><br><span class="line">    vBoxLayout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">    hBxoLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    mainLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    </span><br><span class="line">    vBoxLayout-&gt;<span class="built_in">addSpacerItem</span>(vSpacer);<span class="comment">//vBoxLayout添加垂直间隔</span></span><br><span class="line">    QList &lt;QString&gt;list;<span class="comment">//字符串插入list</span></span><br><span class="line">    </span><br><span class="line">    list &lt;&lt; <span class="string">&quot;按钮1&quot;</span>&lt;&lt; <span class="string">&quot; 按钮2&quot;</span>&lt;&lt; <span class="string">&quot;按钮3&quot;</span>&lt;&lt; <span class="string">&quot;按钮4&quot;</span>；</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//实例化按钮</span></span><br><span class="line">    &#123;</span><br><span class="line">        bt[i] = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">        bt[i] = <span class="built_in">setText</span>(list[i]);</span><br><span class="line">        bt[i] -&gt;<span class="built_in">setFixedSize</span>( <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">        hBoxLayout-&gt;<span class="built_in">addWidget</span>(bt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    hBoxLayout-&gt;<span class="built_in">addSpacerItem</span>(hSpacer);<span class="comment">//hBoxLayout加入水平间隔</span></span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(vBoxLayout); <span class="comment">//主布局里加入垂直间隔</span></span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(hBoxLayout); <span class="comment">//主布局里加入水平间隔</span></span><br><span class="line">    mainLayout-&gt;<span class="built_in">setSpacing</span>(<span class="number">50</span>);<span class="comment">//设置部件间距</span></span><br><span class="line">    widget-&gt;<span class="built_in">setLayout</span>(mainLayout);<span class="comment">//主布局为widget布局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpinBox，DoubleSpinBox控件（数值调整控件）</p><p>数字显示框，显示整型和浮点型的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDoubleSpinbox&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QDoubleSpinBox *doubleSpinBox;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">:<span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    doubleSpinBox = <span class="keyword">new</span> <span class="built_in">QDoubleSpinBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    doubleSpinBox -&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">/* 设置前缀 */</span></span><br><span class="line">doubleSpinBox-&gt;<span class="built_in">setPrefix</span>(<span class="string">&quot;激光功率&quot;</span>);</span><br><span class="line"><span class="comment">/* 设置后缀 */</span></span><br><span class="line">doubleSpinBox-&gt;<span class="built_in">setSuffix</span>(<span class="string">&quot;%&quot;</span>);</span><br><span class="line">    <span class="comment">/* 设置范围 */</span></span><br><span class="line">doubleSpinBox-&gt;<span class="built_in">setRange</span>(<span class="number">00.00</span>, <span class="number">100.00</span>);</span><br><span class="line"><span class="comment">/* 设置初始值 */</span></span><br><span class="line">doubleSpinBox-&gt;<span class="built_in">setValue</span>(<span class="number">20.00</span>);</span><br><span class="line"><span class="comment">/* 设置步长 */</span></span><br><span class="line">doubleSpinBox-&gt;<span class="built_in">setSingleStep</span>(<span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt控件②</title>
      <link href="/2023/09/06/2023-9-7-qt%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%8E%A7%E4%BB%B62/"/>
      <url>/2023/09/06/2023-9-7-qt%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%8E%A7%E4%BB%B62/</url>
      
        <content type="html"><![CDATA[<p>以下qt控件的学习记录是做毕设应该是需要用到的。</p><p>QPushButton控件</p><p>QPushButton是实现按钮点击的控件。在mainwindow.h文件中改写代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="comment">/* 引入 QPushButton 类 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">/* 声明一个 QPushButton 对象 pushButton1 */</span></span><br><span class="line">QPushButton *pushButton1;</span><br><span class="line"> <span class="comment">/* 声明一个 QPushButton 对象 pushButton2 */</span></span><br><span class="line">QPushButton *pushButton2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="comment">/* 声明对象 pushButton1 的槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButton1_Clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* 声明对象 pushButton2 的槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButton2_Clicked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>之后编写mainwindow.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置宽高为 800×480,位置在 0, 0。（0, 0）代表原点， Qt 默认最左上角的点为原</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化两个按钮对象，并设置其显示文本为窗口皮肤 1 和窗口皮肤 2 */</span></span><br><span class="line">pushButton1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;窗口皮肤 1&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">pushButton2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;窗口皮肤 2&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定两个 QPushButton 对象的位置 */</span></span><br><span class="line">pushButton1-&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>,<span class="number">200</span>,<span class="number">80</span>,<span class="number">40</span>);</span><br><span class="line">pushButton2-&gt;<span class="built_in">setGeometry</span>(<span class="number">400</span>,<span class="number">200</span>,<span class="number">80</span>,<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号槽连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(pushButton1, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">pushButton1_Clicked</span>()));</span><br><span class="line"><span class="built_in">connect</span>(pushButton2, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">pushButton2_Clicked</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 槽函数的实现 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButton1_Clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 设置主窗口的样式 1 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QMainWindow &#123; background-color: rgba(255, 245,238, 100%); &#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 槽函数的实现 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButton2_Clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 设置主窗口的样式 2 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QMainWindow &#123; background-color: rgba(238, 122,233, 100%); &#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QToolButton控件</p><p>工具按钮是带图标的，跟一般的按钮不一样。其实跟PushButton差不多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"> <span class="comment">/* 引入 QToolButton 类 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolButton&gt;</span></span></span><br><span class="line"> <span class="comment">/* 引入 QToolBar 类 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 声明一个 QToolButton 对象 */</span></span><br><span class="line">QToolButton *toolButton;</span><br><span class="line"><span class="comment">/* 声明一个 QToolBar 对象 */</span></span><br><span class="line">QToolBar *toolBar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p>Main window.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStyle&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置主窗体的位置和大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化 QToolBar 对象 */</span></span><br><span class="line">toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/* 设置 toolBar 的位置和大小 */</span></span><br><span class="line">toolBar-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化 QStyle 类对象，用于设置风格，调用系统类自带的图标 */</span></span><br><span class="line">QStyle *style = QApplication::<span class="built_in">style</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 Qt 自带的标准图标，可以在帮助文档里搜索 QStyle::StandardPixmap */</span></span><br><span class="line"> QIcon icon =style-&gt;<span class="built_in">standardIcon</span>(QStyle::SP_TitleBarContextHelpButton);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化 QToolButton 对象 */</span></span><br><span class="line">toolButton = <span class="keyword">new</span> <span class="built_in">QToolButton</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 设置图标 */</span></span><br><span class="line">toolButton-&gt;<span class="built_in">setIcon</span>(icon);</span><br><span class="line"><span class="comment">/* 设置要显示的文本 */</span></span><br><span class="line">toolButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;帮助&quot;</span>);</span><br><span class="line"><span class="comment">/* 调用 setToolButtonStyle()方法，设置 toolButoon 的样式，设置为文本置于图标下方 */</span></span><br><span class="line">toolButton-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonTextUnderIcon);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最后将 toolButton 添加到 ToolBar 里 */</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addWidget</span>(toolButton);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QCheckBox控件</p><p>QCheckBox 继承 QAbstractButton。三态选择框，复选按钮（复选框）与 RadioButton 的区别是选择模式，单选按钮提供多选一，复选按钮提供多选多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="comment">/* 引入 QCheckBox */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCheckBox&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 声明一个 QCheckBox 对象 */</span></span><br><span class="line">QCheckBox *checkBox;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="comment">/* 声明 QCheckBox 的槽函数，并带参数传递，用这个参数接收信号的参数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkBoxStateChanged</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>mainwindow.cpp </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*（ 主窗体设置位置和显示的大小及背景颜色 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QMainWindow &#123;background-color: rgba(100, 100,100, 100%);&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化对象 */</span></span><br><span class="line">checkBox = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 QCheckBox 位置和显示大小 */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setGeometry</span>(<span class="number">350</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">/* 初始化三态复选框的状态为 Checked */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示的文本 */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setText</span>(<span class="string">&quot;初始化为 Checked 状态&quot;</span>);</span><br><span class="line"><span class="comment">/* 开启三态模式，必须开启，否则只有两种状态，即 Checked 和 Unchecked */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setTristate</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 连接 checkBox 的信号 stateChanged(int)，与我们定义的槽</span></span><br><span class="line"><span class="comment">checkBoxStateChanged(int)连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(checkBox, <span class="built_in">SIGNAL</span>(<span class="built_in">stateChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">checkBoxStateChanged</span>(<span class="type">int</span>)));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 槽函数的实现 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::checkBoxStateChanged</span><span class="params">(<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 判断 checkBox 的 state 状态，设置 checkBox 的文本 */</span></span><br><span class="line"><span class="keyword">switch</span> (state) &#123;</span><br><span class="line"><span class="keyword">case</span> Qt::Checked:</span><br><span class="line"><span class="comment">/* 选中状态 */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Checked 状态&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Unchecked:</span><br><span class="line"><span class="comment">/* 未选中状态 */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Unchecked 状态&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::PartiallyChecked:</span><br><span class="line"><span class="comment">/* 半选状态 */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setText</span>(<span class="string">&quot;PartiallyChecked 状态&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lineEdit控件</p><p>QLineEdit 小部件是一个单行文本编辑器。行编辑允许用户使用一组有用的编辑函数输入和编辑一行纯文本。 编写输入密码的窗口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLineEdit *lineEdit;</span><br><span class="line">    QPushButton *pushButton;</span><br><span class="line">    QLabel *label1;</span><br><span class="line">    QLabel *label2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">pushButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p>mainwindow.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span> , <span class="number">0</span>, <span class="number">800</span> , <span class="number">480</span>);</span><br><span class="line">    lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">    lineEdit -&gt; <span class="built_in">setGeometry</span>( <span class="number">280</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">20</span>);</span><br><span class="line">    pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    pushButton-&gt;<span class="built_in">setGeometry</span>( <span class="number">280</span>, <span class="number">280</span>, <span class="number">100</span>, <span class="number">21</span>);</span><br><span class="line">    pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;确认&quot;</span>);</span><br><span class="line">    label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    label1 -&gt;<span class="built_in">setGeometry</span>( <span class="number">280</span>, <span class="number">240</span>, <span class="number">400</span>, <span class="number">20</span>);</span><br><span class="line">    label1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;请输入密码:&quot;</span>);</span><br><span class="line">    label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    label2 -&gt;<span class="built_in">setGeometry</span>(<span class="number">280</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButtonClicked</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str1;</span><br><span class="line">    QString str2;</span><br><span class="line">    QString str3;</span><br><span class="line">    str3 = lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">    str1 = <span class="string">&quot;你输入的内容是&quot;</span>;</span><br><span class="line">    str2 = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(QString::<span class="built_in">compare</span>(str2, str3, Qt::CaseSensitive) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        label2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;密码正确&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        label2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    str1 += lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">    label1-&gt;<span class="built_in">setText</span>(str1);</span><br><span class="line">    lineEdit-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-07%20211317.png"></p><p>QFontComboBox控件</p><p>调整字体的控件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFontComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QFontComboBox *fontComboBox;</span><br><span class="line">    QLabel *label;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fontComboBoxFontChanged</span><span class="params">(QFont)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    fontComboBox = <span class="keyword">new</span> <span class="built_in">QFontComboBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    fontComboBox -&gt;<span class="built_in">setGeometry</span>(<span class="number">280</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">    label-&gt;<span class="built_in">setGeometry</span>( <span class="number">280</span>, <span class="number">250</span>, <span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">connect</span>(fontComboBox, <span class="built_in">SIGNAL</span>(<span class="built_in">currentFontChanged</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">fontComboBoxFontChanged</span>(QFont)));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::fontComboBoxFontChanged</span><span class="params">(QFont font)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    label-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">    QString str = <span class="string">&quot;设置的字体为：&quot;</span> + fontComboBox-&gt; <span class="built_in">itemText</span>(fontComboBox-&gt;<span class="built_in">currentIndex</span>());</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-07%20211206.png">QcomboBox控件</p><p>可以使用在单位的选择上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QComboBox *comboBox;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">comboBoxIndexChanged</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    comboBox = <span class="keyword">new</span> <span class="built_in">QComboBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    comboBox -&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>, <span class="number">200</span>, <span class="number">150</span>, <span class="number">30</span>);</span><br><span class="line">    comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;cm(默认)&quot;</span>);</span><br><span class="line">    comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;mm&quot;</span>);</span><br><span class="line">    comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;dm&quot;</span>);</span><br><span class="line">    <span class="built_in">connect</span>(comboBox, <span class="built_in">SIGNAL</span>(<span class="built_in">currentIndexChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">comboBoxIndexChanged</span>(<span class="type">int</span>)));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::comboBoxIndexChanged</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 打印出选择的省份 */</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;您选择的省份是&quot;</span>&lt;&lt; comboBox-&gt;<span class="built_in">itemText</span>(index)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-07%20211109.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt控件①</title>
      <link href="/2023/09/04/2023-9-5-qt%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%8E%A7%E4%BB%B61/"/>
      <url>/2023/09/04/2023-9-5-qt%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%8E%A7%E4%BB%B61/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><h4 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h4><p>QString 提供了一个二元的“+”操作符用于组合两个字符串，<strong>并提供一个+&#x3D;操作符将一个字符串追加到另一个字符串的结尾</strong>，<strong>另一种方法QString::append()函数具有同样功能。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str1 = <span class="string">&quot;welcome&quot;</span>;</span><br><span class="line">str1 = str1 + <span class="string">&quot;to you&quot;</span>;<span class="comment">//str1 = &quot;welcome to you&quot;;</span></span><br><span class="line">QString.<span class="built_in">append</span>(<span class="string">&quot;!&quot;</span>);<span class="comment">//str = &quot;welcome to you !&quot;;</span></span><br></pre></td></tr></table></figure><p>其他组合字符串作用函数：</p><table><thead><tr><th>insert()函数</th><th>原字符串特定位置插入另一个字符串</th></tr></thead><tbody><tr><td><strong>prepend()函数</strong></td><td><strong>原字符串的开头插入另一个字符串</strong></td></tr><tr><td><strong>replace()函数</strong></td><td><strong>用指定的字符串代替另一个字符串</strong></td></tr><tr><td><strong>arg()函数</strong></td><td><strong>重载数据类型</strong></td></tr><tr><td><strong>trimmed()函数</strong></td><td><strong>移除字符串两端的空白字符</strong></td></tr><tr><td><strong>simplified()函数</strong></td><td><strong>移除字符串两端的空白字符，使用单个空格字符”“代替字符串中出现的空白字符。</strong></td></tr></tbody></table><p><strong>查询字符串数据</strong></p><p>QString::startsWith()函数判断一个字符串是否以第一个参数的字符串开头，第二个参数是是否大小写敏感。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str= <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">QString::<span class="built_in">startsWith</span>(<span class="string">&quot;hello&quot;</span>, Qt::CaseSensitive); <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure><p>同理QString::endWith是判断一个字符串是否以第一个参数的字符串结尾。</p><p>QString::contains判断一个指定字符串是否出现过。</p><p>localeAwareCompare(const QSring&amp;, const QString&amp;):静态函数比较前后两个字符串。</p><p><strong>字符串转换函数</strong></p><p>QString::toInt()函数将字符串转换为整型数值，类似的函数还有 toDouble() 、 toFloat() 、toLong() 、 toLongLong()等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString str=<span class="string">&quot;l25&quot;</span>; <span class="comment">//初始化一个 &quot;125&quot; 的字符串</span></span><br><span class="line"><span class="type">bool</span> ok;</span><br><span class="line"><span class="type">int</span> hex=str. <span class="built_in">toInt</span> (&amp;ok, <span class="number">16</span>) ; / / ok=<span class="literal">true</span>, hex=<span class="number">2</span> <span class="number">93</span></span><br><span class="line"><span class="type">int</span> dec=str.<span class="built_in">toint</span>(&amp;ok,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>第一个参数bool类型指针用于返回转换状态。成功true，失败false。第二个参数指定了转换基数，0x为16基数16，0为基数8，其他都是10;</p><p>① toAsciiO~ 返回一个 ASCII 编码的 8 位字符串。<br>② toLatinlO: 返回一个 Latin-I 0S08859-1) 编码的 8 位字符串。<br>③ toUtf80: 返回一个 UTF-8 编码的 8 位字符串 (UTF-8 是 ASCII 码的超集<br>④ toLocal8Bit0: 返回一个系统本地 (locale) 编码的 8 位字符串。 </p><h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>Qt库提供了一套通用的基于模板的容器类，可以用这些类存储指定类型的项。比如，你需要一个大小可变的QString的数组，则使用QVector<QString>。</p><p>这些容器类比STL（C++标准模板库）容器设计得更轻量、更安全并且更易于使用。如果对STL不熟悉，或者倾向于用“Qt的方式”，那么你可以使用这些类，而不去使用STL的类。</p><p>存储在 Qt 容器中的数据必须是可赋值的数据类型，也就是说，这种数据类型必须提供一个默认的构造函数（不需要参数的构造函数）、一个复制构造函数和一个赋值操作运算符。 </p><h4 id="QList-类、QLinkedList-类和-QVector-类"><a href="#QList-类、QLinkedList-类和-QVector-类" class="headerlink" title="QList 类、QLinkedList 类和 QVector 类"></a>QList 类、QLinkedList 类和 QVector 类</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-05%20154308.png"></h4><table><thead><tr><th>类</th><th>概述</th></tr></thead><tbody><tr><td>QList<T></td><td>这是目前<strong>使用最频繁的容器类</strong>，它存储了指定类型(T)的一串值，可以通过索引来获得。本质上QList是用数组实现的，从而保证基于索引的访问非常快。</td></tr><tr><td>QLinkedList<T></td><td>类似于QList，但它使用迭代器而不是整数索引来获得项。当在一个很大的list中间插入项时，它提供了更好的性能，并且它有更好的迭代器机制。</td></tr><tr><td>QVector<T></td><td>在内存中相邻的位置存储一组值，在开头或中间插入会非常慢，因为它会导致内存中很多项移动一个位置。</td></tr><tr><td>QStack<T></td><td>QVector的一个子类，提供后进先出的机制。在当前的QVector中增加了几个方法：push()、pos()、top()。</td></tr><tr><td>QQueue<T></td><td>QList的一个子类，提供了先进先出的机制，在当前的QList中增加了几个方法：enqueue()、dequeue()、head()。</td></tr><tr><td>QSet<T></td><td>单值的数学集合，能够快速查找。</td></tr><tr><td>QMap&lt;Key, T&gt;</td><td>提供了字典（关联数组）将类型Key的键对应类型T的值。通常一个键对应一个值，QMap以Key的顺序存储数据，如果顺序不重要，QHash是一个更快的选择。</td></tr><tr><td>QMultiMap&lt;Key, T&gt;</td><td>QMap的子类，提供了多值的接口，一个键对应多个值。</td></tr><tr><td>QHash&lt;Key, T&gt;</td><td>和QMap几乎有着相同的接口，但查找起来更快。QHash存储数据没有什么顺序。</td></tr><tr><td>QMultiHash&lt;Key, T&gt;</td><td>QHash的子类，提供了多值的接口。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span></span><br><span class="line"><span class="function">    QList&lt;<span class="type">int</span>&gt; list</span>;</span><br><span class="line">    list&lt;&lt;<span class="number">1</span> &lt;&lt; <span class="number">2</span>&lt;&lt; <span class="number">3</span>&lt;&lt; <span class="number">4</span>&lt;&lt; <span class="number">5</span>;</span><br><span class="line">    <span class="function">QListIterator&lt;<span class="type">int</span>&gt; <span class="title">i</span> <span class="params">(list)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(; i.<span class="built_in">hasNext</span>();)</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; i.<span class="built_in">next</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QVariant-类"><a href="#QVariant-类" class="headerlink" title="QVariant 类"></a>QVariant 类</h3><p>QVariant 类类似千 C++的联合 (union) 数据类型，它不仅能保存很多 Qt 类型的值，包括QColor 、 QBrush 、 QFont 、 QPen 、 QRect 、 QString 和 QSize 等，而且也能存放 Qt 的容器类型的值。 </p><p>新建QtWidgets Application基类选择QWidget，取消创建界面复选框。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Qdebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColor&gt;</span></span></span><br><span class="line">Widget :: <span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">:<span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">QVariant <span class="title">v</span><span class="params">(<span class="number">709</span>)</span></span>;<span class="comment">//声明了一个QVariant变量v,并初始化为整数</span></span><br><span class="line">    <span class="built_in">QDebug</span>() &lt;&lt; v.<span class="built_in">toInt</span>();<span class="comment">//调用QVariant::toInt函数将QVariant变量包含的内容换为整数并输出。</span></span><br><span class="line">    <span class="function">QVariant <span class="title">w</span><span class="params">(<span class="string">&quot;How are you ?&quot;</span>)</span></span>; <span class="comment">//声明一个QVariant变量w初始化为字符串</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; w.<span class="built_in">toString</span>();<span class="comment">//调用QVariant::toString函数将QVariant变量包含的内容换为整数并输出。</span></span><br><span class="line">    QMap&lt;QString, QVariant&gt; map;<span class="comment">//声明一个 QMap 变量 map, 使用字符串作为键， QVariant变量作为值。</span></span><br><span class="line">    map[<span class="string">&quot;int&quot;</span>] = <span class="number">709</span>;</span><br><span class="line">    map[<span class="string">&quot;int&quot;</span>J=<span class="number">709</span>;</span><br><span class="line">map[<span class="string">&quot;double&quot;</span>)=<span class="number">709.</span> <span class="number">709</span>;</span><br><span class="line">map [<span class="string">&quot;string&quot;</span>) =<span class="string">&quot;How are you! &quot;</span>;</span><br><span class="line">map[<span class="string">&quot;color&quot;</span>)=<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">qDebug</span> () &lt;&lt;map [<span class="string">&quot;int&quot;</span>]&lt;&lt; map[<span class="string">&quot;int&quot;</span>] .<span class="built_in">toint</span>();</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;map[<span class="string">&quot;double&quot;</span>]&lt;&lt; map[<span class="string">&quot;double&quot;</span>].<span class="built_in">toDouble</span>();</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;map[<span class="string">&quot;string&quot;</span>J&lt;&lt; map[<span class="string">&quot;string&quot;</span>] .<span class="built_in">toString</span>();</span><br><span class="line"><span class="built_in">qDebug</span> () &lt;&lt;map [<span class="string">&quot;color&quot;</span>]&lt;&lt; map [<span class="string">&quot;color&quot;</span>]. <span class="built_in">value</span>&lt;QColor&gt; (); <span class="comment">//在 QVariant 变量中保存了一个 QColor 对象，并使用模板 QVariant: :value()还原为 QColor, 然后输出。</span></span><br><span class="line">QStringList sl; <span class="comment">//创建一个字符串列表</span></span><br><span class="line">sl&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;<span class="string">&quot;D&quot;</span>;</span><br><span class="line"><span class="function">QVariant <span class="title">slv</span><span class="params">(sl)</span></span>; <span class="comment">//将该列表保存在一个 QVariant 变量中</span></span><br><span class="line"><span class="keyword">if</span> (slv. <span class="built_in">type</span>() ==QVariant:: StringList) <span class="comment">//QVariant: :type() 函数返回存储在 QVariant 变量中的值的数据类型。 </span></span><br><span class="line">&#123;</span><br><span class="line">QStringLis 七 list=slv.<span class="built_in">toStringList</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=O;i&lt;list.<span class="built_in">size</span>() ;++i)</span><br><span class="line"><span class="built_in">qDebug</span> ()«list. <span class="built_in">at</span> (i); / /输出列表内容    </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法及正则表达式"><a href="#算法及正则表达式" class="headerlink" title="算法及正则表达式"></a>算法及正则表达式</h3><blockquote><p>常用的算法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a0</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">-19.3</span>, b=<span class="number">9.7</span>;</span><br><span class="line">    <span class="type">double</span> c =<span class="built_in">aAbs</span>(a);</span><br><span class="line">    <span class="type">double</span> max = <span class="built_in">aMax</span>(b, c);</span><br><span class="line">    <span class="type">int</span> bn = <span class="built_in">qRound</span>(b);</span><br><span class="line">    <span class="type">int</span> cn = <span class="built_in">qRound</span>(c);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;a= &quot;</span>&lt;&lt; a;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;b= &quot;</span>&lt;&lt; b;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;c = qAbs(a)= &quot;</span> &lt;&lt; c;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;c=qAbs(a)= &quot;</span>&lt;&lt;c;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qMax(b,c)= &quot;</span>&lt;&lt;max;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bn=qRound(b)= &quot;</span>&lt;&lt;bn;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;cn=qRound(c)= &quot;</span>&lt;&lt;en;</span><br><span class="line"><span class="built_in">qSwap</span> (bn, en); </span><br><span class="line">／／调用 <span class="built_in">qDebug</span> ()函数输出所有的计算结果</span><br><span class="line"><span class="built_in">qDebug</span> () &lt;&lt;<span class="string">&quot;qSwap (l?n, en) : &quot;</span>&lt;&lt;<span class="string">&quot;bn=&quot;</span>&lt;&lt;bn&lt;&lt;<span class="string">&quot; cn=&quot;</span>&lt;&lt;cn;</span><br><span class="line"><span class="keyword">return</span> aO. <span class="built_in">exec</span>() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>正则表达式</p></blockquote><p><strong>正则表达式由表达式、量词、断言组成。</strong></p><ol><li><p>最简单的表达式是一个字符。</p></li><li><p>量词说明表达式出现的次数。</p><table><thead><tr><th>量词</th><th>含义</th><th>量词</th><th>含义</th></tr></thead><tbody><tr><td>E?</td><td>匹配0次或1次</td><td>E[n,]</td><td>至少匹配n次</td></tr><tr><td>E+</td><td>匹配1次或多次</td><td>E[,m]</td><td>最多匹配m次</td></tr><tr><td>E*</td><td>匹配0次或多次</td><td>E[n,m]</td><td>至少匹配n次，最多匹配m次</td></tr><tr><td>E[n]</td><td>匹配n次</td><td></td><td></td></tr></tbody></table></li><li><p>“^””$””\b”都是正则表达式的断言，</p></li></ol><table><thead><tr><th align="center">符号</th><th align="center">含义</th><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">表示在字符串开头进行匹配</td><td align="center">\B</td><td align="center">非单词边界</td></tr><tr><td align="center">$$</td><td align="center">表示字符串结尾进行匹配</td><td align="center">(?&#x3D;E)</td><td align="center">表示表达式后跟随E才匹配</td></tr><tr><td align="center">\b</td><td align="center">单词边界</td><td align="center">(?!E)</td><td align="center">表示表达式后不跟随E才匹配</td></tr></tbody></table><p>例如，若要只有在 using 后面是 namespace 时才匹配 using, 则可以使用 “using(?&#x3D;E\s+namespace)” </p><h3 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h3><p>QWidget 是所有 Qt GUI 界面类的基类，它接收鼠标、键盘及其他窗口事件，并在显示器上绘制自己。通过传入 QWidget 构造函数的参数（或者调用 QWidget: :setWindowFlagsQ和 QWidget::setParentO 函数）可以指定一个窗口部件的窗口标识 (window flags) 和父窗口部件。 </p><p>窗口部件的窗口标识 (window flags) 定义了窗口部件的窗口类型和窗口提示 (hint) 。窗口类型指定了窗口部件的窗口系统属性 (window-system properties), 一个窗口部件只有一个窗口类型窗口提示定义了顶层窗口的外观，一个窗口可以有多个提示（提示能够进行按位或操作）。没有父窗口部件的 Widget 对象是一个窗口，窗口通常具有一个窗口边框 (frame) 和一个标题栏。 </p><p>QMainWindow 和所有的 QDialog 对话框子类都是经常使用的窗口类型，而子窗口部件通常处在父窗口部件的内部，没有窗口边框和标题栏。 </p><p>QWidget 窗口部件的构造函数为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QWidget(QWidget *parent=O,Qt::WindowFlags f=O)</span><br></pre></td></tr></table></figure><p>参数 parent 指定了窗口部件的父窗口部件，如果 parent&#x3D;O C 默认值），则新建的窗口部件将是一个窗口；否则，新建的窗口部件是 parent 的子窗口部件 。</p><p><strong>创建窗口</strong></p><p>如果 Widget 未使用父级进行创建，则在显示时视为窗口或顶层 Widget。由于顶层 Widget没有父级对象类来确保在其不再被使用时就被删除，所以需要开发人员在应用程序中对其进行跟踪。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QWidget *window= <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line">window-&gt;<span class="built_in">resize</span>(<span class="number">320</span>, <span class="number">240</span>);</span><br><span class="line">window-&gt;<span class="built_in">show</span>();</span><br><span class="line">QPushButton *button= <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">tr</span>(<span class="string">&quot;Press me&quot;</span>), window); <span class="comment">//通过将 window 作为父级传递给其构造器来向窗口添加子 Widget:button</span></span><br><span class="line">button-&gt;<span class="built_in">move</span> (<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">button-&gt;<span class="built_in">show</span> ();</span><br></pre></td></tr></table></figure><p>使用布局<br>通常，子 Widget 是通过使用布局对象在窗口中进行排列的，而不是通过指定位置和大小进行排列的。在此，构造一个并排排列的标签和行编辑框 Widget:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="built_in">tr</span>(<span class="string">&quot;Name:&quot;</span>));</span><br><span class="line">QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">QHBoxLayout * layout<span class="string">&quot;&quot;</span> <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span> (&#125;;</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span> (label);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span> (lineEdit);</span><br><span class="line">window-&gt;<span class="built_in">setLayout</span>(layout);</span><br></pre></td></tr></table></figure><p>构造的布局对象管理通过 addWidgetO函数提供 Widget 的位置和大小。布局本身是通过调用setLayout 函数提供给窗口的。布局仅可通过其对所管理的 Widget C 或其他布局）的显示效果来展示。 </p><h4 id="输入控件"><a href="#输入控件" class="headerlink" title="输入控件"></a>输入控件</h4><p>QCheckBox是一个选项按钮，可以打开（选中）或关闭（未选中）。复选框通常用于表示应用程序中可以启用或禁用而不影响其他功能的功能。可以实现不同类型的行为。提供了多选多的选择模式。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>setText(const QString &amp;text)</td><td>设置显示文本</td></tr><tr><td>setChecked(bool)</td><td>未开启三态模式设置选中状态，默认为未选中，true为选中</td></tr><tr><td>isChecked()</td><td>判断是否选中</td></tr><tr><td>setTristate(bool y &#x3D; true)</td><td>true为开启三态模式</td></tr><tr><td>setCheckState(Qt::CheckState state)</td><td>开启三态模式后设置选中状态</td></tr></tbody></table><p>Qt::CheckState类型</p><table><thead><tr><th>类型</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Qt::Unchecked</td><td>0</td><td>未选中</td></tr><tr><td>Qt::PartiallyChecked</td><td>1</td><td>半选中</td></tr><tr><td>Qt::Checked</td><td>2</td><td>选中</td></tr></tbody></table><p>常用信号</p><table><thead><tr><th>信号</th><th>描述</th></tr></thead><tbody><tr><td>stateChanged(int)</td><td>选中状态改变触发该信号</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发板Qt环境搭建</title>
      <link href="/2023/09/01/2023-9-1-%E5%BC%80%E5%8F%91%E6%9D%BFqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/09/01/2023-9-1-%E5%BC%80%E5%8F%91%E6%9D%BFqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="搭建Qt环境"><a href="#搭建Qt环境" class="headerlink" title="搭建Qt环境"></a>搭建Qt环境</h3><p>防止因为运行qt程序导致网络中断，从而通过NFS挂载的根文件系统断联，串口中断没有反应，运行慢等情况，所以使用mfgtool进行固化系统到开发板上在进行，搭建qt。</p><h3 id="烧录文件系统"><a href="#烧录文件系统" class="headerlink" title="烧录文件系统"></a>烧录文件系统</h3><p>烧录文件系统之前有过，但是并不全面，这回进行整个系统的固化。</p><p>首先编译u-boot，编译方法跟以前一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mx6ull_alientek_emmc.sh</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20162850.png"></p><p>用到的文件是u-boot.imx。打开固化文件工具</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20163125.png"></p><p>进入文件夹中打开boot，将自己的uboot文件照着重命名后进行替换。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20163252.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20163303.png"></p><p>使用自构建的系统镜像和设备树文件进行重命名为以上的名字，来进行替换。</p><p>最后替换根文件系统，根文件系统不是替换文件，而是替换压缩包。</p><p>所以进行对根文件系统压缩。</p><p>首先我的压缩是在rootfs的外部使用的命令压缩，但是固化系统失败了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -vcjf rootfs.tar.bz2</span><br></pre></td></tr></table></figure><p>查询原因是应该变为内部打包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd rootfs</span><br><span class="line">tar -vcjf rootfs.tar.bz2 *</span><br></pre></td></tr></table></figure><p>这个*是打包所有文件包括了隐藏文件所以可能是这个问题。解决可以固化系统了。</p><p>之后打开串口软件观察，从内部emmc中进行启动。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20164227.png"></p><p>卡住了，这是因为这时的uboot是新的，一个白板，所以要进行设置命令给它，让其从emmc启动板子。分别设置bootcmd和bootargs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb; bootz 80800000 - 83000000;&#x27;</span><br><span class="line">setenv bootargs &#x27;console = tty1 console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">saveenv</span><br><span class="line">boot</span><br></pre></td></tr></table></figure><p>ok 启动成功了。因为文件系统是之前写驱动的文件系统，所以可以设置bootargs来使用屏幕</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20164515.png"></p><p>烧录之后的新系统是不支持网络的，所以在uboot中ping通网络设置，添加网络相关环境变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv ipaddr 192.168.1.102</span><br><span class="line">setenv ethaddr 00:04:9f:04:d2:35</span><br><span class="line">setenv gatewap ip 192.168.1.1</span><br><span class="line">setenv netmask 255.255.255.0</span><br><span class="line">setenv serverip 192.168.1.128</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>搭建Qt运行环境</p><p>qt使用版本为5.12.9,此版本为长期支持版本，到qt网站进行下载,之后进行压缩包的解压。这个压缩包还是编译完挺大的有7个G，提前预留好地方，不然会提示空间不够，还要重新弄，只要在虚拟机外面设置空大硬盘空间，之后使用Gparted来进行分配多余的硬盘空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf qt-everywhere-src-5.12.9.tar.xz</span><br></pre></td></tr></table></figure><p>修改qmake.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf</span><br></pre></td></tr></table></figure><p>改完后为以下文本，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># qmake configuration for building with arm-linux-gnueabi-g++</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">MAKEFILE_GENERATOR = UNIX</span></span><br><span class="line">CONFIG += incremental</span><br><span class="line">QMAKE_INCREMENTAL_STYLE = sublib</span><br><span class="line">QT_QPA_DEFAULT_PLATFORM = linuxfb</span><br><span class="line">QMAKE_CFLAGS += -O2 -march=armv7-a -mtune=cortex-a7 -mfpu=neon -mfloat-abi=hard</span><br><span class="line">QMAKE_CXXFLAGS += -O2 -march=armv7-a -mtune=cortex-a7 -mfpu=neon -mfloat-abi=hard</span><br><span class="line">include(../common/linux.conf)</span><br><span class="line">include(../common/gcc-base-unix.conf)</span><br><span class="line">include(../common/g++-unix.conf)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modifications to g++.conf</span></span><br><span class="line">QMAKE_CC = arm-linux-gnueabihf-gcc</span><br><span class="line">QMAKE_CXX = arm-linux-gnueabihf-g++</span><br><span class="line">QMAKE_LINK = arm-linux-gnueabihf-g++</span><br><span class="line">QMAKE_LINK_SHLIB = arm-linux-gnueabihf-g++</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modifications to linux.conf</span></span><br><span class="line">QMAKE_AR = arm-linux-gnueabihf-ar cqs</span><br><span class="line">QMAKE_OBJCOPY = arm-linux-gnueabihf-objcopy</span><br><span class="line">QMAKE_NM = arm-linux-gnueabihf-nm -P</span><br><span class="line">QMAKE_STRIP = arm-linux-gnueabihf-strip</span><br><span class="line">load(qt_config)</span><br></pre></td></tr></table></figure><p><strong>配置编译选项</strong></p><p>可执行文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">./configure -prefix /home/moss/linux/qt-everywhere-src-5.12.9/arm-qt \</span><br><span class="line">-opensource \</span><br><span class="line">-confirm-license \</span><br><span class="line">-release \</span><br><span class="line">-strip \</span><br><span class="line">-shared \</span><br><span class="line">-xplatform linux-arm-gnueabi-g++ \</span><br><span class="line">-optimized-qmake \</span><br><span class="line">-c++std c++11 \</span><br><span class="line">--rpath=no \</span><br><span class="line">-pch \</span><br><span class="line">-skip qt3d \</span><br><span class="line">-skip qtactiveqt \</span><br><span class="line">-skip qtandroidextras \</span><br><span class="line">-skip qtcanvas3d \</span><br><span class="line">-skip qtconnectivity \</span><br><span class="line">-skip qtdatavis3d \</span><br><span class="line">-skip qtdoc \</span><br><span class="line">-skip qtgamepad \</span><br><span class="line">-skip qtlocation \</span><br><span class="line">-skip qtmacextras \</span><br><span class="line">-skip qtnetworkauth \</span><br><span class="line">-skip qtpurchasing \</span><br><span class="line">-skip qtremoteobjects \</span><br><span class="line">-skip qtscript \</span><br><span class="line">-skip qtscxml \</span><br><span class="line">-skip qtsensors \</span><br><span class="line">-skip qtspeech \</span><br><span class="line">-skip qtsvg \</span><br><span class="line">-skip qttools \</span><br><span class="line">-skip qttranslations \</span><br><span class="line">-skip qtwayland \</span><br><span class="line">-skip qtwebengine \</span><br><span class="line">-skip qtwebview \</span><br><span class="line">-skip qtwinextras \</span><br><span class="line">-skip qtx11extras \</span><br><span class="line">-skip qtxmlpatterns \</span><br><span class="line">-make libs \</span><br><span class="line">-make examples \</span><br><span class="line">-nomake tools -nomake tests \</span><br><span class="line">-gui \</span><br><span class="line">-widgets \</span><br><span class="line">-dbus-runtime \</span><br><span class="line">--glib=no \</span><br><span class="line">--iconv=no \</span><br><span class="line">--pcre=qt \</span><br><span class="line">--zlib=qt \</span><br><span class="line">-no-openssl \</span><br><span class="line">--freetype=qt \</span><br><span class="line">--harfbuzz=qt \</span><br><span class="line">-no-opengl \</span><br><span class="line">-linuxfb \</span><br><span class="line">--xcb=no \</span><br><span class="line">-tslib \</span><br><span class="line">--libpng=qt \</span><br><span class="line">--libjpeg=qt \</span><br><span class="line">--sqlite=qt \</span><br><span class="line">-plugin-sql-sqlite \</span><br><span class="line">-I/home/moss/linux/tool/tslib/include \</span><br><span class="line">-L/home/moss/linux/tool/tslib/lib \</span><br><span class="line">-recheck-all</span><br></pre></td></tr></table></figure><p>赋予脚本可执行权限。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x autoconfigure.sh</span><br></pre></td></tr></table></figure><p>直接执行 autoconfigure.sh。 配置需要一段时间，请耐心等待！配置前请先安装 g++</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++ </span><br><span class="line">./autoconfigure.sh</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20170414.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 16</span><br></pre></td></tr></table></figure><p>编译，之后执行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="移植Qt到文件系统"><a href="#移植Qt到文件系统" class="headerlink" title="移植Qt到文件系统"></a>移植Qt到文件系统</h3><p>首先按照正常的步骤来将需要移植tslib的库，但是如果是开发过触摸屏驱动的话，可以发现你已经移植过了，经过测试用之前移植的tslib库以及编写的&#x2F;etc&#x2F;profile，是完全能够使用的。所以移植tslib库的步骤请参考触摸屏幕驱动后半部分。</p><p><strong>下载arm平台的qt源码</strong><a href="https://download.qt.io/archive/qt/5.12/5.12.9/single/">https://download.qt.io/archive/qt/5.12/5.12.9/single/</a></p><p>将qt的源码压缩包进行解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf qt-everywhere-src-5.12.9.tar.xz</span><br></pre></td></tr></table></figure><p>编辑 mkspecs&#x2F;qws&#x2F;linux-arm-gnueabi-g++&#x2F;qmake.conf， 配置相关编译器及路径。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># qmake configuration for building with arm-linux-gnueabi-g++</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">MAKEFILE_GENERATOR = UNIX</span></span><br><span class="line">CONFIG += incremental</span><br><span class="line">QMAKE_INCREMENTAL_STYLE = sublib</span><br><span class="line">QT_QPA_DEFAULT_PLATFORM = linuxfb</span><br><span class="line">QMAKE_CFLAGS += -O2 -march=armv7-a -mtune=cortex-a7 -mfpu=neon -mfloat-abi=hard</span><br><span class="line">QMAKE_CXXFLAGS += -O2 -march=armv7-a -mtune=cortex-a7 -mfpu=neon -mfloat-abi=hard</span><br><span class="line">include(../common/linux.conf)</span><br><span class="line">include(../common/gcc-base-unix.conf)</span><br><span class="line">include(../common/g++-unix.conf)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modifications to g++.conf</span></span><br><span class="line">QMAKE_CC = arm-linux-gnueabihf-gcc</span><br><span class="line">QMAKE_CXX = arm-linux-gnueabihf-g++</span><br><span class="line">QMAKE_LINK = arm-linux-gnueabihf-g++</span><br><span class="line">QMAKE_LINK_SHLIB = arm-linux-gnueabihf-g++</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modifications to linux.conf</span></span><br><span class="line">QMAKE_AR = arm-linux-gnueabihf-ar cqs</span><br><span class="line">QMAKE_OBJCOPY = arm-linux-gnueabihf-objcopy</span><br><span class="line">QMAKE_NM = arm-linux-gnueabihf-nm -P</span><br><span class="line">QMAKE_STRIP = arm-linux-gnueabihf-strip</span><br><span class="line">load(qt_config)</span><br></pre></td></tr></table></figure><p>进行配置编译选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/configure -prefix /home/moss/linux/qt-everywhere-src-5.12.9/arm-qt \</span><br><span class="line">-opensource \</span><br><span class="line">-confirm-license \</span><br><span class="line">-release \</span><br><span class="line">-strip \</span><br><span class="line">-shared \</span><br><span class="line">-xplatform linux-arm-gnueabi-g++ \</span><br><span class="line">-optimized-qmake \</span><br><span class="line">-c++std c++11 \</span><br><span class="line">--rpath=no \</span><br><span class="line">-pch \</span><br><span class="line">-skip qt3d \</span><br><span class="line">-skip qtactiveqt \</span><br><span class="line">-skip qtandroidextras \</span><br><span class="line">-skip qtcanvas3d \</span><br><span class="line">-skip qtconnectivity \</span><br><span class="line">-skip qtdatavis3d \</span><br><span class="line">-skip qtdoc \</span><br><span class="line">-skip qtgamepad \</span><br><span class="line">-skip qtlocation \</span><br><span class="line">-skip qtmacextras \</span><br><span class="line">-skip qtnetworkauth \</span><br><span class="line">-skip qtpurchasing \</span><br><span class="line">-skip qtremoteobjects \</span><br><span class="line">-skip qtscript \</span><br><span class="line">-skip qtscxml \</span><br><span class="line">-skip qtsensors \</span><br><span class="line">-skip qtspeech \</span><br><span class="line">-skip qtsvg \</span><br><span class="line">-skip qttools \</span><br><span class="line">-skip qttranslations \</span><br><span class="line">-skip qtwayland \</span><br><span class="line">-skip qtwebengine \</span><br><span class="line">-skip qtwebview \</span><br><span class="line">-skip qtwinextras \</span><br><span class="line">-skip qtx11extras \</span><br><span class="line">-skip qtxmlpatterns \</span><br><span class="line">-make libs \</span><br><span class="line">-make examples \</span><br><span class="line">-nomake tools -nomake tests \</span><br><span class="line">-gui \</span><br><span class="line">-widgets \</span><br><span class="line">-dbus-runtime \</span><br><span class="line">--glib=no \</span><br><span class="line">--iconv=no \</span><br><span class="line">--pcre=qt \</span><br><span class="line">--zlib=qt \</span><br><span class="line">-no-openssl \</span><br><span class="line">--freetype=qt \</span><br><span class="line">--harfbuzz=qt \</span><br><span class="line">-no-opengl \</span><br><span class="line">-linuxfb \</span><br><span class="line">--xcb=no \</span><br><span class="line">-tslib \</span><br><span class="line">--libpng=qt \</span><br><span class="line">--libjpeg=qt \</span><br><span class="line">--sqlite=qt \</span><br><span class="line">-plugin-sql-sqlite \</span><br><span class="line">-I/home/moss/linux/tool/tslib/include \</span><br><span class="line">-L/home/moss/linux/tool/tslib/lib \</span><br><span class="line">-recheck-all</span><br></pre></td></tr></table></figure><p>可以把上述配置变成可执行的脚本文件，之后赋予脚本可执行权限,后编译源码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod +x autoconfigure.sh</span><br><span class="line">sudo apt-get install g++ // 配置前请先安装 g++</span><br><span class="line">./autoconfigure.sh</span><br><span class="line">make -j16</span><br></pre></td></tr></table></figure><p>之后将arm-qt移动到&#x2F;usr&#x2F;lib的目录下。编译qt5的环境变量。编辑&#x2F;etc&#x2F;profile，在末尾添加以下内容。 如下图红色框内。 注意要改为个人实际的路径。要<br>想 Qt 程序显示中文，请自行将 windows 下的（路径 C:\Windows\Fonts） 下的中文字库放到新建一个&#x2F;usr&#x2F;share&#x2F;fonts&#x2F;目录下就可以了 。以下是&#x2F;etc&#x2F;profile的环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">export TERM=vt100</span><br><span class="line">export TERMINFO=/usr/share/terminfo</span><br><span class="line"></span><br><span class="line">export TSLIB_TSDEVICE=/dev/input/event2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">event2是我的触摸屏序号</span></span><br><span class="line">export TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line">export TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line">export TSLIB_PLUGINDIR=/lib/ts</span><br><span class="line">export TSLIB_CONSOLEDEVICE=none</span><br><span class="line">export TSLIB_FBDEVICE=/dev/fb0</span><br><span class="line"></span><br><span class="line">export QT_ROOT=/usr/lib/arm-qt</span><br><span class="line">export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event2</span><br><span class="line">export QT_QPA_FONTDIR=/usr/share/fonts</span><br><span class="line">export QT_QPA_PLATFORM_PLUGIN_PATH=$QT_ROOT/plugins</span><br><span class="line">export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0</span><br><span class="line">export QT_PLUGIN_PATH=$QT_ROOT/plugins</span><br><span class="line">export LD_LIBRARY_PATH=$QT_ROOT/lib:$QT_ROOT/plugins/platforms</span><br><span class="line">export QML2_IMPORT_PATH=$QT_ROOT/qml</span><br><span class="line">export QT_QPA_FB_TSLIB=1</span><br><span class="line"></span><br><span class="line">export ALSA_CONFIG_PATH=/usr/share/arm-alsa/alsa.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后使能环境变量，测试程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line">/usr/lib/arm-qt/examples/widgets/animation/animatedtiles/animatedtiles</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-04%20173550.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt信号和槽</title>
      <link href="/2023/08/30/2023-8-30-%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/"/>
      <url>/2023/08/30/2023-8-30-%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h3><p>信号和槽本质上是两个类在进行通信。<br>信号或是传递值，或者是传递动作变化，槽函数响应信号或是接受值，或者根据动作变化来做出对应操作。<br><strong>信号本质</strong><br>信号是由于用户对窗口或者控件做了操作，导致窗口或者控件产生了某个特定事件，这时候对应的窗口类会发出某个信号，以此对用户的挑选做出反应。<br>信号是qt对象中特殊的函数，本质上是一种函数指针，事件发生时调用，不是在信号所属的对象中直接执行。<br>信号的呈现形式就是函数，也就是说某个事件产生了，qt框架会调用某个对应的信号函数，通知使用者。<br><strong>槽的本质</strong><br>槽的职责是对qt框架中产生的信号进行处理。<br>槽是qt对象中普通成员函数，用于处理信号发生时的动作。一个槽可以连接一个或者多个信号，当信号触发时，与之连接的槽会被调用。</p><p><strong>信号和槽机制优点</strong></p><p>①类型安全：需要关联的信号和槽的签名必须是等同的。</p><p>②松散耦合：槽和信号不需要知道对方（信号不用知道是哪个槽接收的，槽不用知道哪些信号关联自己）</p><p><strong>连接</strong><br>连接是信号和槽之间的桥梁，它将一个信号与一个槽相关联。当信号发生时，连接会调用与之关联的槽。连接的建立通常通过函数实现。</p><p>信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</span><br></pre></td></tr></table></figure><p>connect() 是 QObject 类的一个静态函数，而 QObject 是所有 Qt 类的基类，在实际调用<br>时可以忽略前面的限定符，所以可以直接写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</span><br></pre></td></tr></table></figure><p>其中， sender 是发射信号的对象的名称， signal() 是信号名称。信号可以看做是特殊的函数，需要带括号，有参数时还需要指明参数。 receiver 是接收信号的对象名称， slot() 是槽函数的名称，需要带括号，有参数时还需要指明参数。<br>SIGNAL 和 SLOT 是 Qt 的宏，用于指明信号和槽，并将它们的参数转换成为相应的字符串。<br>###创建一个UI项目<br><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20153047.png"><br><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20153805.png"><br>点击mainwindow.ui文件进入ui界面设计地步。<br><strong>ui界面英文含义</strong></p><table><thead><tr><th>Layouts</th><th>布局</th></tr></thead><tbody><tr><td>vertical Layouts</td><td>垂直布局</td></tr><tr><td>Horizontal Layouts</td><td>水平布局</td></tr><tr><td>gridLayouts</td><td>网格布局</td></tr><tr><td>formLayouts</td><td>表格布局</td></tr><tr><td>Horizontal spacer</td><td>水平部件</td></tr><tr><td>vertical   spacer</td><td>垂直部件</td></tr><tr><td>pushbutton</td><td>下压按钮</td></tr><tr><td>toolbutton</td><td>工具按钮</td></tr><tr><td>radiobutton</td><td>选择按钮</td></tr><tr><td>checkbutton</td><td>复选按钮</td></tr><tr><td>command check button</td><td>命令链接按钮</td></tr><tr><td>dialog button box</td><td>对话框按钮</td></tr><tr><td>listview</td><td>列表视图</td></tr><tr><td>treeview</td><td>树视图</td></tr><tr><td>tableview</td><td>表视图</td></tr><tr><td>columnview</td><td>列视图</td></tr><tr><td>undoview</td><td>撤销视图</td></tr><tr><td>widget</td><td>控件</td></tr><tr><td>显示hello world，把控件中的文本控件拽出，并打字hello world就可以编译运行了。</td><td></td></tr><tr><td>创建一个简单的UI按键项目</td><td></td></tr><tr><td>将控件push button 拿出，打字关闭程序，这时候就要将控件以及信号槽连接。</td><td></td></tr><tr><td><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20162155.png"></td><td></td></tr><tr><td><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20162336.png"></td><td></td></tr><tr><td>选择按钮的 clicked()信号，将其连接 MainWindow 对象的 close()槽。这样就完成了信号与槽的连接。</td><td></td></tr><tr><td>在使用信号与槽的类中，必须在类的定义中加入宏 Q_OBJECT（特别重要）。</td><td></td></tr><tr><td>当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。</td><td></td></tr><tr><td>只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码。</td><td></td></tr><tr><td>总结如下图， 可以看到发送者与发送的信号是在一起的，接收者与接收的信号&#x2F;槽是在一起的。 它们不能在 connect()方法里写乱顺序！ 由发送者发送出信号到接收者用信号&#x2F;槽接收。</td><td></td></tr></tbody></table><p><strong>如何在项目中创建槽</strong><br>创建槽的方法也很简单， 也是直接在 mianwindow.h 里直接声明槽，在 mianwindow.cpp 里实现槽的定义， 声明槽必须写槽的定义(定义指函数体的实现)，否则编译器编译时将会报错。<br>槽有以下特点：</p><ol><li><p><strong>槽可以是任何成员函数、普通全局函数、静态函数</strong></p></li><li><p><strong>槽函数和信号的参数和返回值要一致</strong><br> mainwindow.h 添加槽函数后的代码</p></li></ol>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="comment">/* 引入 QPushButton */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"><span class="comment">/* 声明一个信号，只需声明，无需定义 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButtonTextChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="comment">/* 声明一个槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeButtonText</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明按钮点击的槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">/* 声明一个对象 pushButton */</span></span><br><span class="line">QPushButton *pushButton;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><p>  在 mainwindow.cpp 里 实 现 声 明 的 槽 函 数 void changeButtonText(); 和 voidpushButtonClicked();。 同时还实例化了 pushButton 对象。代码如下。<br>  mainwindow.cpp 添加槽的实现代码</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent): <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置窗体的宽为 800,高为 480 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(<span class="number">800</span>,<span class="number">480</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化 pushButton 对象 */</span></span><br><span class="line">pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 setText()方法设定按钮的文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;我是一个按钮&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现按钮点击槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 使用 emit 发送信号 */</span></span><br><span class="line"><span class="function">emit <span class="title">pushButtonTextChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现按钮文本改变的槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::changeButtonText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 在槽函数里改变按钮的文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;被点击了！ &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>如何在项目中连接信号与槽</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButtonClicked</span>()));</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">pushButtonTextChanged</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">changeButtonText</span>()));</span><br></pre></td></tr></table></figure><p>  注意，发送信号的对象，和接收的信号的对象。 因为我们 pushButtonClicked()是本类里定义的槽，所以用 this 来接收。同理， pushButtonTextChanged()也是本类定义的信号。所以发送者写成 this。 changeButtonText()也是本类的槽函数，所以接收槽的对象也是 this。</p><p>  在 mainwindow.cpp 中信号槽连接的代码如下。<br>  mainwindow.cpp 实现连接信号槽</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent): <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置窗体的宽为 800,高为 480 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(<span class="number">800</span>,<span class="number">480</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化 pushButton 对象 */</span></span><br><span class="line">pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 setText()方法设定按钮的文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;我是一个按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 信号与槽连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">pushButtonClicked</span>()));</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">pushButtonTextChanged</span>()), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">changeButtonText</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现按钮点击槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 使用 emit 发送信号 */</span></span><br><span class="line"><span class="function">emit <span class="title">pushButtonTextChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现按钮文本改变的槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::changeButtonText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* 在槽函数里改变按钮的文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;被点击了！ &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++浅学</title>
      <link href="/2023/08/20/2023-8-20-c++%E6%B5%85%E5%AD%A6/"/>
      <url>/2023/08/20/2023-8-20-c++%E6%B5%85%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>浅学一下C++ ，为qt打基础写一个上位机软件来做毕设。</p><h3 id="C-编译器"><a href="#C-编译器" class="headerlink" title="C++编译器"></a>C++编译器</h3><p>C语言的编译器是gcc，但是C++的编译器是g++，可以通过命令行进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure><p>###hello world</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//iostream是输入和输出的库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//使用空间名词std</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;<span class="comment">//cout为</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;<span class="comment">//输出运算符&lt;&lt;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">std:: cout &lt;&lt; std:: endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cc -o hello</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>cin和cout都是std命名空间下的东西，std::cout和std::cin表示std命名空间下的cout和cin。</p><p>命名空间示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">namespace A</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A namespace&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">using namespace A</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fun();</span><br><span class="line">    A::x = <span class="number">3</span>;<span class="comment">//对命名空间的X进行复制</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A :: x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    A::fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类和对象</strong></p><p>从类中实例化对象分两种方法，一种是从栈中实例化对象，一种是从堆中实例化对象。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thing</span><span class="comment">//定义一个类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//访问限定符 public（公有的）， 此外还有 private（私有的） 和 protected（受保护的）</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;物品数量是&quot;</span>&lt;&lt; number &lt;&lt; <span class="string">&quot;物品名字是&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thing thing1;<span class="comment">//从栈中实例化一个对象</span></span><br><span class="line">    thing1.name = <span class="string">&quot;伞&quot;</span>;</span><br><span class="line">    thing1.number = <span class="number">1</span>;</span><br><span class="line">    thing1.<span class="built_in">print</span>();</span><br><span class="line">thing *thing2 = <span class="keyword">new</span> <span class="built_in">thing</span>();<span class="comment">//使用关键字 new 的都是从堆中实例化对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == thing2) &#123;<span class="comment">//判断指针指向开辟内存</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">thing2-&gt;name = <span class="string">&quot;桌子&quot;</span>;</span><br><span class="line">thing2-&gt;number = <span class="number">2</span>;</span><br><span class="line"> thing2-&gt;<span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">delete</span> thing2;</span><br><span class="line">thing2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造函数和析构函数</strong></p><p>构造函数的特点如下：<br>（1） 构造函数必须与类名同名；<br>（2） 可以重载，（重载？新概念，后面学到什么是重载。）；<br>（3） 没有返回类型，即使是 void 也不行。<br>什么是析构函数？与构造函数相反， 在对象结束其生命周期时系统自动执行析构函数。 实<br>际上定义类时，编译器会生成一个析构函数。<br>析构函数的特点如下：<br>（1） 析构函数的格式为~类名()；<br>（2） 调用时释放内存（资源）；<br>（3） ~类名()不能加参数；<br>（4） 没有返回值，即使是 void 也不行。 </p><blockquote><ol><li>构造函数在实例化对象时自动被调用，且在每个对象的生命期仅被调用一次。</li><li>可以被重载。</li><li>若程序员没有主动给类定义构造函数，编译器自动给一个缺省的构造函数。</li><li>一旦程序员定义了一个构造函数，系统将不会再给出缺省构造函数。</li><li>除了系统缺省的构造函数外，只要构造函数无参或者参数有缺省值， 编译器会认为它就是缺省构造函数。缺省的构造函数同时只能有1个。</li></ol></blockquote><p>缺省构造函数：即无参或参数有缺省值。仅仅是为了构造对象，一种是构造函数不含形参，另一种是构造函数含有形参，并且形参被赋有默认值。</p><p><strong>this指针</strong></p><p>每个对象都拥有一个 this 指针， this 指针记录对象的内存地址。<br>在 C++中， this 指针是指向类自身数据的指针， 简单的来说就是指向当前类的当前实例对象。关于类的 this 指针有以下特点：<br>（1） <strong>this 只能在成员函数中使用， 全局函数、静态函数都不能使用 this。 实际上，成员函数默认第一个参数为 T * const this。</strong> 也就是一个类里面的成员了函数 int func(int p)， func 的原型在编译器看来应该是 int func(T * const this,int p)。<br>（2） this 在成员函数的开始前构造，在成员函数的结束后清除。<br>（3） this 指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。 </p><p><strong>继承</strong></p><p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 </p><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>-<span class="keyword">class</span>: access-specifier base-<span class="keyword">class</span></span><br></pre></td></tr></table></figure><p>与类的访问修饰限定符一样，继承的方式也有几种。 其中，访问修饰符 access-specifier 是public、 protected 或 private 其中的一个， base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 </p><ol><li>公有继承（public）：当一个类派生继承公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li><li>保护继承（protected）： 当一个类派生继承保护基类时，基类的公有和保护成员将成为派生类的保护成员。</li><li>私有继承（private）：当一个类派生继承私有基类时，基类的公有和保护成员将成为派生类的私有成员。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*动物类，抽象出下面两种属性，</span></span><br><span class="line"><span class="comment">*颜色和体重，是每种动物都具有的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line"><span class="comment">/* 颜色成员变量 */</span></span><br><span class="line"><span class="built_in">string</span> color;</span><br><span class="line"><span class="comment">/* 体重成员变量 */</span></span><br><span class="line"><span class="type">int</span> weight;原子哥在线教学:www.yuanzige.com 论坛:www.openedv.com</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*让狗类继承这个动物类，并在狗类里写自己的属性。</span></span><br><span class="line"><span class="comment">*狗类拥有自己的属性 name， age， run()方法，同时也继承了</span></span><br><span class="line"><span class="comment">*动物类的 color 和 weight 的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Dog dog;</span><br><span class="line">dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">dog.age = <span class="number">2</span>;</span><br><span class="line">dog.color = <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line">dog.weight = <span class="number">120</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;狗的名字叫： &quot;</span>&lt;&lt;dog.name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;狗的年龄是： &quot;</span>&lt;&lt;dog.age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;狗的毛发颜色是： &quot;</span>&lt;&lt;dog.color&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;狗的体重是： &quot;</span>&lt;&lt;dog.weight&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重载</strong><br>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为<strong>函数重载和运算符重载。</strong><br>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。<br>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="number">3</span> using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line"><span class="class">6 &#123;</span></span><br><span class="line"><span class="number">7</span> public:</span><br><span class="line"><span class="number">8</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="number">9</span> <span class="type">void</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> weight)</span> &#123;</span><br><span class="line"><span class="number">10</span> <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;的体重是： &quot;</span>&lt;&lt;weight&lt;&lt;<span class="string">&quot;kG&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">double</span> weight)</span> &#123;</span><br><span class="line"><span class="number">14</span> <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;的体重是： &quot;</span>&lt;&lt;weight&lt;&lt;<span class="string">&quot;kG&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> &#125;;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">19 &#123;</span><br><span class="line"><span class="number">20</span> Dog dog;</span><br><span class="line"><span class="number">21</span> dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line"><span class="number">22</span> dog.getWeight(<span class="number">10</span>);</span><br><span class="line"><span class="number">23</span> dog.getWeight(<span class="number">10.5</span>);</span><br><span class="line"><span class="number">24</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">25</span> &#125;</span><br></pre></td></tr></table></figure><p>程序中getWeight两个同名函数拥有不同的参数类型，这就是函数重载。</p><p>运算符重载的实质就是函数重载或函数多态。运算符重载是一种形式的 C++多态。目的在于让人能够用同名的函数来完成不同的基本操作要重载运算符，需要使用被称为运算符函数的特殊函数形式，运算符函数形式： operatorp（argument-list）， operator 后面的’p’为要重载的运<br>算符符号。 重载运算符的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回类型说明符&gt; <span class="keyword">operator</span> &lt;运算符符号&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">&lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多态</strong><br>C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数；<br>形成多态必须具备三个条件：</p><ol><li>必须存在继承关系；</li><li>继承关系必须有同名虚函数（其中虚函数是在基类中使用关键字 virtual 声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数）；</li><li>存在基类类型的指针或者引用，通过该指针或引用调用虚函数</li></ol><p><strong>虚函数：</strong><br>是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，<br>会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 虚函数声明如下： virtualReturnType FunctionName(Parameter) 虚函数必须实现，如果不实现，编译器将报错<br>纯虚函数：<br>若在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 纯虚函数声明如下：<br>virtual void funtion1()&#x3D;0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。<br>包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。 </p><p><strong>数据封装</strong><br>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。<br>数据封装是一种把数据和操作数据的函数捆绑在一起的机制， 数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制， C++ 通过创建类来支持封装和数据隐藏（public、protected、 private）。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础知识</title>
      <link href="/2023/08/19/2023-8-18-tcpip%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/19/2023-8-18-tcpip%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>开一个新的篇章，同时进行学习，只学习一种知识点太枯燥了，有点难啃。并且看到有的招聘网站上需要tcp&#x2F;ip协议的科技树，所以学习一下。</p><p><u>参考书为《图解TCP_IP》</u></p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>网络通信本质上是一种进程间通信，是位于网络中不同主机上的进程之间的通信，属于 IPC 的一种，通常称为 socket IPC </p><p>网络通信是为了解决在网络环境中，不同主机上的应用程序之间的通信问题。<br>大概可以分为三个层次，如下所示：<br>（1）、硬件层：网卡设备，收发网络数据<br>（2）、驱动层：网卡驱动（Linux 内核网卡驱动代码）<br>（3）、应用层：上层应用程序（调用 socket 接口或更高级别接口实现网络相关应用程序） <img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-10%20101353.png"></p><p>在硬件上，两台主机都提供了网卡设备，也就满足了进行网络通信最基本的要求，网卡设备是实现网络数据收发的硬件基础。并且通信的两台主机之间需要建立网络连接，这样两台主机之间才可以进行数据传输。网络数据的传输媒介有很多种，大体上分为有线传输（譬如双绞线网线、光纤等）和无线传输（譬如 WIFI、蓝牙、 ZigBee、 4G&#x2F;5G&#x2F;GPRS 等）， PC 机通常使用有线网络，而手机等移动设备通常使用无线网络。<br>在内核层，提供了网卡驱动程序，可以驱动底层网卡硬件设备，同时向应用层提供 socket 接口。<br>在应用层，应用程序基于内核提供的 socket 接口进行应用编程，实现自己的网络应用程序。需要注意的是， socket 接口是内核向应用层提供的一套网络编程接口，所以我们学习网络编程其实就是学习 socket 编程，如何基于 socket 接口编写应用程序。<br>除了 socket 接口之外，在应用层通常还会使用一些更为高级的编程接口，譬如 http、网络控件等，那么这些接口实际上是对 socket 接口的一种更高级别的封装。 </p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络根据规模分为 了WAN（广域网）和LAN（局域网）。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20211031.png"></p><p>TCP&#x2F;IP协议是IP、TCP、HTTP等协议的集合。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20212831.png"></p><p>在计算机通信中，事先达成一个详细的约定，并且遵守这一约定进行处理尤为重要，这种约定就是“协议”。</p><p>分组交换是将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。计算机通信会在每一个分组附加上源主机地址和目标主机地址给通信线路。**<u>这些发送端地址、接收端地址以及分组序号写入的部分称为”报文首部“</u>**</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20214246.png"></p><p>一个较大的数据被分为多个分组时，为了表明是原始数据的哪一部分，就有必要将分组的序号写入包中。接收端会根据这个序号，再将每个分组按照序号重新分配。</p><p>通信协议中通常会规定报文首部应该写入哪些信息、如何处理。</p><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>OSI参考模型将通信功能分为7个分层，称作OSI参考模型。OSI协议以OSI参考模型为基础界定了每个阶层的协议和每个阶层之间的接口标准。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20110837.png"></p><p>物理层中，将数据0、1转换为电压和脉冲光传输给物理的传输介质，而相互直连的设备之间使用地址实现传输。这种地址称为MAC地址（物理地址或者硬件地址）。</p><p><strong>应用层</strong></p><p>为应用层序提供服务并规定应用程序中通信相关的细节，包括文件传输、电子邮件、远程登录等协议。</p><p><strong>表示层</strong></p><p>将应用处理的信息转换为适合网络传输的格式，或来自下一层的数据转换为上层能处理的格式。</p><p><strong>会话层</strong></p><p>负责建立和断开通信连接，以及数据的分割等数据传输相关的管理。</p><p><strong>传输层</strong>（4~7层交换机处理传输层以上网络传输）</p><p>起着可靠传输的作用，只在通信双方节点上处理无需路由器上处理。</p><p><strong>网络层</strong>（路由器&#x2F;3层交换机）</p><p>将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。</p><p><strong>数据链路层</strong>（网桥&#x2F;2层交换机）</p><p>负责将物理层面上互连的、节点之间的通信传输。例如一个以太网相连的2个节点之间的通信。</p><p><strong>物理层</strong>（中继器物理层上延长设备）</p><p>负责0、1比特流与电压高低、光亮灭之间的转换。</p><p><strong>网络层与数据链接层都是基于目标地址将数据发送给接收端，但是网络层负责将整个数据发送给最终目标地址，而数据链接层则只负责发送一个分段内的数据。</strong></p><hr><p><u>7层之间通信</u>：每个分层上，在处理由上一层传过来的数据时可以附加上当前封层协议所必须的<strong>首部信息</strong>，然后接收端对收到的数据进行数据首部与内容的分离，再转发给上一层，并最终将发送端的数据恢复为原状。<img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20201355.png"></p><p>地址具有唯一性和层次性。一个地址必须明确表示也给主体对象。</p><h3 id="TCP-x2F-IP四层-x2F-五层模型"><a href="#TCP-x2F-IP四层-x2F-五层模型" class="headerlink" title="TCP&#x2F;IP四层&#x2F;五层模型"></a>TCP&#x2F;IP四层&#x2F;五层模型</h3><p><img src="C:\Users\hanfeng\AppData\Roaming\Typora\typora-user-images\1696904432451.png" alt="1696904432451"></p><p>网络通信中，数据从上层到下层交付时，要进行封装；同理，当目标主机接收到数据时，数据由下层传递给上层时需要进行拆封。这就是数据的封装与拆封。数据的封装过程如下图所示： </p><p><img src="C:\Users\hanfeng\AppData\Roaming\Typora\typora-user-images\1696904515895.png" alt="1696904515895"></p><p>这就是网络数据的发送过程，从图中可以看到，各层协议均会对数据进行相应的封装，可以概括为 TCP&#x2F;IP 模型中的各层协议对数据进行封装的过程。 </p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>Internet 依靠 TCP&#x2F;IP 协议，在全球范围内实现不同硬件结构、不同操作系统、不同网络系统的主机之间的互联。IP是实现多个数据链路之间的通信协议<br>IP相当于OSI参考模型中的第三层–网络层。网络层可以跨越不同的数据链路，即使是不同的数据链路上也能实现两端节点之间的数据包传输。<br>IP面向无连接。即在发包之前，不需要建立与对端目标地址之间的连接。上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。面向无连接为了简化和提速。<br>在 Internet 上，每一个节点都依靠唯一的 IP 地址相互区分和相互联系， IP 地址用于标识互联网中的每台主机的身份，设计人员为每个接入网络中的主机都分配一个 IP 地址（Internet Protocol Address），只有合法的 IP 地址才能接入互联网中并且与其他主机进行网络通信， IP 地址是软件地址，不是硬件地址，硬件 MAC 地址是存储在网卡中的，应用于局域网中寻找目标主机。 </p><p>IP 地址中的 32 位实际上包含 2 部分，分别为（网络标识）网络地址和（主机标识）主机地址，可通过子网掩码来确定网络地址和主机地址分别占用多少位。 网络标识在数据链路的每个段配置不同的值。网络标识必须保证互相连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的主机标识则不允许在同一个网段内重复出现。<br><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-10%20132934.png"></p><p>根据 IP 地址中网络地址和主机地址两部分分别占多少位的不同，将 IP 地址划分为 5 类，分别为 A、B、 C、 D、 E 五类 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-10%20103336.png"></p><h4 id="A-类-IP-地址"><a href="#A-类-IP-地址" class="headerlink" title="A 类 IP 地址"></a>A 类 IP 地址</h4><p>从上图中可以看到，一个 A 类 IP 地址由 1 个字节网络地址和 3 个字节主机地址组成，而网络地址的最高位必须为 0，因此可知，网络地址取值范围为 0~127，一共 128 个网络地址(一个字节8位)。当然，这 128 个网络地址中，其中 3 个网络地址用作特殊用途，因此可用的网络地址有 125 个。<br>(1)、 A 类地址的第一字节为网络地址，其它 3 个字节为主机地址；<br>(2)、 A 类地址范围为： 1.0.0.1 ~ 127.255.255.254；<br>(3)、 A 类地址中设有私有地址和保留地址：<br>①、 10.X.X.X 是私有地址，所谓私有地址就是在互联网中不能使用，而被用在局域网中使用的地址。<br>②、 127.X.X.X 是保留地址，用作循环测试使用。</p><h4 id="B-类-IP-地址"><a href="#B-类-IP-地址" class="headerlink" title="B 类 IP 地址"></a>B 类 IP 地址</h4><p>一个 B 类 IP 地址由 2 个字节的网络地址和 2 个字节的主机地址组成，网络地址的最高位必须是“10”，因此，网络地址第一个字节的取值范围为 128~191， IP 地址范围从 128.0.0.0 到 191.255.255.255。对于 B 类地址来说，一共拥有 16384 个网络地址，其中可用的网络地址有 16382 个，每个网络地址能容纳约 6 万（2^16-2&#x3D;65534）多个主机。<br>(1)、 B 类地址中第 1 字节和第 2 字节为网络地址，其它 2 个字节为主机地址。<br>(2)、 B 类地址范围： 128.0.0.1 ~ 191.255.255.254。<br>(3)、 B 类地址中设有私有地址和保留地址：<br>①、 172.16.0.0 ~ 172.31.255.255 是私有地址<br>②、 169.254.X.X 是保留地址。如果你的 IP 地址是自动获取 IP 地址，而你在网络上又没有找到可用的DHCP 服务器。就会得到其中一个 IP。</p><h4 id="C-类-IP-地址"><a href="#C-类-IP-地址" class="headerlink" title="C 类 IP 地址"></a>C 类 IP 地址</h4><p>一个 C 类 IP 地址由 3 字节的网络地址和 1 字节的主机地址组成，网络地址的最高位必须是“110”，因此 C 类 IP 地址的第一个字节的取值范围为 192~223。范围从 192.0.0.0 到 223.255.255.255，网络地址可达209 万余个，每个网络地址能容纳 254 个主机。<br>(1)、 C 类地址第 1 字节、第 2 字节和第 3 个字节为网络地址，第 4 个个字节为主机地址。另外第 1 个字节的高三位固定为 110。<br>(2)、 C 类地址范围为： 192.0.0.1 ~ 223.255.255.254。<br>(3)、 C 类地址中的私有地址： 192.168.X.X 是私有地址。</p><h4 id="D-类-IP-地址"><a href="#D-类-IP-地址" class="headerlink" title="D 类 IP 地址"></a>D 类 IP 地址</h4><p>D 类 IP 地址第一个字节以“1110”开始，它是一个专门保留的地址，它并不指向特定的网络，目前这一类地址被用在多点广播（多播， Multicast），多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。<br>(1)、 D 类地址不分网络地址和主机地址，它的第 1 个字节的高四位固定为 1110。<br>(2)、 D 类地址范围： 224.0.0.1 ~ 239.255.255.254。</p><h4 id="E-类-IP-地址"><a href="#E-类-IP-地址" class="headerlink" title="E 类 IP 地址"></a>E 类 IP 地址</h4><p>E 类 IP 地址以“llll0”开始，为将来使用保留。全零(“0.0.0.0” )地址对应于当前主机。全“1”的 IP 地址(“255.255.255.255” )是当前子网的广播地址。<br>(1)、 E 类地址也不分网络地址和主机地址，它的第 1 个字节的前五位固定为 11110。<br>(2)、 E 类地址范围： 240.0.0.1 ~ 255.255.255.254。特殊的 IP 地址</p><h3 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h3><p>这些 IP 地址不能分配给任何一个网络的主机使用。<br><strong>直接广播地址</strong><br>在不同网络之间的广播叫做直接广播。<br>直接广播（Direct Broadcast Address）：向某个网络上所有的主机发送报文。 TCP&#x2F;IP 规定，主机号各位全部为“1”的 IP 地址用于广播，叫作广播地址。譬如一个 IP 地址是 192.168.0.181，这是一个 C 类地址，所以它的主机号只有一个字节，那么对主机号全取 1 得到一个广播地址 192.168.0.255，向这个地址发送数据就能让同一网络下的所有主机接收到。<br>A、 B、 C 三类地址的广播地址结构如下：<br>⚫ A 类地址的广播地址为： XXX.255.255.255（XXX 为 A 类地址中网络地址对应的取值范围，譬如：120.255.255.255）。<br>⚫ B 类地址的广播地址为： XXX.XXX.255.255（ XXX 为 B 类地址中网络地址的取值范围，譬如139.22.255.255）。<br>⚫ C 类地址的广播地址为： XXX.XXX.XXX.255（XXX 为 C 类地址中网络地址的取值范围，譬如203.120.16.255）。<br><strong>受限广播地址</strong><br>直接广播要求发送方必须广播网络对应的网络号。但有些主机在启动时，往往并不知道本网络的网络号，这时候如果想要向本网络广播，只能采用受限广播地址（Limited Broadcast Address）。<br>受限广播地址是在本网络内部进行广播的一种广播地址， TCP&#x2F;IP 规定， 32 比特全为“1”的 IP 地址用于本网络内的广播，也就是 255.255.255.255。<br><strong>多播地址</strong><br>多播地址用在一对多的通信中，即一个发送者，多个接收者，不论接受者数量的多少，发送者只发送一次数据包。多播地址属于 D 类地址， D 类地址只能用作目的地址，而不能作为主机中的源地址。<br><strong>环回地址</strong><br>环回地址（Loopback Address）是用于网络软件测试以及本机进程之间通信的特殊地址。把 A 类地址中的 127.XXX.XXX.XXX 的所有地址都称为环回地址，主要用来测试网络协议是否工作正常的作用。比如在电脑中使用 ping 命令去 ping 127.1.1.1 就可以测试本地 TCP&#x2F;IP 协议是否正常。不能将环回地址作为任何一台主机的 IP 地址使用。</p><p><strong>0.0.0.0 地址</strong></p><p>IP 地址 32bit 全为 0 的地址（也就是 0.0.0.0）表示本网络上的本主机，只能用作源地址。<br>0.0.0.0 是不能被 ping 通的，在服务器中， 0.0.0.0 并不是一个真实的的 IP 地址，它表示本机中所有的IPv4 地址。监听 0.0.0.0 的端口，就是监听本机中所有 IP 的端口。</p><p>如何判断两个 IP 地址是否处于同一个子网，可通过网络标识来进行判断，网络标识定义如下：<br><strong>网络标识 &#x3D; IP 地址 &amp; 子网掩码</strong> </p><p>一样就是处于同一个网络内。</p><h4 id="子网与子网掩码"><a href="#子网与子网掩码" class="headerlink" title="子网与子网掩码"></a>子网与子网掩码</h4><p>现在一个IP地址的网络标识和主机标识已不再受限与该地址的类别，而是一个叫做”子网掩码“的识别码通过子网网络地址细分比A类、B类、C类更小粒度的网络。这种方式实际上就是将原来A类、B类、C类等分类中的地址部分用于子网地址，可以将原网络分为多个物理网络的一种机制。</p><h3 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h3><p>TCP&#x2F;IP协议是一个协议族，包含了众多的协议，比如HTTP、FTP、MQTT、TCP、UDP等等。</p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>HTTP超文本传输协议，HTTP是万维网数据通信的基础。HTTP应用是最基础的。HTTP协议工作于客户端(用户)、服务器端（网站）模式下，浏览器作为HTTP客户端通过URL（<strong>URL是web页的地址</strong>），向HTTP服务器端即web服务器发送请求。</p><h4 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h4><p>FTP 协议的英文全称为 File Transfer Protocol，简称为FTP，它是一种文件传输协议，从一个主机向一个主机传输文件的协议。 FTP 协议同样也是基于客户端-服务器模式，在客户端和服务器之间进行文件传输，一般用在两个主机间的通信，比如虚拟机的Ubuntu和Windows间进行传输数据就是使用FTP协议。<br>FTP 除了基本的文件上传&#x2F;下载功能外，还有目录操作、权限设置、身份验证等机制，许多网盘的文件传输功能都是基于 FTP 实现的。 </p><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于 IP 的传输协议。TCP 协议工作在传输层，对上服务 socket 接口，对下调用 IP 层（网络层）。 </p><blockquote><p>①、 TCP 协议工作在传输层，对上服务 socket 接口，对下调用 IP 层；<br>②、 TCP 是一种面向连接的传输协议，通信之前必须通过三次握手与客户端建立连接关系后才可通信；<br>③、 TCP 协议提供可靠传输，不怕丢包、乱序。 </p></blockquote><p><strong>TCP 协议如何保证可靠传输？</strong><br>①、 TCP 协议采用发送应答机制，即发送端发送的每个 TCP 报文段都必须得到接收方的应答，才能认为这个 TCP 报文段传输成功。<br>②、 TCP 协议采用超时重传机制，发送端在发送出一个 TCP 报文段之后启动定时器，如果在定时时间内未收到应答，它将重新发送该报文段。<br>③、由于 TCP 报文段最终是以 IP 数据报发送的，而 IP 数据报到达接收端可能乱序、重复、所以 TCP协议还会将接收到的 TCP 报文段重排、整理、再交付给应用层。 </p><p><strong>TCP 协议的特点：</strong><br>⚫ 面向连接的<br>TCP 是一个面向连接的协议，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一个 TCP连接，否则将无法发送数据，通过三次握手建立连接。<br>⚫ 确认与重传<br>当数据从主机 A 发送到主机 B 时，主机 B 会返回给主机 A 一个确认应答； TCP 通过确认应答 ACK 实现可靠的数据传输。当发送端将数据发送出去之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，数据丢失的可能性比较大。<br>在一定的时间内如果没有收到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢失，仍然可以保证数据能够到达对端，实现可靠传输。<br>⚫ 全双工通信<br>TCP 连接一旦建立，就可以在连接上进行双向的通信。任何一个主机都可以向另一个主机发送数据，数据是双向流通的，所以 TCP 协议是一个全双工的协议。<br>⚫ 基于字节流而非报文<br>将数据按字节大小进行编号，接收端通过 ACK 来确认收到的数据编号，通过这种机制能够保证 TCP 协议的有序性和完整性，因此 TCP 能够提供可靠性传输。<br>⚫ 流量控制（滑动窗口协议）<br>TCP 流量控制主要是针对接收端的处理速度不如发送端发送速度快的问题，消除发送方使接收方缓存溢出的可能性。 TCP 流量控制主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。这样通过调整发送方窗口和接收方窗口的大小可以实现流量控制。<br>⚫ 差错控制<br>TCP 协议除了确认应答与重传机制外， TCP 协议也会采用校验和的方式来检验数据的有效性，主机在接收数据的时候，会将重复的报文丢弃，将乱序的报文重组，发现某段报文丢失了会请求发送方进行重发，因此在 TCP 往上层协议递交的数据是顺序的、无差错的完整数据。<br>⚫ 拥塞控制<br>如果网络上的负载（发送到网络上的分组数）大于网络上的容量（网络同时能处理的分组数），就可能引起拥塞，判断网络拥塞的两个因素：延时和吞吐量。拥塞控制机制是：开环（预防）和闭环（消除）。<br>流量控制是通过接收方来控制流量的一种方式；而拥塞控制则是通过发送方来控制流量的一种方式。<br>TCP 发送方可能因为 IP 网络的拥塞而被遏制， TCP 拥塞控制就是为了解决这个问题（注意和 TCP 流量控制的区别）。<br>TCP 拥塞控制的几种方法：慢启动，拥塞避免，快重传和快恢复。</p><h4 id="字节流和报文流的定义与区别"><a href="#字节流和报文流的定义与区别" class="headerlink" title="字节流和报文流的定义与区别"></a>字节流和报文流的定义与区别</h4><p>流是全双工的处理过程，它是内核中驱动程序和用户进程之间的数据传输通道。流在I&#x2F;O系统中是一种I&#x2F;O机制和功能，不是一个物理设备的概念。字节流是最基本的，所有的InputStrem和OutputStream的子类都是，主要用在处理二进制数据，它是按字节来处理的。</p><p>报文是网络中交换与传输的数据单元。报文包含了将要发送的完整的数据信息，其长短很不一致。（可分为自由报文和数字报文）<br>报文也是网络传输的单位,传输过程中会不断的封装成分组、包、帧来传输，封装的方式就是添加一些信息段，那些就是报文头以一定格式组织起来的数据。</p><h4 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h4><p>当数据由上层发送到传输层时，数据会被封装为 TCP 数据段，我们将其称为 TCP 报文（或 TCP 报文段）， TCP 报文由 TCP 首部+数据区域组成，一般 TCP 首部通常为 20 个字节大小 。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-10%20130302.png"></p><p><strong>源端口号和目标端口号</strong><br>源端口号和目标端口号各占 2 个字节，一个 4 个字节，每个 TCP 报文都包含源主机和目标主机的端口号，用于寻找发送端和接收端应用进程，这两个值加上 IP 首部中的源 IP 地址和目标 IP 地址就能确定唯一一个 TCP 连接。**<u>有时一个 IP 地址和一个端口号也称为 socket（插口）。</u>** </p><p><strong>序号</strong><br>占 4 个字节，用来标识从 TCP 发送端向 TCP 接收端发送的数据字节流，它的值表示在这个报文段中的第一个数据字节所处位置码，根据接收到的数据区域长度，就能计算出报文最后一个数据所处的序号，因为TCP 协议会对发送或者接收的数据进行编号（按字节的形式），那么使用序号对每个字节进行计数，就能很轻易管理这些数据。<br>在 TCP 传送的数据流中，每一个字节都有一个序号。例如，一报文段的序号为 300，而且数据共 100 字节，则下一个报文段的序号就是 400；序号是 32bit 的无符号数，序号到达 2^32-1 后从 0 开始。 <strong>确认序号</strong><br>确认序号占 4 字节，是期望收到对方下次发送的数据的第一个字节的序号，也就是期望收到的下一个<br>报文段的首部中的序号；确认序号应该是上次已成功收到数据字节序号+1。只有 ACK 标志为 1 时，确认序号才有效。 TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输，因此确认序号通常会与反向数据（即接收端传输给发送端的数据）封装在同一个报文中（即捎带），所以连接的每一端都必须保持每个方向上的传输数据序号准确性。<br><strong>首部长度</strong><br>首部长度字段占 4 个 bit 位，它指出了 TCP 报文段首部长度，以字节为单位，最大能记录 15*4&#x3D;60 字<br>节的首部长度，因此， TCP 报文段首部最大长度为 60 字节。在字段后接下来有 6bit 空间是保留未用的，供以后应用，现在置为 0。<br><strong>6 个标志位： URG&#x2F;ACK&#x2F;PSH&#x2F;RST&#x2F;SYN&#x2F;FIN</strong><br>保留位之后有 6 个标志位，分别如下：<br>①、 URG： 首部中的紧急指针字段标志，如果是 1 表示紧急指针字段有效。<br>②、 ACK： 只有当 ACK&#x3D;1 时，确认序号字段才有效。<br>③、 PSH： 当 PSH&#x3D;1 时，接收方应该尽快将本报文段立即传送给其应用层。<br>④、 RST： 当 RST&#x3D;1 时，表示出现连接错误，必须释放连接，然后再重建传输连接。复位比特还用来<br>拒绝一个不法的报文段或拒绝打开一个连接。<br>⑤、 SYN： SYN&#x3D;1， ACK&#x3D;0 时表示请求建立一个连接，携带 SYN 标志的 TCP 报文段为同步报文段。<br>⑥、 FIN： 为 1 表示发送方没有数据要传输了，要求释放连接。<br><strong>窗口大小</strong><br>占用 2 个字节大小，表示从确认号开始，本报文的发送方可以接收的字节数，即接收窗口大小，用于流量控制。<br><strong>校验和</strong><br>对整个的 TCP 报文段，包括 TCP 首部和 TCP 数据，以 16 位字进行计算所得。这是一个强制性的字段。<br><strong>紧急指针</strong><br>本报文段中的紧急数据的最后一个字节的序号。<br><strong>选项</strong><br>选项字段的大小是不确定的，最多 40 字节</p><h4 id="建立TCP连接：三次握手"><a href="#建立TCP连接：三次握手" class="headerlink" title="建立TCP连接：三次握手"></a>建立TCP连接：三次握手</h4><p>TCP 协议是一个面向连接的协议，双方在进行网络通信之间，都必须先在双方之间建立一条连接，俗称“握手”， 三次握手”其实是指建立 TCP 连接的一个过程，通信双方建立一个 TCP 连接需要经过“三次握手”这样一个过程。<br>首先建立连接的过程是由客户端发起，而服务器会时刻监听、等待着客户端的连接，其示意图如下 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-10%20140941.png">TCP 连接一般来说会经历以下过程：<br>⚫ 第一次握手<br>客户端将 TCP 报文标志位 SYN 置为 1，随机产生一个序号值 seq&#x3D;J，保存在 TCP 首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入 SYN_SENT 状态，等待服务器端确认。<br>⚫ 第二次握手<br>服务器端收到数据包后由标志位 SYN&#x3D;1 知道客户端请求建立连接，服务器端将 TCP 报文标志位 SYN和 ACK 都置为 1， ack&#x3D;J+1，随机产生一个序号值 seq&#x3D;K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD 状态。<br>⚫ 第三次握手<br>客户端收到确认后，检查 ack 是否为 J+1， ACK 是否为 1，如果正确则将标志位 ACK 置为 1， ack&#x3D;K+1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 K+1， ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p><h4 id="关闭-TCP-连接：四次挥手"><a href="#关闭-TCP-连接：四次挥手" class="headerlink" title="关闭 TCP 连接：四次挥手"></a>关闭 TCP 连接：四次挥手</h4><p>除了“三次握手”，还有“四次挥手”，“四次挥手”（有一些书也会称为四次握手）其实是指关闭 TCP<br>连接的一个过程，当通信双方需要关闭 TCP 连接时需要经过“四次挥手”这样一个过程。四次挥手即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。在 socket 编程中，这一过程由客户端或服务端任一方执行 close 来触发。<br>由于 TCP 连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送<br>任务后，发送一个 FIN 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-10%20141708.png"></p><p><strong><u>挥手请求可以是 Client 端，也可以是 Server 端发起的</u></strong> ，这是假设由client端发起的。</p><p>⚫ 第一次挥手<br>Client 端发起挥手请求，向 Server 端发出一个 FIN 报文段主动进行关闭连接，此时报文段的 FIN 标志<br>位被设置为 1。此时， Client 端进入 FIN_WAIT_1 状态，这表示 Client 端没有数据要发送给 Server 端了。<br>⚫ 第二次挥手<br>Server 端收到了 Client 端发送的 FIN 报文段，向 Client 端返回一个 ACK 报文段，此时报文段的 ACK<br>标志位被设置为 1。 ack 设为 seq 加 1， Client 端进入 FIN_WAIT_2 状态， Server 端告诉 Client 端，我确认并<br>同意你的关闭请求。<br>⚫ 第三次挥手<br>Server 端向 Client 端发送一个 FIN 报文段请求关闭连接，此时报文段的 FIN 标志位被设置为 1，同时<br>Client 端进入 LAST_ACK 状态。<br>⚫ 第四次挥手<br>Client 端收到 Server 端发送的 FIN 报文段后，向 Server 端发送 ACK 报文段（此时报文段的 ACK 标志<br>位被设置为 1），然后 Client 端进入 TIME_WAIT 状态。 Server 端收到 Client 端的 ACK 报文段以后，就关闭连接。此时， Client 端等待 2MSL 的时间后依然没有收到回复，则证明 Server 端已正常关闭，那好， Client端也可以关闭连接了。</p><h4 id="TCP状态说明"><a href="#TCP状态说明" class="headerlink" title="TCP状态说明"></a>TCP状态说明</h4><p>建立连接和断开连接以及数据传输过程会呈现不同状态：</p><p>⚫ CLOSED 状态： 表示一个初始状态。<br>⚫ LISTENING 状态： 这是一个非常容易理解的状态，表示服务器端的某个 SOCKET 处于监听状态，监听客户端的连接请求，可以接受连接了。譬如服务器能够提供某种服务，它会监听客户端 TCP端口的连接请求，处于 LISTENING 状态，端口是开放的，等待被客户端连接。<br>⚫ SYN_SENT 状态(客户端状态)： 当客户端调用 connect()函数连接时，它首先会发送 SYN 报文给服务器请求建立连接，因此也随即它会进入到了 SYN_SENT 状态，并等待服务器的发送三次握手中的第 2 个报文。 SYN_SENT 状态表示客户端已发送 SYN 报文。<br>⚫ SYN_REVD 状态(服务端状态)： 这个状态表示服务器接受到了 SYN 报文，在正常情况下，这个状态是服务器端的 SOCKET 在建立 TCP 连接时的三次握手过程中的一个中间状态， 很短暂，基本上用 netstat 你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次 TCP 握手过程中最后一个 ACK 报文不予发送。因此这种状态时，当收到客户端的 ACK 报文后，它会进入到 ESTABLISHED 状态。<br>⚫ ESTABLISHED 状态： 这个容易理解了，表示连接已经建立了。<br>⚫ FIN_WAIT_1 和 FIN_WAIT_2 状态： 其实 FIN_WAIT_1 和 FIN_WAIT_2 状态的真正含义都是表示等待对方的 FIN 报文。而这两种状态的区别是： FIN_WAIT_1 状态实际上是当 SOCKET 在ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 FIN 报文，此时该 SOCKET 即进入到FIN_WAIT_1 状态。而当对方回应 ACK 报文后，则进入到 FIN_WAIT_2 状态，<u>当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 ACK 报文，所以 FIN_WAIT_1 状态一般是比较难见到的，而 FIN_WAIT_2 状态还有时常常可以用 netstat 看到。</u><br>⚫ TIME_WAIT 状态： 表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 CLOSED 可用状态了。如果 FIN_WAIT_1 状态下，收到了对方同时带 FIN 标志和 ACK 标志的报文时，可以直接进入到 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。<br>⚫ CLOSE_WAIT 状态： 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个SOCKET 后发送 FIN 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 FIN 报文给对方，也即关闭连接。所以你在 CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。<br>⚫ LAST_ACK 状态： 它是被动关闭一方在发送 FIN 报文后，最后等待对方的 ACK 报文。当收到 ACK报文后，也即可以进入到 CLOSED 状态了。</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP（用户数据报协议）是一种无连接、不可靠的协议，同时它也工作在传输层，它只是简单地从一端主机到另一个主机的数据传输功能，这些数据通过IP层发送，在网络中传输，到达目标主机的顺序是无法预知的。<br>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，并且它是将应用程序发来的数据在收到的一刻，立刻按照原样发送到网络上的一种机制。传输途中即使丢包，UDP也不负责重发。</p><p>由于UDP面向无连接，它可以随时发送数据。再加上本身UDP本身处理简单高效，因此经常用于几个方面：</p><blockquote><p>包总量较少的通信（DNS、SNMP等）</p><p>视频、音频等多媒体通信（即时通信）</p><p>限定于LAN等特定网络中的应用通信</p><p>广播通信（广播、多播）</p></blockquote><p>UDP具有以下几个特点：</p><p>①、无连接、不可靠；<br>②、尽可能提供交付数据服务，出现差错直接丢弃，无反馈；<br>③、面向报文，发送方的 UDP 拿到上层数据直接添加个 UDP 首部，然后进行校验后就递交给 IP 层，而接收的一方在接收到 UDP 报文后简单进行校验，然后直接去除数据递交给上层应用；<br>④、速度快，因为 UDP 协议没有 TCP 协议的握手、确认、窗口、 重传、拥塞控制等机制， UDP 是一个无状态的传输协议，所以它在传递数据时非常快，即使在网络拥塞的时候 UDP 也不会降低发送的数据。 </p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>数据链路和IP中的地址分别指的是MAC地址和IP地址。前者用来识别同一链路中的不同的计算机，后者用来识别TCP&#x2F;IP网络中互连的主机和路由器。在传输层中也有类似于地址的概念，这就是端口号，<strong>端口号用来识别同一台计算机中进行通信的不同应用程序</strong>，也叫做<strong>程序地址</strong>。</p><p>一个计算机上同时可以运行多个程序，例如web服务器、电子邮箱客户端等都可以同时运行，传输层协议正式利用端口识别号识别本机中正在通信的应用程序，并准确将数据传输。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-10%20151608.png"></p><p>TCP&#x2F;IP或者UDP&#x2F;IP通信采用5个信息来识别一个通信，它们是源IP地址、目标IP地址、协议号、源端口号、目标端口号，只要其中一项不同，就是其他的通信。</p><h4 id="端口号如何确定"><a href="#端口号如何确定" class="headerlink" title="端口号如何确定"></a>端口号如何确定</h4><p>确定端口号有两种方法：</p><p>①标准既定的端口号</p><p>也叫静态方法，它只每个应用程序都有其指定的端口号，但并不是说可以使用认识一个端口号，每个端口号都有对应的使用目的。例如HTTP、TELNET、FTP等应用协议中使用的端口号就是固定的。这些端口号就是</p><p>②时序分配法</p><p>此时服务端也必要确定监听端口号，但是接收服务的客户端也没必要确定端口号。这种情况下客服端应用程序可以完全不用自己设置端口号，而全权交给操作系统分配。</p><p><strong>常见服务器具有特定的端口号：</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-06%20204527.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIO驱动</title>
      <link href="/2023/08/17/2023-8-17-IIO%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/08/17/2023-8-17-IIO%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="IIO介绍"><a href="#IIO介绍" class="headerlink" title="IIO介绍"></a>IIO介绍</h3><p>IIO 全称是 Industrial I&#x2F;O，翻译过来就是工业 I&#x2F;O，大家不要看到“工业”两个字就觉得 IIO是只用于工业领域的。大家一般在搜索 IIO 子系统的时候，会发现大多数讲的都是 ADC，这是因为 IIO 就是为 ADC 类传感器准备的，当然了 DAC 也是可以的。</p><p>1、 iio_dev 结构体<br>IIO 子系统使用结构体 iio_dev 来描述一个具体 IIO 设备，此设备结构体定义在include&#x2F;linux&#x2F;iio&#x2F;iio.h 文件中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">474</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> &#123;</span></span><br><span class="line"><span class="number">475</span> <span class="type">int</span> id;</span><br><span class="line"><span class="number">476</span></span><br><span class="line"><span class="number">477</span> <span class="type">int</span> modes;<span class="comment">//为设备支持模式</span></span><br><span class="line">    <span class="comment">/*INDIO_DIRECT_MODE 提供 sysfs 接口。</span></span><br><span class="line"><span class="comment">INDIO_BUFFER_TRIGGERED 支持硬件缓冲触发。</span></span><br><span class="line"><span class="comment">INDIO_BUFFER_SOFTWARE 支持软件缓冲触发。</span></span><br><span class="line"><span class="comment">INDIO_BUFFER_HARDWARE 支持硬件缓冲区。*/</span></span><br><span class="line"><span class="number">478</span> <span class="type">int</span> currentmode;<span class="comment">//currentmode 为当前模式。</span></span><br><span class="line"><span class="number">479</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"><span class="number">480</span></span><br><span class="line"><span class="number">481</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_event_interface</span> *<span class="title">event_interface</span>;</span></span><br><span class="line"><span class="number">482</span></span><br><span class="line"><span class="number">483</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer</span> *<span class="title">buffer</span>;</span><span class="comment">//缓冲区</span></span><br><span class="line"><span class="number">484</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffer_list</span>;</span><span class="comment">//buffer_list 为当前匹配的缓冲区列表。</span></span><br><span class="line"><span class="number">485</span> <span class="type">int</span> scan_bytes;<span class="comment">//scan_bytes 为捕获到，并且提供给缓冲区的字节数</span></span><br><span class="line"><span class="number">486</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mlock</span>;</span><span class="comment">//available_scan_masks 为可选的扫描位掩码，使用触发缓冲区的时候可以通过设</span></span><br><span class="line"><span class="number">487</span><span class="comment">//置掩码来确定使能哪些通道，使能以后的通道会将捕获到的数据发送到 IIO 缓冲区。</span></span><br><span class="line"><span class="number">488</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *available_scan_masks;</span><br><span class="line"><span class="number">489</span> <span class="type">unsigned</span> masklength;</span><br><span class="line"><span class="number">490</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *active_scan_mask;<span class="comment">//active_scan_mask 为缓冲区已经开启的通道掩码。只有这些使能了的通道数据才能被发送到缓冲区</span></span><br><span class="line"><span class="number">491</span> <span class="type">bool</span> scan_timestamp; <span class="comment">//scan_timestamp 为扫描时间戳，如果使能以后会将捕获时间戳放到缓冲区里面。</span></span><br><span class="line"><span class="number">492</span> <span class="type">unsigned</span> scan_index_timestamp;</span><br><span class="line"><span class="number">493</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger</span> *<span class="title">trig</span>;</span><span class="comment">//触发器</span></span><br><span class="line"><span class="number">494</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_poll_func</span> *<span class="title">pollfunc</span>;</span><span class="comment">//pollfunc 为一个函数，在接收到的触发器上运行</span></span><br><span class="line"><span class="number">495</span></span><br><span class="line"><span class="number">496</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">const</span> *<span class="title">channels</span>;</span><span class="comment">// IIO 设备通道</span></span><br><span class="line"><span class="number">497</span> <span class="type">int</span> num_channels;<span class="comment">//num_channels 为 IIO 设备的通道数</span></span><br><span class="line"><span class="number">498</span></span><br><span class="line"><span class="number">499</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">channel_attr_list</span>;</span></span><br><span class="line"><span class="number">500</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">chan_attr_group</span>;</span></span><br><span class="line"><span class="number">501</span> <span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//name 为 IIO 设备名字</span></span><br><span class="line"><span class="number">502</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="number">503</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">info_exist_lock</span>;</span></span><br><span class="line"><span class="number">504</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_setup_ops</span> *<span class="title">setup_ops</span>;</span></span><br><span class="line"><span class="number">505</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">chrdev</span>;</span><span class="comment">// chrdev 为字符设备，由 IIO 内核创建</span></span><br><span class="line">......</span><br><span class="line"><span class="number">515</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="操作集合iio-buffer-setup-ops"><a href="#操作集合iio-buffer-setup-ops" class="headerlink" title="操作集合iio_buffer_setup_ops"></a>操作集合iio_buffer_setup_ops</h4><p>第 504 行， 为 iio_buffer_setup_ops 结构体类型，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">427</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_setup_ops</span> &#123;</span></span><br><span class="line"><span class="number">428</span> <span class="type">int</span> (*preenable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区使能之前调用 */</span></span><br><span class="line"><span class="number">429</span> <span class="type">int</span> (*postenable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区使能之后调用 */</span></span><br><span class="line"><span class="number">430</span> <span class="type">int</span> (*predisable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区禁用之前调用 */</span></span><br><span class="line"><span class="number">431</span> <span class="type">int</span> (*postdisable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区禁用之后调用 */</span></span><br><span class="line"><span class="number">432</span> <span class="type">bool</span> (*validate_scan_mask)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line"><span class="number">433</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *scan_mask); <span class="comment">/* 检查扫描掩码是否有效 */</span></span><br><span class="line"><span class="number">434</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="iio-dev-申请与释放"><a href="#iio-dev-申请与释放" class="headerlink" title="iio_dev 申请与释放"></a>iio_dev 申请与释放</h4><p>在使用之前要先申请 iio_dev，申请函数为 iio_device_alloc，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> iio_dev *<span class="title function_">iio_device_alloc</span><span class="params">(<span class="type">int</span> sizeof_priv)</span></span><br></pre></td></tr></table></figure><p>sizeof_priv： 私有数据内存空间大小，一般我们会将自己定义的设备结构体变量作为 iio_dev的私有数据，这样可以直接通过 iio_device_alloc 函数同时完成 iio_dev 和设备结构体变量的内存申请。 申请成功以后使用 iio_priv 函数来得到自定义的设备结构体变量首地址。<br>返回值：如果申请成功就返回 iio_dev 首地址，如果失败就返回 NULL。<br>一般 iio_device_alloc 和 iio_priv 之间的配合使用如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span>;</span><span class="comment">// icm20608_dev 是自定义的设备结构体。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> *<span class="title">indio_dev</span>;</span><span class="comment">// indio_dev 是 iio_dev 结构体变量指针。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1、申请 iio_dev 内存 */</span></span><br><span class="line">indio_dev = iio_device_alloc(<span class="keyword">sizeof</span>(*dev));<span class="comment">//使用 iio_device_alloc 函数来申请 iio_dev，并且一起申请了icm2060_dev 的内存。</span></span><br><span class="line"><span class="keyword">if</span> (!indio_dev)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、获取设备结构体变量地址 */</span>c</span><br><span class="line">dev = iio_priv(indio_dev);<span class="comment">//使用 iio_priv 函数从 iio_dev 中提取出私有数据，也就是 icm2608_dev 这个自定义结构体变量首地址。</span></span><br></pre></td></tr></table></figure><p>如果要释放 iio_dev，需要使用 iio_device_free 函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iio_device_free</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev)</span><span class="comment">//indio_dev： 需要释放的 iio_dev。</span></span><br></pre></td></tr></table></figure><h4 id="iio-dev-注册与注销"><a href="#iio-dev-注册与注销" class="headerlink" title="iio_dev 注册与注销"></a>iio_dev 注册与注销</h4><p>前面分配好 iio_dev 以后就要初始化各种成员变量，初始化完成以后就需要将 iio_dev 注册到内核中，需要用到 iio_device_register 函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">iio_device_register</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev)</span><span class="comment">//indio_dev： 需要注册的 iio_dev。</span></span><br></pre></td></tr></table></figure><p>返回值： 0，成功；其他值，失败。<br>如果要注销 iio_dev 使用 iio_device_unregister 函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iio_device_unregister</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev)</span><span class="comment">//indio_dev： 需要注销的 iio_dev。</span></span><br></pre></td></tr></table></figure><p>返回值： 0，成功；其他值，失败</p><h4 id="iio-info"><a href="#iio-info" class="headerlink" title="iio_info"></a>iio_info</h4><p>iio_dev 有个成员变量： info，为 iio_info 结构体指针变量，这个是我们在编写 IIO 驱动的时候需要着重去实现的，因为用户空间对设备的具体操作最终都会反映到 iio_info 里面。 iio_info结构体定义在 include&#x2F;linux&#x2F;iio&#x2F;iio.h 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">352</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span> &#123;</span></span><br><span class="line"><span class="number">353</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">driver_module</span>;</span></span><br><span class="line"><span class="number">354</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> *<span class="title">event_attrs</span>;</span></span><br><span class="line"><span class="number">355</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> *<span class="title">attrs</span>;</span><span class="comment">//attrs 是通用的设备属性。</span></span><br><span class="line"><span class="number">356</span></span><br><span class="line"><span class="number">357</span> <span class="type">int</span> (*read_raw)(<span class="keyword">struct</span> iio_dev *indio_dev, <span class="comment">//读设备内部数据函数 indio_dev为读写设备</span></span><br><span class="line"><span class="number">358</span> <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,<span class="comment">//需要读取的通道</span></span><br><span class="line"><span class="number">359</span> <span class="type">int</span> *val,<span class="comment">// 是数据值，val 是整数部分， val2 是小数部分</span></span><br><span class="line"><span class="number">360</span> <span class="type">int</span> *val2,</span><br><span class="line"><span class="number">361</span> <span class="type">long</span> mask); <span class="comment">//掩码</span></span><br><span class="line">......</span><br><span class="line"><span class="number">369</span></span><br><span class="line"><span class="number">370</span> <span class="type">int</span> (*write_raw)(<span class="keyword">struct</span> iio_dev *indio_dev,<span class="comment">//写设备内部数据函数</span></span><br><span class="line"><span class="number">371</span> <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span><br><span class="line"><span class="number">372</span> <span class="type">int</span> val,<span class="comment">//应用程序从内核空间读取到数据</span></span><br><span class="line"><span class="number">373</span> <span class="type">int</span> val2,</span><br><span class="line"><span class="number">374</span> <span class="type">long</span> mask);</span><br><span class="line"><span class="number">375</span></span><br><span class="line"><span class="number">376</span> <span class="type">int</span> (*write_raw_get_fmt)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line"><span class="number">377</span> <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span><br><span class="line"><span class="number">378</span> <span class="type">long</span> mask);</span><br><span class="line">......</span><br><span class="line"><span class="number">415</span> &#125;;</span><br></pre></td></tr></table></figure><p>Linux 内核使用 iio_chan_spec 结构体来描述通道，定义在 include&#x2F;linux&#x2F;iio&#x2F;iio.h 文件中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">223</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> &#123;</span></span><br><span class="line"><span class="number">224</span> <span class="class"><span class="keyword">enum</span> <span class="title">iio_chan_type</span> <span class="title">type</span>;</span></span><br><span class="line"><span class="number">225</span> <span class="type">int</span> channel;</span><br><span class="line"><span class="number">226</span> <span class="type">int</span> channel2;</span><br><span class="line"><span class="number">227</span> <span class="type">unsigned</span> <span class="type">long</span> address;</span><br><span class="line"><span class="number">228</span> <span class="type">int</span> scan_index;</span><br><span class="line"><span class="number">229</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="number">230</span> <span class="type">char</span> sign;</span><br><span class="line"><span class="number">231</span> u8 realbits;</span><br><span class="line"><span class="number">232</span> u8 storagebits;</span><br><span class="line"><span class="number">233</span> u8 shift;</span><br><span class="line"><span class="number">234</span> u8 repeat;</span><br><span class="line"><span class="number">235</span> <span class="class"><span class="keyword">enum</span> <span class="title">iio_endian</span> <span class="title">endianness</span>;</span></span><br><span class="line"><span class="number">236</span> &#125; scan_type;</span><br><span class="line"><span class="number">237</span> <span class="type">long</span> info_mask_separate;</span><br><span class="line"><span class="number">238</span> <span class="type">long</span> info_mask_shared_by_type;<span class="comment">// info_mask_shared_by_type 标记导出的信息由相同类型的通道共享。</span></span><br><span class="line"><span class="number">239</span> <span class="type">long</span> info_mask_shared_by_dir;<span class="comment">//info_mask_shared_by_dir 标记某些导出的信息由相同方向的通道共享。</span></span><br><span class="line"><span class="number">240</span> <span class="type">long</span> info_mask_shared_by_all;</span><br><span class="line"><span class="number">241</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_event_spec</span> *<span class="title">event_spec</span>;</span></span><br><span class="line"><span class="number">242</span> <span class="type">unsigned</span> <span class="type">int</span> num_event_specs;</span><br><span class="line"><span class="number">243</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec_ext_info</span> *<span class="title">ext_info</span>;</span></span><br><span class="line"><span class="number">244</span> <span class="type">const</span> <span class="type">char</span> *extend_name;</span><br><span class="line"><span class="number">245</span> <span class="type">const</span> <span class="type">char</span> *datasheet_name;</span><br><span class="line"><span class="number">246</span> <span class="type">unsigned</span> modified:<span class="number">1</span>;<span class="comment">//modified 为 1 的时候， channel2 为通道修饰符。</span></span><br><span class="line"><span class="number">247</span> <span class="type">unsigned</span> indexed:<span class="number">1</span>;<span class="comment">//indexed 为 1 的时候， channel 为通道索引。</span></span><br><span class="line"><span class="number">248</span> <span class="type">unsigned</span> output:<span class="number">1</span>;<span class="comment">//</span></span><br><span class="line"><span class="number">249</span> <span class="type">unsigned</span> differential:<span class="number">1</span>;<span class="comment">//differential为差分通道</span></span><br><span class="line"><span class="number">250</span> &#125;;</span><br></pre></td></tr></table></figure><p>来看一下 iio_chan_spec 结构体中一些比较重要的成员变量：<br>第 224 行， type 为通道类型， iio_chan_type 是一个枚举类型，列举出了可以选择的通道类型，定义在 include&#x2F;uapi&#x2F;linux&#x2F;iio&#x2F;types.h 文件里面，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span> <span class="class"><span class="keyword">enum</span> <span class="title">iio_chan_type</span> &#123;</span></span><br><span class="line"><span class="number">14</span> IIO_VOLTAGE, <span class="comment">/* 电压类型 */</span></span><br><span class="line"><span class="number">15</span> IIO_CURRENT, <span class="comment">/* 电流类型 */</span></span><br><span class="line"><span class="number">16</span> IIO_POWER, <span class="comment">/* 功率类型 */</span></span><br><span class="line"><span class="number">17</span> IIO_ACCEL, <span class="comment">/* 加速度类型 */</span></span><br><span class="line"><span class="number">18</span> IIO_ANGL_VEL, <span class="comment">/* 角度类型(陀螺仪) */</span></span><br><span class="line"><span class="number">19</span> IIO_MAGN, <span class="comment">/* 电磁类型(磁力计) */</span></span><br><span class="line"><span class="number">20</span> IIO_LIGHT, <span class="comment">/* 灯光类型 */</span></span><br><span class="line"><span class="number">21</span> IIO_INTENSITY, <span class="comment">/* 强度类型(光强传感器) */</span></span><br><span class="line"><span class="number">22</span> IIO_PROXIMITY, <span class="comment">/* 接近类型(接近传感器) */</span></span><br><span class="line"><span class="number">23</span> IIO_TEMP, <span class="comment">/* 温度类型 */</span></span><br><span class="line"><span class="number">24</span> IIO_INCLI, <span class="comment">/* 倾角类型(倾角测量传感器) */</span></span><br><span class="line"><span class="number">25</span> IIO_ROT, <span class="comment">/* 旋转角度类型 */</span></span><br><span class="line"><span class="number">26</span> IIO_ANGL, <span class="comment">/* 转动角度类型(电机旋转角度测量传感器) */</span></span><br><span class="line"><span class="number">27</span> IIO_TIMESTAMP, <span class="comment">/* 时间戳类型 */</span></span><br><span class="line"><span class="number">28</span> IIO_CAPACITANCE, <span class="comment">/* 电容类型 */</span></span><br><span class="line"><span class="number">29</span> IIO_ALTVOLTAGE, <span class="comment">/* 频率类型 */</span></span><br><span class="line"><span class="number">30</span> IIO_CCT, <span class="comment">/* 笔者暂时未知的类型 */</span></span><br><span class="line"><span class="number">31</span> IIO_PRESSURE, <span class="comment">/* 压力类型 */</span></span><br><span class="line"><span class="number">32</span> IIO_HUMIDITYRELATIVE, <span class="comment">/* 湿度类型 */</span></span><br><span class="line"><span class="number">33</span> IIO_ACTIVITY, <span class="comment">/* 活动类型(计步传感器) */</span></span><br><span class="line"><span class="number">34</span> IIO_STEPS, <span class="comment">/* 步数类型 */</span></span><br><span class="line"><span class="number">35</span> IIO_ENERGY, <span class="comment">/* 能量类型(卡路里) */</span></span><br><span class="line"><span class="number">36</span> IIO_DISTANCE, <span class="comment">/* 距离类型 */</span></span><br><span class="line"><span class="number">37</span> IIO_VELOCITY, <span class="comment">/* 速度类型 */</span></span><br><span class="line"><span class="number">38</span> &#125;;</span><br></pre></td></tr></table></figure><p>目前 Linux 内核支持的传感器类型非常丰富，而且支持类型也会不断的增加。如果是 ADC，那就是 IIO_VOLTAGE 类型。如果是 ICM20608 这样的多轴传感器，那么就是复合类型了，陀螺仪部分是 IIO_ANGL_VEL 类型，加速度计部分是IIO_ACCEL 类型，温度部分是IIO_TEMP。</p><h3 id="设备驱动框架"><a href="#设备驱动框架" class="headerlink" title="设备驱动框架"></a>设备驱动框架</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 自定义设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span>;</span> <span class="comment">/* spi 设备 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *<span class="title">regmap</span>;</span> <span class="comment">/* regmap */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap_config</span> <span class="title">regmap_config</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通道数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">xxx_channels</span>[] =</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 读函数，当读取 sysfs 中的文件的时候最终此函数会执行，</span></span><br><span class="line"><span class="comment">* ：此函数里面会从传感器里面读取各种数据，然后上传给应用。</span></span><br><span class="line"><span class="comment">* @param - indio_dev : IIO 设备</span></span><br><span class="line"><span class="comment">* @param - chan : 通道</span></span><br><span class="line"><span class="comment">* @param - val : 读取的值，如果是小数值的话， val 是整数部分。</span></span><br><span class="line"><span class="comment">* @param - val2 : 读取的值，如果是小数值的话， val2 是小数部分。</span></span><br><span class="line"><span class="comment">* @param - mask : 掩码。</span></span><br><span class="line"><span class="comment">* @return : 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_read_raw</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev,<span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,<span class="type">int</span> *val, <span class="type">int</span> *val2, </span></span><br><span class="line"><span class="params">                        <span class="type">long</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 写函数，当向 sysfs 中的文件写数据的时候最终此函数</span></span><br><span class="line"><span class="comment">* ：会执行，一般在此函数里面设置传感器，比如量程等。</span></span><br><span class="line"><span class="comment">* @param - indio_dev : IIO 设备</span></span><br><span class="line"><span class="comment">* @param - chan : 通道</span></span><br><span class="line"><span class="comment">* @param - val : 应用程序写入值，如果是小数的话， val 是整数部分。</span></span><br><span class="line"><span class="comment">* @param - val2 : 应用程序写入值，如果是小数的话， val2 是小数部分。</span></span><br><span class="line"><span class="comment">* @return : 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_write_raw</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span></span><br><span class="line"><span class="params"><span class="type">int</span> val, <span class="type">int</span> val2, <span class="type">long</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 用户空间写数据格式，比如我们在用户空间操作 sysfs 来设</span></span><br><span class="line"><span class="comment">* ：置传感器的分辨率，如果分辨率带小数，那么这个小数传递到</span></span><br><span class="line"><span class="comment">* : 内核空间应该扩大多少倍，此函数就是用来设置这个的。</span></span><br><span class="line"><span class="comment">* @param - indio_dev : iio_dev</span></span><br><span class="line"><span class="comment">* @param - chan : 通道</span></span><br><span class="line"><span class="comment">* @param - mask : 掩码</span></span><br><span class="line"><span class="comment">* @return : 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_write_raw_get_fmt</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan, <span class="type">long</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* iio_info 结构体变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span> <span class="title">xxx_info</span> =</span> &#123;</span><br><span class="line">.read_raw = xxx_read_raw,</span><br><span class="line">.write_raw = xxx_write_raw,</span><br><span class="line">.write_raw_get_fmt = &amp;xxx_write_raw_get_fmt,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : spi 驱动的 probe 函数，当驱动与</span></span><br><span class="line"><span class="comment">* 设备匹配以后此函数就会执行</span></span><br><span class="line"><span class="comment">* @param - spi : spi 设备</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> *<span class="title">indio_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1、申请 iio_dev 内存 */</span></span><br><span class="line">indio_dev = devm_iio_device_alloc(&amp;spi-&gt;dev, <span class="keyword">sizeof</span>(*data));</span><br><span class="line"><span class="keyword">if</span> (!indio_dev)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、获取 xxx_dev 结构体地址 */</span></span><br><span class="line">data = iio_priv(indio_dev);</span><br><span class="line">data-&gt;spi = spi;</span><br><span class="line">spi_set_drvdata(spi, indio_dev);</span><br><span class="line">mutex_init(&amp;data-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、初始化 iio_dev 成员变量 */</span></span><br><span class="line">indio_dev-&gt;dev.parent = &amp;spi-&gt;dev;</span><br><span class="line">indio_dev-&gt;info = &amp;xxx_info;</span><br><span class="line">indio_dev-&gt;name = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">indio_dev-&gt;modes = INDIO_DIRECT_MODE; <span class="comment">/* 直接模式 /</span></span><br><span class="line"><span class="comment">indio_dev-&gt;channels = xxx_channels;</span></span><br><span class="line"><span class="comment">indio_dev-&gt;num_channels = ARRAY_SIZE(xxx_channels);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">iio_device_register(indio_dev);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/* 4、 regmap 相关设置 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、 SPI 相关设置*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6、芯片初始化 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : spi 驱动的 remove 函数，移除 spi 驱动的时候此函数会执行</span></span><br><span class="line"><span class="comment">* @param - spi : spi 设备</span></span><br><span class="line"><span class="comment">* @return : 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> *<span class="title">indio_dev</span> =</span> spi_get_drvdata(spi);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">data</span>;</span></span><br><span class="line">data = iio_priv(indio_dev); ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1、其他资源的注销以及释放 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、注销 IIO */</span></span><br><span class="line">iio_device_unregister(indio_dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络驱动</title>
      <link href="/2023/08/13/2023-8-13-%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/08/13/2023-8-13-%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="网络驱动硬件"><a href="#网络驱动硬件" class="headerlink" title="网络驱动硬件"></a>网络驱动硬件</h3><p>嵌入式网络硬件分为两部分： MAC 和 PHY，大家都是通过看数据手册来判断一款 SOC 是否支持网络，如果一款芯片数据手册说自己支持网络，一般都是说的这款 SOC 内置 MAC， MAC 类似 I2C 控制器、 SPI 控制器一样的外设。但是光有 MAC还不能直接驱动网络，还需要另外一个芯片： PHY，因此对于内置 MAC 的 SOC，其外部必须搭配一个 PHY 芯片。但是有些 SOC 内部没有 MAC，那也就没法搭配 PHY 芯片了，这些内部没有网络 MAC 的芯片如何上网呢？这里就要牵扯出常见的两个嵌入式网络硬件方案了 </p><p><strong>1、 SOC 内部没有网络 MAC 外设</strong><br>我们一般说某个 SOC 不支持网络，说的就是它没有网络 MAC。那么这个芯片就不能上网了吗？显然不是的，既然没有内部 MAC，那么可以找个外置的 MAC 芯片啊，不过一般这种外置的网络芯片都是 MAC+PHY 一体的。 </p><p>这种方案的优点就是让不支持网络的 SOC 能够另辟蹊径，实现网络功能，但是缺点就是网络效率不高，因为一般芯片内置的 MAC 会有网络加速引擎，比如网络专用 DMA，网络处理效率会很高。而且此类芯片网速都不快，基本就是 10&#x2F;100M。 </p><p><strong>2、 SOC 内部集成网络 MAC 外设</strong></p><p>我们一般说某个 SOC 支持网络，说的就是他内部集成网络 MAC 外设，此时我们还需要外接一个网络 PHY 芯片。</p><p>内部集成网络 MAC 的优点如下： </p><p>①、内部 MAC 外设会有专用的加速模块，比如专用的 DMA，加速网速数据的处理。<br>②、网速快，可以支持 10&#x2F;100&#x2F;1000M 网速。<br>③、外接 PHY 可选择性多，成本低。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-13%20130028.png"></p><p>MII接口</p><p>MII 全称是 Media Independent Interface，直译过来就是介质独立接口，它是 IEEE-802.3 定义的以太网标准接口 。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-13%20130138.png"></p><p>MII接口一共16根线，</p><p>TX_CLK： 发送时钟，如果网速为 100M 的话时钟频率为 25MHz， 10M 网速的话时钟频率为 2.5MHz，此时钟由 PHY 产生并发送给 MAC。<br>TX_EN： 发送使能信号。<br>TX_ER： 发送错误信号，高电平有效，表示 TX_ER 有效期内传输的数据无效。 10Mpbs 网速下 TX_ER 不起作用。<br>TXD[3:0]：发送数据信号线，一共 4 根。<br>RXD[3:0]： 接收数据信号线，一共 4 根。<br>RX_CLK： 接收时钟信号，如果网速为 100M 的话时钟频率为 25MHz， 10M 网速的话时钟频率为 2.5MHz， RX_CLK 也是由 PHY 产生的。<br>RX_ER： 接收错误信号，高电平有效，表示 RX_ER 有效期内传输的数据无效。 10Mpbs 网速下 RX_ER 不起作用。<br>RX_DV： 接收数据有效，作用类似 TX_EN。<br>CRS： 载波侦听信号。<br>COL： 冲突检测信号 </p><p>RMII 全称是 Reduced Media Independent Interface，翻译过来就是精简的介质独立接口，也就是 MII 接口的精简版本。 RMII 接口只需要 7 根数据线， </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-13%20130321.png"></p><p>TX_EN： 发送使能信号。<br>TXD[1:0]： 发送数据信号线，一共 2 根。<br>RXD[1:0]：接收数据信号线，一共 2 根。<br>CRS_DV： 相当于 MII 接口中的 RX_DV 和 CRS 这两个信号的混合。<br>REF_CLK： 参考时钟，由外部时钟源提供， 频率为 50MHz。这里与 MII 不同， MII 的接收和发送时钟是独立分开的，而且都是由 PHY 芯片提供的。</p><p><strong>嵌入式网络硬件框图</strong></p><p>一个 MAC 连接一个 PHY 芯片形成一个完整网络接口 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-13%20133933.png"></p><p>PHY 是 IEEE 802.3 规定的一个标准模块，前面说了， SOC 可以对 PHY 进行配置或者读取PHY 相关状态，这个就需要 PHY 内部寄存器去实现了。 PHY 芯片寄存器地址空间为 5 位，地址 0<del>31 共 32 个寄存器， IEEE 定义了 0</del>15 这 16 个寄存器的功能， 16~31 这 16 个寄存器由厂商自行实现。 后面16位的引脚为不同厂商的特色功能引脚，前16位就能保证基本的网络数据通信。</p><h3 id="LAN8720A-（PHY芯片）详解"><a href="#LAN8720A-（PHY芯片）详解" class="headerlink" title="LAN8720A （PHY芯片）详解"></a>LAN8720A （PHY芯片）详解</h3><p>1、 LAN8720A 简介<br>LAN8720A 是低功耗的 10&#x2F;100M 单以太网 PHY 层芯片， 可应用于机顶盒、网络打印机、嵌入式通信设备、 IP 电话等领域。 I&#x2F;O 引脚电压符合 IEEE802.3-2005 标准。 LAN8720A 支持通过 RMII 接口与以太网 MAC 层通信，内置 10-BASE-T&#x2F;100BASE-TX 全双工传输模块，支持10Mbps 和 100Mbps。 LAN8720A 可以通过自协商的方式选择与目的主机最佳的连接方式(速度和双工模式)。支持 HP Auto-MDIX 自动翻转功能，无需更换网线即可将连接更改为直连或交叉连接。<br>LAN8720A 的主要特点如下：<br>· 高性能的 10&#x2F;100M 以太网传输模块<br>· 支持 RMII 接口以减少引脚数<br>· 支持全双工和半双工模式<br>· 两个状态 LED 输出<br>· 可以使用 25M 晶振以降低成本<br>· 支持自协商模式<br>· 支持 HP Auto-MDIX 自动翻转功能<br>· 支持 SMI 串行管理接口<br>· 支持 MAC 接口 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-14%20110141.png"></p><p>LAN8720A 的器件管理接口支持非 IEEE 802.3 规范的中断功能。当一个中断事件发生并且相应事件的中断位使能， LAN8720A 就会在 nINT(14 脚)产生一个低电平有效的中断信号。LAN8720A 的中断系统提供两种中断模式：主中断模式和复用中断模式。主中断模式是默认中断模式， LAN8720A 上电或复位后就工作在主中断模式，当模式控制&#x2F;状态寄存器(十进制地址为 17)的 ALTINT 位为 0 时 LAN8720A 工作在主模式，当 ALTINT 位为 1 时工作在复用中断模式。 </p><p>MAC 层通过 MDIO&#x2F;MDC 总线对 PHY 进行读写操作， MDIO 最多可以控制 32 个 PHY 芯片，通过不同的 PHY 芯片地址来对不同的 PHY 操作。 LAN8720A 通过设置 RXER&#x2F;PHYAD0引脚来设置其 PHY 地址，默认情况下为 0，其地址设置如表 </p><table><thead><tr><th>RXER&#x2F;PHYAD0 引脚状态</th><th>PHY 地址</th></tr></thead><tbody><tr><td>上拉</td><td>0X01</td></tr><tr><td>下拉(默认)</td><td>0X00</td></tr></tbody></table><p>nINTSEL 引脚(2 号引脚)用于设置 nINT&#x2F;REFCLKO 引脚(14 号引脚)的功能。 nINTSEL 配置如表 </p><table><thead><tr><th>nINTSEL 引脚值</th><th>模式</th><th>nINT&#x2F;REFCLKO 引脚功能</th></tr></thead><tbody><tr><td>nINTSEL&#x3D; 0</td><td>REF_CLK Out 模式</td><td>nINT&#x2F;REFCLKO 作为 REF_CLK 时钟源</td></tr><tr><td>nINTSEL &#x3D; 1(默认)</td><td>REF_CLK In 模式</td><td>nINT&#x2F;REFCLKO 作为中断引脚</td></tr></tbody></table><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-14%20110621.png"></p><p>LAN8720寄存器引脚</p><table><thead><tr><th>位</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>15</td><td>软件复位 1：软件复位，此位自动清零</td><td>R&#x2F;W</td></tr><tr><td>14</td><td>回测 0：正常运行 1：使能回测模式</td><td>R&#x2F;W</td></tr><tr><td>13</td><td>速度选择 0： 10Mbps 1： 100Mbps 注意：当使用自动协商功能时此位失能</td><td>R&#x2F;W</td></tr><tr><td>12</td><td>自动协商功能 0：关闭自动协商功能 1：打开自动协商功能</td><td>R&#x2F;W</td></tr><tr><td>11</td><td>掉电（ power down） 0：正常运行 1：进入掉电模式 注意:进入掉电模式前自动协商必须失能</td><td>R&#x2F;W</td></tr><tr><td>10</td><td>隔离 0：正常运行</td><td>R&#x2F;W</td></tr><tr><td>9</td><td>重启自动协商功能 0：正常运行 1：重启自动协商功能 注意:此位会被自动清零</td><td>R&#x2F;W SC</td></tr><tr><td>8</td><td>双工模式 0：半双工 1：全双工 注意:开启自动协商功能后此位失效</td><td>R&#x2F;W</td></tr><tr><td>7:0</td><td>保留</td><td>RO</td></tr></tbody></table><h3 id="Linux内核网络驱动框架"><a href="#Linux内核网络驱动框架" class="headerlink" title="Linux内核网络驱动框架"></a>Linux内核网络驱动框架</h3><p>Linux 内核使用 net_device 结构体表示一个具体的网络设备， <strong>net_device</strong> 是整个网络驱动的灵魂。网络驱动的<strong>核心就是初始化 net_device 结构体中的各个成员变量</strong>，然后将初始化完成以后的 net_device <strong>注册到 Linux 内核中</strong>。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">char</span> name[IFNAMSIZ];<span class="comment">//name 是网络设备的名字。</span></span><br><span class="line"><span class="number">3</span> <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">name_hlist</span>;</span></span><br><span class="line"><span class="number">4</span> <span class="type">char</span> *ifalias;</span><br><span class="line"><span class="number">5</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">6 * I/O specific fields</span></span><br><span class="line"><span class="comment">7 * <span class="doctag">FIXME:</span> Merge these and struct ifmap into one</span></span><br><span class="line"><span class="comment">8 */</span></span><br><span class="line"><span class="number">9</span> <span class="type">unsigned</span> <span class="type">long</span> mem_end;<span class="comment">//mem_end 是共享内存结束地址。</span></span><br><span class="line"><span class="number">10</span> <span class="type">unsigned</span> <span class="type">long</span> mem_start;<span class="comment">//mem_start 是共享内存起始地址。</span></span><br><span class="line"><span class="number">11</span> <span class="type">unsigned</span> <span class="type">long</span> base_addr;<span class="comment">//base_addr 是网络设备 I/O 地址。</span></span><br><span class="line"><span class="number">12</span> <span class="type">int</span> irq;<span class="comment">//irq 是网络设备的中断号。</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="type">atomic_t</span> carrier_changes;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">17 * Some hardware also needs these fields (state,dev_list,</span></span><br><span class="line"><span class="comment">18 * napi_list,unreg_list,close_list) but they are not</span></span><br><span class="line"><span class="comment">19 * part of the usual set specified in Space.c.</span></span><br><span class="line"><span class="comment">20 */</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dev_list</span>;</span><span class="comment">//dev_list 是全局网络设备列表。</span></span><br><span class="line"><span class="number">25</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">napi_list</span>;</span><span class="comment">//napi_list 是 napi 网络设备的列表入口。</span></span><br><span class="line"><span class="number">26</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">unreg_list</span>;</span><span class="comment">//unreg_list 是注销(unregister)的网络设备列表入口。</span></span><br><span class="line"><span class="number">27</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">close_list</span>;</span><span class="comment">//close_list 是关闭的网络设备列表入口。</span></span><br><span class="line">......</span><br><span class="line"><span class="number">60</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> *<span class="title">netdev_ops</span>;</span><span class="comment">/*netdev_ops 是网络设备的操作集函数，包含了一系列的网络设备操作回调函数，类似字符设备中的 file_operations，稍后会讲解 netdev_ops 结构体。*/</span></span><br><span class="line"><span class="number">61</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_ops</span> *<span class="title">ethtool_ops</span>;</span><span class="comment">/*ethtool_ops 是网络管理工具相关函数集，用户空间网络管理工具会调用此结构体中的相关函数获取网卡状态或者配置网卡。*/</span></span><br><span class="line"><span class="number">62</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_SWITCHDEV</span></span><br><span class="line"><span class="number">63</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">swdev_ops</span> *<span class="title">swdev_ops</span>;</span></span><br><span class="line"><span class="number">64</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="number">66</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">header_ops</span> *<span class="title">header_ops</span>;</span><span class="comment">// header_ops 是头部的相关操作函数集，比如创建、解析、缓冲等。</span></span><br><span class="line"><span class="number">67</span></span><br><span class="line"><span class="number">68</span> <span class="type">unsigned</span> <span class="type">int</span> flags;<span class="comment">//flags 是网络接口标志</span></span><br><span class="line">......</span><br><span class="line"><span class="number">77</span> <span class="type">unsigned</span> <span class="type">char</span> if_port;<span class="comment">//if_port 指定接口的端口类型，如果设备支持多端口的话就通过 if_port 来指定所使用的端口类型。</span></span><br><span class="line"><span class="number">78</span> <span class="type">unsigned</span> <span class="type">char</span> dma;<span class="comment">//dma 是网络设备所使用的 DMA 通道，不是所有的设备都会用到 DMA。</span></span><br><span class="line"><span class="number">79</span></span><br><span class="line"><span class="number">80</span> <span class="type">unsigned</span> <span class="type">int</span> mtu;<span class="comment">//mtu 是网络最大传输单元，为 1500</span></span><br><span class="line"><span class="number">81</span> <span class="type">unsigned</span> <span class="type">short</span> type;<span class="comment">//type 用于指定 ARP 模块的类型，以太网的 ARP 接口为 ARPHRD_ETHER</span></span><br><span class="line"><span class="number">82</span> <span class="type">unsigned</span> <span class="type">short</span> hard_header_len;<span class="comment">//perm_addr 是永久的硬件地址</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">84</span> <span class="type">unsigned</span> <span class="type">short</span> needed_headroom;</span><br><span class="line"><span class="number">85</span> <span class="type">unsigned</span> <span class="type">short</span> needed_tailroom;</span><br><span class="line"><span class="number">86</span></span><br><span class="line"><span class="number">87</span> <span class="comment">/* Interface address info. */</span></span><br><span class="line"><span class="number">88</span> <span class="type">unsigned</span> <span class="type">char</span> perm_addr[MAX_ADDR_LEN];</span><br><span class="line"><span class="number">89</span> <span class="type">unsigned</span> <span class="type">char</span> addr_assign_type;</span><br><span class="line"><span class="number">90</span> <span class="type">unsigned</span> <span class="type">char</span> addr_len;<span class="comment">//addr_len 是硬件地址长度</span></span><br><span class="line">......</span><br><span class="line"><span class="number">130</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">131 * Cache lines mostly used on receive path (including</span></span><br><span class="line"><span class="comment">eth_type_trans())</span></span><br><span class="line"><span class="comment">132 */</span></span><br><span class="line"><span class="number">133</span> <span class="type">unsigned</span> <span class="type">long</span> last_rx;<span class="comment">//last_rx 是最后接收的数据包时间戳，记录的是 jiffies</span></span><br><span class="line"><span class="number">134</span></span><br><span class="line"><span class="number">135</span> <span class="comment">/* Interface address info used in eth_type_trans() */</span></span><br><span class="line"><span class="number">136</span> <span class="type">unsigned</span> <span class="type">char</span> *dev_addr;<span class="comment">//dev_addr 也是硬件地址，是当前分配的 MAC 地址，可以通过软件修改。</span></span><br><span class="line"><span class="number">137</span></span><br><span class="line"><span class="number">138</span></span><br><span class="line"><span class="number">139</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line"><span class="number">140</span> <span class="class"><span class="keyword">struct</span> <span class="title">netdev_rx_queue</span> *_<span class="title">rx</span>;</span><span class="comment">//_rx 是接收队列。</span></span><br><span class="line"><span class="number">141</span></span><br><span class="line"><span class="number">142</span> <span class="type">unsigned</span> <span class="type">int</span> num_rx_queues;<span class="comment">/*num_rx_queues 是接收队列数量，在调用 register_netdev 注册网络设备的时候会</span></span><br><span class="line"><span class="comment">分配指定数量的接收队列。*/</span></span><br><span class="line"><span class="number">143</span> <span class="type">unsigned</span> <span class="type">int</span> real_num_rx_queues;<span class="comment">//real_num_rx_queues 是当前活动的队列数量。</span></span><br><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">145</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line"><span class="number">158</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">159 * Cache lines mostly used on transmit path</span></span><br><span class="line"><span class="comment">160 */</span></span><br><span class="line"><span class="number">161</span> <span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span> *_<span class="title">tx</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span><span class="comment">//_tx 是发送队列。</span></span><br><span class="line"><span class="number">162</span> <span class="type">unsigned</span> <span class="type">int</span> num_tx_queues;<span class="comment">/*num_tx_queues 是发送队列数量，通过 alloc_netdev_mq 函数分配指定数量的发</span></span><br><span class="line"><span class="comment">送队列。*/</span></span><br><span class="line"><span class="number">163</span> <span class="type">unsigned</span> <span class="type">int</span> real_num_tx_queues;<span class="comment">//real_num_tx_queues 是当前有效的发送队列数量。</span></span><br><span class="line"><span class="number">164</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">qdisc</span>;</span></span><br><span class="line"><span class="number">165</span> <span class="type">unsigned</span> <span class="type">long</span> tx_queue_len;</span><br><span class="line"><span class="number">166</span> <span class="type">spinlock_t</span> tx_global_lock;</span><br><span class="line"><span class="number">167</span> <span class="type">int</span> watchdog_timeo;</span><br><span class="line">......</span><br><span class="line"><span class="number">173</span> <span class="comment">/* These may be needed for future network-power-down code. */</span></span><br><span class="line"><span class="number">174</span></span><br><span class="line"><span class="number">175</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">176 * trans_start here is expensive for high speed devices on SMP,</span></span><br><span class="line"><span class="comment">177 * please use netdev_queue-&gt;trans_start instead.</span></span><br><span class="line"><span class="comment">178 */</span></span><br><span class="line"><span class="number">179</span> <span class="type">unsigned</span> <span class="type">long</span> trans_start;<span class="comment">//trans_start 是最后的数据包发送的时间戳，记录的是 jiffies。</span></span><br><span class="line">......</span><br><span class="line"><span class="number">248</span> <span class="class"><span class="keyword">struct</span> <span class="title">phy_device</span> *<span class="title">phydev</span>;</span><span class="comment">//phydev 是对应的 PHY 设备。</span></span><br><span class="line"><span class="number">249</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">qdisc_tx_busylock</span>;</span></span><br><span class="line"><span class="number">250</span> &#125;;</span><br></pre></td></tr></table></figure><p>申请 net_device<br>编写网络驱动的时候首先要申请 net_device，使用 alloc_netdev 函数来申请 net_device，这是一个宏，宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_netdev(sizeof_priv, name, name_assign_type, setup) alloc_netdev_mqs(sizeof_priv, name, name_assign_type, setup, 1, 1)</span></span><br></pre></td></tr></table></figure><p>可以看出 alloc_netdev 的本质是 alloc_netdev_mqs 函数，此函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net_device * <span class="title function_">alloc_netdev_mqs</span> <span class="params">( <span class="type">int</span> sizeof_priv,<span class="comment">//sizeof_priv： 私有数据块大小。</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name,<span class="comment">//name： 设备名字。</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> (*setup) (<span class="keyword">struct</span> net_device *))</span><span class="comment">//setup： 回调函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> txqs,<span class="comment">//txqs： 分配的发送队列数量。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rxqs);<span class="comment">//rxqs： 分配的接收队列数量。</span></span><br></pre></td></tr></table></figure><p>返回值： 如果申请成功的话就返回申请到的 net_device 指针，失败的话就返回 NULL。</p><p>以太网的网络初始化封装为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_etherdev_mq(sizeof_priv, count)alloc_etherdev_mqs(sizeof_priv, count, count)</span></span><br></pre></td></tr></table></figure><p>ether_setup 函数会对 net_device 做初步的初始化，函数内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ether_setup</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;header_ops = &amp;eth_header_ops;</span><br><span class="line">dev-&gt;type = ARPHRD_ETHER;</span><br><span class="line">dev-&gt;hard_header_len = ETH_HLEN;</span><br><span class="line">dev-&gt;mtu = ETH_DATA_LEN;</span><br><span class="line">dev-&gt;addr_len = ETH_ALEN;</span><br><span class="line">dev-&gt;tx_queue_len = <span class="number">1000</span>; <span class="comment">/* Ethernet wants good queues */</span></span><br><span class="line">dev-&gt;flags = IFF_BROADCAST|IFF_MULTICAST;</span><br><span class="line">dev-&gt;priv_flags |= IFF_TX_SKB_SHARING;</span><br><span class="line">eth_broadcast_addr(dev-&gt;broadcast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于网络设备而言，使用 alloc_etherdev 或alloc_etherdev_mqs 来申请 net_device。 NXP 官方编写的网络驱动就是采用alloc_etherdev_mqs来申请 net_device。 </p><p>删除 net_device<br>当注销网络驱动的时候需要释放掉前面已经申请到的 net_device，释放函数为free_netdev，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span><span class="comment">//dev： 要释放掉的 net_device 指针。</span></span><br></pre></td></tr></table></figure><p>注册 net_device<br>net_device 申请并初始化完成以后就需要向内核注册 net_device，要用到函数 register_netdev，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span><span class="comment">//dev： 要注册的 net_device 指针。返回值： 0 注册成功，负值 注册失败。</span></span><br></pre></td></tr></table></figure><p>注销 net_device<br>既然有注册，那么必然有注销，注销 net_device 使用函数 unregister_netdev，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unregister_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span><span class="comment">//dev： 要注销的 net_device 指针。</span></span><br></pre></td></tr></table></figure><p><strong>操作集</strong></p><p>net_device 有个非常重要的成员变量： netdev_ops，为 net_device_ops 结构体指针类型，这就是网络设备的操作集。 net_device_ops 结构体定义在 include&#x2F;linux&#x2F;netdevice.h 文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> (*ndo_init)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//当第一次注册网络设备的时候此函数会执行</span></span><br><span class="line"><span class="number">3</span> <span class="type">void</span> (*ndo_uninit)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//卸载网络设备的时候此函数会执行</span></span><br><span class="line"><span class="number">4</span> <span class="type">int</span> (*ndo_open)(<span class="keyword">struct</span> net_device *dev);</span><br><span class="line"><span class="comment">/*·使能网络外设时钟。</span></span><br><span class="line"><span class="comment">·申请网络所使用的环形缓冲区。</span></span><br><span class="line"><span class="comment">·初始化 MAC 外设。</span></span><br><span class="line"><span class="comment">·绑定接口对应的 PHY。</span></span><br><span class="line"><span class="comment">·如果使用 NAPI 的话要使能 NAPI 模块，通过 napi_enable 函数来使能。</span></span><br><span class="line"><span class="comment">·开启 PHY。</span></span><br><span class="line"><span class="comment">·调用 netif_tx_start_all_queues 来使能传输队列，也可能调用 netif_start_queue 函数。等*/</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> (*ndo_stop)(<span class="keyword">struct</span> net_device *dev);</span><br><span class="line"><span class="number">6</span> <span class="type">netdev_tx_t</span> (*ndo_start_xmit) (<span class="keyword">struct</span> sk_buff *skb, <span class="comment">/*需要发送数据的时候此函数就会执行， sk_buff 保存了上层传</span></span><br><span class="line"><span class="comment">递给网络驱动层的数据。*/</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">struct</span> net_device *dev);</span><br><span class="line"><span class="number">8</span> u16 (*ndo_select_queue)(<span class="keyword">struct</span> net_device *dev,<span class="comment">//当设备支持多传输队列的时候选择使用哪个队列。</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">struct</span> sk_buff *skb,</span><br><span class="line"><span class="number">10</span> <span class="type">void</span> *accel_priv,</span><br><span class="line"><span class="number">11</span> <span class="type">select_queue_fallback_t</span> fallback);</span><br><span class="line"><span class="number">12</span> <span class="type">void</span> (*ndo_change_rx_flags)(<span class="keyword">struct</span> net_device *dev,</span><br><span class="line"><span class="number">13</span> <span class="type">int</span> flags);</span><br><span class="line"><span class="number">14</span> <span class="type">void</span> (*ndo_set_rx_mode)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//此函数用于改变地址过滤列表，根据 net_device 的 flags成员变量来设置 SOC 的网络外设寄存器</span></span><br><span class="line"><span class="number">15</span> <span class="type">int</span> (*ndo_set_mac_address)(<span class="keyword">struct</span> net_device *dev,<span class="comment">//此函数用于修改网卡的 MAC 地址，并且将 MAC 地址写入到网络外设的硬件寄存器中。</span></span><br><span class="line"><span class="number">16</span> <span class="type">void</span> *addr);</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> (*ndo_validate_addr)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//验证 MAC 地址是否合法</span></span><br><span class="line"><span class="number">18</span> <span class="type">int</span> (*ndo_do_ioctl)(<span class="keyword">struct</span> net_device *dev,<span class="comment">//用户程序调用 ioctl 的时候此函数就会执行用户程序调用 ioctl 的时候此函数就会执行</span></span><br><span class="line"><span class="number">19</span> <span class="keyword">struct</span> ifreq *ifr, <span class="type">int</span> cmd);</span><br><span class="line"><span class="number">20</span> <span class="type">int</span> (*ndo_set_config)(<span class="keyword">struct</span> net_device *dev,</span><br><span class="line"><span class="number">21</span> <span class="keyword">struct</span> ifmap *<span class="built_in">map</span>);</span><br><span class="line"><span class="number">22</span> <span class="type">int</span> (*ndo_change_mtu)(<span class="keyword">struct</span> net_device *dev,<span class="comment">//更改 MTU(最大传输单元)大小</span></span><br><span class="line"><span class="number">23</span> <span class="type">int</span> new_mtu);</span><br><span class="line"><span class="number">24</span> <span class="type">int</span> (*ndo_neigh_setup)(<span class="keyword">struct</span> net_device *dev,</span><br><span class="line"><span class="number">25</span> <span class="keyword">struct</span> neigh_parms *);</span><br><span class="line"><span class="number">26</span> <span class="type">void</span> (*ndo_tx_timeout) (<span class="keyword">struct</span> net_device *dev);<span class="comment">//当发送超时的时候函数会执行，一般可能会重启 MAC 和 PHY，重新开始数据发送等</span></span><br><span class="line">......</span><br><span class="line"><span class="number">36</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class="line"><span class="number">37</span> <span class="type">void</span> (*ndo_poll_controller)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//使用查询方式来处理网卡数据的收发。</span></span><br><span class="line"><span class="number">38</span> <span class="type">int</span> (*ndo_netpoll_setup)(<span class="keyword">struct</span> net_device *dev,</span><br><span class="line"><span class="number">39</span> <span class="keyword">struct</span> netpoll_info *info);</span><br><span class="line"><span class="number">40</span> <span class="type">void</span> (*ndo_netpoll_cleanup)(<span class="keyword">struct</span> net_device *dev);</span><br><span class="line"><span class="number">41</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line"><span class="number">104</span> <span class="type">int</span> (*ndo_set_features)(<span class="keyword">struct</span> net_device *dev,<span class="comment">//修改 net_device 的 features 属性，设置相应的硬件属性</span></span><br><span class="line"><span class="number">105</span> <span class="type">netdev_features_t</span> features);</span><br><span class="line">......</span><br><span class="line"><span class="number">166</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="NAPI机制"><a href="#NAPI机制" class="headerlink" title="NAPI机制"></a>NAPI机制</h3><p>如果玩过单片机的话应该都知道，像 IIC、 SPI、网络等这些通信接口，接收数据有两种方法：轮询或中断。 Linux 里面的网络数据接收也轮询和中断两种，中断的好处就是响应快，数据量小的时候处理及时，速度快，但是一旦当数据量大，而且都是短帧的时候会导致中断频繁发生，消耗大量的 CPU 处理时间在中断自身处理上。轮询恰好相反，响应没有中断及时，但是在处理大量数据的时候不需要消耗过多的 CPU 处理时间。</p><p>Linux 在这两个处理方式的基础上提出了另外一种网络数据接收的处理方法： <strong>NAPI(New API)， NAPI 是一种高效的网络处理技术。NAPI 的核心思想就是不全部采用中断来读取网络数据，而是采用中断来唤醒数据接收服务程序，在接收服务程序中采用 POLL 的方法来轮询处理数据。</strong>这种方法的好处就是可以提高短数据包的接收效率，减少中断处理的时间。目前 NAPI 已经在 Linux 的网络驱动中得到了大量的应用，  </p><p>1、<strong>初始化 NAPI</strong><br>首先要初始化一个 napi_struct 实例，使用 netif_napi_add 函数，此函数定义在 net&#x2F;core&#x2F;dev.c中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_napi_add</span><span class="params">(<span class="keyword">struct</span> net_device *dev,<span class="comment">// 每个 NAPI 必须关联一个网络设备，此参数指定 NAPI 要关联的网络设备</span></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> napi_struct *napi,<span class="comment">//要初始化的 NAPI 实例</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> (*poll)(<span class="keyword">struct</span> napi_struct *, <span class="type">int</span>),<span class="comment">//NAPI 所使用的轮询函数，一般在此完成网络数据接收</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> weight)</span><span class="comment">//NAPI 默认权重(weight)，一般为 NAPI_POLL_WEIGHT。</span></span><br></pre></td></tr></table></figure><p>2、<strong>删除 NAPI</strong><br>如果要删除 NAPI，使用 netif_napi_del 函数即可，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_napi_del</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi)</span><span class="comment">//napi： 要删除的 NAPI。</span></span><br></pre></td></tr></table></figure><p>3、 <strong>使能 NAPI</strong><br>初始化完 NAPI 以后，必须使能才能使用，使用函数 napi_enable，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">napi_enable</span><span class="params">(<span class="keyword">struct</span> napi_struct *n)</span><span class="comment">//n： 要使能的 NAPI。</span></span><br></pre></td></tr></table></figure><p>4、<strong>关闭 NAPI</strong><br>关闭 NAPI 使用 napi_disable 函数即可，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">napi_disable</span><span class="params">(<span class="keyword">struct</span> napi_struct *n)</span><span class="comment">//n： 要关闭的 NAPI。</span></span><br></pre></td></tr></table></figure><p>5、<strong>检查 NAPI 是否可以进行调度</strong><br>使用 napi_schedule_prep 函数检查 NAPI 是否可以进行调度，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">napi_schedule_prep</span><span class="params">(<span class="keyword">struct</span> napi_struct *n)</span><span class="comment">//n： 要检查的 NAPI。返回值可调度为真</span></span><br></pre></td></tr></table></figure><p>6、<strong>NAPI 调度</strong><br>如果可以调度的话就进行调度，使用napi_schedule 函数完成 NAPI 调度，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __napi_schedule(<span class="keyword">struct</span> napi_struct *n)<span class="comment">//n： 要调度的 NAPI。</span></span><br></pre></td></tr></table></figure><p>7、 <strong>NAPI 处理完成</strong><br>NAPI 处理完成以后需要调用 napi_complete 函数来标记 NAPI 处理完成，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">napi_complete</span><span class="params">(<span class="keyword">struct</span> napi_struct *n)</span><span class="comment">//n： 处理完成的 NAPI。</span></span><br></pre></td></tr></table></figure><h3 id="网络外设驱动树"><a href="#网络外设驱动树" class="headerlink" title="网络外设驱动树"></a>网络外设驱动树</h3><p>NXP 的 I.MX 系 列 SOC 网 络 绑 定 文 档 为<br>Documentation&#x2F;devicetree&#x2F;bindings&#x2F;net&#x2F;fsl-fec.txt，此绑定文档描述了 I.MX 系列 SOC 网络设备树节点的要求。<br><strong>①、 必要属性</strong><br>compatible： 这个肯定是必须的，一般是“fsl,<soc>-fec”，比如 I.MX6ULL 的 compatible 属<br>性就是”fsl,imx6ul-fec”,和”fsl,imx6q-fec”。<br>reg： SOC 网络外设寄存器地址范围。<br>interrupts：网络中断。<br>phy-mode： 网络所使用的 PHY 接口模式，是 MII 还是 RMII。<br><strong>②、 可选属性</strong><br>phy-reset-gpios： PHY 芯片的复位引脚。<br>phy-reset-duration： PHY 复位引脚复位持续时间，单位为毫秒。只有当设置了 phy-resetgpios 属性此属性才会有效，如果不设置此属性的话 PHY 芯片复位引脚的复位持续时间默认为1 毫秒，数值不能大于 1000 毫秒，大于 1000 毫秒的话就会强制设置为 1 毫秒。<br>phy-supply： PHY 芯片的电源调节。<br>phy-handle：连接到此网络设备的 PHY 芯片句柄。<br>fsl,num-tx-queues： 此属性指定发送队列的数量，如果不指定的话默认为 1。<br>fsl,num-rx-queues： 此属性指定接收队列的数量，如果不指定的话默认为 2。<br>fsl,magic-packet： 此属性不用设置具体的值，直接将此属性名字写到设备树里面即可，表示支持硬件魔术帧唤醒。<br>fsl,wakeup_irq： 此属性设置唤醒中断索引。<br>stop-mode： 如果此属性存在的话表明 SOC 需要设置 GPR 位来请求停止模式。<br>③、可选子节点<br>mdio：可以设置名为“mdio”的子节点，此子节点用于指定网络外设所使用的 MDIO 总线，主要作为 PHY 节点的容器，也就是在 mdio 子节点下指定 PHY 相关的属性信息，具体信息可以参考 PHY 的绑定文档 Documentation&#x2F;devicetree&#x2F;bindings&#x2F;net&#x2F;phy.txt。<br>PHY 节点相关属性内容如下：<br>interrupts：中断属性，可以不需要。<br>interrupt-parent： 中断控制器句柄，可以不需要。<br>reg： PHY 芯片地址，必须的！<br>compatible： 兼容性列表，一般为“ethernet-phy-ieee802.3-c22”或“ethernet-phy-ieee802.3-c45”，分别对应 IEEE802.3 的 22 簇和 45 簇，默认是 22 簇。也可以设置为其他值，如果 PHY的 ID 不知道的话可以 compatible 属性可以设置为“ethernet-phy-idAAAA.BBBB”， AAAA 和BBBB 的含义如下：<br>AAAA： PHY 的 16 位 ID 寄存器 1 值，也就是 OUI 的 bit3<del>18， 16 进制格式。<br>BBBB： PHY 的 16 位 ID 寄存器 2 值，也就是 OUI 的 bit19</del>24， 16 进制格式。<br>max-speed： PHY 支持的最高速度，比如 10、 100 或 1000。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>块设备驱动开发</title>
      <link href="/2023/08/08/2023-8-8-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/08/08/2023-8-8-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="块设备介绍"><a href="#块设备介绍" class="headerlink" title="块设备介绍"></a>块设备介绍</h3><p>块设备是针对存储设备的，比如 SD 卡、 EMMC、 NAND Flash、 Nor Flash、 SPI Flash、机械硬盘、固态硬盘等。因此块设备驱动其实就是这些存储设备驱动，块设备驱动相比字符设备驱动的主要区别如下：<br>①、块设备只能以块为单位进行读写访问，块是 linux 虚拟文件系统(VFS)基本的数据传输单位。字符设备是以字节为单位进行数据传输的，不需要缓冲。<br>②、块设备在结构上是可以进行随机访问的，对于这些设备的读写都是按块进行的，块设备使用缓冲区来暂时存放数据，等到条件成熟以后再一次性将缓冲区中的数据写入块设备中。 </p><p>linux 内 核 使 用 block_device 表 示 块 设 备 ， block_device 为 一 个 结 构 体 ， 定 义 在include&#x2F;linux&#x2F;fs.h 文件中，结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">dev_t</span> bd_dev; <span class="comment">/* not a kdev_t - it&#x27;s a search key */</span></span><br><span class="line"><span class="number">3</span> <span class="type">int</span> bd_openers;</span><br><span class="line"><span class="number">4</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">bd_inode</span>;</span> <span class="comment">/* will die */</span></span><br><span class="line"><span class="number">5</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">bd_super</span>;</span></span><br><span class="line"><span class="number">6</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bd_mutex</span>;</span> <span class="comment">/* open/close mutex */</span></span><br><span class="line"><span class="number">7</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">bd_inodes</span>;</span></span><br><span class="line"><span class="number">8</span><span class="type">void</span> * bd_claiming;</span><br><span class="line"><span class="number">9</span> <span class="type">void</span> * bd_holder;</span><br><span class="line"><span class="number">10</span> <span class="type">int</span> bd_holders;</span><br><span class="line"><span class="number">11</span> <span class="type">bool</span> bd_write_holder;</span><br><span class="line"><span class="number">12</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line"><span class="number">13</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">bd_holder_disks</span>;</span></span><br><span class="line"><span class="number">14</span><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">15</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bd_contains</span>;</span></span><br><span class="line"><span class="number">16</span> <span class="type">unsigned</span> bd_block_size;</span><br><span class="line"><span class="number">17</span> <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> *<span class="title">bd_part</span>;</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/*number of times partitions within this device have been opened.*/</span></span><br><span class="line"><span class="number">19</span> <span class="type">unsigned</span> bd_part_count;</span><br><span class="line"><span class="number">20</span> <span class="type">int</span> bd_invalidated;</span><br><span class="line"><span class="number">21</span> <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">bd_disk</span>;</span></span><br><span class="line"><span class="number">22</span> <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">bd_queue</span>;</span></span><br><span class="line"><span class="number">23</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">bd_list</span>;</span></span><br><span class="line"><span class="number">24</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">25 * Private data. You must have bd_claim&#x27;ed the block_device</span></span><br><span class="line"><span class="comment">26 * to use this. <span class="doctag">NOTE:</span> bd_claim allows an owner to claim</span></span><br><span class="line"><span class="comment">27 * the same device multiple times, the owner must take special</span></span><br><span class="line"><span class="comment">28 * care to not mess up bd_private for that case.</span></span><br><span class="line"><span class="comment">29 */</span></span><br><span class="line"><span class="number">30</span> <span class="type">unsigned</span> <span class="type">long</span> bd_private;</span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="number">32</span> <span class="comment">/* The counter of freeze processes */</span></span><br><span class="line"><span class="number">33</span> <span class="type">int</span> bd_fsfreeze_count;</span><br><span class="line"><span class="number">34</span> <span class="comment">/* Mutex for freeze */</span></span><br><span class="line"><span class="number">35</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bd_fsfreeze_mutex</span>;</span></span><br><span class="line"><span class="number">36</span> &#125;;</span><br></pre></td></tr></table></figure><p>注册块设备和注销块设备和字符设备驱动一样，我们需要向内核注册新的块设备、申请设备号，块设备注册函数为register_blkdev，如果不使用某个块设备了，那么就需要注销掉，函数为unregister_blkdev，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_blkdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span><span class="comment">/*如果参数 major 在 1~255 之间的话表示自定义主设备号，那么返回 0 表示注册成功，如果返回负值的话表示注册失败。如果 major 为 0 的话表示由系统自动分配主设备号，那么返回值就是系统分配的主设备号(1~255)，如果返回负值那就表示注册失败。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_blkdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span><span class="comment">//无返回值</span></span><br><span class="line"><span class="comment">//major： 主设备号，name： 块设备名字。</span></span><br></pre></td></tr></table></figure><p><strong>linux 内核使用 gendisk 来描述一个磁盘设备</strong>，这是一个结构体，定义在 include&#x2F;linux&#x2F;genhd.h中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="comment">/* major, first_minor and minors are input parameters only,</span></span><br><span class="line"><span class="comment">3 * don&#x27;t use directly. Use disk_devt() and disk_max_parts().</span></span><br><span class="line"><span class="comment">4 */</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> major; <span class="comment">/* major number of driver */</span></span><br><span class="line"><span class="number">6</span> <span class="type">int</span> first_minor;</span><br><span class="line"><span class="number">7</span> <span class="type">int</span> minors; <span class="comment">/* maximum number of minors, =1 for disks that can&#x27;t be partitioned. */</span></span><br><span class="line"><span class="number">8</span> </span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">char</span> disk_name[DISK_NAME_LEN]; <span class="comment">/* name of major driver */</span></span><br><span class="line"><span class="number">11</span> <span class="type">char</span> *(*devnode)(<span class="keyword">struct</span> gendisk *gd, <span class="type">umode_t</span> *mode);</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">unsigned</span> <span class="type">int</span> events; <span class="comment">/* supported events */</span></span><br><span class="line"><span class="number">14</span> <span class="type">unsigned</span> <span class="type">int</span> async_events; <span class="comment">/* async events, subset of all */</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="comment">/* Array of pointers to partitions indexed by partno.</span></span><br><span class="line"><span class="comment">17 * Protected with matching bdev lock but stat and other</span></span><br><span class="line"><span class="comment">18 * non-critical accesses use RCU. Always access through</span></span><br><span class="line"><span class="comment">19 * helpers.</span></span><br><span class="line"><span class="comment">20 */</span></span><br><span class="line"><span class="number">21</span> <span class="class"><span class="keyword">struct</span> <span class="title">disk_part_tbl</span> __<span class="title">rcu</span> *<span class="title">part_tbl</span>;</span><span class="comment">//磁盘对应的分区表</span></span><br><span class="line"><span class="number">22</span> <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> <span class="title">part0</span>;</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line"><span class="number">25</span> <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span><span class="comment">//为磁盘对应的请求队列</span></span><br><span class="line"><span class="number">26</span> <span class="type">void</span> *private_data;</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="number">29</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">driverfs_dev</span>;</span> <span class="comment">// <span class="doctag">FIXME:</span> remove</span></span><br><span class="line"><span class="number">30</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">slave_dir</span>;</span></span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="number">32</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_rand_state</span> *<span class="title">random</span>;</span></span><br><span class="line"><span class="number">33</span> <span class="type">atomic_t</span> sync_io; <span class="comment">/* RAID */</span></span><br><span class="line"><span class="number">34</span> <span class="class"><span class="keyword">struct</span> <span class="title">disk_events</span> *<span class="title">ev</span>;</span></span><br><span class="line"><span class="number">35</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INTEGRITY</span></span><br><span class="line"><span class="number">36</span> <span class="class"><span class="keyword">struct</span> <span class="title">blk_integrity</span> *<span class="title">integrity</span>;</span></span><br><span class="line"><span class="number">37</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">38</span> <span class="type">int</span> node_id;</span><br><span class="line"><span class="number">39</span> &#125;;</span><br></pre></td></tr></table></figure><p>关于编写块的设备驱动的时候需要分配并初始化一个 gendisk，使用的 API 函数。 </p><p>1、 申请 gendisk<br>使用 gendisk 之前要先申请， allo_disk 函数用于申请一个 gendisk，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> gendisk *<span class="title function_">alloc_disk</span><span class="params">(<span class="type">int</span> minors)</span></span><br><span class="line"><span class="comment">//minors： 次设备号数量， 也就是 gendisk 对应的分区数量。</span></span><br><span class="line"><span class="comment">//返回值： 成功：返回申请到的 gendisk，失败： NULL。</span></span><br></pre></td></tr></table></figure><p>2、删除 gendisk<br>如果要删除 gendisk 的话可以使用函数 del_gendisk，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del_gendisk</span><span class="params">(<span class="keyword">struct</span> gendisk *gp)</span></span><br><span class="line"><span class="comment">//gp： 要删除的 gendisk。无返回值</span></span><br></pre></td></tr></table></figure><p>3、将 gendisk 添加到内核<br>使用 alloc_disk 申请到 gendisk 以后系统还不能使用，必须使用 add_disk 函数将申请到的gendisk 添加到内核中， add_disk 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span></span><br><span class="line"><span class="comment">//disk： 要添加到内核的 gendisk。返回值： 无。</span></span><br></pre></td></tr></table></figure><p>4、设置 gendisk 容量<br>每一个磁盘都有容量，所以在初始化 gendisk 的时候也需要设置其容量，使用函数set_capacity，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_capacity</span><span class="params">(<span class="keyword">struct</span> gendisk *disk, <span class="type">sector_t</span> size)</span></span><br><span class="line"><span class="comment">/*disk： 要设置容量的 gendisk。</span></span><br><span class="line"><span class="comment">size： 磁盘容量大小，注意这里是扇区数量。块设备中最小的可寻址单元是扇区，一个扇区一般是 512 字节，有些设备的物理扇区可能不是 512 字节。不管物理扇区是多少，内核和块设备驱动之间的扇区都是 512 字节。所以 set_capacity 函数设置的大小就是块设备实际容量除以512 字节得到的扇区数量。比如一个 2MB 的磁盘，其扇区数量就是(2*1024*1024)/512=4096。</span></span><br><span class="line"><span class="comment">返回值： 无。*/</span></span><br></pre></td></tr></table></figure><p>块设备中最小的可寻址单元为扇区，扇区大小一般是2的整数倍，最常见的大小是512字节，扇区大小是设备的物理属性，扇区是所有块设备的基本单元，块设备无法对比它还小的单元进行寻址和操作，不过许多块设备能够一次传输多个扇区。</p><p>5、调整 gendisk 引用计数<br>内核会通过 get_disk 和 put_disk 这两个函数来调整 gendisk 的引用计数， get_disk 是增加 gendisk 的引用计数， put_disk 是减少 gendisk 的引用计数，这两个函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kobject *<span class="title function_">get_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span></span><br></pre></td></tr></table></figure><p>块设备也有操作集，为结构体 block_device_operations，此结构体定义在 include&#x2F;linux&#x2F;blkdev.h 中，结构体内容如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> (*open) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>);</span><br><span class="line"><span class="number">3</span> <span class="type">void</span> (*release) (<span class="keyword">struct</span> gendisk *, <span class="type">fmode_t</span>);</span><br><span class="line"><span class="number">4</span> <span class="type">int</span> (*rw_page)(<span class="keyword">struct</span> block_device *, <span class="type">sector_t</span>, <span class="keyword">struct</span> page *,<span class="type">int</span> rw);<span class="comment">//读写指定的页</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>,<span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">//用于块设备的 I/O 控制，在32位系统</span></span><br><span class="line"><span class="number">6</span> <span class="type">int</span> (*compat_ioctl) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>,<span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">//用于块设备的 I/O 控制，64位</span></span><br><span class="line"><span class="number">7</span> <span class="type">long</span> (*direct_access)(<span class="keyword">struct</span> block_device *, <span class="type">sector_t</span>,</span><br><span class="line"><span class="number">8</span> <span class="type">void</span> **, <span class="type">unsigned</span> <span class="type">long</span> *pfn, <span class="type">long</span> size);</span><br><span class="line"><span class="number">9</span> <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*check_events)</span> <span class="params">(<span class="keyword">struct</span> gendisk *disk,</span></span><br><span class="line"><span class="params"><span class="number">10</span> <span class="type">unsigned</span> <span class="type">int</span> clearing)</span>;</span><br><span class="line"><span class="number">11</span> <span class="comment">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span></span><br><span class="line"><span class="number">12</span> <span class="type">int</span> (*media_changed) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line"><span class="number">13</span> <span class="type">void</span> (*unlock_native_capacity) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line"><span class="number">14</span> <span class="type">int</span> (*revalidate_disk) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line"><span class="number">15</span> <span class="type">int</span> (*getgeo)(<span class="keyword">struct</span> block_device *, <span class="keyword">struct</span> hd_geometry *);<span class="comment">//用于获取磁盘信息，包括磁头、柱面和扇区等信息。</span></span><br><span class="line"><span class="number">16</span> <span class="comment">/* this callback is with swap_lock and sometimes page table lockheld */</span></span><br><span class="line"><span class="number">17</span> <span class="type">void</span> (*swap_slot_free_notify) (<span class="keyword">struct</span> block_device *,<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="number">18</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">//表示此结构体属于哪个模块，一般直接设置为 THIS_MODULE。</span></span><br><span class="line"><span class="number">19</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="块设备-I-x2F-O-请求过程"><a href="#块设备-I-x2F-O-请求过程" class="headerlink" title="块设备 I&#x2F;O 请求过程"></a>块设备 I&#x2F;O 请求过程</h3><p>在编写块设备驱动的时候，每个磁盘(gendisk)都要分配一个 request_queue ，内核将对块设备的读写都发送到请求队列 request_queue 中， request_queue 中是大量的request(请求结构体)，而 request 又包含了 bio， bio 保存了读写相关数据。</p><p>通常一个bio对应一个I&#x2F;O请求。调度算法可以将连续的bio合并成一个请求，所以一个请求包含多个bio。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20143303.png"></p><p><strong>请求队列API函数解析</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">request_queue *<span class="title function_">blk_init_queue</span><span class="params">(request_fn_proc *rfn, <span class="type">spinlock_t</span> *lock)</span></span><br><span class="line"><span class="comment">/*rfn： 请求处理函数指针 lock： 自旋锁指针，需要驱动编写人员定义一个自旋锁，然后传递进来。，请求队列会使用</span></span><br><span class="line"><span class="comment">这个自旋锁。返回值： 如果为 NULL 的话表示失败，成功的话就返回申请到的 request_queue 地址。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_cleanup_queue</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line"> <span class="comment">/*q： 需要删除的请求队列。返回值： 无。*/</span></span><br><span class="line"><span class="keyword">struct</span> request_queue *<span class="title function_">blk_alloc_queue</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span></span><br><span class="line"> <span class="comment">/*gfp_mask： 内存分配掩码，返回值： 申请到的无 I/O 调度的 request_queue。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_queue_make_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q, make_request_fn *mfn)</span></span><br><span class="line"> <span class="comment">/*q： 需要绑定的请求队列，也就是 blk_alloc_queue 申请到的请求队列。mfn：需要绑定的“制造”请求函数*/</span></span><br><span class="line"><span class="title function_">void</span> <span class="params">(make_request_fn)</span> <span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> bio *bio)</span></span><br><span class="line"> <span class="comment">/*返回值： 无*/</span></span><br></pre></td></tr></table></figure><p><strong>请求API函数解析</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">request *<span class="title function_">blk_peek_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line"><span class="comment">/*q： 指定 request_queue。</span></span><br><span class="line"><span class="comment">返回值： request_queue 中下一个要处理的请求(request)，如果没有要处理的请求就返回NULL。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_start_request</span><span class="params">(<span class="keyword">struct</span> request *req)</span></span><br><span class="line"><span class="comment">/*req： 要开始处理的请求。返回值： 无。*/</span></span><br><span class="line"><span class="comment">//一步到位处理请求</span></span><br><span class="line"><span class="keyword">struct</span> request *<span class="title function_">blk_fetch_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>;</span></span><br><span class="line">rq = blk_peek_request(q);</span><br><span class="line"><span class="keyword">if</span> (rq)</span><br><span class="line">blk_start_request(rq);</span><br><span class="line"><span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20211257.png"></p><p>每个 request 里面会有多个 bio， bio 保存着最终要读写的数据、地址等信息。上层应用程序对于块设备的读写会被构造成一个或多个 bio 结构， bio 结构描述了要读写的起始扇区、要读写的扇区数量、是读取还是写入、页偏移、数据长度等等信息。上层会将 bio 提交给 I&#x2F;O 调度器，I&#x2F;O 调度器会将这些 bio 构造成 request 结构，而一个物理存储设备对应一个 request_queue，request_queue 里面顺序存放着一系列的 request。新产生的 bio 可能被合并到 request_queue 里现有的 request 中，也可能产生新的 request，然后插入到 request_queue 中合适的位置，这一切都是由 I&#x2F;O 调度器来完成的。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20141959.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bio 是个结构体，定义在 include/linux/blk_types.h 中</span></span><br><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bi_next</span>;</span> <span class="comment">/* 请求队列的下一个 bio */</span></span><br><span class="line"><span class="number">3</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bi_bdev</span>;</span> <span class="comment">/* 指向块设备 */</span></span><br><span class="line"><span class="number">4</span> <span class="type">unsigned</span> <span class="type">long</span> bi_flags; <span class="comment">/* bio 状态等信息 */</span></span><br><span class="line"><span class="number">5</span> <span class="type">unsigned</span> <span class="type">long</span> bi_rw; <span class="comment">/* I/O 操作,读或写 */</span></span><br><span class="line"><span class="number">6</span><span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span> <span class="title">bi_iter</span>;</span> <span class="comment">/* I/O 操作,读或写 */</span></span><br><span class="line"><span class="number">7</span> <span class="type">unsigned</span> <span class="type">int</span> bi_phys_segments;</span><br><span class="line"><span class="number">8</span> <span class="type">unsigned</span> <span class="type">int</span> bi_seg_front_size;</span><br><span class="line"><span class="number">9</span> <span class="type">unsigned</span> <span class="type">int</span> bi_seg_back_size;</span><br><span class="line"><span class="number">10</span> <span class="type">atomic_t</span> bi_remaining;</span><br><span class="line"><span class="number">11</span> <span class="type">bio_end_io_t</span> *bi_end_io;</span><br><span class="line"><span class="number">12</span> <span class="type">void</span> *bi_private;</span><br><span class="line"><span class="number">13</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line"><span class="number">14</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">15 * Optional ioc and css associated with this bio. Put on bio</span></span><br><span class="line"><span class="comment">16 * release. Read comment on top of bio_associate_current().</span></span><br><span class="line"><span class="comment">17 */</span></span><br><span class="line"><span class="number">18</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_context</span> *<span class="title">bi_ioc</span>;</span></span><br><span class="line"><span class="number">19</span> <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">bi_css</span>;</span></span><br><span class="line"><span class="number">20</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">21</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="number">22</span> <span class="meta">#<span class="keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line"><span class="number">23</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span></span><br><span class="line"><span class="number">24</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">25</span> &#125;;</span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span> <span class="type">unsigned</span> <span class="type">short</span> bi_vcnt; <span class="comment">/* bio_vec 列表中元素数量 */</span></span><br><span class="line"><span class="number">28</span> <span class="type">unsigned</span> <span class="type">short</span> bi_max_vecs; <span class="comment">/* bio_vec 列表长度 */</span></span><br><span class="line"><span class="number">29</span> <span class="type">atomic_t</span> bi_cnt; <span class="comment">/* pin count */</span></span><br><span class="line"><span class="number">30</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> *<span class="title">bi_io_vec</span>;</span> <span class="comment">/* bio_vec 列表 */</span></span><br><span class="line"><span class="number">31</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_set</span> *<span class="title">bi_pool</span>;</span></span><br><span class="line"><span class="number">32</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> <span class="title">bi_inline_vecs</span>[0];</span></span><br><span class="line"><span class="number">33</span> &#125;;</span><br></pre></td></tr></table></figure><p>重点来看一下第 6 行和第 30 行，第 6 行为 bvec_iter 结构体类型的成员变量，第 30 行为bio_vec 结构体指针类型的成员变量。<br>bvec_iter 结构体描述了要操作的设备扇区等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span> &#123;</span></span><br><span class="line"><span class="type">sector_t</span> bi_sector; <span class="comment">/*I/O 请求的设备起始扇区(512 字节) */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bi_size; <span class="comment">/* 剩余的 I/O 数量 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bi_idx; <span class="comment">/* blv_vec 中当前索引 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bi_bvec_done; <span class="comment">/* 当前 bvec 中已经处理完成的字节数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">bv_page</span>;</span> <span class="comment">/* 页 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bv_len; <span class="comment">/* 长度 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bv_offset; <span class="comment">/* 偏移 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20213733.png"></p><p><strong>①、遍历请求中的 bio</strong><br>请求中包含有大量的 bio，因此就涉及到遍历请求中所有 bio 并进行处理。遍历请求中的 bio 使用函数______rq_for_each_bio,这是一个宏，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __rq_for_each_bio(_bio, rq)  <span class="keyword">if</span> ((rq-&gt;bio)) for (_bio = (rq)-&gt;bio; _bio; _bio = _bio-&gt;bi_next)</span></span><br></pre></td></tr></table></figure><p>_bio 就是遍历出来的每个 bio， rq 是要进行遍历操作的请求， _bio 参数为 bio 结构体指针类型， rq 参数为 request 结构体指针类型。<br><strong>②、遍历 bio 中的所有段</strong><br>bio 包含了最终要操作的数据，因此还需要遍历 bio 中的所有段，这里要用到bio_for_each_segment 函数，此函数也是一个宏，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bio_for_each_segment(bvl, bio, iter) __bio_for_each_segment(bvl, bio, iter, (bio)-&gt;bi_iter)</span></span><br></pre></td></tr></table></figure><p>第一个 bvl 参数就是遍历出来的每个 bio_vec，第二个 bio 参数就是要遍历的 bio，类型为bio 结构体指针，第三个 iter 参数保存要遍历的 bio 中 bi_iter 成员变量。<br><strong>③、通知 bio 处理结束</strong><br>如果使用“制造请求”，也就是抛开 I&#x2F;O 调度器直接处理 bio 的话，在 bio 处理完成以后要通过内核 bio 处理完成，使用 bio_endio 函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bvoid <span class="title function_">bio_endio</span><span class="params">(<span class="keyword">struct</span> bio *bio, <span class="type">int</span> error)</span></span><br></pre></td></tr></table></figure><p>bio： 要结束的 bio。<br>error： 如果 bio 处理成功的话就直接填 0，如果失败的话就填个负值，比如-EIO。<br>返回值： 无</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><p>block_device: 描述一个分区或整个磁盘对内核的一个块设备实例<br>gendisk: 描述一个通用硬盘（generic hard disk）对象。<br>hd_struct: 描述分区应有的分区信息<br>bio: 描述块数据传送时怎样完成填充或读取块给driver<br>request: 描述向内核请求一个列表准备做队列处理。<br>request_queue: 描述内核申请request资源建立请求链表并填写BIO形成队列。</p></blockquote><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-10%20172007.png"></p><blockquote><p>在Linux中，驱动对块设备的输入或输出(I&#x2F;O)操作，都会向块设备发出一个请求，在驱动中用&gt;request结构体描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些I&#x2F;O请求添加到队列中（即：请求队列），在驱动中用request_queue结构体描述。在向块设备提交这些请求前内核会先执行请求的合并和排序预操作，以提高访问的效率，然后再由内核中的I&#x2F;O调度程序子系统来负责提交 I&#x2F;O 请求， 调度程序将磁盘资源分配给系统中所有挂起的块 I&#x2F;O 请求，其工作是管理块设备的请求队列，决定队列中的请求的排列顺序以及什么时候派发请求到设备。<br>由通用块层(Generic Block Layer)负责维持一个I&#x2F;O请求在上层文件系统与底层物理磁盘之间的关系。在通用块层中，通常用一个bio结构体来对应一个I&#x2F;O请求。<br>Linux提供了一个gendisk数据结构体，用来表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。在gendisk中有一个类似字符设备中file_operations的硬件操作结构指针，是block_device_operations结构体。<br>当多个请求提交给块设备时，执行效率依赖于请求的顺序。如果所有的请求是同一个方向（如：写数据），执行效率是最大的。内核在调用块设备驱动程序例程处理请求之前，先收集I&#x2F;O请求并将请求排序，然后，将连续扇区操作的多个请求进行合并以提高执行效率（内核算法会自己做，不用你管），对I&#x2F;O请求排序的算法称为电梯算法（elevator algorithm）。电梯算法在I&#x2F;O调度层完成。</p></blockquote><p><strong>代码框架</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-12%20212433.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>can通信协议</title>
      <link href="/2023/08/07/2023-8-7-can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/08/07/2023-8-7-can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="CAN通信协议"><a href="#CAN通信协议" class="headerlink" title="CAN通信协议"></a>CAN通信协议</h2><p>CAN 的特点主要有一下几点：<br>①、多主控制<br>②、系统的柔软性<br>③、通信速度快，距离远<br>④、具有错误检测、错误通知和错误恢复功能<br>⑤、故障封闭功能<br>⑥、连接节点多</p><h3 id="CAN-电气属性"><a href="#CAN-电气属性" class="headerlink" title="CAN 电气属性"></a>CAN 电气属性</h3><p>CAN 总线使用两根线来连接各个单元：CAN_H 和 CAN_L， CAN 控制器通过判断这两根线上的电位差来得到总线电平， CAN 总线电平分为显性电平和隐性电平两种。显性电平表示逻辑“0”，此时 CAN_H 电平比 CAN_L 高，分别为 3.5V 和 1.5V，电位差为 2V。隐形电平表示逻辑“1”，此时 CAN_H 和 CAN_L 电压都为 2.5V 左右，电位差为 0V。 CAN 总线就通过显性和隐形电平的变化来将具体的数据发送出去 。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20185240.png"></p><p>CAN 总线上没有节点传输数据的时候一直处于隐性状态，也就是说总线空闲状态的时候一直处于隐性。 </p><h3 id="CAN协议帧"><a href="#CAN协议帧" class="headerlink" title="CAN协议帧"></a>CAN协议帧</h3><p>CAN 协议提供了 5 种帧格式来传输数据：数据帧、遥控帧、错误帧、过载帧和帧间隔。其中数据帧和遥控帧有标准格式和扩展格式两种，标准格式有 11 位标识符(ID)，扩展格式有 29 个标识符(ID)。 </p><table><thead><tr><th align="center">帧类型</th><th align="center">帧用途</th></tr></thead><tbody><tr><td align="center">数据帧</td><td align="center">用于 CAN 节点单元之间进行数据传输的帧</td></tr><tr><td align="center">遥控帧</td><td align="center">用于接收单元向具有相同 ID 的发送单元请求数据的帧</td></tr><tr><td align="center">错误帧</td><td align="center">用于当检测出错误时向其它单元通知错误的帧</td></tr><tr><td align="center">过载帧</td><td align="center">用于接收单元通知其尚未做好接收准备的帧</td></tr><tr><td align="center">间隔帧</td><td align="center">用于将数据帧及遥控帧与前面的帧分离开来的帧</td></tr></tbody></table><p>D为显性0，R为隐形1。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE_202308071734_13201%203.jpg"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE_202308071734_11851%201.jpg"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE_202308071734_14251%204.jpg"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE_202308071734_15346%205.jpg"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE_202308071734_12590%202.jpg"></p><h3 id="CAN速率"><a href="#CAN速率" class="headerlink" title="CAN速率"></a>CAN速率</h3><p>CAN 总线以帧的形式发送数据，但是最终到总线上的就是“0”和“1”这样的二进制数据，这里就涉及到了通信速率，也就是每秒钟发送多少位数据， CAN2.0 最高速度为1Mbps&#x2F;S。对于 CAN 总线，一个位分为 4 段：<br>①、同步段(SS)<br>②、传播时间段(PTS)<br>③、相位缓冲段 1(PBS1)<br>④、相位缓冲段 2(PBS2)<br>这些段由 Tq(Time Quantum)组成， <strong>Tq 是 CAN 总线的最小时间单位。帧由位构成，一个位由 4 个段构成，每个段又由若干个 Tq 组成，这个就是位时序。</strong> 1 位由多少个 Tq 构成、每个段又由多少个 Tq 构成等，可以任意设定位时序。通过设定位时序，多个单元可同时采样，也可任意设定采样点。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20191029.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20191432.png"></p><h3 id="can传输仲裁"><a href="#can传输仲裁" class="headerlink" title="can传输仲裁"></a>can传输仲裁</h3><p>在总线空闲态，最先开始发送消息的单元获得发送权。当多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的单元可继续发送。 </p><p><img src="C:\Users\hanfeng\AppData\Roaming\Typora\typora-user-images\1691407245638.png" alt="1691407245638"></p><p>单元 1 和单元 2 同时开始向总线发送数据，开始部分他们的数据格式是一样的，故无法区分优先级，直到 T 时刻，单元 1 输出隐性电平，而单元 2 输出显性电平，此时单元 1 仲裁失利，立刻转入接收状态工作，不再与单元 2 竞争，而单元 2 则顺利获得总线使用权，继续发送自己的数据。这就实现了仲裁，让连续发送显性电平多的单元获得总线使用权。 </p><p><a href="https://gitee.com/hanfengdyh/code/blob/master/CAN%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.pdf">CAN入门教程.pdf · 码云 </a></p><h3 id="FlexCAN（CAN外设）"><a href="#FlexCAN（CAN外设）" class="headerlink" title="FlexCAN（CAN外设）"></a>FlexCAN（CAN外设）</h3><p> FlexCAN 符合 CAN2.0B 协议。 FlexCAN完全符合CAN协议，支持标准格式和扩展格式，支持 64个消息缓冲。I.MX6ULL自带的FlexCAN模块特性如下：<br>①、支持 CAN2.0B 协议，数据帧和遥控帧支持标准和扩展两种格式，数据长度支持 0~8 字<br>节，可编程速度，最高 1Mbit&#x2F;S。<br>②、灵活的消息邮箱，最高支持 8 个字节。<br>③、每个消息邮箱可以配置为接收或发送，都支持标准和扩展这两种格式的消息。<br>④、每个消息邮箱都有独立的接收掩码寄存器。<br>⑤、强大的接收 FIFO ID 过滤。<br>⑥、未使用的空间可以用作通用 RAM。<br>⑦、可编程的回测模式，用于进行自测。<br>⑧、可编程的优先级组合。</p><p>FlexCAN 支持四种模式：正常模式(Normal)、冻结模式(Freeze)、仅监听模式(Listen-Only)和回环模式(Loop-Back)，另外还有两种低功耗模式：禁止模式(Disable)和停止模式(Stop)。<br>①、正常模式(Normal)<br>在正常模式下， FlexCAN 正常接收或发送消息帧，所有的 CAN 协议功能都使能。<br>②、冻结模式(Freeze)<br>当 MCR 寄存器的 FRZ 位置 1 的时候使能此模式，在此模式下无法进行帧的发送或接收，CAN 总线同步丢失。<br>③、仅监听模式(Listen-Onley)<br>当 CTRL 寄存器的 LOM 位置 1 的时候使能此模式，在此模式下帧发送被禁止，所有错误计数器被冻结， CAN 控制器工作在被动错误模式，此时只会接收其他 CAN 单元发出的 ACK 消息。<br>④、 回环模式(Loop-Back)<br>当 CTRL 寄存器的 LPB 位置 1 的时候进入此模式，此模式下 FlexCAN 工作在内部回环模式，一般用来进行自测。从模式下发送出来的数据流直接反馈给内部接收单元。 </p><p>控制寄存器 CTRL 用于设置这些位时序， CTRL 寄存器中的 PRESDIV、 PROPSEG、 PSEG1、PSEG2 和 RJW 这 5 个位域用于设置 CAN 位时序。<br>PRESDIV 为 CAN 分频值，也即是设置 CAN 协议中的 Tq 值，公式如下：<br>$$<br>𝑓_{𝑇𝑞} &#x3D;𝑓_{𝐶𝐴𝑁𝐶𝐿𝐾}&#x2F;PRESDIV + 1<br>$$<br><strong>fCANCLK为 FlexCAN 模块时钟，这个根据时钟章节设置即可，设置好以后就是一个定值，因此只需要修改 PRESDIV 即可修改 FlexCAN 的 Tq 频率值。</strong><br>Tq 定了以后我们结合各个段来看一下如何设置 FlexCAN 的速率：</p><p>SS： 同步段(Synchronization Segment)，在 I.MX6ULL 参考手册中叫做 SYNC_SEG，此段固定为 1 个 Tq 长度，因此不需要去设置。<br>PTS： 传播时间段(Propagatin Segment)， FlexCAN 的 CTRL 寄存器中的 PROPSEG 位域设置此段，可以设置为 0<del>7，对应 1</del>8 个 Tq。<br>PBS1： 相位缓冲段 1(Phase Buffer Segment 1)， FlexCAN 的 CRTL 寄存器中的 PSEG1 位域设置此段，可以设置为 0<del>7，对应 1</del>8 个 Tq。<br>PBS2：相位缓冲段 2(Phase Buffer Segment 2)， FlexCAN 的 CRTL 寄存器中的 PSEG2 位域设置此段，可以设置为 1<del>7，对应 2</del>8 个 Tq。<br>SJW： 再同步补偿宽度(reSynchronization Jump Width)， FlexCAN 的 CRTL 寄存器中的 RJW位域设置此段，可以设置 0<del>3，对应 1</del>4 个 Tq。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20195038.png"></p><p>SYNC+SEG+(PROP_SEG+PSEG1+2)+(PSEG2+1)就是总的 Tq，因此FlexCAN 的波特率就是：<br>$$<br>𝐶𝐴𝑁波特率 &#x3D; 𝑓_{𝑇𝑞}&#x2F;总Tq<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux开发板安装第三方库</title>
      <link href="/2023/08/06/2023-8-6-%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
      <url>/2023/08/06/2023-8-6-%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="第三方库的安装配置"><a href="#第三方库的安装配置" class="headerlink" title="第三方库的安装配置"></a>第三方库的安装配置</h2><h3 id="串口（minicom和ncurse）"><a href="#串口（minicom和ncurse）" class="headerlink" title="串口（minicom和ncurse）"></a>串口（minicom和ncurse）</h3><p>ncurses (new curses)库是System V Release 4.0及curses更高版本中的免费软件仿真库。它使用terminfo格式，支持pads和color ，多种高亮显示，多形式字符和功能键映射，该库很容易移植到任何符合ANSI&#x2F; posix的类unix系统中运行。</p><p>下载地址<a href="https://directory.fsf.org/wiki/Ncurses">Ncurses - Free Software </a></p><p>具体编译构建步骤如下：</p><h5 id="1、构建配置"><a href="#1、构建配置" class="headerlink" title="1、构建配置"></a>1、构建配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/moss/linux/tool/ncurse --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf --with-shared --without-profile --disable-stripping --without-progs --with-manpages --without-tests</span><br></pre></td></tr></table></figure><ul><li>configure ：配置脚本。（在命令行终端下运行）</li><li>–prefix： 用于指定编译结果的保存目录。</li><li>–host： 用于指定编译器前缀，这里设置为 “arm-linux-gnueabihf”。</li><li>–target ：用于指定目标，这里设置为“arm-linux-gnueabihf”。</li></ul><p>配置结果：<img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20124119.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make#make进行编译</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20124530.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install#进行安装</span><br></pre></td></tr></table></figure><p>可能会有报错，可能是找不到交叉编译位置，可以使用命令转到root的模式下进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo -s //切换到 root </span><br><span class="line">source /etc/profile //执行/etc/profile</span><br><span class="line">make install //安装，此时已经工作在 root 下，因此不需要加“sudo”</span><br><span class="line">su moss //编译完成以后回原来的用户</span><br></pre></td></tr></table></figure><p>安装成功以后查看一下前面创建的“ncurses”文件夹，会发现里面多了一些东西，</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20125053.png"></p><p>我们需要将 include、 lib 和 share 这三个目录中存放的文件分别拷贝到开发板根文件系统中的&#x2F;usr&#x2F;include、 &#x2F;usr&#x2F;lib 和&#x2F;usr&#x2F;share 这三个目录中，如果哪个目录不存在的话请自行创建！！拷贝命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp lib/* /home/moss/linux/nfs/rootfs/usr/lib/ -rfa</span><br><span class="line">sudo cp share/* /home/moss/linux/nfs/rootfs/usr/share/ -rfa</span><br><span class="line">sudo cp include/* /home/moss/linux/nfs/rootfs/usr/include/ -rfa</span><br></pre></td></tr></table></figure><p>然后在开发板根目录的&#x2F;etc&#x2F;profile(没有的话自己创建一个)文件中添加如下所示内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH</span><br><span class="line">export LD_LIBRARY_PATH</span><br><span class="line">export TERM=vt100</span><br><span class="line">export TERMINFO=/usr/share/terminfo </span><br></pre></td></tr></table></figure><p>minicom是一个命令行终端中由菜单驱动的串行通信调试程序。</p><p>下载地址<a href="https://fossies.org/linux/misc/minicom-2.8.tar.bz2/">minicom 2.8 - Download| Fossies Archive</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure CC=arm-linux-gnueabihf-gcc --prefix=/home/moss/linux/tool/minicom --host=arm-linux-gnueabihf CPPFLAGS=-I/home/moss/linux/tool/ncurses/include LDFLAGS=-L/home/moss/linux/tool/ncurses/lib -enable-cfg-dir=/etc/minicom              </span><br></pre></td></tr></table></figure><p> CC 表示要使用的 gcc 交叉编译器， –prefix 指定编译出来的文件存放目录，肯定要存放前面创建的 minicom 目录中。 –host 指定交叉编译器前缀， CPPFLAGS 指定 ncurses 的头文件路径，LDFLAGS 指定ncurses的库路径。配置成功后</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20130403.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20130558.png"></p><p>装完后文件生成如图。将 minicom 目录中 bin 子目录下的所有文件拷贝到开发板根目录中的&#x2F;usr&#x2F;bin 目录下，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp bin/* /home/moss/linux/nfs/rootfs/usr/bin/ </span><br></pre></td></tr></table></figure><p>之后打开开发板的根文件系统，新建&#x2F;etc&#x2F;passwd 文件，然后在 passwd 文件里面输入如下所示内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/sh</span><br></pre></td></tr></table></figure><h3 id="音频声卡"><a href="#音频声卡" class="headerlink" title="音频声卡"></a>音频声卡</h3><p>alsa-lib 和 alsa-utils 源 码 ， 下 载 地 址 为 ： <a href="http://www.alsa-project.org/main/index.php/Main_Page">Advanced Linux Sound Architecture</a></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20131711.png"></p><p><strong>alsa-lib 移植</strong><br>注意 alsa-lib 编译过程中会生成一些配置文件，而这些配置信息的路径都是绝对路径，因此为了保证 ubuntu 和开发板根文件系统中的路径一致！在 ubuntu 和开发板中各创建一个路径和名字完全一样的目录，这里我们都创建一个&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录， ubuntu 中创建命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share </span><br><span class="line">sudo mkdir arm-alsa </span><br></pre></td></tr></table></figure><p>最后在开发板根文件系统中也创建一个&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/share/arm-alsa -p </span><br></pre></td></tr></table></figure><p>这样 ubuntu 和开发板根文件系统都有一个“&#x2F;usr&#x2F;share&#x2F;arm-alsa”目录，交叉编译的时候就不怕存在引用绝对路径了，因为 ubuntu 和开发板中的配置文件路径都是一模一样的。由于 alsa-utils 要用到 alsa-lib 库，因此要先编译 alsa-lib 库。 alsa-lib 就是 ALSA 相关库文件，应用程序通过调用 ALSA 库来对 ALSA 框架下的声卡进行操作。先创建一个名为“alsa-lib”的目录用来保存 alsa-lib 的编译结果，然后将 alsa-lib-1.2.2.tar.bz2 拷贝到 ubuntu 中并解压，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxjf alsa-lib-1.2.9.tar.bz2 </span><br></pre></td></tr></table></figure><p>解压完成以后就会得到一个名为“alsa-lib-1.2.9”的文件夹，这个就是 alsa-lib 的源码。进入alsa-lib-1.2.9 目录，然后配置并编译，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=arm-linux-gnueabihf --prefix=/home/moss/linux/tool/alsalib --with-configdir=/usr/share/arm-alsa </span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;配置注意， “–with-configdir”用于设置 alsa-lib 编译出来的配置文件存放位置，这里设置为前面创建的“&#x2F;usr&#x2F;share&#x2F;arm-alsa”目录。<br>配置完成以后就可以编译了，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make </span><br><span class="line">sudo make install </span><br></pre></td></tr></table></figure><p>可能会出现错误提示：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20132326.png"><br> libatopology.la 编译失败， 这是因为 sudo 会切换到 root 用户下，但是此时 root 用户下的环境变量中没有交叉编译器路径，因此会提示找不到“arm-linux-gnueabihf-gcc”，从而导致 libatopology.la 编译失败。解决方法就是先切换到 root 用户，重新执行一下&#x2F;etc&#x2F;profile<br>文件，然后直接 make install 即可，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo -s </span><br><span class="line">source /etc/profile </span><br><span class="line">make install </span><br><span class="line">su moss</span><br></pre></td></tr></table></figure><p>编译完成以后前面创建的“alsa-lib”目录就会保存相应的编译结果，如图 65.4.1.2 所示：<br>图 65.4.1.2 alsa-lib 编译结果<br>ubuntu 中&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下的内容如图 65.4.1.3 所示：<br>图 65.4.1.3 编译出来的配置文件。<br>将图 65.4.1.2 中 lib 目录下的所有文件拷贝到开发板根文件系统的&#x2F;usr&#x2F;lib 目录下，将图<br>65.4.1.3 中&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下的所有文件拷贝到开发板的&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd alsa-lib //进入 alsa-lib</span><br><span class="line">sudo cp lib/* /home/moss/linux/nfs/rootfs/lib/ -af</span><br><span class="line">cd /usr/share/arm-alsa //进入 arm-alsa 目录，拷贝配置文件</span><br><span class="line">sudo cp * /home/moss/linux/nfs/rootfs/usr/share/arm-alsa/ -raf</span><br></pre></td></tr></table></figure><p><strong>alsa-utils 移植</strong><br>alsa-utils 是 ALSA 的一些小工具集合，我们可以通过这些小工具还测试我们的声卡。将 alsautils-1.2.2.tar.bz2 复制到 ubuntu 中并解压，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxjf alsa-utils-1.2.9.tar.bz2 </span><br></pre></td></tr></table></figure><p>解压成功以后会得到一个名为“alsa-utils-1.2.9”的文件夹，此文件夹就是 alsa-utils 源码。<br>重新创建一个名为“alsa-utils”的目录用于存放 alsa-utils-1.2.9 的编译结果。按照如下命令编译alsa-utils：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=arm-linux-gnueabihf --prefix=/home/moss/linux/tool/alsautils --with-alsa-inc-prefix=/home/moss/linux/tool/alsa-lib/include/ --with-alsaprefix=/home/moss/linux/tool/alsa-lib/lib/ --disable-alsamixer --disable-xmlto</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>编译完成以后就会在前面创建的“alsa-utils”目录下生成 bin、 sbin 和 share 三个文件夹，如<br><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20144427.png"><br><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20144522.png"><br>将图 中 bin、 sbin 和 share 这三个目录中的所有文件分别拷贝到开发板根目录下的<br>&#x2F;bin、 &#x2F;sbin 和&#x2F;usr&#x2F;share&#x2F;alsa 目录下，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd alsa-utils</span><br><span class="line">sudo cp bin/* /home/zuozhongkai/linux/nfs/rootfs/bin/ -rfa</span><br><span class="line">sudo cp sbin/* /home/zuozhongkai/linux/nfs/rootfs/sbin/ -rfa</span><br><span class="line">sudo cp share/* /home/zuozhongkai/linux/nfs/rootfs/usr/share/ -rfa</span><br></pre></td></tr></table></figure><p>打开开发板根文件系统中的&#x2F;etc&#x2F;profile 文件，在里面加入如下所示内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALSA_CONFIG_PATH=/usr/share/arm-alsa/alsa.conf</span><br></pre></td></tr></table></figure><p>ALSA_CONFIG_PATH 用于指定 alsa 的配置文件，这个配置文件是 alsa-lib 编译出来的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音频驱动开发</title>
      <link href="/2023/08/05/2023-8-5-%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/08/05/2023-8-5-%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="音频解码"><a href="#音频解码" class="headerlink" title="音频解码"></a>音频解码</h2><p>处理器接收音频需要将声音通过ADC采集，将模拟信号转换成为数字信号，相反播放声音就需要将数字信号转换成为模拟信号使用DAC芯片。音频编解码芯片，英文名字就是 Audio CODEC 。</p><p>既然音频 CODEC 的本质是 ADC 和 DAC，那么采样率和采样位数就是衡量一款音频<br>CODEC 最重要的指标。比如常见音频采样率有 8K、 44.1K、 48K、 192K 甚至 384K 和 768K，采样位数常见的有 8 位、 16 位、 24 位、 32 位。采样率和采样位数越高，那么音频 CODEC 越能真实的还原声音，也就是大家说的 HIFI。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-21%20140523.png"></p><p>模拟量转成数字量过程，一般可以分为三个过程，分别为采样、量化、编码。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20140803.png"></p><p>①、此部分是 WM8960 提供的输入接口，作为立体声音频输入源，一共提供了三路，分别为 LINPUT1&#x2F;RINPUT1、 LINPUT2&#x2F;RINPUT2、 LINPUT3&#x2F;RINPUT3。麦克风或线路输入就连接到此接口上。<br>②、此部分是 WM8960 的输出接口，比如输出给耳机或喇叭， SPK_LP&#x2F;SPK_LN 用于连接左声道的喇叭，支持 1W 的 8Ω喇叭。  </p><p>③、此部分是数字音频接口，用于和主控制器连接，有 5 根线，用于主控制器和 WM8960之间进行数据“沟通”。主控制器向 WM8960 的 DAC 发送的数据，WM8960 的 ADC 向主控制传递的数据都是通过此音频接口来完成的。 </p><p>此接口支持 I2S 格式。此接口 5 根线的作用如下：<br>ADCDAT： ADC 数据输出引脚，采集到的音频数据转换为数字信号以后通过此引脚传输给主控制器。<br>ADCLRC： ADC 数据对齐时钟，也就是帧时钟(LRCK)，用于切换左右声道数据， 此信号的频率就是采样率。此引脚可以配置为 GPIO 功能，配置为 GPIO 以后 ADC 就会使用 DACLRC引脚作为帧时钟。<br>DACDAT： DAC 数据输入引脚，主控器通过此引脚将数字信号输入给 WM8960 的 DAC。<br>DACLRC： DAC 数据对齐时钟，功能和 ADCLRC 一样，都是帧时钟(LRCK)，用于切换左右声道数据，此信号的频率等于采样率。<br>BCLK： 位时钟，用于同步。<br>MCLK： 主时钟， WM8960 工作的时候还需要一路主时钟，此时钟由 I.MX6ULL 提供，MCLK 频率等于采样率的 256 或 384 倍。</p><p>④、此部分为控制接口，是一个标准的 I2C 接口， WM8960 要想工作必须对其进行配置，这个 I2C 接口就是用于配置 WM8960 的。 </p><h3 id="I2S总线"><a href="#I2S总线" class="headerlink" title="I2S总线"></a>I2S总线</h3><p>I2S 是飞利浦公司提出的一种用于数字音频设备之间进行音频数据传输的总线。I2S 总线用于主控制器和音频 CODEC 芯片之间传输音频数据。因此，要想使用 I2S 协议， 主控制器和音频 CODEC 都得支持 I2S 协议  。</p><p><strong>SCK</strong>： 串行时钟信号，也叫做位时钟(BCLK)，<strong>音频数据的每一位数据都对应一个 SCK</strong>，立体声都是双声道的，因此 <strong>SCK&#x3D;2×采样率×采样位数</strong>。比如采样率为 44.1KHz、 16 位的立体声音频，那么 SCK&#x3D;2× 44100×16&#x3D;1411200Hz&#x3D;1.4112MHz。<br><strong>WS</strong>： 字段(声道)选择信号，也叫做 LRCK，也叫做帧时钟，用于切换左右声道数据， WS 为“1”表示正在传输左声道的数据， WS 为“0”表示正在传输右声道的数据。 WS 的频率等于采样率，比如采样率为 44.1KHz 的音频， WS&#x3D;44.1KHz。<br><strong>SD</strong>： 串行数据信号，<strong>也就是我们实际的音频数据</strong>，如果要同时实现放音和录音，那么就需要 2 根数据线，比如 WM8960 的 ADCDAT 和 DACDAT，就是分别用于录音和放音。不管音频数据是多少位的，数据的最高位都是最先传输的。数据的最高位总是出现在一帧开始后(LRCK变化)的第 2 个 SCK 脉冲处。<br>另外，有时候为了使音频 CODEC 芯片与主控制器之间能够更好的同步，会引入另外一个叫做 MCLK 的信号，也叫做主时钟或系统时钟，一般是采样率的 256 倍或 384 倍。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20143955.png"></p><p>​一帧立体声时序图</p><p>SAI接口，全称为 Synchronous Audio Interface （同步音频接口）</p><p>SAI的主要特性是：</p><p>①、帧最大为32字</p><p>②、字最大可选择8bit和32bit</p><p>③、每个接收和发送通道拥有32x32bit的FIFO</p><p>④、FIFO错误以后支持平滑重启 。     <a href="https://blog.csdn.net/qq_46015011/article/details/107086812">FIFO是什么意思_飞鸟211的博客</a>)</p><p>使用音频芯片为wm8960芯片，在imx6ull上的硬件框图为</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20190900.png"></p><h3 id="音频驱动使能"><a href="#音频驱动使能" class="headerlink" title="音频驱动使能"></a>音频驱动使能</h3><p>nxp的官方写好了wm8960驱动，因此配置内核使能就行。</p><p>首先是添加设备树的节点，查看设备树关于此芯片的驱动手册，位置在Documentation&#x2F;devicetree&#x2F;bindings&#x2F;sound&#x2F;wm8960.txt</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20190436.png"></p><p>可以看到需要两个必备特性，compatitble和reg，还有两个可选特性，wlf,shared-lrclk和wlf,capless。</p><p>由于硬件线路将配置接口接在了i2c2上，所以在i2c2上添加设备树的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">codec: wm8960@<span class="number">1</span>a &#123;</span><br><span class="line">compatible = <span class="string">&quot;wlf,wm8960&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x1a</span>&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;<span class="comment">//时钟源SAI2</span></span><br><span class="line">clock-names = <span class="string">&quot;mclk&quot;</span>;<span class="comment">//时钟名字，为了同步一般提供mclk的时钟</span></span><br><span class="line">wlf,shared-lrclk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后是SAI的的节点代码，sound是在根节点下的一个代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">sound &#123;</span><br><span class="line">compatible = <span class="string">&quot;fsl,imx6ul-evk-wm8960&quot;</span>,</span><br><span class="line">   <span class="string">&quot;fsl,imx-audio-wm8960&quot;</span>;<span class="comment">//用于匹配驱动时使用</span></span><br><span class="line">model = <span class="string">&quot;wm8960-audio&quot;</span>;<span class="comment">//声卡的名字，相当于设备名字</span></span><br><span class="line">cpu-dai = &lt;&amp;sai2&gt;;<span class="comment">//CPU DAI（Digtial Audio Interface）句柄</span></span><br><span class="line">audio-codec = &lt;&amp;codec&gt;;<span class="comment">//音频解码芯片句柄</span></span><br><span class="line">asrc-controller = &lt;&amp;asrc&gt;;<span class="comment">//asrc控制器</span></span><br><span class="line">codec-master;</span><br><span class="line">gpr = &lt;&amp;gpr <span class="number">4</span> <span class="number">0x100000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * hp-det = &lt;hp-det-pin hp-det-polarity&gt;;</span></span><br><span class="line"><span class="comment"> * hp-det-pin: JD1 JD2  or JD3</span></span><br><span class="line"><span class="comment"> * hp-det-polarity = 0: hp detect high for headphone</span></span><br><span class="line"><span class="comment"> * hp-det-polarity = 1: hp detect high for speaker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hp-det = &lt;<span class="number">3</span> <span class="number">0</span>&gt;;<span class="comment">//耳机插入检测</span></span><br><span class="line"><span class="comment">/*hp-det-gpios = &lt;&amp;gpio5 4 0&gt;;</span></span><br><span class="line"><span class="comment">mic-det-gpios = &lt;&amp;gpio5 4 0&gt;;*/</span></span><br><span class="line">audio-routing =<span class="comment">//音频器件一系列的连接设置</span></span><br><span class="line"><span class="string">&quot;Headphone Jack&quot;</span>, <span class="string">&quot;HP_L&quot;</span>,</span><br><span class="line"><span class="string">&quot;Headphone Jack&quot;</span>, <span class="string">&quot;HP_R&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ext Spk&quot;</span>, <span class="string">&quot;SPK_LP&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ext Spk&quot;</span>, <span class="string">&quot;SPK_LN&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ext Spk&quot;</span>, <span class="string">&quot;SPK_RP&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ext Spk&quot;</span>, <span class="string">&quot;SPK_RN&quot;</span>,</span><br><span class="line"><span class="string">&quot;LINPUT2&quot;</span>, <span class="string">&quot;Mic Jack&quot;</span>,</span><br><span class="line"><span class="string">&quot;LINPUT3&quot;</span>, <span class="string">&quot;Mic Jack&quot;</span>,</span><br><span class="line"><span class="string">&quot;RINPUT1&quot;</span>, <span class="string">&quot;Main MIC&quot;</span>,</span><br><span class="line"><span class="string">&quot;RINPUT2&quot;</span>, <span class="string">&quot;Main MIC&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mic Jack&quot;</span>, <span class="string">&quot;MICB&quot;</span>,</span><br><span class="line"><span class="string">&quot;Main MIC&quot;</span>, <span class="string">&quot;MICB&quot;</span>,</span><br><span class="line"><span class="string">&quot;CPU-Playback&quot;</span>, <span class="string">&quot;ASRC-Playback&quot;</span>,</span><br><span class="line"><span class="string">&quot;Playback&quot;</span>, <span class="string">&quot;CPU-Playback&quot;</span>,</span><br><span class="line"><span class="string">&quot;ASRC-Capture&quot;</span>, <span class="string">&quot;CPU-Capture&quot;</span>,</span><br><span class="line"><span class="string">&quot;CPU-Capture&quot;</span>, <span class="string">&quot;Capture&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果查看使用SAI引脚的设置，查看sai2的节点，首先看imx6ull.dtsi的设备节点，之后对自己的设备树文件进行追加修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;sai2 &#123;</span><br><span class="line"><span class="number">2</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">3</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_sai2</span><br><span class="line"><span class="number">4</span>                &amp;pinctrl_sai2_hp_det_b&gt;;</span><br><span class="line"><span class="number">5</span>assigned-clocks = &lt;&amp;clks IMX6UL_CLK_SAI2_SEL&gt;,</span><br><span class="line"><span class="number">6</span>                   &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;</span><br><span class="line"><span class="number">7</span> assigned-clock-parents = &lt;&amp;clks IMX6UL_CLK_PLL4_AUDIO_DIV&gt;;</span><br><span class="line"><span class="number">8</span> assigned-clock-rates = &lt;<span class="number">0</span>&gt;, &lt;<span class="number">12288000</span>&gt;;</span><br><span class="line"><span class="number">9</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure><p>从 pinctrl-0 属性可以看出这里一共有两组 IO： pinctrl_sai2 和 pinctrl_sai2_hp_det_b，看这两个节点中引脚是否正确。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驱动程序编译进入内核(在内核编辑界面显示)</title>
      <link href="/2023/08/04/2023-8-4-%E9%A9%B1%E5%8A%A8%E7%BC%96%E8%AF%91%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8/"/>
      <url>/2023/08/04/2023-8-4-%E9%A9%B1%E5%8A%A8%E7%BC%96%E8%AF%91%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<p>通常都是将驱动源码编译为.ok文件，然后通过insmod 或者modprobe加载进系统中，而在脱离网络的设备中就需要将驱动编译进入内核。</p><h3 id="已知驱动类型操作步骤："><a href="#已知驱动类型操作步骤：" class="headerlink" title="已知驱动类型操作步骤："></a>已知驱动类型操作步骤：</h3><ol><li><p>查看自己编写驱动的所属类型，例如编写一个led的驱动，那么寻找内核drivers目录中的led驱动目录</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-04%20154249.png"></p></li><li><p>首先打开编写Kconfig文件</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-04%20154652.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tristate &quot;内容&quot;</span><br></pre></td></tr></table></figure><p>这行的内容是显示在menuconfig的目录中，相当于这个驱动的说明。</p></li><li><p>之后修改leds这个目录的Makefile</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-04%20150403.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">obj-$</span><span class="language-bash">(CONFIG_GPIOLED)+= gpioled.o</span></span><br></pre></td></tr></table></figure><p>$()的内容是CONFIG_后面加上Kconfig里添加的内容，+&#x3D;后面加上文件.o的名字</p></li><li><p>最后在内核中编译make menuconfig,可以在设备驱动的led驱动里面看到自己写的驱动。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-04%20153656.png"></p></li></ol><h3 id="未知驱动类型操作步骤："><a href="#未知驱动类型操作步骤：" class="headerlink" title="未知驱动类型操作步骤："></a>未知驱动类型操作步骤：</h3><ol><li><p>在drivers的目录下自行创建一个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir nxpops</span><br></pre></td></tr></table></figure></li><li><p>在此目录下创建Kconfig文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd nxpops</span><br><span class="line">vi Kconfig</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menuconfigNXPOPS</span><br><span class="line">bool &quot;nxpops driver&quot;</span><br><span class="line">help </span><br><span class="line">Put the driver the operation in nxp</span><br><span class="line">configMULTITOUCH</span><br><span class="line">tristate &quot;multitouch&quot;</span><br><span class="line">depends on NXPOPS</span><br><span class="line">help</span><br><span class="line">nxp multitouch</span><br></pre></td></tr></table></figure></li><li><p>编写Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_BEEP)</span>+= beep.o</span><br></pre></td></tr></table></figure></li><li><p>之后修改drivers目录中的Kconfig和Makefile文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &quot;drivers/nxpops/Kconfig&quot;</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-y+= nxpops/</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>触摸屏驱动</title>
      <link href="/2023/07/23/2023-7-23-%E8%A7%A6%E6%91%B8%E5%B1%8F/"/>
      <url>/2023/07/23/2023-7-23-%E8%A7%A6%E6%91%B8%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="触屏需要的知识点"><a href="#触屏需要的知识点" class="headerlink" title="触屏需要的知识点"></a>触屏需要的知识点</h2><p>首先触摸屏的驱动，也是使用之前使用input的知识点。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-22%20150749.png"></p><p>通过注册函数注册到内核，<img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-22%20150847.png"></p><p>触控屏幕，电容屏幕是控制 IC ，所以要使用到IIC的驱动，因为触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息 ，上报屏幕坐标等信息需要使用input的系统上报。<br><strong>单点触摸和多点触摸</strong><br>触摸屏分为多点触摸屏幕和单点触摸屏幕，单点触摸设备只支持单点触摸，一个同步事件完成数据只包含一个触摸点信息，单点触摸设备以ABS_XXX事件承载、上报触摸点的信息，有的设备还支持其他事件例如压力，z轴坐标等数据。<br>多点电容触摸的(Multi-touch，简称 MT)， MT 协议被分为两种类型， TypeA 和 TypeB，这两种类型的区别如下：<br>Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少！ )。<br>Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息， FT5426 就属于此类型，一般的多点电容触摸屏 IC 都有此能力。 </p><p>触摸点的信息通过一系列的 ABS_MT 事件(有的资料也叫消息)上报给 linux 内核 ，ABS_MT 事件定义在文件 include&#x2F;uapi&#x2F;linux&#x2F;input.h中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_mt_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span><span class="comment">//A型隔离触摸点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_mt_slot</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">int</span> slot)</span><span class="comment">//B型区分触摸点数据</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对于 Type A 类型的设备，发送触摸点信息的时序*/</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]<span class="comment">//通过 ABS_MT_POSITION_X 事件上报第一个触摸点的 X 坐标数据</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]<span class="comment">//通过 ABS_MT_POSITION_Y 事件上报第一个触摸点的 Y 坐标数据。</span></span><br><span class="line">SYN_MT_REPORT<span class="comment">//上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]<span class="comment">//通过 ABS_MT_POSITION_X 事件上报第二个触摸点的 X 坐标数据。</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]<span class="comment">//通过 ABS_MT_POSITION_Y 事件上报第二个触摸点的 Y 坐标数据。</span></span><br><span class="line">SYN_MT_REPORT<span class="comment">//上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。</span></span><br><span class="line">SYN_REPORT<span class="comment">//上报 SYN_REPORT 事件，通过调用 input_sync 函数实现。</span></span><br><span class="line">    <span class="comment">/*对于 Type B 类型的设备，发送触摸点信息的时序*/</span></span><br><span class="line">ABS_MT_SLOT <span class="number">0</span><span class="comment">//上报 ABS_MT_SLOT 事件，也就是触摸点对应的 SLOT。</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">45</span><span class="comment">/*根据 Type B 的要求，每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。*/</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]<span class="comment">//上报触摸点 0 的 X 轴坐标，使用函数 input_report_abs 来完成</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]<span class="comment">//上报触摸点 0 的 Y 轴坐标</span></span><br><span class="line">ABS_MT_SLOT <span class="number">1</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">46</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]</span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]</span><br><span class="line">SYN_REPORT<span class="comment">//当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件，使用 input_sync函数来完成。</span></span><br></pre></td></tr></table></figure><p>以上是TypeA和B 类型的时序，使用多点触摸驱动的时候就需要以上的时序上报坐标信息。 </p><h3 id="多点触摸所使用到的-API-函数"><a href="#多点触摸所使用到的-API-函数" class="headerlink" title="多点触摸所使用到的 API 函数"></a>多点触摸所使用到的 API 函数</h3><ol><li><p>input_mt_init_slots 函数用于初始化 MT 的输入 slots，编写 MT 驱动的时候必须先调用此函数初始化 slots。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span><span class="title function_">input_mt_init_slots</span><span class="params">( <span class="keyword">struct</span> input_dev *dev,<span class="comment">//MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev。</span></span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> num_slots,<span class="comment">//设备要使用的 SLOT 数量，也就是触摸点的数量。</span></span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> flags)</span><span class="comment">//其他一些 flags 信息，</span></span><br></pre></td></tr></table></figure></li><li><p>input_mt_slot 函数 此函数用于 Type B 类型，此函数用于产生 ABS_MT_SLOT 事件，告诉内核当前上报的是哪个触摸点的坐标数据 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_mt_slot</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,<span class="type">int</span> slot)</span></span><br></pre></td></tr></table></figure></li><li><p>input_mt_report_slot_state 函数此函数用于 Type B 类型，用于产生 ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE事 件 ， ABS_MT_TRACKING_ID 事 件 给 slot 关 联 一 个 ABS_MT_TRACKING_ID ，ABS_MT_TOOL_TYPE 事 件 指 定 触 摸 类 型 （ 是 笔 还 是 手 指 等 ）。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_mt_report_slot_state</span><span class="params">( <span class="keyword">struct</span> input_dev *dev,<span class="type">unsigned</span> <span class="type">int</span> tool_type,<span class="type">bool</span> active)</span></span><br><span class="line"><span class="comment">/*dev： MT 设备对应的 input_dev。</span></span><br><span class="line"><span class="comment">tool_type：触摸类型，可以选择 MT_TOOL_FINGER(手指)、 MT_TOOL_PEN(笔)或</span></span><br><span class="line"><span class="comment">MT_TOOL_PALM(手掌)，对于多点电容触摸屏来说一般都是手指。</span></span><br><span class="line"><span class="comment">active： true，连续触摸， input 子系统内核会自动分配一个 ABS_MT_TRACKING_ID 给 slot。</span></span><br><span class="line"><span class="comment">false，触摸点抬起，表示某个触摸点无效了， input 子系统内核会分配一个-1 给 slot，表示触摸</span></span><br><span class="line"><span class="comment">点溢出。*/</span></span><br></pre></td></tr></table></figure></li><li><p>input_report_abs 函数Type A 和 Type B 类型都使用此函数上报触摸点坐标信息，通过 ABS_MT_POSITION_X 和ABS_MT_POSITION_Y 事 件 实 现 X 和 Y 轴 坐 标 信 息 上 报 。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_report_abs</span><span class="params">( <span class="keyword">struct</span> input_dev *dev,<span class="type">unsigned</span> <span class="type">int</span> code,<span class="type">int</span> value)</span></span><br><span class="line"><span class="comment">/*dev： MT 设备对应的 input_dev。</span></span><br><span class="line"><span class="comment">code：要上报的是什么数据，可以设置为 ABS_MT_POSITION_X 或 ABS_MT_POSITION_Y，</span></span><br><span class="line"><span class="comment">也就是 X 轴或者 Y 轴坐标数据。</span></span><br><span class="line"><span class="comment">value： 具体的 X 轴或 Y 轴坐标数据值*/</span></span><br></pre></td></tr></table></figure></li><li><p>input_mt_report_pointer_emulation 如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量，然后调用 input_mt_report_pointer_emulation 函数将use_count 参数设置为 false。否则的话将use_count 参数设置为 true，表示当前的触摸点数量(函数会获取到具体的触摸点数量，不需要用户给出) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_mt_report_pointer_emulation</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,<span class="type">bool</span> use_count)</span></span><br><span class="line"><span class="comment">/*dev： MT 设备对应的 input_dev。</span></span><br><span class="line"><span class="comment">use_count： true，有效的触摸点数量； false，追踪到的触摸点数量多于当前上报的数量。*/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="多点电容触摸驱动框架"><a href="#多点电容触摸驱动框架" class="headerlink" title="多点电容触摸驱动框架"></a>多点电容触摸驱动框架</h3><p>①、多点电容触摸芯片的接口，一般都为 I2C 接口，因此驱动主框架肯定是 I2C。<br>②、 linux 里面一般都是通过中断来上报触摸点坐标信息，因此需要用到中断框架。<br>③、多点电容触摸属于 input 子系统，因此还要用到 input 子系统框架。<br>④、在中断处理程序中按照 linux 的 MT 协议上报坐标信息。 </p><h4 id="IIC驱动框架"><a href="#IIC驱动框架" class="headerlink" title="IIC驱动框架"></a>IIC驱动框架</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* 设备树匹配表 */</span></span><br><span class="line"><span class="number">2</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">xxx_ts_id</span>[] =</span> &#123;</span><br><span class="line"><span class="number">3</span> &#123; <span class="string">&quot;xxx&quot;</span>, <span class="number">0</span>, &#125;,</span><br><span class="line"><span class="number">4</span> &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line"><span class="number">5</span> &#125;;</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span><span class="comment">/* 设备树匹配表 */</span></span><br><span class="line"><span class="number">8</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">xxx_of_match</span>[] =</span> &#123;</span><br><span class="line"><span class="number">9</span> &#123; .compatible = <span class="string">&quot;xxx&quot;</span>, &#125;,</span><br><span class="line"><span class="number">10</span> &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line"><span class="number">11</span> &#125;;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="comment">/* i2c 驱动结构体 */</span></span><br><span class="line"><span class="number">14</span> <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ft5x06_ts_driver</span> =</span> &#123;</span><br><span class="line"><span class="number">15</span> .driver = &#123;</span><br><span class="line"><span class="number">16</span> .owner = THIS_MODULE,</span><br><span class="line"><span class="number">17</span> .name = <span class="string">&quot;edt_ft5x06&quot;</span>,</span><br><span class="line"><span class="number">18</span> .of_match_table =of_match_ptr(xxx_of_match),</span><br><span class="line"><span class="number">19</span> &#125;,</span><br><span class="line"><span class="number">20</span> .id_table = xxx_ts_id,</span><br><span class="line"><span class="number">21</span> .probe = xxx_ts_probe,</span><br><span class="line"><span class="number">22</span> .remove = xxx_ts_remove,</span><br><span class="line"><span class="number">23</span> &#125;;</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">26 * @description : 驱动入口函数</span></span><br><span class="line"><span class="comment">27 * @param : 无</span></span><br><span class="line"><span class="comment">28 * @return : 无</span></span><br><span class="line"><span class="comment">29 */</span></span><br><span class="line"><span class="number">30</span> <span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">31 &#123;</span><br><span class="line"><span class="number">32</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">34</span> ret = i2c_add_driver(&amp;xxx_ts_driver);</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">36</span> <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">37</span> &#125;</span><br><span class="line"><span class="number">38</span></span><br><span class="line"><span class="number">39</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">40 * @description : 驱动出口函数</span></span><br><span class="line"><span class="comment">41 * @param : 无</span></span><br><span class="line"><span class="comment">42 * @return : 无</span></span><br><span class="line"><span class="comment">43 */</span></span><br><span class="line"><span class="number">44</span> <span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">45 &#123;</span><br><span class="line"><span class="number">46</span> i2c_del_driver(&amp;ft5x06_ts_driver);</span><br><span class="line"><span class="number">47</span> &#125;</span><br><span class="line"><span class="number">48</span></span><br><span class="line"><span class="number">49</span> module_init(xxx_init);</span><br><span class="line"><span class="number">50</span> module_exit(xxx_exit);</span><br><span class="line"><span class="number">51</span> MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="number">52</span> MODULE_AUTHOR(<span class="string">&quot;zuozhongkai&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="初始化触摸-IC、中断和-input-子系统"><a href="#初始化触摸-IC、中断和-input-子系统" class="headerlink" title="初始化触摸 IC、中断和 input 子系统"></a>初始化触摸 IC、中断和 input 子系统</h4><p>在probe函数中完成初始化中断，input等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_ts_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="params">i2c_device_id *id)</span></span><br><span class="line">2 &#123;</span><br><span class="line"><span class="number">3</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span>;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="comment">/* 1、初始化 I2C */</span></span><br><span class="line"><span class="number">6</span> ......</span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="comment">/* 2，申请中断， */</span></span><br><span class="line"><span class="number">9</span> devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="literal">NULL</span>,</span><br><span class="line"><span class="number">10</span> xxx_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line"><span class="number">11</span> client-&gt;name, &amp;xxx);</span><br><span class="line"><span class="number">12</span> ......</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="comment">/* 3， input 设备申请与初始化 */</span></span><br><span class="line"><span class="number">15</span> input = devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> input-&gt;name = client-&gt;name;</span><br><span class="line"><span class="number">18</span> input-&gt;id.bustype = BUS_I2C;</span><br><span class="line"><span class="number">19</span> input-&gt;dev.parent = &amp;client-&gt;dev;</span><br><span class="line"><span class="number">20</span> ......</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="comment">/* 4，初始化 input 和 MT */</span></span><br><span class="line"><span class="number">23</span> __set_bit(EV_ABS, input-&gt;evbit);</span><br><span class="line"><span class="number">24</span> __set_bit(BTN_TOUCH, input-&gt;keybit);</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span> input_set_abs_params(input, ABS_X, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">27</span> input_set_abs_params(input, ABS_Y, <span class="number">0</span>, height, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">28</span> input_set_abs_params(input, ABS_MT_POSITION_X,<span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">29</span> input_set_abs_params(input, ABS_MT_POSITION_Y,<span class="number">0</span>, height, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">30</span> input_mt_init_slots(input, MAX_SUPPORT_POINTS, <span class="number">0</span>);</span><br><span class="line"><span class="number">31</span> ......</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span> <span class="comment">/* 5，注册 input_dev */</span></span><br><span class="line"><span class="number">34</span> input_register_device(input);</span><br><span class="line"><span class="number">35</span> ......</span><br><span class="line"><span class="number">36</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="上报坐标信息"><a href="#上报坐标信息" class="headerlink" title="上报坐标信息"></a>上报坐标信息</h4><p>typeB时序的设备多，按照typeB的时序来进行抒写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">xxx_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">2 &#123;</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="type">int</span> num; <span class="comment">/* 触摸点数量 */</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> x[n], y[n]; <span class="comment">/* 保存坐标值 */</span></span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span><span class="comment">/* 1、从触摸芯片获取各个触摸点坐标值 */</span></span><br><span class="line"><span class="number">8</span> ......</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* 2、上报每一个触摸点坐标 */</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="number">12</span> input_mt_slot(input, id);</span><br><span class="line"><span class="number">13</span> input_mt_report_slot_state(input, MT_TOOL_FINGER, <span class="literal">true</span>);</span><br><span class="line"><span class="number">14</span> input_report_abs(input, ABS_MT_POSITION_X, x[i]);</span><br><span class="line"><span class="number">15</span> input_report_abs(input, ABS_MT_POSITION_Y, y[i]);</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> ......</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span> input_sync(input);</span><br><span class="line"><span class="number">20</span> ......</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"><span class="number">23</span> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-01%20203604.png"></p><h3 id="移植tslib库"><a href="#移植tslib库" class="headerlink" title="移植tslib库"></a>移植tslib库</h3><p>tslib 是一个开源的第三方库，用于触摸屏性能调试，使用电阻屏的时候一般使用 tslib 进行校准。虽然电容屏不需要校准，但是由于电容屏加工的原因，有的时候其不一定精准，因此有时候也需要进行校准。最主要的是 tslib 提供了一些其他软件，我们可以通过这些软件来测试触摸屏工作是否正常。最新版本的 tslib 已经支持了多点电容触摸屏，因此可以通过 tslib 来直观的测试多点电容触摸屏驱动，这个要比观看 eventX 原始数据方便的多。<br>tslib 的移植很简单，步骤如下：<br><strong>1、获取 tslib 源码</strong><br>首先肯定是获取 tslib 的源码， git 地址为 <a href="https://github.com/kergoth/tslib%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AF1.21%E3%80%82">https://github.com/kergoth/tslib，目前最新的版本是1.21。</a><br><strong>2、修改 tslib 源码所属用户</strong><br>修改解压得到的 tslib-1.21 目录所属用户为当前用户，这一步一定要做！否则在稍后的编译<br>中会遇到各种问题。我当前 ubuntu 的登录用户名为“moss”，那么修改命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown moss:moss tslib-1.21 -R</span><br></pre></td></tr></table></figure><p><strong>3、 ubuntu 工具安装</strong><br>编译 tslib 的时候需要先在 ubuntu 中安装一些文件，防止编译 tslib 过程中出错，命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf</span><br><span class="line">sudo apt-get install automake</span><br><span class="line">sudo apt-get install libtool</span><br></pre></td></tr></table></figure><p><strong>4、编译 tslib</strong><br>首先在 ubuntu 中创建一个名为“tslib”的目录存放编译结果，比如我们创建的 tslib 目录路径为： &#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;IMX6ULL&#x2F;tool&#x2F;tslib。<br>接下来输入如下命令配置并编译 tslib：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd tslib-1.21/ //进入 tslib 源码目录</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure --host=arm-linux-gnueabihf --prefix=/home/moss/linux/tool/tslib</span><br><span class="line">make //编译</span><br><span class="line">make install //安装</span><br></pre></td></tr></table></figure><p>注意，在使用.&#x2F;configure 配置 tslib 的时候“–host”参数指定编译器，“–prefix”参数指定编译完成以后的 tslib 文件安装到哪里，这里肯定是安装到我们刚刚创建的“tslib”目录下。<br>bin 目录下是可执行文件，包括 tslib 的测试工具。 etc 目录下是 tslib 的配置文件， lib 目录下是相关的库文件。将lib的所有文件拷贝到开发板的根文件系统中，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp * -rf /home/zuozhongkai/linux/nfs/rootfs</span><br></pre></td></tr></table></figure><p>5、 配置 tslib<br>打开&#x2F;etc&#x2F;ts.conf 文件，找到下面这一行：module_raw input<br>如果上面这句前面有“#”的话就删除掉“#”。打开&#x2F;etc&#x2F;profile 文件，在里面加入如下内容：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> export TSLIB_TSDEVICE=/dev/input/event2</span><br><span class="line"><span class="number">2</span> export TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line"><span class="number">3</span> export TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line"><span class="number">4</span> export TSLIB_PLUGINDIR=/lib/ts</span><br><span class="line"><span class="number">5</span> export TSLIB_CONSOLEDEVICE=none</span><br><span class="line"><span class="number">6</span> export TSLIB_FBDEVICE=/dev/fb0</span><br></pre></td></tr></table></figure><p>第 1 行， TSLIB_TSDEVICE 表示触摸设备文件，这里设置为&#x2F;dev&#x2F;input&#x2F;event2，这个要根据具体情况设置，如果你的触摸设备文件为 event2 那么就应该设置为&#x2F;dev&#x2F;input&#x2F;event2，以此类推。<br>第 2 行， TSLIB_CALIBFILE 表示校准文件，如果进行屏幕校准的话校准结果就保存在这个文件中，这里设置校准文件为&#x2F;etc&#x2F;pointercal， 此文件可以不存在，校准的时候会自动生成。<br>第 3 行， TSLIB_CONFFILE 表示触摸配置文件，文件为&#x2F;etc&#x2F;ts.conf，此文件在移植 tslib 的时候会生成。<br>第 4 行， TSLIB_PLUGINDIR 表示 tslib 插件目录位置，目录为&#x2F;lib&#x2F;ts。<br>第 5 行， TSLIB_CONSOLEDEVICE 表示控制台设置，这里不设置，因此为 none。<br>第 6 行， TSLIB_FBDEVICE 表示 FB 设备，也就是屏幕，根据实际情况配置，我的屏幕文件为&#x2F;dev&#x2F;fb0，因此这里设置为&#x2F;dev&#x2F;fb0。全部配置好以后重启开发板，然后就可以进行测试了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串口驱动</title>
      <link href="/2023/07/20/2023-7-20-%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/20/2023-7-20-%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="串口驱动程序层次结构"><a href="#串口驱动程序层次结构" class="headerlink" title="串口驱动程序层次结构"></a>串口驱动程序层次结构</h2><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-20%20203055.png"></p><p>下层为串口驱动层，它直接与硬件相接触，需要填充一个 struct uart_ops 的结构体。上层为tty层，包括tty核心层及线路规程，它们各自都有一个 ops 结构体，用户空间可以通过tty注册的字符设备节点来访问串口设备。涉及到了4个 ops 结构体，层层进行跳转。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-20%20194425.png"></p><p>uart_driver包含了串口设备名、串口驱动名、主次设备号、串口控制台(可选)等信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">module</span>  *<span class="title">owner</span>;</span> <span class="comment">//拥有该uart_driver的模块,一般为THIS_MODULE </span></span><br><span class="line">   constchar *driver_name; <span class="comment">// 串口驱动名，串口设备文件名以驱动名为基础 </span></span><br><span class="line">   constchar *dev_name; <span class="comment">// 串口设备名 </span></span><br><span class="line">   <span class="type">int</span> major; <span class="comment">//主设备号 </span></span><br><span class="line">   <span class="type">int</span> minor; <span class="comment">//次设备号 </span></span><br><span class="line">   <span class="type">int</span> nr; <span class="comment">// 该uart_driver支持的串口个数(最大) </span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">console</span>  *<span class="title">cons</span>;</span><span class="comment">// 其对应的console.若该uart_driver支持serial console,否则为NULL </span></span><br><span class="line">    .............................</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span>  *<span class="title">state</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span>  *<span class="title">tty_driver</span>;</span>   <span class="comment">//uart_driver封装了tty_driver，使底层uart驱动不用关心ttr_driver。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(1)一个tty驱动程序必须注册&#x2F;注销tty_driver。</p><p>(2)一个uart驱动则变为注册&#x2F;注销uart_driver。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uart_register_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_unregister_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_register_driver</span><span class="params">(<span class="keyword">struct</span> tty_driver *drv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_unregister_driver</span><span class="params">(<span class="keyword">struct</span> tty_driver *drv)</span>;</span><br></pre></td></tr></table></figure><p><em>uart_port用于描述一个UART端口（直接对应于一个串口）的I&#x2F;O端口或I&#x2F;O内存地址、FIFO大小、端口类型等信息。</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;<span class="comment">/* 串口端口锁 */</span></span><br><span class="line">unsignedint iobase;<span class="comment">/* IO端口基地址 */</span></span><br><span class="line">unsignedchar __iomem *membase;<span class="comment">/* IO内存基地址,经映射(如ioremap)后的IO内存虚拟基地址 */</span></span><br><span class="line">unsignedint irq;<span class="comment">/* 中断号 */</span></span><br><span class="line">unsignedint uartclk;<span class="comment">/* 串口时钟 */</span></span><br><span class="line">unsignedint fifosize;<span class="comment">/* 串口FIFO缓冲大小 */</span></span><br><span class="line">unsignedchar x_char;<span class="comment">/* xon/xoff字符 */</span></span><br><span class="line">unsignedchar regshift;<span class="comment">/* 寄存器位移 */</span></span><br><span class="line">unsignedchar iotype;<span class="comment">/* IO访问方式 */</span></span><br><span class="line">unsignedchar unused1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_PORT (0)<span class="comment">/* IO端口 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_HUB6 (1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM (2)<span class="comment">/* IO内存 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM32 (3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_AU (4)<span class="comment">/* Au1x00 type IO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_TSI (5)<span class="comment">/* Tsi108/109 type IO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_DWAPB (6)<span class="comment">/* DesignWare APB UART */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_RM9000 (7)<span class="comment">/* RM9000 type IO */</span></span></span><br><span class="line"></span><br><span class="line">unsignedint read_status_mask;<span class="comment">/* 关心的Rx error status */</span></span><br><span class="line">unsignedint ignore_status_mask;<span class="comment">/* 忽略的Rx error status */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_info</span> *<span class="title">info</span>;</span>        <span class="comment">//重要，见下面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_icount</span>  <span class="title">icount</span>;</span>   <span class="comment">/* 计数器 uart_icount为串口信息计数器，包含了发送字符计数、接收字符计数等。在串口的发送中断处理函数和接收中断处理函数中，我们需要管理这些计数。*/</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">cons</span>;</span><span class="comment">/* console结构体 */</span></span><br><span class="line">#ifdefCONFIG_SERIAL_CORE_CONSOLE</span><br><span class="line">unsignedlong sysrq;<span class="comment">/* sysrq timeout */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">upf_t</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_FOURPORT ((__forceupf_t)(1 &lt;&lt; 1))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SAK ((__forceupf_t)(1 &lt;&lt; 2))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_MASK ((__forceupf_t)(0x1030))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_HI ((__forceupf_t)(0x0010))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_VHI ((__forceupf_t)(0x0020))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_CUST ((__forceupf_t)(0x0030))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_SHI ((__forceupf_t)(0x1000))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_WARP ((__forceupf_t)(0x1010))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SKIP_TEST ((__forceupf_t)(1 &lt;&lt; 6))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_AUTO_IRQ ((__forceupf_t)(1 &lt;&lt; 7))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_HARDPPS_CD ((__forceupf_t)(1 &lt;&lt; 11))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_LOW_LATENCY ((__forceupf_t)(1 &lt;&lt; 13))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_BUGGY_UART ((__forceupf_t)(1 &lt;&lt; 14))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_MAGIC_MULTIPLIER((__force upf_t)(1 &lt;&lt; 16))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_CONS_FLOW ((__forceupf_t)(1 &lt;&lt; 23))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SHARE_IRQ ((__forceupf_t)(1 &lt;&lt; 24))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_BOOT_AUTOCONF ((__forceupf_t)(1 &lt;&lt; 28))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_FIXED_PORT ((__forceupf_t)(1 &lt;&lt; 29))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_DEAD ((__forceupf_t)(1 &lt;&lt; 30))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_IOREMAP ((__forceupf_t)(1 &lt;&lt; 31))</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_CHANGE_MASK ((__forceupf_t)(0x17fff))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_USR_MASK ((__forceupf_t)(UPF_SPD_MASK|UPF_LOW_LATENCY))</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mctrl;<span class="comment">/* 当前的moden设置 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> timeout;<span class="comment">/* character-based timeout */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> type;<span class="comment">/* 端口类型 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> *<span class="title">ops</span>;</span><span class="comment">/* 串口端口操作函数集 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> custom_divisor;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  line;<span class="comment">/* 端口索引 */</span></span><br><span class="line">    <span class="type">resource_size_t</span> mapbase;<span class="comment">/* IO内存物理基地址，可用于ioremap */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span><span class="comment">/* 父设备 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hub6;<span class="comment">/* this should be in the 8250 driver */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> suspended;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> unused[<span class="number">2</span>];</span><br><span class="line">    <span class="type">void</span>*private_data;<span class="comment">/* 端口私有数据,一般为platform数据指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPI驱动</title>
      <link href="/2023/07/18/2023-7-18-SPI%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/18/2023-7-18-SPI%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-18%20202734.png"></p><h3 id="SPI-控制器驱动程序"><a href="#SPI-控制器驱动程序" class="headerlink" title="SPI 控制器驱动程序"></a><strong>SPI 控制器驱动程序</strong></h3><p><strong>SPI 主机驱动就是 SOC 的 SPI 控制器驱动，</strong>SPI 控制器不用关心设备的具体功能，它只负责把上层协议驱动准备好的数据按 SPI 总线的时序要求发送给 SPI 设备，同时把从设备收到的数据返回给上层的协议驱动，因此，内核把 SPI 控制器的驱动程序独立出来。</p><p>SPI 控制器驱动负责控制具体的控制器硬件，诸如 DMA 和中断操作等等，因为多个上层的协议驱动可能会通过控制器请求数据传输操作，所以，SPI 控制器驱动同时也要负责对这些请求进行队列管理，保证先进先出的原则。</p><ol><li><p>申请必要的硬件资源，比如中断、DMA 通道、DMA 内存缓冲区等等</p></li><li><p>配置 SPI 控制器的工作模式和参数，使之可以和相应的设备进行正确的数据交换</p></li><li><p>向通用接口层提供接口，使得上层的协议驱动可以通过通用接口层访问控制器驱动</p></li><li><p>配合通用接口层，完成数据消息队列的排队和处理，直到消息队列变空为止</p></li></ol><p><strong>SPI 主机驱动的核心就是申请 spi_master，然后初始化 spi_master，最后向 Linux 内核注册spi_master。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spi_alloc_master 函数：申请 spi_master。</span><br><span class="line">spi_master_put 函数：释放 spi_master。</span><br><span class="line"></span><br><span class="line">spi_register_master函数：注册 spi_master。</span><br><span class="line">spi_unregister_master 函数：注销 spi_master。</span><br><span class="line"></span><br><span class="line">spi_bitbang_start函数：注册 spi_master。</span><br><span class="line">spi_bitbang_stop 函数：注销 spi_master</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-18%20201838.png"></p><h3 id="SPI-通用接口封装层"><a href="#SPI-通用接口封装层" class="headerlink" title="SPI 通用接口封装层"></a><strong>SPI 通用接口封装层</strong></h3><p>为了简化 SPI 驱动程序的编程工作，同时也为了降低【协议驱动程序】和【控制器驱动程序】的耦合程度，内核把控制器驱动和协议驱动的一些通用操作封装成标准的接口，加上一些通用的逻辑处理操作，组成了 SPI 通用接口封装层。</p><p>这样的好处是，对于控制器驱动程序，只要实现标准的接口回调 API，并把它注册到通用接口层即可，无需直接和协议层驱动程序进行交互。而对于协议层驱动来说，只需通过通用接口层提供的 API 即可完成设备和驱动的注册，并通过通用接口层的 API 完成数据的传输，无需关注 SPI 控制器驱动的实现细节。</p><ol><li><p>SPI 通用接口层把具体的 SPI 设备的协议驱动和 SPI 控制器驱动连接在一起。</p></li><li><p>负责 SPI 系统与 Linux 设备模型相关的初始化工作。</p></li><li><p>为协议驱动和控制器驱动提供一系列的标准接口 API 及其数据结构。</p></li><li><p>SPI 设备、SPI 协议驱动、SPI 控制器的数据抽象</p></li><li><p>协助数据传输而定义的数据结构</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重要数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>//描述一个 <span class="title">spi</span> 从机设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span>//描述一个 <span class="title">spi</span> 设备驱动</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_board_info</span>//描述一个 <span class="title">spi</span> 从机设备板级信息，无设备树时使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>/<span class="title">spi_master</span>//描述一个 <span class="title">spi</span> 主机设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>//描述 <span class="title">spi</span> 传输的具体数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span>//描述一次 <span class="title">spi</span> 传输的信息，是一次 <span class="title">SPI</span> 数据交换的原子操作</span></span><br><span class="line"><span class="class">//重要<span class="title">API</span></span></span><br><span class="line"><span class="class"><span class="title">spi_message_init</span></span></span><br><span class="line"><span class="class"><span class="title">spi_message_add_tail</span></span></span><br><span class="line"><span class="class"><span class="title">spi_sync</span></span></span><br><span class="line"><span class="class"><span class="title">spi_async</span></span></span><br><span class="line"><span class="class"><span class="title">spi_write</span></span></span><br><span class="line"><span class="class"><span class="title">spi_read</span></span></span><br></pre></td></tr></table></figure><h3 id="SPI-协议驱动程序"><a href="#SPI-协议驱动程序" class="headerlink" title="SPI 协议驱动程序"></a><strong>SPI 协议驱动程序</strong></h3><p>SPI 设备的具体功能是由 SPI 协议驱动程序完成的，SPI 协议驱动程序了解设备的功能和通信数据的协议格式。向下，协议驱动通过通用接口层和控制器交换数据，向上，协议驱动通常会根据设备具体的功能和内核的其它子系统进行交互。</p><p>例如，和 MTD 层交互以便把 SPI 接口的存储设备实现为某个文件系统，和 TTY 子系统交互把 SPI 设备实现为一个 TTY 设备，和网络子系统交互以便把一个 SPI 设备实现为一个网络设备。如果是一个专有的 SPI 设备，我们也可以按设备的协议要求，实现自己的专有协议驱动。</p><h3 id="SPI-通用设备驱动程序"><a href="#SPI-通用设备驱动程序" class="headerlink" title="SPI 通用设备驱动程序"></a><strong>SPI 通用设备驱动程序</strong></h3><p>考虑到连接在 SPI 控制器上的设备的可变性，在内核没有配备相应的协议驱动程序，对于这种情况，内核为我们准备了通用的 SPI 设备驱动程序，该通用设备驱动程序向用户空间提供了控制 SPI 控制的控制接口，具体的协议控制和数据传输工作交由用户空间根据具体的设备来完成，在这种方式中，只能采用同步的方式和 SPI 设备进行通信，所以通常用于一些数据量较少的简单 SPI 设备。</p><p>在Linux内核中spi的函数存放位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel<span class="number">-4.15</span>/drivers/spi/spi.c  Linux 提供的通用接口封装层驱动</span><br><span class="line">kernel<span class="number">-4.15</span>/drivers/spi/spidev.c  linux 提供的 SPI 通用设备驱动程序</span><br><span class="line">kernel<span class="number">-4.15</span>/include/linux/spi/spi.h  linux 提供的包含 SPI 的主要数据结构和函数</span><br></pre></td></tr></table></figure><p><strong>SPI 数据传输可以有两种方式：同步方式和异步方式。</strong></p><p>同步方式：数据传输的发起者必须等待本次传输的结束，期间不能做其它事情，用代码来解释就是，调用传输的函数后，直到数据传输完成，函数才会返回。</p><p>异步方式：数据传输的发起者无需等待传输的结束，数据传输期间还可以做其它事情，用代码来解释就是，调用传输的函数后，函数会立刻返回而不用等待数据传输完成，我们只需设置一个回调函数，传输完成后，该回调函数会被调用以通知发起者数据传送已经完成。</p><p>spi_async函数是发起一个异步传输的API，它会把spi_message结构挂在spi_master的queue字段下，然后启动专门为spi传输准备的内核工作线程，由该工作线程来实际处理message的传输工作，因为是异步操作，所以该函数会立刻返回，不会等待传输的完成，这时，协议驱动程序（可能是另一个协议驱动程序）可以再次调用该API，发起另一个message传输请求，结果就是，当工作线程被唤醒时，spi_master下面可能已经挂了多个待处理的spi_message结构，工作线程会按先进先出的原则来逐个处理这些message请求，每个message传送完成后，对应spi_message结构的complete回调函数就会被调用，以通知协议驱动程序准备下一帧数据。这就是spi_message的队列化。工作线程唤醒时，spi_master、spi_message和spi_transfer之间的关系可以用下图来描述：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-18%20200811.png"></p><h3 id="SPI驱动结构"><a href="#SPI驱动结构" class="headerlink" title="SPI驱动结构"></a>SPI驱动结构</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-18%20204137.png"></p><p>spi_driver 注册示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* probe 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 具体函数内容 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* remove 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 具体函数内容 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 传统匹配方式 ID 列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">xxx_id</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;xxx&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">xxx_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;xxx&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI 驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">xxx_driver</span> =</span> &#123;</span><br><span class="line">.probe = xxx_probe,</span><br><span class="line">.remove = xxx_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.name = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">.of_match_table = xxx_of_match,</span><br><span class="line">&#125;,</span><br><span class="line">.id_table = xxx_id,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> spi_register_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">spi_unregister_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure><h3 id="设备驱动的编写流程"><a href="#设备驱动的编写流程" class="headerlink" title="设备驱动的编写流程"></a>设备驱动的编写流程</h3><p>SPI使用的API函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">603</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span></span><br><span class="line"><span class="number">604</span> <span class="comment">/* it&#x27;s ok if tx_buf == rx_buf (right?)</span></span><br><span class="line"><span class="comment">605 * for MicroWire, one buffer must be null</span></span><br><span class="line"><span class="comment">606 * buffers must work with dma_*map_single() calls, unless</span></span><br><span class="line"><span class="comment">607 * spi_message.is_dma_mapped reports a pre-existing mapping</span></span><br><span class="line"><span class="comment">608 */</span></span><br><span class="line"><span class="number">609</span> <span class="type">const</span> <span class="type">void</span> *tx_buf;<span class="comment">//发送数据</span></span><br><span class="line"><span class="number">610</span> <span class="type">void</span> *rx_buf;<span class="comment">//接收数据</span></span><br><span class="line"><span class="number">611</span> <span class="type">unsigned</span> len;<span class="comment">//len 是要进行传输的数据长度</span></span><br><span class="line"><span class="number">612</span></span><br><span class="line"><span class="number">613</span> <span class="type">dma_addr_t</span> tx_dma;</span><br><span class="line"><span class="number">614</span> <span class="type">dma_addr_t</span> rx_dma;</span><br><span class="line"><span class="number">615</span> <span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">tx_sg</span>;</span></span><br><span class="line"><span class="number">616</span> <span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">rx_sg</span>;</span></span><br><span class="line"><span class="number">617</span></span><br><span class="line"><span class="number">618</span> <span class="type">unsigned</span> cs_change:<span class="number">1</span>;</span><br><span class="line"><span class="number">619</span> <span class="type">unsigned</span> tx_nbits:<span class="number">3</span>;</span><br><span class="line"><span class="number">620</span> <span class="type">unsigned</span> rx_nbits:<span class="number">3</span>;</span><br><span class="line"><span class="number">621</span> <span class="meta">#<span class="keyword">define</span> SPI_NBITS_SINGLE 0x01 <span class="comment">/* 1bit transfer */</span></span></span><br><span class="line"><span class="number">622</span> <span class="meta">#<span class="keyword">define</span> SPI_NBITS_DUAL 0x02 <span class="comment">/* 2bits transfer */</span></span></span><br><span class="line"><span class="number">623</span> <span class="meta">#<span class="keyword">define</span> SPI_NBITS_QUAD 0x04 <span class="comment">/* 4bits transfer */</span></span></span><br><span class="line"><span class="number">624</span> u8 bits_per_word;</span><br><span class="line"><span class="number">625</span> u16 delay_usecs;</span><br><span class="line"><span class="number">626</span> u32 speed_hz;</span><br><span class="line"><span class="number">627</span></span><br><span class="line"><span class="number">628</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfer_list</span>;</span></span><br><span class="line"><span class="number">629</span> &#125;;</span><br></pre></td></tr></table></figure><p>spi_transfer 需要组织成 spi_message， spi_message 也是一个结构体 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> &#123;</span></span><br><span class="line"><span class="number">661</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfers</span>;</span></span><br><span class="line"><span class="number">662</span></span><br><span class="line"><span class="number">663</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span>;</span></span><br><span class="line"><span class="number">664</span></span><br><span class="line"><span class="number">665</span> <span class="type">unsigned</span> is_dma_mapped:<span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">678</span> <span class="comment">/* completion is reported through a callback */</span></span><br><span class="line"><span class="number">679</span> <span class="type">void</span> (*complete)(<span class="type">void</span> *context);</span><br><span class="line"><span class="number">680</span> <span class="type">void</span> *context;</span><br><span class="line"><span class="number">681</span> <span class="type">unsigned</span> frame_length;</span><br><span class="line"><span class="number">682</span> <span class="type">unsigned</span> actual_length;</span><br><span class="line"><span class="number">683</span> <span class="type">int</span> status;</span><br><span class="line"><span class="number">684</span></span><br><span class="line"><span class="number">685</span> <span class="comment">/* for optional use by whatever driver currently owns the</span></span><br><span class="line"><span class="comment">686 * spi_message ... between calls to spi_async and then later</span></span><br><span class="line"><span class="comment">687 * complete(), that&#x27;s the spi_master controller driver.</span></span><br><span class="line"><span class="comment">688 */</span></span><br><span class="line"><span class="number">689</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>;</span></span><br><span class="line"><span class="number">690</span> <span class="type">void</span> *state;</span><br><span class="line"><span class="number">691</span> &#125;;</span><br></pre></td></tr></table></figure><p>在使用spi_message之前需要对其进行初始化， spi_message初始化函数为spi_message_init，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spi_message_init</span><span class="params">(<span class="keyword">struct</span> spi_message *m)</span></span><br><span class="line"><span class="comment">/*m： 要初始化的 spi_message。</span></span><br><span class="line"><span class="comment">返回值： 无。*/</span></span><br></pre></td></tr></table></figure><p>spi_message 初始化完成以后需要将 spi_transfer 添加到 spi_message 队列中，这里我们要用到 spi_message_add_tail 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spi_message_add_tail</span><span class="params">(<span class="keyword">struct</span> spi_transfer *t, <span class="keyword">struct</span> spi_message *m)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">t： 要添加到队列中的 spi_transfer。</span></span><br><span class="line"><span class="comment">m： spi_transfer 要加入的 spi_message。</span></span><br><span class="line"><span class="comment">返回值： 无。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>spi_message 准备好以后就可以进行数据传输了，数据传输分为同步传输和异步传输，<strong>同步传输会阻塞的等待 SPI 数据传输完成</strong>，同步传输函数为 spi_sync，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_sync</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *message)</span></span><br><span class="line"><span class="comment">/*spi： 要进行数据传输的 spi_device。</span></span><br><span class="line"><span class="comment">message：要传输的 spi_message。</span></span><br><span class="line"><span class="comment">返回值： 无。*/</span></span><br></pre></td></tr></table></figure><p><strong>异步传输不会阻塞的等到 SPI 数据传输完成</strong>，异步传输需要设置 spi_message 中的 complete成员变量， complete 是一个回调函数，当 SPI 异步传输完成以后此函数就会被调用。 SPI 异步传输函数为 spi_async。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_async</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *message)</span></span><br><span class="line"><span class="comment">/*spi： 要进行数据传输的 spi_device。</span></span><br><span class="line"><span class="comment">message：要传输的 spi_message。</span></span><br><span class="line"><span class="comment">返回值： 无。 */</span></span><br></pre></td></tr></table></figure><p>同步传输通过 SPI 进行 n 个字节的数据发送和接收的示例代码 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPI 多字节发送 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_send</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, u8 *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> <span class="title">t</span> =</span> &#123;</span><br><span class="line">.tx_buf = buf,</span><br><span class="line">.len = len,</span><br><span class="line">&#125;;</span><br><span class="line">spi_message_init(&amp;m); <span class="comment">/* 初始化 spi_message */</span></span><br><span class="line">spi_message_add_tail(t, &amp;m);<span class="comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span></span><br><span class="line">ret = spi_sync(spi, &amp;m); <span class="comment">/* 同步传输 */</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* SPI 多字节接收 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_receive</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, u8 *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> <span class="title">t</span> =</span> &#123;</span><br><span class="line">.rx_buf = buf,</span><br><span class="line">.len = len,</span><br><span class="line">&#125;;</span><br><span class="line">spi_message_init(&amp;m); <span class="comment">/* 初始化 spi_message */</span></span><br><span class="line">spi_message_add_tail(t, &amp;m);<span class="comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span></span><br><span class="line">ret = spi_sync(spi, &amp;m); <span class="comment">/* 同步传输 */</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下的IIC</title>
      <link href="/2023/07/18/2023-7-18-linux%E4%B8%8B%E7%9A%84IIC/"/>
      <url>/2023/07/18/2023-7-18-linux%E4%B8%8B%E7%9A%84IIC/</url>
      
        <content type="html"><![CDATA[<h1 id="linux的IIC体系结构"><a href="#linux的IIC体系结构" class="headerlink" title="linux的IIC体系结构"></a>linux的IIC体系结构</h1><p>Linux的IIC体系结构分为3个组成部分，分别是IIC核心、IIC总线驱动和IIC设备驱动！</p><p>（1）IIC核心</p><p>提供了IIC总线驱动与IIC设备驱动的注册、注销方法和与具体IIC控制器无关的代码，该部分用来管理IIC总线驱动与IIC设备驱动。</p><p>（2）IIC总线驱动</p><p>IIC总线驱动是适配器（IIC控制器）的驱动程序，包含了适配器（IIC控制器）的数据描述结构i2c_adapter、通信方法数据结构i2c_algorithm、控制适配器产生通信时序的函数。</p><p>（3）IIC设备驱动</p><p>是具体IIC设备的驱动，因为不同的IIC设备可能有不同的读写时序要求，比如at24cxx读写需要发送16位地址，而tmp75只需要8位地址即可。IIC设备驱动通过i2c_algorithm通信方法驱动适配器驱动程序去访问具体的IIC设备。</p><p>体系结构</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-19%20205901.png"></p><h2 id="架构层次分类"><a href="#架构层次分类" class="headerlink" title="架构层次分类"></a>架构层次分类</h2><p>　　<strong>第一层</strong>：提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。图中的硬件实现控制层。</p><p>　　<strong>第二层：</strong>提供i2c adapter的algorithm，用具体适配器的xxx_xfer()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。图中的访问抽象层。</p><p>　　<strong>第三层：</strong>实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的probe()、remove()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的匹配挂接。图中的driver驱动层。</p><p>　　<strong>第四层：</strong>实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。也是图中的driver驱动层。</p><p>​       <strong>第一层和第二层属于i2c总线驱动(bus)（芯片厂商写），第三第四属于i2c设备驱动(device driver)（驱动工程师来写）。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC驱动</title>
      <link href="/2023/07/14/2023-7-14-IIC%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/14/2023-7-14-IIC%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="IIC驱动框架"><a href="#IIC驱动框架" class="headerlink" title="IIC驱动框架"></a>IIC驱动框架</h3><p>Linux内核将 I2C 驱动分为两部分：<br>①、 I2C 总线驱动， I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。<br>②、 I2C 设备驱动， I2C 设备驱动就是针对具体的 I2C 设备而编写的驱动。 </p><p>IIC驱动也是借用platform思想，将设备和总线进行分离，但是IIC有自己的总线，所以就不用使用虚拟总线。</p><p>I2C 总线驱动重点是 I2C 适配器(也就是 SOC 的 I2C 接口控制器)驱动，这里要用到两个重要的数据结构： i2c_adapter 和 i2c_algorithm， Linux 内核将 SOC 的 I2C 适配器(控制器)抽象成 i2c_adapter， i2c_adapter 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">498</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line"><span class="number">499</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="number">500</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span> <span class="comment">/* classes to allow probing for */</span></span><br><span class="line"><span class="number">501</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* 总线访问算法 */</span></span><br><span class="line"><span class="number">502</span> <span class="type">void</span> *algo_data;</span><br><span class="line"><span class="number">503</span></span><br><span class="line"><span class="number">504</span> <span class="comment">/* data fields that are valid for all devices */</span></span><br><span class="line"><span class="number">505</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line"><span class="number">506</span></span><br><span class="line"><span class="number">507</span> <span class="type">int</span> timeout; <span class="comment">/* in jiffies */</span></span><br><span class="line"><span class="number">508</span> <span class="type">int</span> retries;</span><br><span class="line"><span class="number">509</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span> <span class="comment">/* the adapter device */</span></span><br><span class="line"><span class="number">510</span></span><br><span class="line"><span class="number">511</span> <span class="type">int</span> nr;</span><br><span class="line"><span class="number">512</span> <span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line"><span class="number">513</span> <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"><span class="number">514</span></span><br><span class="line"><span class="number">515</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line"><span class="number">516</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line"><span class="number">517</span></span><br><span class="line"><span class="number">518</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line"><span class="number">519</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line"><span class="number">520</span> &#125;;</span><br></pre></td></tr></table></figure><p> i2c_algorithm 就是 I2C 适配器与 IIC 设备进行通信的方法。i2c_algorithm 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">391</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">......</span><br><span class="line"><span class="number">398</span> <span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap,<span class="keyword">struct</span> i2c_msg *msgs,<span class="type">int</span> num);</span><br><span class="line"><span class="number">399</span> <span class="comment">//master_xfer 就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之间的通信。</span></span><br><span class="line"><span class="number">400</span> <span class="type">int</span> (*smbus_xfer) (<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,<span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line"><span class="number">401</span> u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"><span class="number">402</span> <span class="comment">//smbus_xfer 就是 SMBUS 总线的传输函数</span></span><br><span class="line"><span class="number">403</span></span><br><span class="line"><span class="number">404</span> <span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line"><span class="number">405</span> u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line">......</span><br><span class="line"><span class="number">411</span> &#125;;</span><br></pre></td></tr></table></figure><p><strong>I2C 总线驱动，或者说 I2C 适配器驱动的主要工作就是初始化 i2c_adapter 结构体变量，然后设置 i2c_algorithm 中的 master_xfer 函数。完成以后通过 i2c_add_numbered_adapter或 i2c_add_adapter 这两个函数向系统注册设置好的 i2c_adapter</strong>，这两个函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span><span class="comment">//使用动态的总线号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_numbered_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span> <span class="comment">//使用静态的总线号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter * adap)</span><span class="comment">//删除 I2C 适配器</span></span><br></pre></td></tr></table></figure><h3 id="I2C-设备驱动"><a href="#I2C-设备驱动" class="headerlink" title="I2C 设备驱动"></a>I2C 设备驱动</h3><p>I2C 描写设备驱动，类似platform，分为描述设备的i2c_client和描述驱动内容的i2c_driver</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">217</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line"><span class="number">218</span> <span class="type">unsigned</span> <span class="type">short</span> flags; <span class="comment">/* 标志 */</span></span><br><span class="line"><span class="number">219</span> <span class="type">unsigned</span> <span class="type">short</span> addr; <span class="comment">/* 芯片地址， 7 位，存在低 7 位*/</span></span><br><span class="line">......</span><br><span class="line"><span class="number">222</span> <span class="type">char</span> name[I2C_NAME_SIZE]; <span class="comment">/* 名字 */</span></span><br><span class="line"><span class="number">223</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span> <span class="comment">/* 对应的 I2C 适配器 */</span></span><br><span class="line"><span class="number">224</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span> <span class="comment">/* 设备结构体 */</span></span><br><span class="line"><span class="number">225</span> <span class="type">int</span> irq; <span class="comment">/* 中断 */</span></span><br><span class="line"><span class="number">226</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="number">230</span> &#125;;</span><br><span class="line"><span class="comment">//一个设备对应一个 i2c_client，每检测到一个 I2C 设备就会给这个 I2C 设备分配一个i2c_client。</span></span><br><span class="line"></span><br><span class="line"><span class="number">161</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line"><span class="number">162</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"><span class="number">163</span></span><br><span class="line"><span class="number">164</span> <span class="comment">/* Notifies the driver that a new bus has appeared. You should</span></span><br><span class="line"><span class="comment">165 * avoid using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">166 */</span></span><br><span class="line"><span class="number">167</span> <span class="type">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;</span><br><span class="line"><span class="number">168</span></span><br><span class="line"><span class="number">169</span> <span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line"><span class="number">170</span> <span class="type">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *);<span class="comment">//当 I2C 设备和驱动匹配成功以后 probe 函数就会执行</span></span><br><span class="line"><span class="number">171</span> <span class="type">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"><span class="number">172</span></span><br><span class="line"><span class="number">173</span> <span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration */</span></span><br><span class="line"><span class="number">174</span> <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"><span class="number">175</span></span><br><span class="line"><span class="number">176</span> <span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">177 * The format and meaning of the data value depends on the</span></span><br><span class="line"><span class="comment">178 * protocol.For the SMBus alert protocol, there is a single bit</span></span><br><span class="line"><span class="comment">179 * of data passed as the alert response&#x27;s low bit (&quot;event</span></span><br><span class="line"><span class="comment">180 flag&quot;). */</span></span><br><span class="line"><span class="number">181</span> <span class="type">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="type">unsigned</span> <span class="type">int</span> data);</span><br><span class="line"><span class="number">182</span></span><br><span class="line"><span class="number">183</span> <span class="comment">/* a ioctl like command that can be used to perform specific</span></span><br><span class="line"><span class="comment">184 * functions with the device.</span></span><br><span class="line"><span class="comment">185 */</span></span><br><span class="line"><span class="number">186</span> <span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd,<span class="type">void</span> *arg);</span><br><span class="line"><span class="number">187</span></span><br><span class="line"><span class="number">188</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span><span class="comment">//使用设备树需要设置 device_driver 的of_match_table 成员变量</span></span><br><span class="line"><span class="number">189</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span><span class="comment">//id_table 是传统的、未使用设备树的设备匹配 ID 表</span></span><br><span class="line"><span class="number">190</span></span><br><span class="line"><span class="number">191</span> <span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line"><span class="number">192</span> <span class="type">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *);</span><br><span class="line"><span class="number">193</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list;</span><br><span class="line"><span class="number">194</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span></span><br><span class="line"><span class="number">195</span> &#125;;</span><br></pre></td></tr></table></figure><p>i2c_driver 的注册示例代码如下 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* i2c 驱动的 probe 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client,<span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 函数具体程序 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c 驱动的 remove 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 函数具体程序 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 传统匹配方式 ID 列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">xxx_id</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;xxx&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;&#125;<span class="comment">//空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">xxx_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;xxx&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c 驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">xxx_driver</span> =</span> &#123;</span><br><span class="line">.probe = xxx_probe,</span><br><span class="line">.remove = xxx_remove,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.name = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">.of_match_table = xxx_of_match,</span><br><span class="line">&#125;,</span><br><span class="line"> .id_table = xxx_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = i2c_add_driver(&amp;xxx_driver);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">i2c_del_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure><h3 id="I2C-设备和驱动匹配过程"><a href="#I2C-设备和驱动匹配过程" class="headerlink" title="I2C 设备和驱动匹配过程"></a>I2C 设备和驱动匹配过程</h3><p>I2C 设备和驱动的匹配过程是由 I2C 核心来完成的， drivers&#x2F;i2c&#x2F;i2c-core.c 就是 I2C 的核心<br>部分， I2C 核心提供了一些与具体硬件无关的 API 函数，比如前面讲过的：</p><p>i2c_adapter 注册&#x2F;注销函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_numbered_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter * adap)</span></span><br></pre></td></tr></table></figure><p>i2c_driver 注册&#x2F;注销函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_register_driver</span><span class="params">(<span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_driver</span> <span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_driver</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span></span><br></pre></td></tr></table></figure><p>设备和驱动的匹配过程也是由 I2C 总线完成的， </p><p>I2C 总线的数据结构为 i2c_bus_type，定义在 drivers&#x2F;i2c&#x2F;i2c-core.c 文件， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">.name = <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">.match = i2c_device_match,</span><br><span class="line">.probe = i2c_device_probe,</span><br><span class="line">.remove = i2c_device_remove,</span><br><span class="line">.shutdown = i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>I2C 总线的设备和驱动匹配函数，在这里就是 i2c_device_match 这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">457</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">458 &#123;</span><br><span class="line"><span class="number">459</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line"><span class="number">460</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line"><span class="number">461</span></span><br><span class="line"><span class="number">462</span> <span class="keyword">if</span> (!client)</span><br><span class="line"><span class="number">463</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">464</span></span><br><span class="line"><span class="number">465</span> <span class="comment">/* Attempt an OF style match */</span></span><br><span class="line"><span class="number">466</span> <span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line"><span class="number">467</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">468</span></span><br><span class="line"><span class="number">469</span> <span class="comment">/* Then ACPI style match */</span></span><br><span class="line"><span class="number">470</span> <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line"><span class="number">471</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">472</span></span><br><span class="line"><span class="number">473</span> driver = to_i2c_driver(drv);</span><br><span class="line"><span class="number">474</span> <span class="comment">/* match on an id table if there is one */</span></span><br><span class="line"><span class="number">475</span> <span class="keyword">if</span> (driver-&gt;id_table)</span><br><span class="line"><span class="number">476</span> <span class="keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">477</span></span><br><span class="line"><span class="number">478</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">479</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="分析驱动流程"><a href="#分析驱动流程" class="headerlink" title="分析驱动流程"></a>分析驱动流程</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-14%20191536.png"></p><p>当设备和驱动匹配成功以后 i2c_imx_probe 函数就会执行 ，由此分析i2c_imx_probe的执行函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">971</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">972 &#123;</span><br><span class="line"><span class="number">973</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span> =</span></span><br><span class="line"><span class="number">974</span> of_match_device(i2c_imx_dt_ids, &amp;pdev-&gt;dev);</span><br><span class="line"><span class="number">975</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span>;</span></span><br><span class="line"><span class="number">976</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line"><span class="number">977</span> <span class="class"><span class="keyword">struct</span> <span class="title">imxi2c_platform_data</span> *<span class="title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);<span class="comment">//获取成员变量</span></span><br><span class="line"><span class="number">978</span> <span class="type">void</span> __iomem *base;</span><br><span class="line"><span class="number">979</span> <span class="type">int</span> irq, ret;</span><br><span class="line"><span class="number">980</span> <span class="type">dma_addr_t</span> phy_addr;</span><br><span class="line"><span class="number">981</span></span><br><span class="line"><span class="number">982</span> dev_dbg(&amp;pdev-&gt;dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"><span class="number">983</span></span><br><span class="line"><span class="number">984</span> irq = platform_get_irq(pdev, <span class="number">0</span>);<span class="comment">//获取中断号</span></span><br><span class="line">......</span><br><span class="line"><span class="number">990</span> res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);<span class="comment">//从设备树获取寄存器物理基地址</span></span><br><span class="line"><span class="number">991</span> base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line"><span class="number">992</span> <span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line"><span class="number">993</span> <span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line"><span class="number">994</span></span><br><span class="line"><span class="number">995</span> phy_addr = (<span class="type">dma_addr_t</span>)res-&gt;start;</span><br><span class="line"><span class="number">996</span> i2c_imx = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*i2c_imx),GFP_KERNEL);<span class="comment">//申请内存</span></span><br><span class="line"><span class="number">997</span> <span class="keyword">if</span> (!i2c_imx)</span><br><span class="line"><span class="number">998</span> <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="number">999</span></span><br><span class="line"><span class="number">1000</span> <span class="keyword">if</span> (of_id)</span><br><span class="line"><span class="number">1001</span> i2c_imx-&gt;hwdata = of_id-&gt;data;</span><br><span class="line"><span class="number">1002</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">1003</span> i2c_imx-&gt;hwdata = (<span class="keyword">struct</span> imx_i2c_hwdata *)platform_get_device_id(pdev)-&gt;driver_data;</span><br><span class="line"><span class="number">1004</span> </span><br><span class="line"><span class="number">1005</span></span><br><span class="line"><span class="number">1006</span> <span class="comment">/* Setup i2c_imx driver structure */</span></span><br><span class="line"><span class="number">1007</span> strlcpy(i2c_imx-&gt;adapter.name, pdev-&gt;name,<span class="keyword">sizeof</span>(i2c_imx-&gt;adapter.name));</span><br><span class="line"><span class="number">1008</span> i2c_imx-&gt;adapter.owner = THIS_MODULE;<span class="comment">//初始化i2c_adapter</span></span><br><span class="line"><span class="number">1009</span> i2c_imx-&gt;adapter.algo = &amp;i2c_imx_algo;</span><br><span class="line"><span class="number">1010</span> i2c_imx-&gt;adapter.dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line"><span class="number">1011</span> i2c_imx-&gt;adapter.nr = pdev-&gt;id;</span><br><span class="line"><span class="number">1012</span> i2c_imx-&gt;adapter.dev.of_node = pdev-&gt;dev.of_node;</span><br><span class="line"><span class="number">1013</span> i2c_imx-&gt;base = base;</span><br><span class="line"><span class="number">1014</span></span><br><span class="line"><span class="number">1015</span> <span class="comment">/* Get I2C clock */</span></span><br><span class="line"><span class="number">1016</span> i2c_imx-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">......</span><br><span class="line"><span class="number">1022</span> ret = clk_prepare_enable(i2c_imx-&gt;clk);</span><br><span class="line">......</span><br><span class="line"><span class="number">1027</span> <span class="comment">/* Request IRQ */</span></span><br><span class="line"><span class="number">1028</span> ret = devm_request_irq(&amp;pdev-&gt;dev, irq, i2c_imx_isr,IRQF_NO_SUSPEND, pdev-&gt;name, i2c_imx);<span class="comment">//注册控制器中断</span></span><br><span class="line"><span class="number">1029</span> </span><br><span class="line">......</span><br><span class="line"><span class="number">1035</span> <span class="comment">/* Init queue */</span></span><br><span class="line"><span class="number">1036</span> init_waitqueue_head(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line"><span class="number">1037</span></span><br><span class="line"><span class="number">1038</span> <span class="comment">/* Set up adapter data */</span></span><br><span class="line"><span class="number">1039</span> i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);</span><br><span class="line"><span class="number">1040</span></span><br><span class="line"><span class="number">1041</span> <span class="comment">/* Set up clock divider */</span></span><br><span class="line"><span class="number">1042</span> i2c_imx-&gt;bitrate = IMX_I2C_BIT_RATE;<span class="comment">//设置时钟频率</span></span><br><span class="line"><span class="number">1043</span> ret = of_property_read_u32(pdev-&gt;dev.of_node,<span class="string">&quot;clock-frequency&quot;</span>, &amp;i2c_imx-&gt;bitrate);</span><br><span class="line"><span class="number">1044</span> </span><br><span class="line"><span class="number">1045</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; pdata &amp;&amp; pdata-&gt;bitrate)</span><br><span class="line"><span class="number">1046</span> i2c_imx-&gt;bitrate = pdata-&gt;bitrate;</span><br><span class="line"><span class="number">1047</span></span><br><span class="line"><span class="number">1048</span> <span class="comment">/* Set up chip registers to defaults */</span></span><br><span class="line"><span class="number">1049</span> imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,i2c_imx, IMX_I2C_I2CR);</span><br><span class="line"><span class="number">1050</span> </span><br><span class="line"><span class="number">1051</span> imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, IMX_I2C_I2SR);</span><br><span class="line"><span class="number">1052</span><span class="comment">/*设置I2CR和SR寄存器*/</span></span><br><span class="line"><span class="number">1053</span> <span class="comment">/* Add I2C adapter */</span></span><br><span class="line"><span class="number">1054</span> ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);<span class="comment">//内核注册i2c_adapter</span></span><br><span class="line"><span class="number">1055</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">1056</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;registration failed\n&quot;</span>);</span><br><span class="line"><span class="number">1057</span> <span class="keyword">goto</span> clk_disable;</span><br><span class="line"><span class="number">1058</span> &#125;</span><br><span class="line"><span class="number">1059</span></span><br><span class="line"><span class="number">1060</span> <span class="comment">/* Set up platform driver data */</span></span><br><span class="line"><span class="number">1061</span> platform_set_drvdata(pdev, i2c_imx);</span><br><span class="line"><span class="number">1062</span> clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line">......</span><br><span class="line"><span class="number">1070</span> <span class="comment">/* Init DMA config if supported */</span></span><br><span class="line"><span class="number">1071</span> i2c_imx_dma_request(i2c_imx, phy_addr);<span class="comment">//设置了DMA</span></span><br><span class="line"><span class="number">1072</span></span><br><span class="line"><span class="number">1073</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Return OK */</span></span><br><span class="line"><span class="number">1074</span></span><br><span class="line"><span class="number">1075</span> clk_disable:</span><br><span class="line"><span class="number">1076</span> clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line"><span class="number">1077</span> <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">1078</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="设备添加驱动"><a href="#设备添加驱动" class="headerlink" title="设备添加驱动"></a>设备添加驱动</h3><p>以ap3216c设备为例子</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-17%20204441.png"></p><p>在节点i2c1中添加设备的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">ap3216c@<span class="number">1</span>e&#123;<span class="comment">//ap3216芯片设备添加的节点</span></span><br><span class="line">compatible = <span class="string">&quot;alientek,ap3216c&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编写ap3216c的设备驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ap3216creg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_CNT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_NAME    <span class="string">&quot;ap3216c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> devid;</span><br><span class="line">    <span class="type">int</span> major;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="type">void</span> *private_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ir,als,ps;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> <span class="title">ap3216cdev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_read_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line">    msg[<span class="number">0</span>].addr = client-&gt;addr; <span class="comment">//ap3216c地址</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;   <span class="comment">//标记为发送数据</span></span><br><span class="line">    msg[<span class="number">0</span>].buf = &amp;reg; <span class="comment">//读取首地址</span></span><br><span class="line">    msg[<span class="number">0</span>].len = <span class="number">1</span>;     <span class="comment">//数据长度</span></span><br><span class="line"></span><br><span class="line">    msg[<span class="number">1</span>].addr = client-&gt;addr;<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">    msg[<span class="number">1</span>].flags = I2C_M_RD;<span class="comment">/* 标记为读取数据*/</span></span><br><span class="line">    msg[<span class="number">1</span>].buf = val;<span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">    msg[<span class="number">1</span>].len = len;<span class="comment">/* 要读取的数据长度*/</span>    </span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        printk(<span class="string">&quot;i2c rd failed=%d reg = %06x led = %d\n&quot;</span>, ret, reg, len);</span><br><span class="line">        ret = -EREMOTEIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">ap3216c_write_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 b[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *) dev-&gt; private_data;</span><br><span class="line">    b[<span class="number">0</span>] = reg ;    <span class="comment">//寄存器首地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>], buf, len);    <span class="comment">//写入的数据拷贝进入数组b里</span></span><br><span class="line">    msg.addr = client-&gt; addr;   <span class="comment">//ap3216c地址</span></span><br><span class="line">    msg.flags = <span class="number">0</span>;  <span class="comment">//  标记为写数据   </span></span><br><span class="line">    msg.len = len + <span class="number">1</span>; <span class="comment">//数据长度</span></span><br><span class="line">    msg.buf = b;<span class="comment">//写入数据缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ap3216c_read_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ap3216c_read_regs(dev, reg, &amp;data, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ap3216c_write_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 buf = <span class="number">0</span>;</span><br><span class="line">    buf = data;</span><br><span class="line">    ap3216c_write_regs(dev, reg, &amp;buf,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ap3216c_readdata</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 循环读取所有传感器数据 */</span></span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[i] = ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] &amp; <span class="number">0X80</span>) <span class="comment">/* IR_OF 位为 1,则数据无效 */</span></span><br><span class="line">        dev-&gt;ir = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 读取 IR 传感器的数据 */</span></span><br><span class="line">        dev-&gt;ir = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">1</span>] &lt;&lt; <span class="number">2</span>) | (buf[<span class="number">0</span>] &amp; <span class="number">0X03</span>);</span><br><span class="line"></span><br><span class="line">    dev-&gt;als = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">2</span>];<span class="comment">/* ALS 数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">4</span>] &amp; <span class="number">0x40</span>) <span class="comment">/* IR_OF 位为 1,则数据无效 */</span></span><br><span class="line">        dev-&gt;ps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 读取 PS 传感器的数据 */</span></span><br><span class="line">        dev-&gt;ps = ((<span class="type">unsigned</span> <span class="type">short</span>)(buf[<span class="number">5</span>] &amp; <span class="number">0X3F</span>) &lt;&lt; <span class="number">4</span>) | (buf[<span class="number">4</span>] &amp; <span class="number">0X0F</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    filp-&gt;private_data = &amp;ap3216cdev;</span><br><span class="line">    ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0x04</span>);</span><br><span class="line">    mdelay(<span class="number">50</span>);</span><br><span class="line">    ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0x03</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ap3216c_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">short</span> data[<span class="number">3</span>];</span><br><span class="line">    <span class="type">long</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> ap3216c_dev *)filp-&gt;private_data;</span><br><span class="line">    ap3216c_readdata(dev);</span><br><span class="line"></span><br><span class="line">    data[<span class="number">0</span>] = dev-&gt;ir;</span><br><span class="line">    data[<span class="number">1</span>] = dev-&gt;als;</span><br><span class="line">    data[<span class="number">2</span>] = dev-&gt;ps;</span><br><span class="line">    err = copy_to_user(buf, data,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_release</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ap3216c_ops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .read = ap3216c_read,</span><br><span class="line">    .open = ap3216c_open,</span><br><span class="line">    .release = ap3216c_release,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 1、构建设备号 */</span></span><br><span class="line"><span class="keyword">if</span> (ap3216cdev.major) &#123;</span><br><span class="line">ap3216cdev.devid = MKDEV(ap3216cdev.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alloc_chrdev_region(&amp;ap3216cdev.devid, <span class="number">0</span>, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">ap3216cdev.major = MAJOR(ap3216cdev.devid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、注册设备 */</span></span><br><span class="line">cdev_init(&amp;ap3216cdev.cdev, &amp;ap3216c_ops);</span><br><span class="line">cdev_add(&amp;ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、创建类 */</span></span><br><span class="line">ap3216cdev.class = class_create(THIS_MODULE, AP3216C_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ap3216cdev.class)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ap3216cdev.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、创建设备 */</span></span><br><span class="line">ap3216cdev.device = device_create(ap3216cdev.class, <span class="literal">NULL</span>, ap3216cdev.devid, <span class="literal">NULL</span>, AP3216C_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ap3216cdev.device)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ap3216cdev.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ap3216cdev.private_data = client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span></span><br><span class="line"><span class="comment"> * @param - client : i2c设备</span></span><br><span class="line"><span class="comment"> * @return          : 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 删除设备 */</span></span><br><span class="line">cdev_del(&amp;ap3216cdev.cdev);</span><br><span class="line">unregister_chrdev_region(ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销掉类和设备 */</span></span><br><span class="line">device_destroy(ap3216cdev.class, ap3216cdev.devid);</span><br><span class="line">class_destroy(ap3216cdev.class);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 传统匹配方式ID列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ap3216c_id</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;alientek,ap3216c&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ap3216c_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;alientek,ap3216c&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ap3216c_driver</span> =</span> &#123;</span><br><span class="line">.probe = ap3216c_probe,</span><br><span class="line">.remove = ap3216c_remove,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">   .name = <span class="string">&quot;ap3216c&quot;</span>,</span><br><span class="line">   .of_match_table = ap3216c_of_match, </span><br><span class="line">   &#125;,</span><br><span class="line">.id_table = ap3216c_id,</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动入口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ap3216c_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = i2c_add_driver(&amp;ap3216c_driver);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ap3216c_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">i2c_del_driver(&amp;ap3216c_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* module_i2c_driver(ap3216c_driver) */</span></span><br><span class="line"></span><br><span class="line">module_init(ap3216c_init);</span><br><span class="line">module_exit(ap3216c_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTC驱动</title>
      <link href="/2023/07/12/2023-7-12-RTC%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/12/2023-7-12-RTC%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-内核中-RTC-驱动调用流程"><a href="#Linux-内核中-RTC-驱动调用流程" class="headerlink" title="Linux 内核中 RTC 驱动调用流程"></a>Linux 内核中 RTC 驱动调用流程</h2><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-12%20154142.png"></p><p>Linux 内核将 RTC 设备抽象为 rtc_device 结构体，因此 RTC 设备驱动就是申请并初始化rtc_device，最后将 rtc_device 注册到 Linux 内核里面，这样 Linux 内核就有一个 RTC 设备了 。</p><p>当 rtc_class_ops 准备好以后需要将其注册到 Linux 内核中，这里我们可以使用rtc_device_register函数完成注册工作。此函数会申请一个rtc_device并且初始化这个rtc_device，最后向调用者返回这个 rtc_device，此函数原型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rtc_device *<span class="title function_">rtc_device_register</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,<span class="comment">//设备名字</span></span></span><br><span class="line"><span class="params">                                       <span class="keyword">struct</span> device *dev,<span class="comment">//设备</span></span></span><br><span class="line"><span class="params">                                       <span class="type">const</span> <span class="keyword">struct</span> rtc_class_ops *ops,<span class="comment">//RTC 底层驱动函数集</span></span></span><br><span class="line"><span class="params">                                       <span class="keyword">struct</span> module *owner)</span><span class="comment">//驱动模块拥有者</span></span><br><span class="line"><span class="comment">//注册成功的话就返回 rtc_device，错误的话会返回一个负值。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_device_unregister</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc)</span></span><br><span class="line"><span class="comment">//rtc：要删除的 rtc_device。返回值： 无。</span></span><br></pre></td></tr></table></figure><p>RTC 设备的操作肯定是用一个操作集合(结构体 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">104</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span></span></span><br><span class="line"><span class="class">105 &#123;</span></span><br><span class="line"><span class="number">106</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span> <span class="comment">/* 设备 */</span></span><br><span class="line"><span class="number">107</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="number">108</span></span><br><span class="line"><span class="number">109</span> <span class="type">int</span> id; <span class="comment">/* ID */</span></span><br><span class="line"><span class="number">110</span> <span class="type">char</span> name[RTC_DEVICE_NAME_SIZE]; <span class="comment">/* 名字 */</span></span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">112</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">ops</span>;</span> <span class="comment">/* RTC 设备底层操作函数 比较重要*/</span></span><br><span class="line"><span class="number">113</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">ops_lock</span>;</span></span><br><span class="line"><span class="number">114</span></span><br><span class="line"><span class="number">115</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">char_dev</span>;</span> <span class="comment">/* 字符设备 */</span></span><br><span class="line"><span class="number">116</span> <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="number">117</span></span><br><span class="line"><span class="number">118</span> <span class="type">unsigned</span> <span class="type">long</span> irq_data;</span><br><span class="line"><span class="number">119</span> <span class="type">spinlock_t</span> irq_lock;</span><br><span class="line"><span class="number">120</span> <span class="type">wait_queue_head_t</span> irq_queue;</span><br><span class="line"><span class="number">121</span> <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span></span><br><span class="line"><span class="number">122</span></span><br><span class="line"><span class="number">123</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_task</span> *<span class="title">irq_task</span>;</span></span><br><span class="line"><span class="number">124</span> <span class="type">spinlock_t</span> irq_task_lock;</span><br><span class="line"><span class="number">125</span> <span class="type">int</span> irq_freq;</span><br><span class="line"><span class="number">126</span> <span class="type">int</span> max_user_freq;</span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">128</span> <span class="class"><span class="keyword">struct</span> <span class="title">timerqueue_head</span> <span class="title">timerqueue</span>;</span></span><br><span class="line"><span class="number">129</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">aie_timer</span>;</span></span><br><span class="line"><span class="number">130</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">uie_rtctimer</span>;</span></span><br><span class="line"><span class="number">131</span> <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">pie_timer</span>;</span> <span class="comment">/* sub second exp, so needs hrtimer */</span></span><br><span class="line"><span class="number">132</span> <span class="type">int</span> pie_enabled;</span><br><span class="line"><span class="number">133</span> <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">irqwork</span>;</span></span><br><span class="line"><span class="number">134</span> <span class="comment">/* Some hardware can&#x27;t support UIE mode */</span></span><br><span class="line"><span class="number">135</span> <span class="type">int</span> uie_unsupported;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查看rtc_class_ops底层操作数集合，这个集合是最底层的 RTC 设备操作函数 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">71</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> &#123;</span></span><br><span class="line"><span class="number">72</span> <span class="type">int</span> (*open)(<span class="keyword">struct</span> device *);</span><br><span class="line"><span class="number">73</span> <span class="type">void</span> (*release)(<span class="keyword">struct</span> device *);</span><br><span class="line"><span class="number">74</span> <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="number">75</span> <span class="type">int</span> (*read_time)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_time *);</span><br><span class="line"><span class="number">76</span> <span class="type">int</span> (*set_time)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_time *);</span><br><span class="line"><span class="number">77</span> <span class="type">int</span> (*read_alarm)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_wkalrm *);</span><br><span class="line"><span class="number">78</span> <span class="type">int</span> (*set_alarm)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_wkalrm *);</span><br><span class="line"><span class="number">79</span> <span class="type">int</span> (*proc)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> seq_file *);</span><br><span class="line"><span class="number">80</span> <span class="type">int</span> (*set_mmss64)(<span class="keyword">struct</span> device *, <span class="type">time64_t</span> secs);</span><br><span class="line"><span class="number">81</span> <span class="type">int</span> (*set_mmss)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">long</span> secs);</span><br><span class="line"><span class="number">82</span> <span class="type">int</span> (*read_callback)(<span class="keyword">struct</span> device *, <span class="type">int</span> data);</span><br><span class="line"><span class="number">83</span> <span class="type">int</span> (*alarm_irq_enable)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">int</span> enabled);</span><br><span class="line"><span class="number">84</span> &#125;;</span><br></pre></td></tr></table></figure><p>RTC 是字符设备（存在字符设备的 file_operations 函数操作集）， Linux 内核提供了一个 RTC 通用字符设备驱动文件，文件名为 drivers&#x2F;rtc&#x2F;rtc-dev.c， rtcdev.c 文件提供了所有 RTC 设备共用的 file_operations 函数操作集 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">448</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">rtc_dev_fops</span> =</span> &#123;</span><br><span class="line"><span class="number">449</span> .owner = THIS_MODULE,</span><br><span class="line"><span class="number">450</span> .llseek = no_llseek,</span><br><span class="line"><span class="number">451</span> .read = rtc_dev_read,</span><br><span class="line"><span class="number">452</span> .poll = rtc_dev_poll,</span><br><span class="line"><span class="number">453</span> .unlocked_ioctl = rtc_dev_ioctl,<span class="comment">/* rtc_class_ops 中的 read_time、 </span></span><br><span class="line"><span class="comment">set_time 等函数来对具体 RTC 设备的读写操作。*/</span></span><br><span class="line"><span class="number">454</span> .open = rtc_dev_open,</span><br><span class="line"><span class="number">455</span> .release = rtc_dev_release,</span><br><span class="line"><span class="number">456</span> .fasync = rtc_dev_fasync,</span><br><span class="line"><span class="number">457</span> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">218</span> <span class="type">static</span> <span class="type">long</span> <span class="title function_">rtc_dev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params"><span class="number">219</span> <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">220 &#123;</span><br><span class="line"><span class="number">221</span> <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"><span class="number">222</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span> =</span> file-&gt;private_data;</span><br><span class="line"><span class="number">223</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">ops</span> =</span> rtc-&gt;ops;</span><br><span class="line"><span class="number">224</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">tm</span>;</span></span><br><span class="line"><span class="number">225</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_wkalrm</span> <span class="title">alarm</span>;</span></span><br><span class="line"><span class="number">226</span> <span class="type">void</span> __user *uarg = (<span class="type">void</span> __user *) arg;</span><br><span class="line"><span class="number">227</span></span><br><span class="line"><span class="number">228</span> err = mutex_lock_interruptible(&amp;rtc-&gt;ops_lock);</span><br><span class="line"><span class="number">229</span> <span class="keyword">if</span> (err)</span><br><span class="line"><span class="number">230</span> <span class="keyword">return</span> err;</span><br><span class="line">......</span><br><span class="line"><span class="number">269</span> <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="number">333</span> <span class="keyword">case</span> RTC_RD_TIME: <span class="comment">/* 读取时间 */</span></span><br><span class="line"><span class="number">334</span> mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"><span class="number">335</span></span><br><span class="line"><span class="number">336</span> err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line"><span class="number">337</span> <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">338</span> <span class="keyword">return</span> err;</span><br><span class="line"><span class="number">339</span></span><br><span class="line"><span class="number">340</span> <span class="keyword">if</span> (copy_to_user(uarg, &amp;tm, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line"><span class="number">341</span> err = -EFAULT;</span><br><span class="line"><span class="number">342</span><span class="keyword">return</span> err;</span><br><span class="line"><span class="number">343</span></span><br><span class="line"><span class="number">344</span> <span class="keyword">case</span> RTC_SET_TIME: <span class="comment">/* 设置时间 */</span></span><br><span class="line"><span class="number">345</span> mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"><span class="number">346</span></span><br><span class="line"><span class="number">347</span> <span class="keyword">if</span> (copy_from_user(&amp;tm, uarg, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line"><span class="number">348</span> <span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="number">349</span></span><br><span class="line"><span class="number">350</span> <span class="keyword">return</span> rtc_set_time(rtc, &amp;tm);</span><br><span class="line">......</span><br><span class="line"><span class="number">401</span> <span class="keyword">default</span>:</span><br><span class="line"><span class="number">402</span> <span class="comment">/* Finally try the driver&#x27;s ioctl interface */</span></span><br><span class="line"><span class="number">403</span> <span class="keyword">if</span> (ops-&gt;ioctl) &#123;</span><br><span class="line"><span class="number">404</span> err = ops-&gt;ioctl(rtc-&gt;dev.parent, cmd, arg);</span><br><span class="line"><span class="number">405</span> <span class="keyword">if</span> (err == -ENOIOCTLCMD)</span><br><span class="line"><span class="number">406</span> err = -ENOTTY;</span><br><span class="line"><span class="number">407</span> &#125; <span class="keyword">else</span></span><br><span class="line"><span class="number">408</span> err = -ENOTTY;</span><br><span class="line"><span class="number">409</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="number">410</span> &#125;</span><br><span class="line"><span class="number">411</span></span><br><span class="line"><span class="number">412</span> done:</span><br><span class="line"><span class="number">413</span> mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"><span class="number">414</span> <span class="keyword">return</span> err;</span><br><span class="line"><span class="number">415</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="1、时间-RTC-查看"><a href="#1、时间-RTC-查看" class="headerlink" title="1、时间 RTC 查看"></a>1、时间 RTC 查看</h4><p>如果要查看时间的话输入“date”命令即可 。</p><h4 id="2、设置-RTC-时间"><a href="#2、设置-RTC-时间" class="headerlink" title="2、设置 RTC 时间"></a>2、设置 RTC 时间</h4><p>RTC 时间设置也是使用的 date 命令，输入“date –help”命令即可查看 date 命令如何设置系统时间 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock -w //将当前系统时间写入到 RTC 里面</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lcd驱动</title>
      <link href="/2023/07/10/2023-7-10-lcd%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/10/2023-7-10-lcd%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Framebuffer"><a href="#Framebuffer" class="headerlink" title="Framebuffer"></a>Framebuffer</h2><p>在 Linux 中应用程序最终也是通过操作 RGB LCD 的显存来实现在 LCD 上显示字符、图片等信息。 因为虚拟内存的存在，驱动程序设置的显存和应用程序访问的显存要是同一片物理内存。</p><p>Framebuffer 诞生了， Framebuffer 翻译过来就是帧缓冲，简称 fb 。fb 是一种机制，将系统中所有跟显示有关的硬件以及软件集合起来，虚拟出一个 fb 设备。帧缓冲是linux系统中的一种显示驱动接口，它将显示设备（比如LCD）进行抽象、屏蔽了不同显示设备硬件的实现，对应用层抽象为一块显示内存（显存），它允许上层应用程序直接对显示缓冲区进行读写操作，而用户不关心物理显存的位置等具体细节，这些都由Framebuffer设备驱动来完成。</p><p>显示设备被称为 FrameBuffer 设备（帧缓冲设备），所以 LCD 显示屏自然而言就是 FrameBuffer 设备。 FrameBuffer 设备对应的设备文件为&#x2F;dev&#x2F;fbX（X 为数字， 0、 1、 2、 3 等） ， Linux下可支持多个 FrameBuffer 设备，最多可达 32 个，分别为&#x2F;dev&#x2F;fb0 到&#x2F;dev&#x2F;fb31， 开发板出厂系统中， &#x2F;dev&#x2F;fb0设备节点便是 LCD 屏 。</p><p>fb 的 file_operations 操作集定义在drivers&#x2F;video&#x2F;fbdev&#x2F;core&#x2F;fbmem.c 文件中 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1495</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fb_fops</span> =</span> &#123;</span><br><span class="line"><span class="number">1496</span> .owner = THIS_MODULE,</span><br><span class="line"><span class="number">1497</span> .read = fb_read,</span><br><span class="line"><span class="number">1498</span> .write = fb_write,</span><br><span class="line"><span class="number">1499</span> .unlocked_ioctl = fb_ioctl,</span><br><span class="line"><span class="number">1500</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="number">1501</span> .compat_ioctl = fb_compat_ioctl,</span><br><span class="line"><span class="number">1502</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">1503</span> .mmap = fb_mmap,</span><br><span class="line"><span class="number">1504</span> .open = fb_open,</span><br><span class="line"><span class="number">1505</span> .release = fb_release,</span><br><span class="line"><span class="number">1506</span> <span class="meta">#<span class="keyword">ifdef</span> HAVE_ARCH_FB_UNMAPPED_AREA</span></span><br><span class="line"><span class="number">1507</span> .get_unmapped_area = get_fb_unmapped_area,</span><br><span class="line"><span class="number">1508</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">1509</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_FB_DEFERRED_IO</span></span><br><span class="line"><span class="number">1510</span> .fsync = fb_deferred_io_fsync,</span><br><span class="line"><span class="number">1511</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">1512</span> .llseek = default_llseek,</span><br><span class="line"><span class="number">1513</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="LCD设备节点"><a href="#LCD设备节点" class="headerlink" title="LCD设备节点"></a>LCD设备节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*imx6ull.dtsi 文件中 lcdif 节点内容*/</span></span><br><span class="line"><span class="number">1</span> lcdif: lcdif@<span class="number">021</span>c8000 &#123;</span><br><span class="line"><span class="number">2</span> compatible = <span class="string">&quot;fsl,imx6ul-lcdif&quot;</span>, <span class="string">&quot;fsl,imx28-lcdif&quot;</span>;</span><br><span class="line"><span class="number">3</span> reg = &lt;<span class="number">0x021c8000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line"><span class="number">4</span> interrupts = &lt;GIC_SPI <span class="number">5</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line"><span class="number">5</span> clocks = &lt;&amp;clks IMX6UL_CLK_LCDIF_PIX&gt;,</span><br><span class="line"><span class="number">6</span> &lt;&amp;clks IMX6UL_CLK_LCDIF_APB&gt;,</span><br><span class="line"><span class="number">7</span> &lt;&amp;clks IMX6UL_CLK_DUMMY&gt;;</span><br><span class="line"><span class="number">8</span> clock-names = <span class="string">&quot;pix&quot;</span>, <span class="string">&quot;axi&quot;</span>, <span class="string">&quot;disp_axi&quot;</span>;</span><br><span class="line"><span class="number">9</span> status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure><p>之后还要向 imx6ullalientek-emmc.dts 中的 lcdif 节点添加其他的属性信息。 </p><p>属性值为“fsl,imx6ul-lcdif”和“fsl,imx28-lcdif”，因此在 Linux 源码中搜索这两个字符串即可找到 I.MX6ULL 的 LCD 驱动文件，这个文件为 drivers&#x2F;video&#x2F;fbdev&#x2F;mxsfb.c，mxsfb.c就是 I.MX6ULL 的 LCD 驱动文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1362</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mxsfb_dt_ids</span>[] =</span> &#123;</span><br><span class="line"><span class="number">1363</span> &#123; .compatible = <span class="string">&quot;fsl,imx23-lcdif&quot;</span>, .data = &amp;mxsfb_devtype[<span class="number">0</span>], &#125;,</span><br><span class="line"><span class="number">1364</span> &#123; .compatible = <span class="string">&quot;fsl,imx28-lcdif&quot;</span>, .data = &amp;mxsfb_devtype[<span class="number">1</span>], &#125;,</span><br><span class="line"><span class="number">1365</span> &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line"><span class="number">1366</span> &#125;;</span><br><span class="line">......</span><br><span class="line"><span class="number">1625</span> <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">mxsfb_driver</span> =</span> &#123;</span><br><span class="line"><span class="number">1626</span> .probe = mxsfb_probe,</span><br><span class="line"><span class="number">1627</span> .remove = mxsfb_remove,</span><br><span class="line"><span class="number">1628</span> .shutdown = mxsfb_shutdown,</span><br><span class="line"><span class="number">1629</span> .id_table = mxsfb_devtype,</span><br><span class="line"><span class="number">1630</span> .driver = &#123;</span><br><span class="line"><span class="number">1631</span> .name = DRIVER_NAME,</span><br><span class="line"><span class="number">1632</span> .of_match_table = mxsfb_dt_ids,</span><br><span class="line"><span class="number">1633</span> .pm = &amp;mxsfb_pm_ops,</span><br><span class="line"><span class="number">1634</span> &#125;,</span><br><span class="line"><span class="number">1635</span> &#125;;</span><br><span class="line"><span class="number">1636</span></span><br><span class="line"><span class="number">1637</span> module_platform_driver(mxsfb_driver);</span><br></pre></td></tr></table></figure><p>这是一个标准的 platform 驱动，当驱动和设备匹配以后mxsfb_probe 函数就会执行。 <strong>LCD 的驱动就是构建 fb_info，并且向系统注册 fb_info的过程。</strong> </p><p>fb_info 结构体定义在 include&#x2F;linux&#x2F;fb.h 文件里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">448</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> &#123;</span></span><br><span class="line"><span class="number">449</span> <span class="type">atomic_t</span> count;</span><br><span class="line"><span class="number">450</span> <span class="type">int</span> node;</span><br><span class="line"><span class="number">451</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="number">452</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* 互斥锁 */</span></span><br><span class="line"><span class="number">453</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mm_lock</span>;</span> <span class="comment">/* 互斥锁，用于 fb_mmap 和 smem_*域*/</span></span><br><span class="line"><span class="number">454</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span> <span class="comment">/* 当前可变参数 */</span></span><br><span class="line"><span class="number">455</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">fix</span>;</span> <span class="comment">/* 当前固定参数 */</span></span><br><span class="line"><span class="number">456</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_monspecs</span> <span class="title">monspecs</span>;</span> <span class="comment">/* 当前显示器特性 */</span></span><br><span class="line"><span class="number">457</span> <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">queue</span>;</span> <span class="comment">/* 帧缓冲事件队列 */</span></span><br><span class="line"><span class="number">458</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">pixmap</span>;</span> <span class="comment">/* 图像硬件映射 */</span></span><br><span class="line"><span class="number">459</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">sprite</span>;</span> <span class="comment">/* 光标硬件映射 */</span></span><br><span class="line"><span class="number">460</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_cmap</span> <span class="title">cmap</span>;</span> <span class="comment">/* 当前调色板 */</span></span><br><span class="line"><span class="number">461</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">modelist</span>;</span> <span class="comment">/* 当前模式列表 */</span></span><br><span class="line"><span class="number">462</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> *<span class="title">mode</span>;</span> <span class="comment">/* 当前视频模式 */</span></span><br><span class="line"><span class="number">463</span></span><br><span class="line"><span class="number">464</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_FB_BACKLIGHT <span class="comment">/* 如果 LCD 支持背光的话 */</span></span></span><br><span class="line"><span class="number">465</span> <span class="comment">/* assigned backlight device */</span></span><br><span class="line"><span class="number">466</span> <span class="comment">/* set before framebuffer registration,</span></span><br><span class="line"><span class="comment">467 remove after unregister */</span></span><br><span class="line"><span class="number">468</span> <span class="class"><span class="keyword">struct</span> <span class="title">backlight_device</span> *<span class="title">bl_dev</span>;</span> <span class="comment">/* 背光设备 */</span></span><br><span class="line"><span class="number">469</span></span><br><span class="line"><span class="number">470</span> <span class="comment">/* Backlight level curve */</span></span><br><span class="line"><span class="number">471</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bl_curve_mutex</span>;</span></span><br><span class="line"><span class="number">472</span> u8 bl_curve[FB_BACKLIGHT_LEVELS];原子哥在线教学:www.yuanzige.com 论坛:www.openedv.com</span><br><span class="line"><span class="number">1416</span></span><br><span class="line">I.MX6U 嵌入式 Linux 驱动开发指南</span><br><span class="line"><span class="number">473</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line"><span class="number">479</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> *<span class="title">fbops</span>;</span> <span class="comment">/* 帧缓冲操作函数集 */</span></span><br><span class="line"><span class="number">480</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">/* 父设备 */</span></span><br><span class="line"><span class="number">481</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span> <span class="comment">/* 当前 fb 设备 */</span></span><br><span class="line"><span class="number">482</span> <span class="type">int</span> class_flag; <span class="comment">/* 私有 sysfs 标志 */</span></span><br><span class="line">......</span><br><span class="line"><span class="number">486</span> <span class="type">char</span> __iomem *screen_base; <span class="comment">/* 虚拟内存基地址(屏幕显存) */</span></span><br><span class="line"><span class="number">487</span> <span class="type">unsigned</span> <span class="type">long</span> screen_size; <span class="comment">/* 虚拟内存大小(屏幕显存大小) */</span></span><br><span class="line"><span class="number">488</span> <span class="type">void</span> *pseudo_palette; <span class="comment">/* 伪 16 位调色板 */</span></span><br><span class="line">......</span><br><span class="line"><span class="number">507</span> &#125;;</span><br></pre></td></tr></table></figure><p><u><strong>mxsfb_probe 函数的主要工作内容为 ：</strong></u></p><p><strong>①、申请 fb_info。</strong><br><strong>②、初始化 fb_info 结构体中的各个成员变量。</strong><br><strong>③、初始化 eLCDIF 控制器。</strong><br><strong>④、使用 register_framebuffer 函数向 Linux 内核注册初始化好的 fb_info。</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mxsfb_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">1370 &#123;</span><br><span class="line"><span class="number">1371</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span> =</span></span><br><span class="line"><span class="number">1372</span> of_match_device(mxsfb_dt_ids, &amp;pdev-&gt;dev);</span><br><span class="line"><span class="number">1373</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line"><span class="number">1374</span> <span class="class"><span class="keyword">struct</span> <span class="title">mxsfb_info</span> *<span class="title">host</span>;</span><span class="comment">//IMX6uLL主控接口，mxsfb_info为NXP定义的fb设备结构体</span></span><br><span class="line"><span class="number">1375</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">fb_info</span>;</span></span><br><span class="line"><span class="number">1376</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span>;</span></span><br><span class="line"><span class="number">1377</span> <span class="type">int</span> irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line"><span class="number">1378</span> <span class="type">int</span> gpio, ret;</span><br><span class="line"><span class="number">1379</span></span><br><span class="line">......</span><br><span class="line"><span class="number">1394</span></span><br><span class="line"><span class="number">1395</span> res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);<span class="comment">//获取eLCDIF接口控制器的寄存器首地址</span></span><br><span class="line"><span class="number">1396</span> <span class="keyword">if</span> (!res) &#123;</span><br><span class="line"><span class="number">1397</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Cannot get memory IO resource\n&quot;</span>);</span><br><span class="line"><span class="number">1398</span> <span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="number">1399</span> &#125;</span><br><span class="line"><span class="number">1400</span></span><br><span class="line"><span class="number">1401</span> host = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mxsfb_info),GFP_KERNEL);<span class="comment">//给host申请内存</span></span><br><span class="line"><span class="number">1402</span> <span class="keyword">if</span> (!host) &#123;</span><br><span class="line"><span class="number">1403</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to allocate IO resource\n&quot;</span>);</span><br><span class="line"><span class="number">1404</span> <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="number">1405</span> &#125;</span><br><span class="line"><span class="number">1406</span></span><br><span class="line"><span class="number">1407</span> fb_info = framebuffer_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> fb_info), &amp;pdev-&gt;dev);<span class="comment">//给fb申请内存</span></span><br><span class="line"><span class="number">1408</span> <span class="keyword">if</span> (!fb_info) &#123;</span><br><span class="line"><span class="number">1409</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to allocate fbdev\n&quot;</span>);</span><br><span class="line"><span class="number">1410</span> devm_kfree(&amp;pdev-&gt;dev, host);</span><br><span class="line"><span class="number">1411</span> <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="number">1412</span> &#125;</span><br><span class="line"><span class="number">1413</span> host-&gt;fb_info = fb_info;</span><br><span class="line"><span class="number">1414</span> fb_info-&gt;par = host;<span class="comment">//将申请的host和fb_info联系到一起</span></span><br><span class="line"><span class="number">1415</span></span><br><span class="line"><span class="number">1416</span> ret = devm_request_irq(&amp;pdev-&gt;dev, irq, mxsfb_irq_handler, <span class="number">0</span>,dev_name(&amp;pdev-&gt;dev), host);</span><br><span class="line"><span class="number">1417</span> <span class="comment">//申请中断</span></span><br><span class="line"><span class="number">1418</span> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="number">1419</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;request_irq (%d) failed with</span></span><br><span class="line"><span class="string">1420 error %d\n&quot;</span>, irq, ret);</span><br><span class="line"><span class="number">1421</span> ret = -ENODEV;</span><br><span class="line"><span class="number">1422</span> <span class="keyword">goto</span> fb_release;</span><br><span class="line"><span class="number">1423</span> &#125;</span><br><span class="line"><span class="number">1424</span></span><br><span class="line"><span class="number">1425</span> host-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);<span class="comment">//对从设备树中获取寄存器首地址进行内存映射</span></span><br><span class="line">          <span class="comment">//   得到虚拟地址保存到host变量中</span></span><br><span class="line"><span class="number">1426</span> <span class="keyword">if</span> (IS_ERR(host-&gt;base)) &#123;</span><br><span class="line"><span class="number">1427</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;ioremap failed\n&quot;</span>);</span><br><span class="line"><span class="number">1428</span> ret = PTR_ERR(host-&gt;base);</span><br><span class="line"><span class="number">1429</span> <span class="keyword">goto</span> fb_release;</span><br><span class="line"><span class="number">1430</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">1461</span></span><br><span class="line"><span class="number">1462</span> fb_info-&gt;pseudo_palette = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(u32) * <span class="number">16</span>, GFP_KERNEL);<span class="comment">//申请内存</span></span><br><span class="line"><span class="number">1463</span> </span><br><span class="line"><span class="number">1464</span> <span class="keyword">if</span> (!fb_info-&gt;pseudo_palette) &#123;</span><br><span class="line"><span class="number">1465</span> ret = -ENOMEM;</span><br><span class="line"><span class="number">1466</span> <span class="keyword">goto</span> fb_release;</span><br><span class="line"><span class="number">1467</span> &#125;</span><br><span class="line"><span class="number">1468</span></span><br><span class="line"><span class="number">1469</span> INIT_LIST_HEAD(&amp;fb_info-&gt;modelist);</span><br><span class="line"><span class="number">1470</span></span><br><span class="line"><span class="number">1471</span> pm_runtime_enable(&amp;host-&gt;pdev-&gt;dev);</span><br><span class="line"><span class="number">1472</span></span><br><span class="line"><span class="number">1473</span> ret = mxsfb_init_fbinfo(host);<span class="comment">//初始化fb_info</span></span><br><span class="line"><span class="number">1474</span> <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line"><span class="number">1475</span> <span class="keyword">goto</span> fb_pm_runtime_disable;</span><br><span class="line"><span class="number">1476</span></span><br><span class="line"><span class="number">1477</span> mxsfb_dispdrv_init(pdev, fb_info);</span><br><span class="line"><span class="number">1478</span></span><br><span class="line"><span class="number">1479</span> <span class="keyword">if</span> (!host-&gt;dispdrv) &#123;</span><br><span class="line"><span class="number">1480</span> pinctrl = devm_pinctrl_get_select_default(&amp;pdev-&gt;dev);</span><br><span class="line"><span class="number">1481</span> <span class="keyword">if</span> (IS_ERR(pinctrl)) &#123;</span><br><span class="line"><span class="number">1482</span> ret = PTR_ERR(pinctrl);</span><br><span class="line"><span class="number">1483</span> <span class="keyword">goto</span> fb_pm_runtime_disable;</span><br><span class="line"><span class="number">1484</span> &#125;</span><br><span class="line"><span class="number">1485</span> &#125;</span><br><span class="line"><span class="number">1486</span></span><br><span class="line"><span class="number">1487</span> <span class="keyword">if</span> (!host-&gt;enabled) &#123;</span><br><span class="line"><span class="number">1488</span> writel(<span class="number">0</span>, host-&gt;base + LCDC_CTRL);</span><br><span class="line"><span class="number">1489</span> mxsfb_set_par(fb_info);<span class="comment">//设置eLCDIF控制器相应的寄存器</span></span><br><span class="line"><span class="number">1490</span> mxsfb_enable_controller(fb_info);</span><br><span class="line"><span class="number">1491</span> pm_runtime_get_sync(&amp;host-&gt;pdev-&gt;dev);</span><br><span class="line"><span class="number">1492</span> &#125;</span><br><span class="line"><span class="number">1493</span></span><br><span class="line"><span class="number">1494</span> ret = register_framebuffer(fb_info);<span class="comment">//内核注册fb_info</span></span><br><span class="line"><span class="number">1495</span> <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">1496</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to register framebuffer\n&quot;</span>);</span><br><span class="line"><span class="number">1497</span> <span class="keyword">goto</span> fb_destroy;</span><br><span class="line"><span class="number">1498</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">1525</span> <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">1526</span> &#125;</span><br></pre></td></tr></table></figure><p>NXP 提供的 fbops 为mxsfb_ops</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">987</span> <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> <span class="title">mxsfb_ops</span> =</span> &#123;</span><br><span class="line"><span class="number">988</span> .owner = THIS_MODULE,</span><br><span class="line"><span class="number">989</span> .fb_check_var = mxsfb_check_var,</span><br><span class="line"><span class="number">990</span> .fb_set_par = mxsfb_set_par,</span><br><span class="line"><span class="number">991</span> .fb_setcolreg = mxsfb_setcolreg,</span><br><span class="line"><span class="number">992</span> .fb_ioctl = mxsfb_ioctl,</span><br><span class="line"><span class="number">993</span> .fb_blank = mxsfb_blank,</span><br><span class="line"><span class="number">994</span> .fb_pan_display = mxsfb_pan_display,</span><br><span class="line"><span class="number">995</span> .fb_mmap = mxsfb_mmap,</span><br><span class="line"><span class="number">996</span> .fb_fillrect = cfb_fillrect,</span><br><span class="line"><span class="number">997</span> .fb_copyarea = cfb_copyarea,</span><br><span class="line"><span class="number">998</span> .fb_imageblit = cfb_imageblit,</span><br><span class="line"><span class="number">999</span> &#125;;</span><br></pre></td></tr></table></figure><p>mxsfb_init_fbinfo 函数通过调用 mxsfb_init_fbinfo_dt 函数从设备树中获取到 LCD 的各个参数信息。最后， mxsfb_init_fbinfo<br>函数会调用 mxsfb_map_videomem 函数申请 LCD 的帧缓冲内存(也就是显存)。 </p><h2 id="驱动编写"><a href="#驱动编写" class="headerlink" title="驱动编写"></a>驱动编写</h2><p>重点要注意三个地方：<br><strong>①、 LCD 所使用的 IO 配置。</strong><br><strong>②、 LCD 屏幕节点修改，修改相应的属性值，所使用的 LCD 屏幕参数。</strong><br><strong>③、 LCD 背光节点信息修改，要根据实际所使用的背光 IO 来修改相应的设备节点信息。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设备树 LCD IO 配置</span></span><br><span class="line"><span class="number">1</span> pinctrl_lcdif_dat: lcdifdatgrp &#123;</span><br><span class="line"><span class="number">2</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">3</span> MX6UL_PAD_LCD_DATA00__LCDIF_DATA00 <span class="number">0x79</span></span><br><span class="line"><span class="number">4</span> MX6UL_PAD_LCD_DATA01__LCDIF_DATA01 <span class="number">0x79</span></span><br><span class="line"><span class="number">5</span> MX6UL_PAD_LCD_DATA02__LCDIF_DATA02 <span class="number">0x79</span></span><br><span class="line"><span class="number">6</span> MX6UL_PAD_LCD_DATA03__LCDIF_DATA03 <span class="number">0x79</span></span><br><span class="line"><span class="number">7</span> MX6UL_PAD_LCD_DATA04__LCDIF_DATA04 <span class="number">0x79</span></span><br><span class="line"><span class="number">8</span> MX6UL_PAD_LCD_DATA05__LCDIF_DATA05 <span class="number">0x79</span></span><br><span class="line"><span class="number">9</span> MX6UL_PAD_LCD_DATA06__LCDIF_DATA06 <span class="number">0x79</span></span><br><span class="line"><span class="number">10</span> MX6UL_PAD_LCD_DATA07__LCDIF_DATA07 <span class="number">0x79</span></span><br><span class="line"><span class="number">11</span> MX6UL_PAD_LCD_DATA08__LCDIF_DATA08 <span class="number">0x79</span></span><br><span class="line"><span class="number">12</span> MX6UL_PAD_LCD_DATA09__LCDIF_DATA09 <span class="number">0x79</span></span><br><span class="line"><span class="number">13</span> MX6UL_PAD_LCD_DATA10__LCDIF_DATA10 <span class="number">0x79</span></span><br><span class="line"><span class="number">14</span> MX6UL_PAD_LCD_DATA11__LCDIF_DATA11 <span class="number">0x79</span></span><br><span class="line"><span class="number">15</span> MX6UL_PAD_LCD_DATA12__LCDIF_DATA12 <span class="number">0x79</span></span><br><span class="line"><span class="number">16</span> MX6UL_PAD_LCD_DATA13__LCDIF_DATA13 <span class="number">0x79</span></span><br><span class="line"><span class="number">17</span> MX6UL_PAD_LCD_DATA14__LCDIF_DATA14 <span class="number">0x79</span></span><br><span class="line"><span class="number">18</span> MX6UL_PAD_LCD_DATA15__LCDIF_DATA15 <span class="number">0x79</span></span><br><span class="line"><span class="number">19</span> MX6UL_PAD_LCD_DATA16__LCDIF_DATA16 <span class="number">0x79</span></span><br><span class="line"><span class="number">20</span> MX6UL_PAD_LCD_DATA17__LCDIF_DATA17 <span class="number">0x79</span></span><br><span class="line"><span class="number">21</span> MX6UL_PAD_LCD_DATA18__LCDIF_DATA18 <span class="number">0x79</span></span><br><span class="line"><span class="number">22</span> MX6UL_PAD_LCD_DATA19__LCDIF_DATA19 <span class="number">0x79</span></span><br><span class="line"><span class="number">23</span> MX6UL_PAD_LCD_DATA20__LCDIF_DATA20 <span class="number">0x79</span></span><br><span class="line"><span class="number">24</span> MX6UL_PAD_LCD_DATA21__LCDIF_DATA21 <span class="number">0x79</span></span><br><span class="line"><span class="number">25</span> MX6UL_PAD_LCD_DATA22__LCDIF_DATA22 <span class="number">0x79</span></span><br><span class="line"><span class="number">26</span> MX6UL_PAD_LCD_DATA23__LCDIF_DATA23 <span class="number">0x79</span></span><br><span class="line"><span class="number">27</span> &gt;;<span class="comment">//为RGBLCD的27根数据线配置项</span></span><br><span class="line"><span class="number">28</span> &#125;;</span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span> pinctrl_lcdif_ctrl: lcdifctrlgrp &#123;</span><br><span class="line"><span class="number">31</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">32</span> MX6UL_PAD_LCD_CLK__LCDIF_CLK <span class="number">0x79</span></span><br><span class="line"><span class="number">33</span> MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE <span class="number">0x79</span></span><br><span class="line"><span class="number">34</span> MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC <span class="number">0x79</span></span><br><span class="line"><span class="number">35</span> MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC <span class="number">0x79</span></span><br><span class="line"><span class="number">36</span> &gt;;<span class="comment">//RGB LCD 的 4 根控制线配置项，包括 CLK、ENABLE、 VSYNC(场同步信号)和 HSYNC(行同步信号)。</span></span><br><span class="line"><span class="number">37</span> pinctrl_pwm1: pwm1grp &#123;</span><br><span class="line"><span class="number">38</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">39</span> MX6UL_PAD_GPIO1_IO08__PWM1_OUT <span class="number">0x110b0</span></span><br><span class="line"><span class="number">40</span> &gt;;<span class="comment">//LCD 背光 PWM 引脚配置项。这个引脚要根据实际情况设置，</span></span><br><span class="line"><span class="number">41</span> &#125;;</span><br></pre></td></tr></table></figure><p>之后修改lcdif节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;lcdif&#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_lcdif_dat</span><br><span class="line">    &amp;pinctrl_lcdif_ctrl</span><br><span class="line">    <span class="comment">/*&amp;pinctrl_lcdif_reset*/</span>&gt;;<span class="comment">//本显示lcd没有复位引脚所以删掉</span></span><br><span class="line">    display = &lt;&amp;display0&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    display0: display &#123; <span class="comment">/* LCD 属性信息 */</span></span><br><span class="line">bits-per-pixel = &lt;<span class="number">24</span>&gt;; <span class="comment">/* 一个像素占用几个 bit ，RGB888 8+8+8 =24bit*/</span></span><br><span class="line">bus-width = &lt;<span class="number">24</span>&gt;; <span class="comment">/* 总线宽度 */</span></span><br><span class="line"></span><br><span class="line">        display-timings &#123;</span><br><span class="line">        native-mode = &lt;&amp;timing0&gt;; <span class="comment">/* 时序信息 */</span></span><br><span class="line">        timing0: timing0 &#123;</span><br><span class="line">            clock-frequency = &lt;<span class="number">33300000</span>&gt;; <span class="comment">/* LCD 像素时钟，单位 Hz */</span></span><br><span class="line">            hactive = &lt;<span class="number">800</span>&gt;; <span class="comment">/* LCD X 轴像素个数 */</span></span><br><span class="line">            vactive = &lt;<span class="number">480</span>&gt;; <span class="comment">/* LCD Y 轴像素个数 */</span></span><br><span class="line">            hfront-porch = &lt;<span class="number">210</span>&gt;; <span class="comment">/* LCD hfp 参数 */</span></span><br><span class="line">            hback-porch = &lt;<span class="number">46</span>&gt;; <span class="comment">/* LCD hbp 参数 */</span></span><br><span class="line">            hsync-len = &lt;<span class="number">1</span>&gt;; <span class="comment">/* LCD hspw 参数 */</span></span><br><span class="line">            vback-porch = &lt;<span class="number">23</span>&gt;; <span class="comment">/* LCD vbp 参数 */</span></span><br><span class="line">            vfront-porch = &lt;<span class="number">22</span>&gt;; <span class="comment">/* LCD vfp 参数 */</span></span><br><span class="line">            vsync-len = &lt;<span class="number">1</span>&gt;; <span class="comment">/* LCD vspw 参数 */</span></span><br><span class="line"></span><br><span class="line">            hsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* hsync 数据线极性 */</span></span><br><span class="line">            vsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* vsync 数据线极性 */</span></span><br><span class="line">            de-active = &lt;<span class="number">1</span>&gt;; <span class="comment">/* de 数据线极性 */</span></span><br><span class="line">            pixelclk-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* clk 数据线先极性 */</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>背光节点信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> pinctrl_pwm1: pwm1grp &#123;</span><br><span class="line"><span class="number">2</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">3</span> MX6UL_PAD_GPIO1_IO08__PWM1_OUT <span class="number">0x110b0</span></span><br><span class="line"><span class="number">4</span> &gt;;</span><br><span class="line"><span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>LCD 背光要用到 PWM1，因此也要设置 PWM1 节点，在 imx6ull.dtsi 文件中找到如下内容： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> pwm1: pwm@<span class="number">02080000</span> &#123;</span><br><span class="line"><span class="number">2</span> compatible = <span class="string">&quot;fsl,imx6ul-pwm&quot;</span>, <span class="string">&quot;fsl,imx27-pwm&quot;</span>;</span><br><span class="line"><span class="number">3</span> reg = &lt;<span class="number">0x02080000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line"><span class="number">4</span> interrupts = &lt;GIC_SPI <span class="number">83</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line"><span class="number">5</span> clocks = &lt;&amp;clks IMX6UL_CLK_PWM1&gt;,</span><br><span class="line"><span class="number">6</span> &lt;&amp;clks IMX6UL_CLK_PWM1&gt;;</span><br><span class="line"><span class="number">7</span> clock-names = <span class="string">&quot;ipg&quot;</span>, <span class="string">&quot;per&quot;</span>;</span><br><span class="line"><span class="number">8</span> <span class="meta">#pwm-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"><span class="number">9</span> &#125;;</span><br></pre></td></tr></table></figure><p>在整个 Linux 源码文件中搜索 compatible 属性的这两个值即可找到 imx6ull 的 pwm 驱动文件。</p><p>继续在 imx6ull-alientek-emmc.dts 文件中找到向 pwm1追加的内容，如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;pwm1 &#123;</span><br><span class="line"><span class="number">2</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">3</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_pwm1&gt;;<span class="comment">//之前定义的GPIO1_08</span></span><br><span class="line"><span class="number">4</span> status = <span class="string">&quot;okay&quot;</span>;<span class="comment">//设置okay</span></span><br><span class="line"><span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>要让Linux知道PWM1_OUT是控制背光的，需要一个节点来将 LCD 背光和 PWM1_OUT连 接 起 来 。 这 个 节 点 就 是 backlight ， backlight 节 点 描 述 可 以 参 考Documentation&#x2F;devicetree&#x2F;indings&#x2F;video&#x2F;backlight&#x2F;pwm-backlight.txt 这个文档，此文档详细讲解了<br>backlight 节点该如何去创建，这里大概总结一下： </p><ol><li>节点名称要为“backlight”。</li><li>节点的 compatible 属性值要为“pwm-backlight”，因此可以通过在 Linux 内核中搜索“ pwm-backlight ” 来 查 找 PWM 背 光 控 制 驱 动 程 序 ， 这 个 驱 动 程 序 文 件 为drivers&#x2F;video&#x2F;backlight&#x2F;pwm_bl.c，感兴趣的可以去看一下这个驱动程序。</li><li>pwms属性用于描述背光所使用的PWM以及PWM频率，比如本章我们要使用的pwm1，pwm 频率设置为 200Hz(NXP 官方推荐设置)。</li><li>brightness-levels 属性描述亮度级别，范围为 0~255， 0 表示 PWM 占空比为 0%，也就是亮度最低， 255 表示 100%占空比，也就是亮度最高 </li><li>default-brightness-level 属性为默认亮度级别。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">backlight &#123;</span><br><span class="line">compatible = <span class="string">&quot;pwm-backlight&quot;</span>;</span><br><span class="line">pwms = &lt;&amp;pwm1 <span class="number">0</span> <span class="number">5000000</span>&gt;;<span class="comment">//设置背光使用 pwm1， PWM 频率为 200Hz。</span></span><br><span class="line">brightness-levels = &lt;<span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span> <span class="number">64</span> <span class="number">128</span> <span class="number">255</span>&gt;;<span class="comment">/*设置背 8 级背光(0~7)，分别为 0、 4、 8、 16、 32、 64、 128、 255，对应占空比为0%、 1.57%、 3.13%、 6.27%、 12.55%、 25.1%、 50.19%、 100%*/</span></span><br><span class="line"><span class="keyword">default</span>-brightness-level = &lt;<span class="number">6</span>&gt;;<span class="comment">//设置默认背光等级为 6，也就是 50.19%的亮度</span></span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make dtbs//编译设备树</span><br></pre></td></tr></table></figure><p>使能 Linux logo 显示 ，make menuconfig打开 Linux内核图形化配置界面，按下路径找到对应的配置项： </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-10%20195842.png"></p><p>重新编译 Linux 内核，编译完成以后使用新编译出来的 imx6ull-alientek-emmc.dtb 和 zImage 镜像启动系统 ，如果显示正常的话，LCD左上角会出现一个彩色的小企鹅logo</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-10%20200126.png"></p><h4 id="设置-LCD-作为终端控制台"><a href="#设置-LCD-作为终端控制台" class="headerlink" title="设置 LCD 作为终端控制台"></a>设置 LCD 作为终端控制台</h4><ol><li><p><strong>设置uboot中的bootargs</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=tty1 console=ttymxc0,115200 root=/dev/nfs rw nfsroot=192.168.1.250:</span><br><span class="line">/home/moss/linux/nfs/rootfs ip=192.168.0.128:192.168.1.250:192.168.0.1:255.255.255.0::eth0:off&#x27;</span><br></pre></td></tr></table></figure><p>设置了两遍 console，第一次设置 console&#x3D;tty1，也就是设置 LCD 屏幕为控制台，第二遍又设置 console&#x3D;ttymxc0,115200，也就是设置串口也作为控制台。相当于我们打开了两个 console，一个是 LCD，一个是串口，大家重启开发板就会发现 LCD 和串口都会显示 Linux 启动 log 信息。 </p></li><li><p><strong>修改&#x2F;etc&#x2F;inittab 文件</strong></p></li></ol><p>打开开发板根文件系统中的&#x2F;etc&#x2F;inittab 文件，在里面加入下面这一行： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tty1::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure><p>添加完成以后的&#x2F;etc&#x2F;inittab 文件内容如图 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-10%20200633.png">·····</p><p>修改完成以后保存&#x2F;etc&#x2F;inittab 并退出，然后重启开发板，重启以后开发板 LCD 屏幕最后一行会显示下面一行语句： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please press Enter to activate this console.</span><br></pre></td></tr></table></figure><p>至此，我们就拥有了两套终端，一个是基于串口的 SecureCRT，一个就是我们开发板的 LCD屏幕，但是为了方便调试，我们以后还是以 SecureCRT 为主。我们可以通过下面这一行命令向LCD 屏幕输出“hello linux！”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello linux &gt; /dev/tty1 </span><br></pre></td></tr></table></figure><p>通过设置背光等级来实现 LCD 背光亮度的调节，进入如下目录：&#x2F;sys&#x2F;devices&#x2F;platform&#x2F;backlight&#x2F;backlight&#x2F;backlight </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-10%20202557.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 7 &gt; brightness//设置背光等级为7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>input驱动</title>
      <link href="/2023/07/09/2023-7-9-input%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/09/2023-7-9-input%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Input子系统"><a href="#Input子系统" class="headerlink" title="Input子系统"></a>Input子系统</h2><p>input 就是输入的意思，因此 input 子系统就是管理输入的子系统，和 pinctrl、 gpio 子系统一样，都是 Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，为此 input 子系统分为 input 驱动层、 input 核心层、 input 事件处理层，最终给用户空间提供可访问的设备节点。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-08%20114135.png"></p><h3 id="驱动部分包含三个部分：驱动层，核心层，事件层"><a href="#驱动部分包含三个部分：驱动层，核心层，事件层" class="headerlink" title="驱动部分包含三个部分：驱动层，核心层，事件层"></a>驱动部分包含三个部分：驱动层，核心层，事件层</h3><p>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。<br>核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。<br>事件层：主要和用户空间进行交互。 </p><h3 id="注册input-dev"><a href="#注册input-dev" class="headerlink" title="注册input_dev"></a>注册input_dev</h3><p>在使用 input 子系统的时候我们只需要注册一个 input 设备即可， input_dev 结构体表示 input设备 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">121</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line"><span class="number">122</span> <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="number">123</span> <span class="type">const</span> <span class="type">char</span> *phys;</span><br><span class="line"><span class="number">124</span> <span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line"><span class="number">125</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span></span><br><span class="line"><span class="number">126</span></span><br><span class="line"><span class="number">127</span> <span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"><span class="number">128</span></span><br><span class="line"><span class="number">129</span> <span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">/* 事件类型的位图 */</span></span><br><span class="line"><span class="number">130</span> <span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="comment">/* 按键值的位图 */</span></span><br><span class="line"><span class="number">131</span> <span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="comment">/* 相对坐标的位图 */</span></span><br><span class="line"><span class="number">132</span> <span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="comment">/* 绝对坐标的位图 */</span></span><br><span class="line"><span class="number">133</span> <span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; <span class="comment">/* 杂项事件的位图 */</span></span><br><span class="line"><span class="number">134</span> <span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; <span class="comment">/*LED 相关的位图 */</span></span><br><span class="line"><span class="number">135</span> <span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="comment">/* sound 有关的位图 */</span></span><br><span class="line"><span class="number">136</span> <span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; <span class="comment">/* 压力反馈的位图 */</span></span><br><span class="line"><span class="number">137</span> <span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; <span class="comment">/*开关状态的位图 */</span></span><br><span class="line">......</span><br><span class="line"><span class="number">189</span> <span class="type">bool</span> devres_managed;</span><br><span class="line"><span class="number">190</span> &#125;;</span><br></pre></td></tr></table></figure><p>evbit 表示输入事件类型，可选的事件类型定义在 include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，事件类型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SYN 0x00 <span class="comment">/* 同步事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_KEY 0x01 <span class="comment">/* 按键事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REL 0x02 <span class="comment">/* 相对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ABS 0x03 <span class="comment">/* 绝对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_MSC 0x04 <span class="comment">/* 杂项(其他)事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SW 0x05 <span class="comment">/* 开关事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_LED 0x11 <span class="comment">/* LED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SND 0x12 <span class="comment">/* sound(声音) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REP 0x14 <span class="comment">/* 重复事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF 0x15 <span class="comment">/* 压力事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PWR 0x16 <span class="comment">/* 电源事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF_STATUS 0x17 <span class="comment">/* 压力状态事件 */</span></span></span><br></pre></td></tr></table></figure><p>Linux 内核定义了很多按键值，这些按键值定义在 include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，按键值如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">215</span> <span class="meta">#<span class="keyword">define</span> KEY_RESERVED 0</span></span><br><span class="line"><span class="number">216</span> <span class="meta">#<span class="keyword">define</span> KEY_ESC 1</span></span><br><span class="line"><span class="number">217</span> <span class="meta">#<span class="keyword">define</span> KEY_1 2</span></span><br><span class="line"><span class="number">218</span> <span class="meta">#<span class="keyword">define</span> KEY_2 3</span></span><br><span class="line"><span class="number">219</span> <span class="meta">#<span class="keyword">define</span> KEY_3 4</span></span><br><span class="line"><span class="number">220</span> <span class="meta">#<span class="keyword">define</span> KEY_4 5</span></span><br><span class="line"><span class="number">221</span> <span class="meta">#<span class="keyword">define</span> KEY_5 6</span></span><br><span class="line"><span class="number">222</span> <span class="meta">#<span class="keyword">define</span> KEY_6 7</span></span><br><span class="line"><span class="number">223</span> <span class="meta">#<span class="keyword">define</span> KEY_7 8</span></span><br><span class="line"><span class="number">224</span> <span class="meta">#<span class="keyword">define</span> KEY_8 9</span></span><br><span class="line"><span class="number">225</span> <span class="meta">#<span class="keyword">define</span> KEY_9 10</span></span><br><span class="line"><span class="number">226</span> <span class="meta">#<span class="keyword">define</span> KEY_0 11</span></span><br><span class="line">......</span><br><span class="line"><span class="number">794</span> <span class="meta">#<span class="keyword">define</span> BTN_TRIGGER_HAPPY39 0x2e6</span></span><br><span class="line"><span class="number">795</span> <span class="meta">#<span class="keyword">define</span> BTN_TRIGGER_HAPPY40 0x2e7</span></span><br></pre></td></tr></table></figure><p>在编写 input 设备驱动的时候我们需要先申请一个 input_dev 结构体变量，使用input_allocate_device 函数来申请一个 input_dev， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> input_dev *<span class="title function_">input_allocate_device</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure><p>如果要注销的 input 设备的话需要使用 input_free_device 函数来释放掉前面申请到的input_dev， i</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_free_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure><p>申请好一个 input_dev 以后就需要初始化这个 input_dev，需要初始化的内容主要为事件类型(evbit)和事件值(keybit)这两种。 input_dev 初始化完成以后就需要向 Linux 内核注册 input_dev了，需要用到 input_register_device 函数 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure><h3 id="input-dev-注册过程如下："><a href="#input-dev-注册过程如下：" class="headerlink" title="input_dev 注册过程如下："></a>input_dev 注册过程如下：</h3><p>①、使用 input_allocate_device 函数申请一个 input_dev。<br>②、初始化 input_dev 的事件类型以及事件值。<br>③、使用 input_register_device 函数向 Linux 系统注册前面初始化好的 input_dev。<br>④、卸载input驱动的时候需要先使用input_unregister_device 函数注销掉注册的input_dev，然后使用 input_free_device 函数释放掉前面申请的 input_dev。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">inputdev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    inputdev = input_allocate_device();<span class="comment">//申请input_dev</span></span><br><span class="line">    inputdev -&gt; name = <span class="string">&quot;test_inputdev&quot;</span>;<span class="comment">//设置名字</span></span><br><span class="line">    <span class="comment">//第一种设置事件和键值</span></span><br><span class="line">    __set_bit(EV_KEY, inputdev-&gt;evbit);<span class="comment">//设置产生按键事件</span></span><br><span class="line">__set_bit(EV_REP, inputdev-&gt;evbit);<span class="comment">//重复事件</span></span><br><span class="line">    __set_bit(KEY_0, inputdev-&gt;keyit);<span class="comment">//设置产生哪些按键值</span></span><br><span class="line"><span class="comment">//第二种设置事件和键值</span></span><br><span class="line">    keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY)|BIT_MASK(EV_REP);</span><br><span class="line">    keyinputdev.inputdev-&gt;keyit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);</span><br><span class="line">    <span class="comment">//第三种设置事件和键值</span></span><br><span class="line">    keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">    input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">    </span><br><span class="line">    input_register_device(inputdev);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    input_unregister_device(inputdev);</span><br><span class="line">    input_free_device(inputdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上报输入事件"><a href="#上报输入事件" class="headerlink" title="上报输入事件"></a>上报输入事件</h3><p> Linux 内核注册好 input_dev 不能顺利的使用input设备， input 设备都是具有输入功能的，但是具体是什么样的输入值 Linux 内核是不知道的，需要获取到具体的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核。比如按键，我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。不同的事件，其上报事件的 API 函数不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于上报指定事件以及对应的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="comment">//dev需要上报inputdev</span></span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> <span class="type">int</span> type,<span class="comment">//上报的事件类型如EV_KEY</span></span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> <span class="type">int</span> code,<span class="comment">//事件码也就是注册的键值</span></span></span><br><span class="line"><span class="params">                 <span class="type">int</span> value)</span><span class="comment">//事件值</span></span><br></pre></td></tr></table></figure><p>nput_event 函数可以上报所有的事件类型和事件值， Linux 内核也提供了其他的针对具体事件的上报函数，这些函数其实都用到了 input_event 函数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">input_report_key</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的还有一些其他的事件上报函数，这些函数如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_report_rel</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_abs</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_ff_status</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_switch</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_mt_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure><p>上报事件以后还需要使用 input_sync 函数来告诉 Linux 内核 input 子系统上报结束，input_sync 函数本质是上报一个同步事件， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span><span class="comment">//dev需要上报的同步事件的input_dev</span></span><br></pre></td></tr></table></figure><p>eg：按键的上报事件代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于按键消抖的定时器服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line"> </span><br><span class="line">value = gpio_get_value(keydesc-&gt;gpio); <span class="comment">/* 读取 IO 值 */</span></span><br><span class="line"><span class="keyword">if</span>(value == <span class="number">0</span>)&#123; <span class="comment">/* 按下按键 */</span></span><br><span class="line"><span class="comment">/* 上报按键值 */</span></span><br><span class="line">    input_report_key(inputdev, KEY_0, <span class="number">1</span>); <span class="comment">/* 最后一个参数 1， 按下 */</span></span><br><span class="line">        input_sync(inputdev); <span class="comment">/* 同步事件 */</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 按键松开 */</span></span><br><span class="line">input_report_key(inputdev, KEY_0, <span class="number">0</span>); <span class="comment">/* 最后一个参数 0， 松开 */</span></span><br><span class="line">input_sync(inputdev); <span class="comment">/* 同步事件 */</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux 内核使用 input_event 这个结构体来表示所有的输入事件， input_envent 结构体定义在include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，结构体内容如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span><span class="comment">//此事件发生的时间</span></span><br><span class="line">__u16 type;<span class="comment">//事件类型</span></span><br><span class="line">__u16 code;<span class="comment">//事件码</span></span><br><span class="line">__s32 value;<span class="comment">//按键值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于时间timeval的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="type">long</span><span class="type">__kernel_long_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__kernel_long_t</span><span class="type">__kernel_time_t</span>;</span><br><span class="line"><span class="keyword">typedef</span><span class="type">__kernel_long_t</span><span class="type">__kernel_suseconds_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">  <span class="type">__kernel_time_t</span>tv_sec;<span class="comment">//秒  </span></span><br><span class="line"><span class="type">__kernel_suseconds_t</span>tv_usec;<span class="comment">//微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Linux-自带按键驱动程序的使用"><a href="#Linux-自带按键驱动程序的使用" class="headerlink" title="Linux 自带按键驱动程序的使用"></a>Linux 自带按键驱动程序的使用</h3><p>编译内核make menuconfig</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-08%20160716.png"></p><p>使 用 Linux 内 核 自 带 的 按 键 驱 动 程 序 添加设备节点。</p><p>①、节点名字为“gpio-keys”。<br>②、 gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。<br>③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述自己：<br>gpios： KEY 所连接的 GPIO 信息。<br>interrupts： KEY 所使用 GPIO 中断信息，不是必须的，可以不写。<br>label： KEY 名字<br>linux,code： KEY 要模拟的按键，也就是示例代码 58.1.2.4 中的这些按键。<br>④、如果按键要支持连按的话要加入 autorepeat。<br> <strong>gpio-keys 节点内容</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gpio-keys &#123;</span><br><span class="line">compatible = <span class="string">&quot;gpio-keys&quot;</span>;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">autorepeat;</span><br><span class="line">key0 &#123;</span><br><span class="line">label = <span class="string">&quot;GPIO Key Enter&quot;</span>;</span><br><span class="line">linux,code = &lt;KEY_ENTER&gt;;</span><br><span class="line">gpios = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MISC设备驱动</title>
      <link href="/2023/07/07/2023-7-7-MISC%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/07/2023-7-7-MISC%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="MISC驱动"><a href="#MISC驱动" class="headerlink" title="MISC驱动"></a>MISC驱动</h2><p>所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。 MISC 设备会自动创建 cdev，不需要像手动创建，因此采用 MISC 设备驱动可以简化字符设备驱动的编写。 需要向 Linux 注册一个 miscdevice 设备 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> &#123;</span></span><br><span class="line"><span class="type">int</span> minor; <span class="comment">/* 子设备号 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/* 设备名字 */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span> <span class="comment">/* 设备操作集 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *nodename;</span><br><span class="line"><span class="type">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Linux 系统已经预定义了一些 MISC 设备的子设备号，这些预定义的子设备号定义在include&#x2F;linux&#x2F;miscdevice.h 文件中，如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span> <span class="meta">#<span class="keyword">define</span> PSMOUSE_MINOR 1</span></span><br><span class="line"><span class="number">14</span> <span class="meta">#<span class="keyword">define</span> MS_BUSMOUSE_MINOR 2 <span class="comment">/* unused */</span></span></span><br><span class="line"><span class="number">15</span> <span class="meta">#<span class="keyword">define</span> ATIXL_BUSMOUSE_MINOR 3 <span class="comment">/* unused */</span></span></span><br><span class="line"><span class="number">16</span> <span class="comment">/*#define AMIGAMOUSE_MINOR 4 FIXME OBSOLETE */</span></span><br><span class="line"><span class="number">17</span> <span class="meta">#<span class="keyword">define</span> ATARIMOUSE_MINOR 5 <span class="comment">/* unused */</span></span></span><br><span class="line"><span class="number">18</span> <span class="meta">#<span class="keyword">define</span> SUN_MOUSE_MINOR 6 <span class="comment">/* unused */</span></span></span><br><span class="line">......</span><br><span class="line"><span class="number">52</span> <span class="meta">#<span class="keyword">define</span> MISC_DYNAMIC_MINOR 255</span></span><br></pre></td></tr></table></figure><p>注册和删除设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">misc_register</span><span class="params">(<span class="keyword">struct</span> miscdevice * misc)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">misc_deregister</span><span class="params">(<span class="keyword">struct</span> miscdevice *misc)</span></span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misc_beepname <span class="string">&quot;miscbeep&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>beep_minor144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>BEEPON1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>BEEPOFF0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscbeep_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"><span class="type">int</span> beep_gpio;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscbeep_dev</span> <span class="title">miscbeep</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">misc_beep_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp -&gt; private_data = &amp;miscbeep;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">misc_beep_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt,<span class="type">loff_t</span> *offt )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscbeep_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t find user&#x27;s data\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">state = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(state == BEEPON)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;beep_gpio, <span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == BEEPOFF)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;beep_gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">misc_beep_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = misc_beep_open,</span><br><span class="line">.write = misc_beep_write,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">beep_miscdev</span> =</span> &#123;</span><br><span class="line">.minor = beep_minor,</span><br><span class="line">.name = misc_beepname,</span><br><span class="line">.fops = &amp;misc_beep_fops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">miscbeep_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">&quot;beep driver and device have matched\r\n&quot;</span>);</span><br><span class="line">miscbeep.nd = of_find_node_by_path(<span class="string">&quot;/beep&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(miscbeep.nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;beep node can&#x27;t find\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">miscbeep.beep_gpio = of_get_named_gpio(miscbeep.nd, <span class="string">&quot;beep-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(miscbeep.beep_gpio &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t get beep-gpio\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">ret = gpio_direction_output(miscbeep.beep_gpio, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;misc device register failed!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">ret = misc_register(&amp;beep_miscdev);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;misc device register failed\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">miscbeep_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(miscbeep.beep_gpio, <span class="number">1</span>);</span><br><span class="line">gpio_free(miscbeep.beep_gpio);<span class="comment">//将硬件资源还给linux内核</span></span><br><span class="line">misc_deregister(&amp;beep_miscdev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">beep_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123;.compatible = <span class="string">&quot;atkalpha-beep&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="comment">/*empty*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">beep_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">&quot;imx6ul-beep&quot;</span>,</span><br><span class="line">.of_match_table = beep_of_match,</span><br><span class="line">&#125;,</span><br><span class="line">.probe = miscbeep_probe,</span><br><span class="line">.remove = miscbeep_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">miscbeep_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> platform_driver_register(&amp;beep_driver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">miscbeep_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;beep_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(miscbeep_init);</span><br><span class="line">module_exit(miscbeep_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树下的platform设备驱动</title>
      <link href="/2023/07/06/2023-7-6-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8B%E7%9A%84platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/06/2023-7-6-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8B%E7%9A%84platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="设备树下的platform驱动"><a href="#设备树下的platform驱动" class="headerlink" title="设备树下的platform驱动"></a>设备树下的platform驱动</h2><p>在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就不需要我们去编写了，我们只需要实现 platform_driver 即可 。</p><h3 id="1-创建设备树中设备节点"><a href="#1-创建设备树中设备节点" class="headerlink" title="1.创建设备树中设备节点"></a>1.创建设备树中设备节点</h3><p>platform 总线需要通过设备节点的 compatible 属性值来匹配驱动！ 以led设备为例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gpioled&#123;</span><br><span class="line">   <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    compatible = <span class="string">&quot;atkalpha-gpioled&quot;</span>;<span class="comment">//匹配的属性</span></span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_led&gt;;</span><br><span class="line">    led-gpio = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h3 id="2-编写platform驱动时候要注意兼容属性"><a href="#2-编写platform驱动时候要注意兼容属性" class="headerlink" title="2.编写platform驱动时候要注意兼容属性"></a>2.编写platform驱动时候要注意兼容属性</h3><p>在使用设备树的时候 platform 驱动会通过 of_match_table 来保存兼容性值，也就是表明此驱动兼容哪些设备。所以， of_match_table 将会尤为重要，比如本例程的 platform 驱动中 platform_driver 就可以按照如下所示设置： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">leds_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;atkalpha-gpioled&quot;</span> &#125;, <span class="comment">/* 兼容属性 */</span></span><br><span class="line">&#123; <span class="comment">/* Sentinel */</span> &#125;<span class="comment">//在编写 of_device_id 的时候最后一个元素一定要为空！</span></span><br><span class="line">&#125;;<span class="comment">/*of_device_id 表，也就是驱动的兼容表，是一个数组，每个数组元素为 of_device_id类型。每个数组元素都是一个兼容属性，表示兼容的设备，一个驱动可以跟多个设备匹配。*/</span></span><br><span class="line">MODULE_DEVICE_TABLE(of, leds_of_match);<span class="comment">// 声明一下 leds_of_match 这个设备匹配表。</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">leds_platform_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">&quot;imx6ul-led&quot;</span>,</span><br><span class="line">    .of_match_table = leds_of_match,<span class="comment">//设置为上面的匹配表</span></span><br><span class="line">&#125;,</span><br><span class="line">    .probe = leds_probe,</span><br><span class="line">.remove = leds_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDDEV_CNT1<span class="comment">/* 设备号长度 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDDEV_NAME<span class="string">&quot;dtsplatled&quot;</span><span class="comment">/* 设备名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 1</span></span><br><span class="line"><span class="comment">/* leddev设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leddev_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备*/</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span><span class="comment">/* LED设备节点 */</span></span><br><span class="line"><span class="type">int</span> led0;<span class="comment">/* LED灯GPIO标号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leddev_dev</span> <span class="title">leddev</span>;</span> <span class="comment">/* led设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: LED打开/关闭</span></span><br><span class="line"><span class="comment"> * @param - sta : LEDON(0) 打开LED，LEDOFF(1) 关闭LED</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led0_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sta == LEDON )</span><br><span class="line">gpio_set_value(leddev.led0, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sta == LEDOFF)</span><br><span class="line">gpio_set_value(leddev.led0, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode : 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> *   一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;leddev; <span class="comment">/* 设置私有数据  */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 向设备写数据 </span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，表示打开的文件描述符</span></span><br><span class="line"><span class="comment"> * @param - buf : 要写给设备写入的数据</span></span><br><span class="line"><span class="comment"> * @param - cnt : 要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">2</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line"></span><br><span class="line">retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ledstat = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (ledstat == LEDON) &#123;</span><br><span class="line">led0_switch(LEDON);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ledstat == LEDOFF) &#123;</span><br><span class="line">led0_switch(LEDOFF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_open,</span><br><span class="line">.write = led_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: flatform驱动的probe函数，当驱动与</span></span><br><span class="line"><span class="comment"> *   设备匹配以后此函数就会执行</span></span><br><span class="line"><span class="comment"> * @param - dev : platform设备</span></span><br><span class="line"><span class="comment"> * @return : 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;led driver and device was matched!\r\n&quot;</span>);</span><br><span class="line"><span class="comment">/* 1、设置设备号 */</span></span><br><span class="line"><span class="keyword">if</span> (leddev.major) &#123;</span><br><span class="line">leddev.devid = MKDEV(leddev.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alloc_chrdev_region(&amp;leddev.devid, <span class="number">0</span>, LEDDEV_CNT, LEDDEV_NAME);</span><br><span class="line">leddev.major = MAJOR(leddev.devid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、注册设备      */</span></span><br><span class="line">cdev_init(&amp;leddev.cdev, &amp;led_fops);</span><br><span class="line">cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、创建类      */</span></span><br><span class="line">leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(leddev.class)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(leddev.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、创建设备 */</span></span><br><span class="line">leddev.device = device_create(leddev.class, <span class="literal">NULL</span>, leddev.devid, <span class="literal">NULL</span>, LEDDEV_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(leddev.device)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(leddev.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、初始化IO */</span></span><br><span class="line">leddev.node = of_find_node_by_path(<span class="string">&quot;/gpioled&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (leddev.node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">printk(<span class="string">&quot;gpioled node nost find!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">leddev.led0 = of_get_named_gpio(leddev.node, <span class="string">&quot;led-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (leddev.led0 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t get led-gpio\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gpio_request(leddev.led0, <span class="string">&quot;led0&quot;</span>);</span><br><span class="line">gpio_direction_output(leddev.led0, <span class="number">1</span>); <span class="comment">/* led0 IO设置为输出，默认高电平*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: platform驱动的remove函数，移除platform驱动的时候此函数会执行</span></span><br><span class="line"><span class="comment"> * @param - dev : platform设备</span></span><br><span class="line"><span class="comment"> * @return : 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(leddev.led0, <span class="number">1</span>); <span class="comment">/* 卸载驱动的时候关闭LED */</span></span><br><span class="line">gpio_free(leddev.led0);<span class="comment">/* 释放IO */</span></span><br><span class="line"></span><br><span class="line">cdev_del(&amp;leddev.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line">device_destroy(leddev.class, leddev.devid);</span><br><span class="line">class_destroy(leddev.class);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">led_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;atkalpha-gpioled&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* platform驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">led_driver</span> =</span> &#123;</span><br><span class="line">.driver= &#123;</span><br><span class="line">.name= <span class="string">&quot;imx6ul-led&quot;</span>,<span class="comment">/* 驱动名字，用于和设备匹配 */</span></span><br><span class="line">.of_match_table= led_of_match, <span class="comment">/* 设备树匹配表  */</span></span><br><span class="line">&#125;,</span><br><span class="line">.probe= led_probe,</span><br><span class="line">.remove= led_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动模块加载函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">leddriver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> platform_driver_register(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动模块卸载函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">leddriver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;zuozhongkai&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>platform设备驱动</title>
      <link href="/2023/07/03/2023-7-3-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/03/2023-7-3-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="驱动框架"><a href="#驱动框架" class="headerlink" title="驱动框架"></a>驱动框架</h2><h4 id="传统驱动框架"><a href="#传统驱动框架" class="headerlink" title="传统驱动框架"></a>传统驱动框架</h4><p>假如现在有三个平台 A、 B 和 C，这三个平台(这里的平台说的是 SOC)上都有 MPU6050 这个 I2C接口的六轴传感器 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-03%20144925.png"></p><p>每种平台下都有一个主机驱动和设备驱动，主机驱动肯定是必须要的，毕竟不同的平台其 I2C 控制器不同。但是右侧的设备驱动就没必要每个平台都写一个，因为不管对于那个 SOC 来说， MPU6050 都是一样，通过 I2C 接口读写数据就行了，只需要一个 MPU6050 的驱动程序即可。 </p><h3 id="分离后的驱动框架"><a href="#分离后的驱动框架" class="headerlink" title="分离后的驱动框架"></a>分离后的驱动框架</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-03%20145117.png"></p><p>相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于驱动只负责驱动，设备只负责设备，想办法将两者进行匹配即可。这个就是 Linux 中的总线(bus)、驱动(driver)和设备(device)模型，也就是常说的驱动分离。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-03%20145316.png"></p><h2 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h2><h3 id="platform总线"><a href="#platform总线" class="headerlink" title="platform总线"></a>platform总线</h3><p>paltform是一种虚拟的总线，用于管理外设资源<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>资源中断资源。在硬件上有USB-BUS总线，PCI-BUS总线，这是在物理设备上实际存在的总线。USB-BUS管理USB设备，PCI总线管理PCI设备。但是在实际中，一些设备不属于这些总线，一些SOC上面的控制器或者设备。使用platform统一管理这些设备。</p><p>Linux系统内核使用bus_type结构体表示总线</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/* 总线名字 */</span></span><br><span class="line"><span class="number">3</span> <span class="type">const</span> <span class="type">char</span> *dev_name;</span><br><span class="line"><span class="number">4</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev_root</span>;</span></span><br><span class="line"><span class="number">5</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attrs</span>;</span></span><br><span class="line"><span class="number">6</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span> <span class="comment">/* 总线属性 */</span></span><br><span class="line"><span class="number">7</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span> <span class="comment">/* 设备属性 */</span></span><br><span class="line"><span class="number">8</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span> <span class="comment">/* 驱动属性 */</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">int</span> (*match)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv);<span class="comment">//完成设备和驱动之间的匹配</span></span><br><span class="line"><span class="number">11</span> <span class="type">int</span> (*uevent)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> kobj_uevent_env *env);</span><br><span class="line"><span class="number">12</span> <span class="type">int</span> (*probe)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">13</span> <span class="type">int</span> (*remove)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">14</span> <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="type">int</span> (*online)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> (*offline)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">18</span> <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state);</span><br><span class="line"><span class="number">19</span> <span class="type">int</span> (*resume)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">20</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"><span class="number">21</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"><span class="number">22</span> <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="number">23</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line"><span class="number">24</span> &#125;;</span><br></pre></td></tr></table></figure><p>总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数。 match 函数有两个参数： dev 和 drv，这两个参数分别为 device 和 device_driver 类型，也就是设备和驱动。 </p><p>platform 总线 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123;</span><br><span class="line"><span class="number">2</span> .name = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line"><span class="number">3</span> .dev_groups = platform_dev_groups,</span><br><span class="line"><span class="number">4</span> .match = platform_match,</span><br><span class="line"><span class="number">5</span> .uevent = platform_uevent,</span><br><span class="line"><span class="number">6</span> .pm = &amp;platform_dev_pm_ops,</span><br><span class="line"><span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure><p>platform_bus_type 就是 platform 平台总线，其中 platform_match 就是匹配函数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">platform_match</span><span class="params">(<span class="keyword">struct</span> device *dev,<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">2 &#123;</span><br><span class="line"><span class="number">3</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line"><span class="number">4</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">6</span><span class="comment">/*When driver_override is set,only bind to the matching driver*/</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">if</span> (of_driver_match_device(dev, drv))<span class="comment">//of设备树的匹配模式比较每个设备节点compatible属性和of_match_table</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="comment">/* Then try ACPI style match */</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))<span class="comment">//ACPI的匹配模式</span></span><br><span class="line"><span class="number">16</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/* Then try to match against the id table */</span></span><br><span class="line"><span class="number">19</span> <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line"><span class="number">20</span> <span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;<span class="comment">//id_table匹配</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line"><span class="number">23</span> <span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);<span class="comment">//如果id匹配的 id_table 不存在的话就比较驱动和设备的 name 字段</span></span><br><span class="line"><span class="number">24</span> &#125;</span><br></pre></td></tr></table></figure><p>对于支持设备树的 Linux 版本号，一般设备驱动为了兼容性都支持设备树和无设备树两种匹配方式。<strong>也就是第一种匹配方式一般都会存在，第三种和第四种只要存在一种就可以</strong>，一般用的最多的还是第四种，也就是直接比较驱动和设备的 name 字段，毕竟这种方式最简单了。 </p><p>platform驱动</p><p> platform_driver 结 构 体 表 示 platform  驱 动 ， 此 结 构 体 定 义 在 文 件 include&#x2F;linux&#x2F;platform_device.h 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"><span class="number">3</span> <span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"><span class="number">4</span> <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);</span><br><span class="line"><span class="number">6</span> <span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"><span class="number">7</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line"><span class="number">8</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line"><span class="number">9</span> <span class="type">bool</span> prevent_deferred_probe;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure><p>第 2 行， probe 函数，当驱动与设备匹配成功以后 probe 函数就会执行，非常重要的函数！！<br>一般驱动的提供者会编写，如果自己要编写一个全新的驱动，那么 probe 就需要自行实现。<br>第 7 行， driver 成员，为 device_driver 结构体变量， Linux 内核里面大量使用到了面向对象的思维， device_driver 相当于基类，提供了最基础的驱动框架。 plaform_driver 继承了这个基类，然后在此基础上又添加了一些特有的成员变量。</p><p>第 8 行， id_table 表，也就是platform 总线匹配驱动和设备的时候采用的第三种方法， id_table 是个表( 也就是数组) ，每个元素的类型为 platform_device_id。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">char</span> name[PLATFORM_NAME_SIZE];</span><br><span class="line"><span class="number">3</span> <span class="type">kernel_ulong_t</span> driver_data;</span><br><span class="line"><span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *mod_name; <span class="comment">/* used for built-in modules */</span></span><br><span class="line"><span class="type">bool</span> suppress_bind_attrs; <span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_match_table</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span> *<span class="title">acpi_match_table</span>;</span></span><br><span class="line">    <span class="type">int</span> (*probe) (<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="type">int</span> (*remove) (<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="type">void</span> (*shutdown) (<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="type">int</span> (*suspend) (<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state);</span><br><span class="line"><span class="type">int</span> (*resume) (<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>of_match_table 就是采用设备树的时候驱动使用的匹配表，同样是数组，每个匹配项都为 of_device_id 结构体类型 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> type[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> compatible[<span class="number">128</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="platform设备"><a href="#platform设备" class="headerlink" title="platform设备"></a>platform设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//设备名字</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">bool</span> id_auto;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">u32 num_resources;<span class="comment">//资源数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span><span class="comment">//资源大小</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_entry</span>;</span></span><br><span class="line"><span class="type">char</span> *driver_override; <span class="comment">/* Driver name to force a match */</span></span><br><span class="line"><span class="comment">/* MFD cell pointer */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"><span class="comment">/* arch specific additions */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line"><span class="type">resource_size_t</span> start;</span><br><span class="line"><span class="type">resource_size_t</span> end;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址， name 表示资源名字， flags 表示资源类型。</p><h2 id="platform框架"><a href="#platform框架" class="headerlink" title="platform框架"></a>platform框架</h2><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/1688375549528.jpg"></p><h2 id="platform总结"><a href="#platform总结" class="headerlink" title="platform总结"></a>platform总结</h2><p>1）定义一个 platform_driver 结构体变量。</p><p>2）实现probe函数。</p><p>3）实现remove函数。</p><p>4）实现of_match_table。</p><p>5）调用platform_driver_register 函数向 Linux 内核注册一个 platform 驱动。</p><p>6）调用platform_driver_unregister 函数卸载 platform 驱动。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典滤波算法</title>
      <link href="/2023/06/15/2023-6-15-%E7%BB%8F%E5%85%B8%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2023/06/15/2023-6-15-%E7%BB%8F%E5%85%B8%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-限幅滤波法（程序判断滤波法）"><a href="#1-限幅滤波法（程序判断滤波法）" class="headerlink" title="1.限幅滤波法（程序判断滤波法）"></a>1.限幅滤波法（程序判断滤波法）</h2><p>方法：确定两次采样允许的最大偏差值，如果本次值与上次值之差&lt;&#x3D;A,则本次有效，反之&gt;A,则本次值无效，放弃本次值，上次代替本次值。</p><p>优点：克服偶然误差造成的干扰</p><p>缺点：无法抑制周期性干扰，平滑度差</p><p>核心内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A 10</span></span><br><span class="line"><span class="type">char</span> value;</span><br><span class="line"><span class="type">char</span> <span class="title function_">filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> new_value;</span><br><span class="line">new_value = get_ad();</span><br><span class="line"><span class="keyword">if</span> ( ( new_value - value &gt; A ) || ( value - new_value &gt; A )</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A 4</span></span><br><span class="line"><span class="type">float</span> data_number[] = &#123;<span class="number">1.2</span> , <span class="number">1.3</span>, <span class="number">3.1</span>, <span class="number">2.1</span>, <span class="number">32</span>, <span class="number">2.4</span>, <span class="number">2.3</span>, <span class="number">4.1</span>&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">input</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">filter</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> sum[<span class="number">7</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">   sum[i] = filter();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%f\r\n&quot;</span>, sum[i]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">input</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> data1;</span><br><span class="line"></span><br><span class="line">j++;</span><br><span class="line">data1 = data_number[j];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> data1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">filter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> new_value;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">value = data_number[<span class="number">0</span>];    </span><br><span class="line">n = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">value = new_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_value = input();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n=%f v=%f\r\n&quot;</span>,new_value, value);</span><br><span class="line"><span class="keyword">if</span>((new_value-value &gt; A))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> new_value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-中位值滤波法"><a href="#2-中位值滤波法" class="headerlink" title="2.中位值滤波法"></a>2.中位值滤波法</h2><p>方法：连续采样 N 次（ N 取奇数）把 N 次采样值按大小排列取中间值为本次有效值。<br>优点：能有效克服因偶然因素引起的波动干扰，对温度、液位的变化缓慢的被测参数有良好的滤波效果。<br>缺点：对流量、速度等快速变化的参数不宜 。</p><p>一般处理椒盐噪声（脉冲噪声），噪声来自于ADC采样，传感器等。</p><p>核心：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 11</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> value_buf[N];</span><br><span class="line"><span class="type">char</span> count,i,j,temp;</span><br><span class="line"><span class="keyword">for</span> ( count = <span class="number">0</span>;count &lt; N; count++） </span><br><span class="line">    &#123;</span><br><span class="line">value_buf[count] = get_ad();</span><br><span class="line">delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N<span class="number">-1</span>;j++) <span class="comment">//冒泡法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>-j;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( value_buf[i]&gt;value_buf[i+<span class="number">1</span>] )</span><br><span class="line">&#123;</span><br><span class="line">temp = value_buf[i];</span><br><span class="line">value_buf [i]= value_buf[i+<span class="number">1</span>];</span><br><span class="line">value_buf[i+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value_buf[(N<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="type">int</span> num[N] = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">filter</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">input</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> med;</span><br><span class="line">med = filter();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;med = %d&quot;</span>, med);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">input</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> j = <span class="number">0</span> ;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">data = num[j];</span><br><span class="line">j++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">filter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> value_buf[N];</span><br><span class="line"><span class="type">int</span> count, i, j, temp;</span><br><span class="line">temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(count = <span class="number">0</span>; count &lt; N; count++)</span><br><span class="line">&#123;</span><br><span class="line">value_buf[count] = input();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N<span class="number">-1</span> ; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N<span class="number">-1</span>-j; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(value_buf[i]&gt;value_buf[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp = value_buf[i];</span><br><span class="line">value_buf[i] = value_buf[i+<span class="number">1</span>];</span><br><span class="line">value_buf[i+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value_buf[(N<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把滤波区间的数据从小到大进行排序，然后取中值，（如果是奇数个数据，那么中值就只有一个了，如果偶数个数据，中值有两个，可以对两个数据再求平均,</p><p><strong>是把要处理的数据用中值代替，不是全部放成中值。</strong></p><h2 id="3-算术平均滤波"><a href="#3-算术平均滤波" class="headerlink" title="3.算术平均滤波"></a>3.算术平均滤波</h2><p>方法：连续取 N 个采样值进行算术平均运算，N 值较大时：信号平滑度较高，但灵敏度较低N 值较小时：信号平滑度较低，但灵敏度较高，N 值的选取：一般流量， N&#x3D;12；压力： N&#x3D;4。<br>优点：<br>适用于对一般具有随机干扰的信号进行滤波，这样信号的特点是有一个平均值，信号在某一数值范围附近上下波动。<br>缺点：<br>对于测量速度较慢或要求数据计算速度较快的实时控制不适用，比较浪费 RAM 。</p><p>一般处理高斯噪声，噪声来源于热产生，是随机噪声，服从高斯分布。</p><p>核心：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 12</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( count=<span class="number">0</span>;count&lt;N;count++)</span><br><span class="line">&#123;</span><br><span class="line">sum + = get_ad();</span><br><span class="line">delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">char</span>)(sum/N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是缺点明显，但是u低于偶然异常，对于某次的采样明显偏大，经过平均计算后导致最终值存在较大偏差，针对这种极大值或者极小值，可以在算数平均前进行剔除。</p><p>改进的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">filter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SAMPLE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vBat[i] &lt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = vBat[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vBat[i] &lt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = vBat[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += vBat[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum - min - max;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum/SAMPL_NAM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、递推平均滤波法（又称滑动平均滤波法）"><a href="#4、递推平均滤波法（又称滑动平均滤波法）" class="headerlink" title="4、递推平均滤波法（又称滑动平均滤波法）"></a>4、递推平均滤波法（又称滑动平均滤波法）</h2><p>方法：<br>把连续取 N 个采样值看成一个队列,队列的长度固定为 N,每次采样到一个新数据放入队尾,并扔掉原来队首的一次数据.(先进先出原则)<br>把队列中的 N 个数据进行算术平均运算,就可获得新的滤波结果,N 值的选取：流量， N&#x3D;12；压力： N&#x3D;4；液面， N&#x3D;4<del>12；温度， N&#x3D;1</del>4<br>优点：<br>对周期性干扰有良好的抑制作用，平滑度高,适用于高频振荡的系统<br>缺点：<br>灵敏度低,对偶然出现的脉冲性干扰的抑制作用较差,不易消除由于脉冲干扰所引起的采样值偏差,不适用于脉冲干扰比较严重的场合,<br>比较浪费 RAM </p><p>核心：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 12</span></span><br><span class="line"><span class="type">char</span> value_buf[N];</span><br><span class="line"><span class="type">char</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> count;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">value_buf[i++] = get_ad();</span><br><span class="line"><span class="keyword">if</span> ( i == N ) i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( count=<span class="number">0</span>;count&lt;N;count++) sum = value_buf[count];</span><br><span class="line"><span class="keyword">return</span> (<span class="type">char</span>)(sum/N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C知识点</title>
      <link href="/2023/06/09/2023-06-09-%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/06/09/2023-06-09-%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h4 id="一-用预处理指令-define-声明一个常数，用以表明1年中有多少秒（忽略闰年问题）"><a href="#一-用预处理指令-define-声明一个常数，用以表明1年中有多少秒（忽略闰年问题）" class="headerlink" title="一. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）"></a>一. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a_year (365*24*60*60)UL</span></span><br><span class="line"><span class="comment">//UL无符号整形</span></span><br></pre></td></tr></table></figure><h4 id="二-写一个”标准”宏MIN-，这个宏输入两个参数并返回较小的一个"><a href="#二-写一个”标准”宏MIN-，这个宏输入两个参数并返回较小的一个" class="headerlink" title="二. 写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个"></a>二. 写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>MIN( a, b)((a&lt;=b)?(a):(b))</span></span><br></pre></td></tr></table></figure><h4 id="三-嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？"><a href="#三-嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？" class="headerlink" title="三. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？"></a>三. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;&#125;</span><br><span class="line">loop:...</span><br><span class="line"><span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure><h4 id="四-用变量a给出下面的定义"><a href="#四-用变量a给出下面的定义" class="headerlink" title="四. 用变量a给出下面的定义"></a>四. 用变量a给出下面的定义</h4><ul><li>a) 一个整型数（An integer）</li><li>b)一个指向整型数的指针（ A pointer to an integer）</li><li>c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）</li><li>d)一个有10个整型数的数组（ An array of 10 integers）</li><li>e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）</li><li>f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）</li><li>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）</li><li>h)  一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数 （ An array of ten pointers to functions that take an integer argument and return an integer ）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> **p;</span><br><span class="line"><span class="type">int</span> sum[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *sum[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*sum)[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *<span class="title function_">prie</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line"><span class="title function_">int</span> <span class="params">(*prie[<span class="number">10</span>](<span class="type">int</span>))</span></span><br></pre></td></tr></table></figure><h4 id="五-关键字static的作用是什么？"><a href="#五-关键字static的作用是什么？" class="headerlink" title="五. 关键字static的作用是什么？"></a>五. 关键字static的作用是什么？</h4><p>首先，是static修饰了变量，延长了变量生命周期，直到程序运行结束后才释放。</p><p>之后是static修饰一个函数则这个函数<strong>只能在本文件中调用，不能被其他文件调用</strong>，Static修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为0；</p><p>static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。</p><h4 id="六-关键字const有什么含意？"><a href="#六-关键字const有什么含意？" class="headerlink" title="六. 关键字const有什么含意？"></a>六. 关键字const有什么含意？</h4><p>要一个变量前用const来修饰，就意味着该变量里的数据只能被访问，而不能被修改，也就是意味着const“只读”（readonly）。</p><h4 id="七-关键字volatile有什么含意？并给出三个不同的例子"><a href="#七-关键字volatile有什么含意？并给出三个不同的例子" class="headerlink" title="七. 关键字volatile有什么含意？并给出三个不同的例子"></a>七. 关键字volatile有什么含意？并给出三个不同的例子</h4><p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p><ul><li>并行设备的硬件寄存器（如：状态寄存器）</li><li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</li><li>多线程应用中被几个任务共享的变量</li></ul><h4 id="八-嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit-3，第二个清除a-的bit-3。在以上两个操作中，要保持其它位不变。"><a href="#八-嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit-3，第二个清除a-的bit-3。在以上两个操作中，要保持其它位不变。" class="headerlink" title="八. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。"></a>八. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    </span><br><span class="line">    a |= (a &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    a &amp;= ~( a &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="九-下面的代码输出是什么，为什么？"><a href="#九-下面的代码输出是什么，为什么？" class="headerlink" title="九. 下面的代码输出是什么，为什么？"></a>九. 下面的代码输出是什么，为什么？</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">-20</span>;</span><br><span class="line">    (a+b &gt; <span class="number">6</span>) ? <span class="built_in">puts</span>(<span class="string">&quot;&gt;6&quot;</span>) : (<span class="string">&quot;&lt;=6&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管如何，这无符号整型问题的答案是输出是 “&gt;6”。原因 是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。</p><p>因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研电赛</title>
      <link href="/2023/05/31/2023-4-22-%E7%A0%94%E7%94%B5%E8%B5%9B/"/>
      <url>/2023/05/31/2023-4-22-%E7%A0%94%E7%94%B5%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：超声接近感知系统"><a href="#题目：超声接近感知系统" class="headerlink" title="题目：超声接近感知系统"></a>题目：超声接近感知系统</h2><p>（1）赛题主要考察接近感知系统的实现，可使用指示灯的亮灭来表征接近态和远离态</p><p>（2）以超声波技术为基础实现接近感知。可辅助使用加速度、陀螺仪或等其他传感器，来提高准确率（如提取接听电话动作中的距离、姿态、运动轨迹…等信息的变化）。</p><h4 id="设计stm32pcb"><a href="#设计stm32pcb" class="headerlink" title="设计stm32pcb"></a>设计stm32pcb</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-31%20141653.png"></p><h4 id="设计姿态传感器pcb"><a href="#设计姿态传感器pcb" class="headerlink" title="设计姿态传感器pcb"></a>设计姿态传感器pcb</h4><p>由磁力计IST8310和陀螺仪BMI088组成。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-21%20214647.png"></p><p>由于先设计的硬件，并没确定使用的IO口，所以分为了两个板子，为了符合题目要求，pcb上打上通孔，便于使用螺丝连接。</p><p>使用MCU是stm32f407VGT6的型号，在使用usart进行串口通信的时候发现会出现，乱码的问题，最后发现问题的原因出在了，晶振的频率源头上，</p><p>#define HSE_VALUE 25000000 把25改为8.</p><p>使用两个超声波模块，使用spi和iic通信来读取姿态传感器的数据。</p><p>关于SPI的通信使用为了节省CPU的占有率，使用了串口DMA的通信方式，DMA传输将数据从一个地址空间复制到另一个地址空间， 提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。</p><p>关于这种pcb的贴片焊接，是建议用<strong>开一个钢网，之后刷锡膏，放器件，回炉加热</strong>就可以了。对于芯片来讲还是要开钢网的，由于此次没开钢网，导致有个别的引脚焊接在一起。</p><p>关于此次的pcb还有一个问题就是外部晶振坏了，所以导致定时器工作不稳定，数据出问题，所以当确定程序无误时候，查一下硬件，毕竟是自己做的，可能是出现了问题，所以时钟源使用的是RC的内部震荡。</p><p>之后超声波的使用是使用定时器来进行输入捕获，来实现高电平的脉宽时间读取，之后才能计算超声波的距离。</p><p>为了控制陀螺仪温度，控制零飘，所以使用了pid来控制温度。复习了一下pid的知识点</p><h4 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-31%20142627.png"></p><h4 id="姿态解算任务"><a href="#姿态解算任务" class="headerlink" title="姿态解算任务"></a>姿态解算任务</h4><p>姿态是反应物体相对于参考坐标系的指向。常使用欧拉角代表物体的姿态，描述物体姿态需要三个角度，分别是 yaw(偏航角), pitch(俯仰角),roll(横滚角)。Yaw(偏航角)是绕 z 轴的角度，pitch 是绕 y 轴的角度，roll 是绕 x 轴的角度。</p><p>mahony 算法是常见的姿态融合算法，将加速度计，磁力计，陀螺仪共九轴数据，融合解算出载体四元数</p><p><a href="https://x-io.co.uk/open-source-imu-and-ahrs-algorithms/%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E3%80%82%E6%94%BE%E5%88%B0%E5%B7%A5%E7%A8%8B%E9%87%8C%E8%BF%9B%E8%A1%8C%E7%A7%BB%E6%A4%8D%E3%80%82">https://x-io.co.uk/open-source-imu-and-ahrs-algorithms/下载网址。放到工程里进行移植。</a></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E7%BD%91%E9%A1%B5%E6%8D%95%E8%8E%B7_31-5-2023_143843_.jpeg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux异步通知</title>
      <link href="/2023/05/18/2023-5-18-linux%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/"/>
      <url>/2023/05/18/2023-5-18-linux%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h2><p><strong>异步通知：一旦设备准备就绪，则主动通知应用程序，这样引用程序根本不需要查询设备状态</strong>，由此引入了信号的概念，信号是在软件层次上的对中断机制的一种模拟，驱动可以通过主动向应用程序发送信号的方式来报告自己可以访问了，应用程序获取到信号以后就可以从驱动设备中读取或者写入数据了。整个过程就相当于应用程序收到了驱动发送过来了的一个中断，然后应用程序去响应这个中断，。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/eatfrqag.png"></p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>Linux中用异步信号来实现进程通信（IPC）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34</span> <span class="meta">#<span class="keyword">define</span> SIGHUP 1 <span class="comment">/* 终端挂起或控制进程终止 */</span></span></span><br><span class="line"><span class="number">35</span> <span class="meta">#<span class="keyword">define</span> SIGINT 2 <span class="comment">/* 终端中断(Ctrl+C 组合键) */</span></span></span><br><span class="line"><span class="number">36</span> <span class="meta">#<span class="keyword">define</span> SIGQUIT 3 <span class="comment">/* 终端退出(Ctrl+\组合键) */</span></span></span><br><span class="line"><span class="number">37</span> <span class="meta">#<span class="keyword">define</span> SIGILL 4 <span class="comment">/* 非法指令 */</span></span></span><br><span class="line"><span class="number">38</span> <span class="meta">#<span class="keyword">define</span> SIGTRAP 5 <span class="comment">/* debug 使用，有断点指令产生 */</span></span></span><br><span class="line"><span class="number">39</span> <span class="meta">#<span class="keyword">define</span> SIGABRT 6 <span class="comment">/* 由 abort(3)发出的退出指令 */</span></span></span><br><span class="line"><span class="number">40</span> <span class="meta">#<span class="keyword">define</span> SIGIOT 6 <span class="comment">/* IOT 指令 */</span></span></span><br><span class="line"><span class="number">41</span> <span class="meta">#<span class="keyword">define</span> SIGBUS 7 <span class="comment">/* 总线错误 */</span></span></span><br><span class="line"><span class="number">42</span> <span class="meta">#<span class="keyword">define</span> SIGFPE 8 <span class="comment">/* 浮点运算错误 */</span></span></span><br><span class="line"><span class="number">43</span> <span class="meta">#<span class="keyword">define</span> SIGKILL 9 <span class="comment">/* 杀死、终止进程 */</span></span></span><br><span class="line"><span class="number">44</span> <span class="meta">#<span class="keyword">define</span> SIGUSR1 10 <span class="comment">/* 用户自定义信号 1 */</span></span></span><br><span class="line"><span class="number">45</span> <span class="meta">#<span class="keyword">define</span> SIGSEGV 11 <span class="comment">/* 段违例(无效的内存段) */</span></span></span><br><span class="line"><span class="number">46</span> <span class="meta">#<span class="keyword">define</span> SIGUSR2 12 <span class="comment">/* 用户自定义信号 2 */</span></span></span><br><span class="line"><span class="number">47</span> <span class="meta">#<span class="keyword">define</span> SIGPIPE 13 <span class="comment">/* 向非读管道写入数据 */</span></span></span><br><span class="line"><span class="number">48</span> <span class="meta">#<span class="keyword">define</span> SIGALRM 14 <span class="comment">/* 闹钟 */</span></span></span><br><span class="line"><span class="number">49</span> <span class="meta">#<span class="keyword">define</span> SIGTERM 15 <span class="comment">/* 软件终止 */</span></span></span><br><span class="line"><span class="number">50</span> <span class="meta">#<span class="keyword">define</span> SIGSTKFLT 16 <span class="comment">/* 栈异常 */</span></span></span><br><span class="line"><span class="number">51</span> <span class="meta">#<span class="keyword">define</span> SIGCHLD 17 <span class="comment">/* 子进程结束 */</span></span></span><br><span class="line"><span class="number">52</span> <span class="meta">#<span class="keyword">define</span> SIGCONT 18 <span class="comment">/* 进程继续 */</span></span></span><br><span class="line"><span class="number">53</span> <span class="meta">#<span class="keyword">define</span> SIGSTOP 19 <span class="comment">/* 停止进程的执行，只是暂停 */</span></span></span><br><span class="line"><span class="number">54</span> <span class="meta">#<span class="keyword">define</span> SIGTSTP 20 <span class="comment">/* 停止进程的运行(Ctrl+Z 组合键) */</span></span></span><br><span class="line"><span class="number">55</span> <span class="meta">#<span class="keyword">define</span> SIGTTIN 21 <span class="comment">/* 后台进程需要从终端读取数据 */</span></span></span><br><span class="line"><span class="number">56</span> <span class="meta">#<span class="keyword">define</span> SIGTTOU 22 <span class="comment">/* 后台进程需要向终端写数据 */</span></span></span><br><span class="line"><span class="number">57</span> <span class="meta">#<span class="keyword">define</span> SIGURG 23 <span class="comment">/* 有&quot;紧急&quot;数据 */</span></span></span><br><span class="line"><span class="number">58</span> <span class="meta">#<span class="keyword">define</span> SIGXCPU 24 <span class="comment">/* 超过 CPU 资源限制 */</span></span></span><br><span class="line"><span class="number">59</span> <span class="meta">#<span class="keyword">define</span> SIGXFSZ 25 <span class="comment">/* 文件大小超额 */</span></span></span><br><span class="line"><span class="number">60</span> <span class="meta">#<span class="keyword">define</span> SIGVTALRM 26 <span class="comment">/* 虚拟时钟信号 */</span></span></span><br><span class="line"><span class="number">61</span> <span class="meta">#<span class="keyword">define</span> SIGPROF 27 <span class="comment">/* 时钟信号描述 */</span></span></span><br><span class="line"><span class="number">62</span> <span class="meta">#<span class="keyword">define</span> SIGWINCH 28 <span class="comment">/* 窗口大小改变 */</span></span></span><br><span class="line"><span class="number">63</span> <span class="meta">#<span class="keyword">define</span> SIGIO 29 <span class="comment">/* 可以进行输入/输出操作 */</span></span></span><br><span class="line"><span class="number">64</span> <span class="meta">#<span class="keyword">define</span> SIGPOLL SIGIO</span></span><br><span class="line"><span class="number">65</span> <span class="comment">/* #define SIGLOS 29 */</span></span><br><span class="line"><span class="number">66</span> <span class="meta">#<span class="keyword">define</span> SIGPWR 30 <span class="comment">/* 断点重启 */</span></span></span><br><span class="line"><span class="number">67</span> <span class="meta">#<span class="keyword">define</span> SIGSYS 31 <span class="comment">/* 非法的系统调用 */</span></span></span><br><span class="line"><span class="number">68</span> <span class="meta">#<span class="keyword">define</span> SIGUNUSED 31 <span class="comment">/* 未使用信号 */</span></span></span><br></pre></td></tr></table></figure><h4 id="信号的接收"><a href="#信号的接收" class="headerlink" title="信号的接收"></a>信号的接收</h4><p><strong>在应用程序中使用 signal 函数来设置指定信号的处理函数</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span><br><span class="line"><span class="comment">/*第一个参数处理的信号，第二个参数指定指针对前面信号值的处理函数，调用成功返回最后一次为信号signum绑定handler值，失败返回SIG_ERR*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span><br></pre></td></tr></table></figure><p><strong>为文件描述符的设置属主</strong></p><p>通过 fcntl() 的 F_SETOWN 操作来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(fd, F_SETOWN, pid)</span><br></pre></td></tr></table></figure><p>属主是当文件描述符上可执行 I&#x2F;O 时，会接收到通知信号的进程或进程组。</p><p>pid 为正整数时，代表了进程 ID 号。</p><p>pid 为负整数时，它的绝对值就代表了进程组 ID 号。</p><p><strong><u>使用信号异步通知的应用程序</u></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 100</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_handler</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data[MAX_LEN];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    len = read(STDIN_FILENO, &amp;data, MAX_LEN)；</span><br><span class="line">    data[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input available :%s\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> oflags;</span><br><span class="line">    signal(SIGIO, input_handler);</span><br><span class="line">    fcntl(STDIN_FILENO, F_SETOWN, getpid());<span class="comment">//fcntl函数对描述符提供控制</span></span><br><span class="line">    oflags = fcntl(STDIN_FILENO,F_GETFL);</span><br><span class="line">    fcntl(STDIN_FILENO, F_SETFL, oflags|FASYNC);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//为了保证进程不终止。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看到，为了在用户空间中能处理一个设备释放的信号，必须完成三项工作：</p><ol><li>通过F_SETOWN IO控制命令设置设备文件的拥有者为本进程，这样从设备驱动发出的信号才能被本进程接收到；</li><li>通过F_SETFL IO控制命令设置设备文件支持FASYNC，即异步通知；</li><li>通过signal函数连结信号和信号处理函数。</li></ol><h4 id="信号的释放"><a href="#信号的释放" class="headerlink" title="信号的释放"></a>信号的释放</h4><p>在设备驱动和应用程序的异步通知交互中，仅仅在应用程序端捕获信号是不够的，因为信号没有的源头在设备驱动端，因此，应该在合适的时机让设备驱动释放信号， 在设备驱动程序中加信号释放的代码。</p><p>为支持异步通知机制，驱动程序中涉及以下三项工作。</p><p>支持F_SETOWN命令。能在这个控制命令处理中设置filp-&gt;f_owner为对应进程ID。不过此项工作已由内核完成，设备驱动无需处理。</p><p>支持S_SETFL命令处理，每当FASYNC标志改变时，驱动程序中的fasync()函数将执行。</p><p>在设备可获得时候，调用kill_fasync()函数激发相应的信号</p><p>异步通知中用户空间和设备驱动之间的交互：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/Screenshot_20230518_204435.jpg"></p><p>设备驱动中要用到一项数据结构和两个函数：</p><p>在驱动程序中定义一个 fasync_struct 结构体指针变量 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> fa_lock;</span><br><span class="line"><span class="type">int</span> magic;</span><br><span class="line"><span class="type">int</span> fa_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fa_next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fa_file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">fa_rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一般将 fasync_struct 结构体指针变量定义到设备结构体中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span> <span class="comment">/* 异步相关结构体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要使用异步通知，需要在设备驱动中实现 file_operations 操作集中的 fasync 函数 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> on)</span><br></pre></td></tr></table></figure><p>fasync 函数里面一般通过调用 fasync_helper 函数来初始化前面定义的 fasync_struct 结构体指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fasync_helper</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file * filp, <span class="type">int</span> on, <span class="keyword">struct</span> fasync_struct **fapp)</span></span><br></pre></td></tr></table></figure><p>  <strong>当应用程序通过“fcntl(fd, F_SETFL, flags | FASYNC)”改变fasync 标记的时候，驱动程序 file_operations 操作集中的 fasync 函数就会执行。</strong></p><p>驱动中fasync参考实例： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span>&#123;</span></span><br><span class="line">  .......  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">dev</span> =</span> (xxx_dev *)filp -&gt; privata_data;</span><br><span class="line">    <span class="keyword">if</span>(fasync_helper(fd, filp, on ,&amp;dev-&gt;async_queue) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_release</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> xxx_fasync( <span class="number">-1</span>, filp, <span class="number">0</span>);<span class="comment">//调用函数完成fasync_struct 的释放工作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_ops</span> =</span> &#123;</span><br><span class="line">  ....</span><br><span class="line">  .fasync = xxx_fasync,</span><br><span class="line">  .release = xxx_release,</span><br><span class="line">  ....  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>kill_fasync 函数</strong> </p><p>当设备可以访问的时候，驱动程序需要向应用程序发出信号，相当于产生“中断”。 kill_fasync函数负责发送指定的信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kill_fasync</span><span class="params">(<span class="keyword">struct</span> fasync_struct **fp, <span class="type">int</span> sig, <span class="type">int</span> band)</span></span><br></pre></td></tr></table></figure><p>fp：要操作的 fasync_struct。<br>sig： 要发送的信号。<br>band： 可读时设置为 POLL_IN，可写时设置为 POLL_OUT。<br>返回值： 无。 </p><h4 id="应用程序对异步通知的处理"><a href="#应用程序对异步通知的处理" class="headerlink" title="应用程序对异步通知的处理"></a>应用程序对异步通知的处理</h4><p>应用程序对异步通知的处理包括以下三步：</p><ol><li>注册信号处理函数（使用signal函数）</li><li>将本应用程序的进程号告诉给内核（使用 fcntl(fd, F_SETOWN, getpid())将本应用程序的进程号告诉给内核 ）</li><li>开启异步通知</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flags = fcntl(fd, F_GETFL); <span class="comment">/* 获取当前的进程状态 */</span></span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC); <span class="comment">/* 开启当前进程异步通知功能 */</span></span><br></pre></td></tr></table></figure><h3 id="备注fcntl函数用法"><a href="#备注fcntl函数用法" class="headerlink" title="备注fcntl函数用法"></a>备注fcntl函数用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span>;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd ,<span class="keyword">struct</span> flock* lock)</span>;  </span><br></pre></td></tr></table></figure><p>cmd的值不同有对应功能如下：</p><table><thead><tr><th>命令名</th><th>描述</th></tr></thead><tbody><tr><td>F_DUPFD</td><td>复制文件描述符</td></tr><tr><td>F_GETFD</td><td>获取文件描述符标志</td></tr><tr><td>F_SETFD</td><td>设置文件描述符标志</td></tr><tr><td>F_GETFL</td><td>获取文件状态标志</td></tr><tr><td>F_SETFL</td><td>设置文件状态标志</td></tr><tr><td>F_GETLK</td><td>获取文件锁</td></tr><tr><td>F_SETLK</td><td>设置文件锁</td></tr><tr><td>F_SETOWN</td><td>设置当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td></tr><tr><td>F_SETLKW</td><td>类似F_SETLK,但等待返回</td></tr><tr><td>F_GETOWN</td><td>获取当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td></tr></tbody></table><h4 id="应用程序对异步通知的处理-1"><a href="#应用程序对异步通知的处理-1" class="headerlink" title="应用程序对异步通知的处理"></a>应用程序对异步通知的处理</h4><p><strong>1、注册信号处理函数</strong><br>应用程序根据驱动程序所使用的信号来设置信号的处理函数，应用程序使用 signal 函数来设置信号的处理函数。<br><strong>2、将本应用程序的进程号告诉给内核</strong><br>使用 fcntl(fd, F_SETOWN, getpid())将本应用程序的进程号告诉给内核。<br><strong>3、开启异步通知</strong><br>使用如下两行程序开启异步通知：<br>flags &#x3D; fcntl(fd, F_GETFL); &#x2F;* 获取当前的进程状态 <em>&#x2F;<br>fcntl(fd, F_SETFL, flags | FASYNC); &#x2F;</em> 开启当前进程异步通知功能 *&#x2F;<br>重点就是通过 fcntl 函数设置进程状态为 FASYNC，经过这一步，驱动程序中的 fasync 函数就会执行 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux阻塞与非阻塞</title>
      <link href="/2023/05/10/2023-5-10-linux%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
      <url>/2023/05/10/2023-5-10-linux%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞和非阻塞IO"><a href="#阻塞和非阻塞IO" class="headerlink" title="阻塞和非阻塞IO"></a>阻塞和非阻塞IO</h2><p>阻塞式</p><p>当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-10%20115842.png"></p><p>非阻塞式</p><p>对于非阻塞 IO，应用程序对应的线程不会挂<br>起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-10%20115857.png"></p><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><h4 id="等待队列头"><a href="#等待队列头" class="headerlink" title="等待队列头"></a>等待队列头</h4><p>阻塞式的好处就是，当无法获取资源的时候进程进入休眠状态，让出cpu来干别的事情，可以操作的时候再进行唤醒（<strong>一般在中断里唤醒</strong>）。</p><p>Linux内核提供了等待队列来实现阻塞进程的唤醒工作，首先要创建并初始化一个等待队列头，等待队列头使用结构体wait_queue_head_t表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span>&#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">task_list</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br><span class="line"><span class="comment">//使用init_waitqueue_head初始化等待队列头</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_waitqueue_head</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span><span class="comment">//q为初始化的等待队列头</span></span><br></pre></td></tr></table></figure><h4 id="等待队列项"><a href="#等待队列项" class="headerlink" title="等待队列项"></a>等待队列项</h4><p>每个访问设备的进程都是一个队列项，当设备不可用的时候就要将这些进程对应的等待队列项添加到等待队列里面。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>flags;</span><br><span class="line">    <span class="type">void</span>*private;</span><br><span class="line">    <span class="type">wait_queue_func_t</span>func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">task_list</span>;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br><span class="line"><span class="comment">//使用宏DECLARE_WAITQUEUE定义初始化一个等待队列项</span></span><br><span class="line">DECLARE_WAITQUEUE(name, tsk)<span class="comment">//name等待队列项的名字，tsk表示等待队列项属于哪个进程</span></span><br></pre></td></tr></table></figure><h4 id="添加或移除等待队列头"><a href="#添加或移除等待队列头" class="headerlink" title="添加或移除等待队列头"></a>添加或移除等待队列头</h4><p>当设备不可访问的时候就需要将进程对应的等待队列项添加到前面创建的等待队列头中，只有添加到等待队列头中以后进程才能进入休眠态。当设备可以访问以后再将进程对应的等待队列项从等待队列头中移除即可 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span>*wait)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span> *wait)</span></span><br></pre></td></tr></table></figure><h4 id="等待唤醒"><a href="#等待唤醒" class="headerlink" title="等待唤醒"></a>等待唤醒</h4><p>当设备可以使用的时候就要唤醒进入休眠态的进程 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up_interruptible</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span></span><br></pre></td></tr></table></figure><p>两个函数会将这个等待队列头中的所有进程都唤醒。wake_up 函数可以唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 状态的进程，而 wake_up_interruptible 函数只能唤醒处于 TASK_INTERRUPTIBLE 状态的进程。 </p><h4 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h4><p>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程 </p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>wait_event(wq, condition)</td><td>等待以 wq 为等待队列头的等待队列被唤醒，前提是 condition 条件必须满足(为真)，否则一直阻塞 此 函 数 会 将 进 程 设 置 为TASK_UNINTERRUPTIBLE 状态</td></tr><tr><td>wait_event_timeout(wq,condition,timeout)</td><td>功能和 wait_event 类似，但是此函数可以添加超时时间，以 jiffies 为单位。此函数有返回值，如果返回 0 的话表示超时时间到，而且 condition为假。为 1 的话表示 condition 为真，也就是条件满足了。</td></tr><tr><td>wait_event_interruptible(wq, condition)</td><td>与 wait_event 函数类似，但是此函数将进程设置为 TASK_INTERRUPTIBLE，就是可以被信号打断。</td></tr><tr><td>wait_event_interruptible_timeout(wq,condition, timeout)</td><td>与 wait_event_timeout 函数类似，此函数也将进程设置为 TASK_INTERRUPTIBLE，可以被信号打断</td></tr></tbody></table><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-19%20184010.png"></p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>如果用户应用程序以非阻塞的方式访问设备，设备驱动程序就要提供非阻塞的处理方式，也就是轮询。 poll、 epoll 和 select 可以用于处理轮询，应用程序通过 select、 epoll 或 poll 函数来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。 </p><p><strong>select函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">           fd_set *readfds,</span></span><br><span class="line"><span class="params">           fd_set *writefds,</span></span><br><span class="line"><span class="params">           fd_set *exceptfds,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> timeval *timeout)</span></span><br></pre></td></tr></table></figure><p>nfds:所要监视的这三类文件描述集合中， 最大文件描述符加 1。 </p><p>readfds、 writefds 和 exceptfds ：readfds 用于监视指定描述符集的读变化，也就是监视这些文件是否可以读取，只要这些集合里面有一个文件可以读取那么 seclect 就会返回一个大于 0 的值表示文件可以读取。如果没有文件可以读取，那么就会根据 timeout 参数来判断是否超时。可以将 readfs设置为 NULL，表示不关心任何文件的读变化。 </p><p>exceptfds 用于监视这些文件的异常 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span><span class="comment">//所有位清零</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span><span class="comment">//将某个位置1，也就是向 fd_set 添加一个文件描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span><span class="comment">//将某个位清0，也就是将一个文件描述符从 fd_set 中删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span><span class="comment">//用于测试一个文件是否属于某个集合</span></span><br></pre></td></tr></table></figure><p>timeout:超时时间，调用select等待某些文件描述符可以设置超时时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">timeval</span>&#123;</span></span><br><span class="line">   <span class="type">long</span>tv_sec ;<span class="comment">//秒</span></span><br><span class="line">   <span class="type">long</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>返回值： 0，表示的话就表示超时发生，但是没有任何文件描述符可以进行操作； -1，发生错误；其他值，可以进行操作的文件描述符个数。 </p><h4 id="select系统阻塞状态判断"><a href="#select系统阻塞状态判断" class="headerlink" title="select系统阻塞状态判断"></a>select系统阻塞状态判断</h4><p>1、timeout传入NULL，则select为阻塞状态，即需要等到监视文件描述符集合中某个文件描述符发生变化才会返回；相当于无穷大的时间，一直等<br>2、timeout置为0秒、0微秒，则select为非阻塞状态，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；<br>3、timeout置为大于0的值，即等待的超时时间，select在timeout时间内阻塞，超时时间之内有事件到来就返回，否则在超时后不管怎样一定返回，返回值同上述。 </p><p><u>使用 select 函数对某个设备驱动文件进行读非阻塞访问的操作</u> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret,fd;</span><br><span class="line">    fd_set readfd;</span><br><span class="line">    </span><br><span class="line">    fd = open(<span class="string">&quot;dev_xx&quot;</span>, O_RDWR|)_NONBLOCK);<span class="comment">//非阻塞打开</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file\r\n&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">FD_ZERO(readfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Poll函数"><a href="#Poll函数" class="headerlink" title="Poll函数"></a>Poll函数</h4><p>在单个线程中，select 函数能够监视的文件描述符数量有最大的限制，一般为 1024，但是 poll 函数没有最大文件描述符限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds,</span></span><br><span class="line"><span class="params"><span class="type">nfds_t</span> nfds,</span></span><br><span class="line"><span class="params"><span class="type">int</span> timeout)</span></span><br></pre></td></tr></table></figure><p>fds： 要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的， pollfd 结构体如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="type">int</span> fd; <span class="comment">/* 文件描述符 */</span></span><br><span class="line"><span class="type">short</span> events; <span class="comment">/* 请求的事件 */</span></span><br><span class="line"><span class="type">short</span> revents; <span class="comment">/* 返回的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>fd 是要监视的文件描述符，如果 fd 无效的话那么 events 监视事件也就无效，并且 revents返回 0。 events 是要监视的事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可监视事件</span><br><span class="line">POLLIN 有数据可以读取。</span><br><span class="line">POLLPRI 有紧急的数据需要读取。</span><br><span class="line">POLLOUT 可以写数据。</span><br><span class="line">POLLERR 指定的文件描述符发生错误。</span><br><span class="line">POLLHUP 指定的文件描述符挂起。</span><br><span class="line">POLLNVAL 无效的请求。</span><br><span class="line">POLLRDNORM 等同于 POLLIN</span><br></pre></td></tr></table></figure><p>revents 是返回参数，也就是返回的事件， 由 Linux 内核设置具体的返回事件 </p><p>nfds： poll 函数要监视的文件描述符数量。<br>timeout： 超时时间，单位为 ms。 </p><p>返回值：返回 revents 域中不为 0 的 pollfd 结构体个数，也就是发生事件或错误的文件描述符数量； 0，超时； -1，发生错误，并且设置 errno 为错误类型。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">int</span> fd; <span class="comment">/* 要监视的文件描述符 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>;</span></span><br><span class="line"></span><br><span class="line">fd = open(filename, O_RDWR | O_NONBLOCK); <span class="comment">/* 非阻塞式访问 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造结构体 */</span></span><br><span class="line">fds.fd = fd;</span><br><span class="line">fds.events = POLLIN; <span class="comment">/* 监视数据是否可以读取 */</span></span><br><span class="line">ret = poll(&amp;fds, <span class="number">1</span>, <span class="number">500</span>); <span class="comment">/* 轮询文件是否可操作，超时 500ms */</span></span><br><span class="line"><span class="keyword">if</span> (ret) &#123; <span class="comment">/* 数据有效 */</span></span><br><span class="line"> ......</span><br><span class="line"><span class="comment">/* 读取数据 */</span></span><br><span class="line"> ......</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123; <span class="comment">/* 超时 */</span></span><br><span class="line"> ......</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">/* 错误 */</span></span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h4><p>epoll 就是为处理大并发而准备的，一般常常在网络编程中使用 epoll 函数。应用程序需要先使用 epoll_create 函数创建一个 epoll 句柄 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure><p>size： 从 Linux2.6.8 开始此参数已经没有意义了，随便填写一个大于 0 的值就可以。<br>返回值： epoll 句柄，如果为-1 的话表示创建失败。 </p><p>epoll 句柄创建成功以后使用 epoll_ctl 函数向其中添加要监视的文件描述符以及监视的事件 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> op,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> epoll_event *event)</span></span><br></pre></td></tr></table></figure><p>epfd： 要操作的 epoll 句柄，也就是使用 epoll_create 函数创建的 epoll 句柄。<br>op： 表示要对 epfd(epoll 句柄)进行的操作，可以设置为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CTL_ADD 向 epfd 添加文件参数 fd 表示的描述符。</span><br><span class="line">EPOLL_CTL_MOD 修改参数 fd 的 event 事件。</span><br><span class="line">EPOLL_CTL_DEL 从 epfd 中删除 fd 描述符。</span><br></pre></td></tr></table></figure><p>fd：要监视的文件描述符。<br>event： 要监视的事件类型，为 epoll_event 结构体类型指针 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> events; <span class="comment">/* epoll 事件 */</span></span><br><span class="line"><span class="type">epoll_data_t</span> data; <span class="comment">/* 用户数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体 epoll_event 的 events 成员变量表示要监视的事件 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EPOLLIN 有数据可以读取。</span><br><span class="line">EPOLLOUT 可以写数据。</span><br><span class="line">EPOLLPRI 有紧急的数据需要读取。</span><br><span class="line">EPOLLERR 指定的文件描述符发生错误。</span><br><span class="line">EPOLLHUP 指定的文件描述符挂起。</span><br><span class="line">EPOLLET 设置 epoll 为边沿触发，默认触发模式为水平触发。</span><br><span class="line">EPOLLONESHOT 一次性的监视，当监视完成以后还需要再次监视某个 fd，那么就需要将</span><br><span class="line">fd 重新添加到 epoll 里面。</span><br></pre></td></tr></table></figure><p>上面这些事件可以进行“或”操作，也就是说可以设置监视多个事件。 </p><p>返回值： 0，成功； -1，失败，并且设置 errno 的值为相应的错误码。 </p><p>一切都设置好以后应用程序就可以通过 epoll_wait 函数来等待事件的发生，类似 select 函数。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd,</span><br><span class="line">   struct epoll_event *events,</span><br><span class="line">               int maxevents,</span><br><span class="line">               int timeout)</span><br></pre></td></tr></table></figure><p>epfd： 要等待的 epoll。 </p><p>events： 指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调<br>用者可以根据 events 判断发生了哪些事件。<br>maxevents： events 数组大小，必须大于 0。<br>timeout： 超时时间，单位为 ms。<br>返回值： 0，超时； -1，错误；其他值，准备就绪的文件描述符数量。 </p><h4 id="Linux-驱动下的-poll-操作函数"><a href="#Linux-驱动下的-poll-操作函数" class="headerlink" title="Linux 驱动下的 poll 操作函数"></a>Linux 驱动下的 poll 操作函数</h4><p>当应用程序调用 select 或 poll 函数来对驱动程序进行非阻塞访问的时候，驱动程序file_operations 操作集中的 poll 函数就会执行。所以驱动程序的编写者需要提供对应的 poll 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//poll函数原型</span></span><br><span class="line"><span class="type">unsigned</span><span class="title function_">int</span><span class="params">(*poll)</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> poll_table_struct *wait)</span></span><br><span class="line"><span class="comment">//filp要打开的设备文件</span></span><br><span class="line"><span class="comment">//wait结构体 poll_table_struct 类型指针， 由应用程序传递进来的。一般将此参数传递给poll_wait 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">poll_wait</span><span class="params">(<span class="keyword">struct</span> file * filp, <span class="type">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span><br><span class="line"> <span class="comment">//poll_wait 函数不会引起阻塞，只是将应用程序添加到 poll_table 中</span></span><br><span class="line"> <span class="comment">//参数 wait_address 是要添加到 poll_table 中的等待队列头，参数 p 就是 poll_table</span></span><br></pre></td></tr></table></figure><p>poll函数的返回值：向应用程序返回设备或者资源状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POLLIN 有数据可以读取。</span><br><span class="line">POLLPRI 有紧急的数据需要读取。</span><br><span class="line">POLLOUT 可以写数据。</span><br><span class="line">POLLERR 指定的文件描述符发生错误。</span><br><span class="line">POLLHUP 指定的文件描述符挂起。</span><br><span class="line">POLLNVAL 无效的请求。</span><br><span class="line">POLLRDNORM 等同于 POLLIN，普通数据可读</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中断</title>
      <link href="/2023/05/04/2023-5-4-linux%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/05/04/2023-5-4-linux%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="linux中断"><a href="#linux中断" class="headerlink" title="linux中断"></a>linux中断</h2><p>中断是指CPU在执行程序执行中，出现了突发事件，CPU必须暂停当前程序的执行，处理突发事件，处理完后又返回程序到中断的位置继续进行。</p><p>根据中断入口跳转方法不同，分为向量中断和非向量中断，采用向量中断的CPU通常为不同的中断分配不同的中断号，当检测到某中断到来后，自动跳转到该中断号对应的地址执行。不同中断号的中断有不同的入口地址。非向量中断的多个中断共享一个入口地址，进入该入口地址后，再通过软件判断中断标志来标识，具体哪个中断。</p><h4 id="申请和释放中断"><a href="#申请和释放中断" class="headerlink" title="申请和释放中断"></a>申请和释放中断</h4><p>request_irq 函数用于申请中断， request_irq函数可能会导致睡眠，因此不能在中断上下文或者其他禁止睡眠的代码段中使用 request_irq 函数。 request_irq 函数会激活(使能)中断，所以不需要我们手动去使能中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params"><span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure><p>irq：要申请中断的中断号。</p><p>每个中断都有一个中断号，通过中断号即可区分不同的中断 。</p><p>handler：中断处理函数，当中断发生以后就会执行此中断处理函数。<br>flags：中断标志，可以在文件 include&#x2F;linux&#x2F;interrupt.h 里面查看所有的中断标志 </p><p>name：中断名字，设置以后可以在&#x2F;proc&#x2F;interrupts 文件中看到对应的中断名字。<br>dev： 如果将 flags 设置为 IRQF_SHARED 的话， dev 用来区分不同的中断，一般情况下将<br>dev 设置为设备结构体， dev 会传递给中断处理函数 irq_handler_t 的第二个参数。<br>返回值： 0 中断申请成功，其他负值 中断申请失败，如果返回-EBUSY 的话表示中断已经被申请了。 </p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>IRQF_SHARED</td><td>多个设备共享一个中断线，共享的所有中断都必须指定此标志。如果使用共享中断的话， request_irq 函数的 dev 参数就是唯一区分的标志</td></tr><tr><td>IRQF_ONESHOT</td><td>单次中断，中断执行一次就结束。</td></tr><tr><td>IRQF_TRIGGER_NONE</td><td>无触发</td></tr><tr><td>IRQF_TRIGGER_RISING</td><td>上升沿触发</td></tr><tr><td>IRQF_TRIGGER_FALLING</td><td>下降沿触发</td></tr><tr><td>IRQF_TRIGGER_HIGH</td><td>高电平触发</td></tr><tr><td>IRQF_TRIGGER_LOW</td><td>低电平触发</td></tr></tbody></table><h4 id="free-irq-函数"><a href="#free-irq-函数" class="headerlink" title="free_irq 函数"></a>free_irq 函数</h4><p>通过 free_irq 函数释放掉相应的中断。 如果中断不是共享的，那么 free_irq 会删除中断处理函数并且禁止中断。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure><p>第一个参数是要中断处理函数要相应的中断号。第二个参数是一个指向 void 的指针，也就是个通用指针，需要与 request_irq 函数的 dev 参数保持一致。用于区分共享中断的不同设备，dev 也可以指向设备数据结构。 </p><p>中断处理函数的返回值为 irqreturn_t 类型， irqreturn_t 类型定义如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> &#123;</span></span><br><span class="line">IRQ_NONE = (<span class="number">0</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">IRQ_HANDLED = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">IRQ_WAKE_THREAD = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> <span class="title">irqreturn_t</span>;</span></span><br></pre></td></tr></table></figure><p>可以看出 irqreturn_t 是个枚举类型，一共有三种返回值。一般中断服务函数返回值使用如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED) </span><br></pre></td></tr></table></figure><h4 id="中断使能与禁止函数"><a href="#中断使能与禁止函数" class="headerlink" title="中断使能与禁止函数"></a>中断使能与禁止函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span><span class="comment">//使能中断irq为中断号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span><span class="comment">//禁止中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span><span class="comment">//需要保证不会产生新的中断，并且确保所有已经开始执行的中断处理程序已经全部退出,调用以后立即返回，不会等待当前中断处理程序执行完毕</span></span><br><span class="line"><span class="title function_">local_irq_enable</span><span class="params">()</span><span class="comment">//使能当前处理器中断系统</span></span><br><span class="line"><span class="title function_">local_irq_disable</span><span class="params">()</span><span class="comment">//禁止当前中断系统</span></span><br><span class="line"><span class="title function_">local_irq_save</span><span class="params">(flags)</span><span class="comment">//用于禁止中断，并且将中断状态保存在 flags 中</span></span><br><span class="line"><span class="title function_">local_irq_restore</span><span class="params">(flags)</span><span class="comment">//用于恢复中断，将中断到 flags 状态</span></span><br></pre></td></tr></table></figure><h4 id="中断上下部"><a href="#中断上下部" class="headerlink" title="中断上下部"></a>中断上下部</h4><p>中断处理过程就分为了两部分：<br>上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。<br>下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。 </p><p>对于网卡的中断处理，上半部会执行通知硬件、拷贝网络数据报到内存并继续读取新数据包，这些重要、紧急且与硬件相关的工作，因为网卡接收的网络数据包的缓存大小通常是固定的、有限的，一旦被延迟可能造成缓存溢出。而数据包的处理等操作，则由下半部来完成。</p><p>Linux 内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，那些对时间敏感、执行速度快的操作可以放到中断处理函数中，也就是上半部。剩下的所有工作都可以放到下半部去执行，比如在上半部将数据拷贝到内存中，关于数据的具体处理就可以放到下半部去执行。至于哪些代码属于上半部，哪些代码属于下半部并没有明确的规定 。</p><ol><li>如果要处理的内容不希望被其他中断打断，那么可以放到上半部。</li><li>如果要处理的任务对时间敏感，可以放到上半部。</li><li>如果要处理的任务与硬件有关，可以放到上半部</li><li>除了上述三点以外的其他任务，优先考虑放到下半部。</li></ol><h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>2.5版本以前使用BH(bottom half)实现下半部分，之后都是使用软中断核tasklet代替BH机制。Linux内核使用结构体softirq_action表示软中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span>(*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在kernel&#x2F;softirq.c文件中一共定义了10个软中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>];</span></span><br></pre></td></tr></table></figure><p>NR_SOFTIRQS是枚举类型，定义在文件include&#x2F;linux&#x2F;interrupt.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">HI_SOFTIRQ=<span class="number">0</span>, <span class="comment">/* 高优先级软中断 */</span></span><br><span class="line">TIMER_SOFTIRQ, <span class="comment">/* 定时器软中断 */</span></span><br><span class="line">NET_TX_SOFTIRQ, <span class="comment">/* 网络数据发送软中断 */</span></span><br><span class="line">NET_RX_SOFTIRQ, <span class="comment">/* 网络数据接收软中断 */</span></span><br><span class="line">BLOCK_SOFTIRQ,</span><br><span class="line">BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">TASKLET_SOFTIRQ, <span class="comment">/* tasklet 软中断 */</span></span><br><span class="line">SCHED_SOFTIRQ, <span class="comment">/* 调度软中断 */</span></span><br><span class="line">HRTIMER_SOFTIRQ, <span class="comment">/* 高精度定时器软中断 */</span></span><br><span class="line">RCU_SOFTIRQ, <span class="comment">/* RCU 软中断 */</span></span><br><span class="line">NR_SOFTIRQS</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>softirq_action 结构体中的 action 成员变量就是软中断的服务函数，数组 softirq_vec 是个全局数组，因此所有的 CPU(对于 SMP 系统而言)都可以访问到，每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。 </p><p>要使用软中断，必须先使用 open_softirq 函数注册对应的软中断处理函数 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span><br><span class="line"><span class="comment">//nr：要开启的软中断，</span></span><br><span class="line"><span class="comment">//action：软中断对应的处理函数。</span></span><br><span class="line"><span class="comment">//返回值： 没有返回值。</span></span><br></pre></td></tr></table></figure><p>注册好软中断以后需要通过 raise_softirq 函数触发 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line"><span class="comment">//nr：要触发的软中断</span></span><br><span class="line"><span class="comment">//返回值： 没有返回值。</span></span><br></pre></td></tr></table></figure><p>软中断必须在编译的时候静态注册！ Linux 内核使用 softirq_init 函数初始化软中断，softirq_init 函数定义在 kernel&#x2F;softirq.c 文件里面， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">softirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line">per_cpu(tasklet_vec, cpu).tail =&amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">per_cpu(tasklet_hi_vec, cpu).tail =&amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tasklet 是利用软中断来实现的另外一种下半部机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span>//结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span> <span class="comment">/* 下一个 tasklet */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> state; <span class="comment">/* tasklet 状态 */</span></span><br><span class="line"><span class="type">atomic_t</span> count; <span class="comment">/* 计数器，记录对 tasklet 的引用数 */</span></span><br><span class="line"><span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">/* tasklet 执行的函数 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> data; <span class="comment">/* 函数 func 的参数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t, <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line"><span class="comment">//t：要初始化的 tasklet</span></span><br><span class="line"><span class="comment">//func： tasklet 的处理函数。</span></span><br><span class="line"><span class="comment">//data： 要传递给 func 函数的参数</span></span><br><span class="line"><span class="comment">//返回值： 没有返回值。</span></span><br></pre></td></tr></table></figure><p>在上半部，也就是中断处理函数中调用 tasklet_schedule 函数就能使 tasklet 在合适的时间运行 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line"><span class="comment">//t：要调度的 tasklet，也就是 DECLARE_TASKLET 宏里面的 name。</span></span><br></pre></td></tr></table></figure><p>tasklet的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义 taselet */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">testtasklet</span>;</span></span><br><span class="line"><span class="comment">/* tasklet 处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testtasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* tasklet 具体处理内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 调度 tasklet */</span></span><br><span class="line">tasklet_schedule(&amp;testtasklet);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 初始化 tasklet */</span></span><br><span class="line">tasklet_init(&amp;testtasklet, testtasklet_func, data);</span><br><span class="line"><span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">request_irq(xxx_irq, test_handler, <span class="number">0</span>, <span class="string">&quot;xxx&quot;</span>, &amp;xxx_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>工作队列是另外一种下半部执行方式，工作队列在进程上下文执行，工作队列将要推后的工作交给一个内核线程去执行，因为工作队列工作在进程上下文，因此工作队列允许睡眠或重新调度。因此如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet。 </p><p>工作队列结构体workqueue_struct结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">int</span> work_color;</span><br><span class="line"><span class="type">int</span> flush_color;</span><br><span class="line"><span class="type">atomic_t</span> nr_pwqs_to_flush;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span> *<span class="title">first_flusher</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flusher_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flusher_overflow</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">maydays</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">rescuer</span>;</span></span><br><span class="line"><span class="type">int</span> nr_drainers;</span><br><span class="line"><span class="type">int</span> saved_max_active;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">unbound_attrs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">dfl_pwq</span>;</span></span><br><span class="line"><span class="type">char</span> name[WQ_NAME_LEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags ____cacheline_aligned;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">percpu</span> *<span class="title">cpu_pwqs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">rcu</span> *<span class="title">numa_pwq_tbl</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内核使用工作者线程(worker thread)来处理工作队列的各个工作，Linux使用worker结构体表示工作者线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hentry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_work</span>;</span></span><br><span class="line"><span class="type">work_func_t</span> current_func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">current_pwq</span>;</span></span><br><span class="line"><span class="type">bool</span> desc_valid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">scheduled</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> last_active;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> desc[WORKER_DESC_LEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">rescue_wq</span>;</span><span class="comment">//工作队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作， INIT_WORK 宏定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_WORK(_work, _func)</span></span><br><span class="line"><span class="comment">//work 表示要初始化的工作， _func 是工作对应的处理函数。</span></span><br></pre></td></tr></table></figure><p>也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WORK(n, f)</span></span><br><span class="line"><span class="comment">//n 表示定义的工作(work_struct)， f 表示工作对应的处理函数。</span></span><br></pre></td></tr></table></figure><p>和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work，函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line"><span class="comment">//work： 要调度的工作。</span></span><br><span class="line"><span class="comment">//返回值： 0 成功，其他值 失败。 </span></span><br></pre></td></tr></table></figure><p>工作队列的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义工作(work) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">testwork</span>;</span></span><br><span class="line"><span class="comment">/* work 处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testwork_func_t</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* work 具体处理内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 调度 work */</span></span><br><span class="line">schedule_work(&amp;testwork);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 初始化 work */</span></span><br><span class="line">INIT_WORK(&amp;testwork, <span class="type">testwork_func_t</span>);</span><br><span class="line"><span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">request_irq(xxx_irq, test_handler, <span class="number">0</span>, <span class="string">&quot;xxx&quot;</span>, &amp;xxx_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-06%20143233.png"></p><h4 id="补充杂项"><a href="#补充杂项" class="headerlink" title="补充杂项"></a>补充杂项</h4><h5 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h5><p>Volatile意思是“易变的”，<strong>直接从变量地址中读取数据</strong>。“易变”是因为外在因素引起的，像多线程，中断等。</p><p>volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。</p><p>如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</p><p><strong>使用场景</strong></p><ol><li>并行设备的硬件寄存器（如：状态寄存器） 存储器映射的硬件寄存器通常也要加 voliate，因为每次对它的读写都可能有不同意义。</li><li><strong>中断服务程序中修改的供其它程序检测的变量，需要加volatile；</strong></li><li>多任务环境下各个任务间的共享标志，应该加volatile</li><li>存储器映射的硬件寄存器通常叶家volatile说明，因为每次对它的读写都可能有不同的意义。</li></ol><h5 id="volatile-问题和总结"><a href="#volatile-问题和总结" class="headerlink" title="volatile 问题和总结"></a>volatile 问题和总结</h5><ol><li><p>一个参数既可以是const还可以是volatile吗？</p><p>可以的，例如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p></li><li><p>一个指针可以是volatile吗？</p><p>可以，当一个中服务子程序修改一个指向buffer的指针时。</p></li></ol><p>volatile long可以保证其可见性。（多线程安全三大特性：可见性，原子性，有序性）</p><p>通常来说，Volatile这个关键字的作用仅保证数据的可见性，并不保证原子性，而对于double和long的读写，Volatile还额外保证了读写的原子性。Volatile对于double、long的读写原子性仅指单次读或单次写，如果一个操作同时具有读写。</p><p><strong>原子性：</strong>操作是不可分的。其表现在于对于共享变量的某些操作，应该是不可分的，必须连续完成。</p><p><strong>可见性：</strong>可见性是指一个线程对共享变量的修改，另外一个线程能够立刻看到；</p><p><strong>有序性：</strong>指程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。</p><p>那为什么会出现不一致的情况呢？<br>这是由于重排序的缘故。</p><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序；重排序不会影响单线程的执行结果，但是在并发情况下，可能会出现诡异的BUG。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内核定时器</title>
      <link href="/2023/04/25/2023-4-25-linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2023/04/25/2023-4-25-linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="时间管理和内核定时器"><a href="#时间管理和内核定时器" class="headerlink" title="时间管理和内核定时器"></a>时间管理和内核定时器</h2><p>Linux 内核中有大量的函数需要时间管理，比如周期性的调度程序、延时程序、对于我们驱动编写者来说最常用的定时器。硬件定时器提供时钟源，时钟源的频率可以设置， 设置好以后就周期性的产生定时中断，系统使用定时中断来计时。中断周期性产生的频率就是系统频率，也叫做节拍率(tick rate)(有的资料也叫系统频率)。</p><p>可以在编译 Linux 内核的时候可以通过图形化界面设置系统节拍率， </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Kernel Features</span><br><span class="line">-&gt; Timer frequency (&lt;choice&gt; [=y])</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-24%20205453.png"></p><p>高节拍率和低节拍率的优缺点： </p><p>①、高节拍率会提高系统时间精度，如果采用 100Hz 的节拍率，时间精度就是 10ms，采用1000Hz 的话时间精度就是 1ms，精度提高了 10 倍。高精度时钟的好处有很多，对于那些对时间要求严格的函数来说，能够以更高的精度运行，时间测量也更加准确。<br>②、高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担， 1000Hz 和 100Hz的系统节拍率相比，系统要花费 10 倍的“精力”去处理中断。中断服务函数占用处理器的时间增加，但是现在的处理器性能都很强大，所以采用 1000Hz 的系统节拍率并不会增加太大的负载压力。根据自己的实际情况，选择合适的系统节拍率。</p><p>Linux 内核使用全局变量 jiffies 来记录系统从启动以来的系统节拍数，系统启动的时候会将 jiffies 初始化为 0， jiffies 定义在文件 include&#x2F;linux&#x2F;jiffies.h 中，定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> u64 __jiffy_data jiffies_64;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> __jiffy_data jiffies;</span><br></pre></td></tr></table></figure><p>jiffies_64 和 jiffies 其实是同一个东西， jiffies_64 用于 64 位系统，而 jiffies 用于 32 位系统。为了兼容不同的硬件， jiffies 其实就是 jiffies_64 的低 32 位 。</p><p>当我们访问 jiffies 的时候其实访问的是 jiffies_64 的低 32 位，使用 get_jiffies_64 这个函数可以获取 jiffies_64 的值。在 32 位的系统上读取 jiffies 的值，在 64 位的系统上 jiffes 和 jiffies_64表示同一个变量，因此也可以直接读取 jiffies 的值。所以不管是 32 位的系统还是 64 位系统，都可以使用 jiffies。 </p><p>HZ 表示每秒的节拍数 ，jiffies 表示系统运行的 jiffies 节拍数，所以 jiffies&#x2F;HZ 就是系统运行时间，单位为秒。 </p><p>不管是 32 位还是 64 位的 jiffies，都有溢出的风险，溢出以后会重新从 0 开始计数，相当于绕回来了，因此有些资料也将这个现象也叫做绕回。 Linux 内核提供了如表所示的几个 API 函数来处理绕回 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-24%20210737.png"></p><p>Linux 内核提供了几个 jiffies 和 ms、 us、 ns 之间的转换函数 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-24%20211000.png"></p><h3 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h3><p>定时器是一个很常用的功能，需要周期性处理的工作都要用到定时器。 Linux 内核定时器采用系统时钟来实现，并不是我们在裸机篇中讲解的 PIT 等硬件定时器。 Linux 内核定时器使用很简单，只需要提供超时时间(相当于定时值)和定时处理函数即可，当超时时间到了以后设置的定时处理函数就会执行，和我们使用硬件定时器的套路一样，只是使用内核定时器不需要做一大堆的寄存器初始化工作。在使用内核定时器的时候要注意一点，内核定时器并不是周期性运行的，超时以后就会自动关闭，因此如果想要实现周期性定时，那么就需要在定时处理函数中重新开启定时器。 </p><p>Linux 内核使用 timer_list 结构体表示内核定时器 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">/* 定时器超时时间，单位是节拍数 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line"><span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">/* 定时处理函数 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> data; <span class="comment">/* 要传递给 function 函数的参数 */</span></span><br><span class="line"><span class="type">int</span> slack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="定时器API函数"><a href="#定时器API函数" class="headerlink" title="定时器API函数"></a>定时器API函数</h4><p>init_timer 函数负责初始化 timer_list 类型变量 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line"><span class="comment">//timer要初始化定时器，没有返回值</span></span><br></pre></td></tr></table></figure><p>add_timer函数用于向linux内核注册定时器，使用add_timer函数注册定时器以后，定时器运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line"><span class="comment">//timer:要注册的定时器，没有返回值</span></span><br></pre></td></tr></table></figure><p>del_timer函数用于删除一个定时器，不管定时器是否被激活，都能删除。在多处理器系统上，定时器可能会在其他的处理器上运行，因此在调用 del_timer 函数删除定时器之前要先等待其他处理器的定时处理器函数退出。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line"><span class="comment">//timer:要删除的定时器</span></span><br><span class="line"><span class="comment">//返回值: 0 定时器还没被激活，1定时器已经激活</span></span><br></pre></td></tr></table></figure><p>del_timer_sync 函数是 del_timer 函数的同步版，会等待其他处理器使用完定时器再删除，del_timer_sync 不能使用在中断上下文中。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer_sync</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line"><span class="comment">//timer：要删除的定时器。</span></span><br><span class="line"><span class="comment">//返回值： 0，定时器还没被激活； 1，定时器已经激活。  </span></span><br></pre></td></tr></table></figure><p>mod_timer 函数用于修改定时值，如果定时器还没有激活的话， mod_timer 函数会激活定时器！ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mod_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">unsigned</span> <span class="type">long</span> expires)</span></span><br><span class="line"><span class="comment">//timer:要修改超时时间（定时值）的定时器</span></span><br><span class="line"><span class="comment">//expires:修改后的超时时间</span></span><br><span class="line"><span class="comment">//返回值： 0，调用 mod_timer 函数前定时器未被激活； 1，调用 mod_timer 函数前定时器已被激活。</span></span><br></pre></td></tr></table></figure><h4 id="ioctl函数（设备控制接口函数）"><a href="#ioctl函数（设备控制接口函数）" class="headerlink" title="ioctl函数（设备控制接口函数）"></a>ioctl函数（设备控制接口函数）</h4><p>octl是设备驱动程序中对设备的I&#x2F;O通道进行管理的函数。所谓对I&#x2F;O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。它的调用个数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ioctl(int fd, ind cmd, …)；</span><br></pre></td></tr></table></figure><p>其中fd就是用户程序打开设备时使用open函数返回的文件标示符，cmd就是用户程序对设备的控制命令，至于后面的省略号，那是一些补充参数，一般最多一个，有或没有是和cmd的意义相关的。<br>ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数控制设备的I&#x2F;O通道。 </p><p><strong>应用程序调用 ioctl函数向驱动发送控制信息，此函数响应并执行。</strong> </p><h4 id="内核定时器一般的使用流程"><a href="#内核定时器一般的使用流程" class="headerlink" title="内核定时器一般的使用流程"></a>内核定时器一般的使用流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span> <span class="comment">/* 定义定时器 */</span></span><br><span class="line"><span class="comment">/* 定时器回调函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定时器处理代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 如果需要定时器周期性运行的话就使用 mod_timer</span></span><br><span class="line"><span class="comment"> * 函数重新设置超时值并且启动定时器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mod_timer(&amp;dev-&gt;timertest, jiffies + msecs_to_jiffies(<span class="number">2000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">init_timer(&amp;timer); <span class="comment">/* 初始化定时器 */</span></span><br><span class="line">timer.function = function; <span class="comment">/* 设置定时处理函数 */</span></span><br><span class="line">timer.expires=jffies + msecs_to_jiffies(<span class="number">2000</span>);<span class="comment">/* 超时时间 2 秒 */</span></span><br><span class="line">timer.data = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;dev; <span class="comment">/* 将设备结构体作为参数 */</span></span><br><span class="line">add_timer(&amp;timer); <span class="comment">/* 启动定时器 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 退出函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">del_timer(&amp;timer); <span class="comment">/* 删除定时器 */</span></span><br><span class="line"> <span class="comment">/* 或者使用 */</span></span><br><span class="line">del_timer_sync(&amp;timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-26%20110943.png"></p><h4 id="Linux-内核短延时函数"><a href="#Linux-内核短延时函数" class="headerlink" title="Linux 内核短延时函数"></a>Linux 内核短延时函数</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-25%20205843.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>globalmem设备驱动</title>
      <link href="/2023/04/23/2023-4-25-globalmem%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/04/23/2023-4-25-globalmem%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="globalmem驱动"><a href="#globalmem驱动" class="headerlink" title="globalmem驱动"></a>globalmem驱动</h2><p>globalmem为“全局内存”的意思，在globalmem字符设备中会分配一片大小为GLOBALMEM_SIZE的内存空间，并在驱动中提供对这片内存的读写、控制和定位函数，供用户空间的进程能通过Linux系统调用获取和设置这片内存。</p><h4 id="头文件、宏定义以及结构体"><a href="#头文件、宏定义以及结构体" class="headerlink" title="头文件、宏定义以及结构体"></a>头文件、宏定义以及结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_SIZE  0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR  0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_MAJOR  230</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> globalmem_major = GLOBALMEM_MAJOR;</span><br><span class="line">module_param(globalmem_major, <span class="type">int</span>, S_IRUGO);<span class="comment">//模块传递参数，在加载模块的时候可以自己传递</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[GLOBALMEM_SIZE];<span class="comment">//使用内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> *<span class="title">globalmem_devp</span>;</span></span><br></pre></td></tr></table></figure><h4 id="内核模块传入参数"><a href="#内核模块传入参数" class="headerlink" title="内核模块传入参数"></a>内核模块传入参数</h4><p>内核模块中没有main函数，所以向模块内部传入参数可以通过module_param这个宏定义来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXU 00700    <span class="comment">// 用户读写可执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR 00400    <span class="comment">// 用户读权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWUSR 00200    <span class="comment">// 用户写权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXUSR 00100    <span class="comment">// 用户可执行权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXG 00070    <span class="comment">// 用户组读写可执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRGRP 00040    <span class="comment">// 用户组读权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWGRP 00020    <span class="comment">// 用户组写权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXGRP 00010    <span class="comment">// 用户组可执行权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXO 00007    <span class="comment">// 其他人可读写执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IROTH 00004    <span class="comment">// 其他人可读权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWOTH 00002    <span class="comment">// 其他人可写权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXOTH 00001    <span class="comment">// 其他人可执行权限</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="kzalloc函数与kfree函数"><a href="#kzalloc函数与kfree函数" class="headerlink" title="kzalloc函数与kfree函数"></a>kzalloc函数与kfree函数</h4><p>用kzalloc申请内存的时候， 效果等同于先是用 <em>kmalloc()</em> 申请空间 <em>,</em> 然后用 <em>memset()</em> 来初始化 *,*所有申请的元素都被初始化为 <em>0.</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure><p>给 kmalloc 的第一个参数是要分配的块的大小. 第 2 个参数, 分配标志, 非常有趣, 因为它以几个方式控制 kmalloc 的行为.</p><p>最一般使用的标志, GFP_KERNEL, 代表运行在内核空间的进程而进行的. 这意味着调用函数是代表一个进程在执行一个系统调用. 使用 GFP_KENRL 意味着 kmalloc 能够使当前进程在少内存的情况下睡眠来等待一页. 一个使用 GFP_KERNEL 来分配内存的函数必须, 因此, 是可重入的并且不能在原子上下文中运行. 当当前进程睡眠, 内核采取正确的动作来定位一些空闲内存, 或者通过刷新缓存到磁盘或者交换出去一个用户进程的内存。</p><p>GFP_KERNEL 不一直是使用的正确分配标志; 有时 kmalloc 从一个进程的上下文的外部调用. 例如, 这类的调用可能发生在中断处理, tasklet, 和内核定时器中. 在这个情况下, 当前进程不应当被置为睡眠, 并且驱动应当使用一个GFP_ATOMIC 标志来代替. 内核正常地试图保持一些空闲页以便来满足原子的分配. 当使用 GFP_ATOMIC 时,kmalloc 能够使用甚至最后一个空闲页. 如果这最后一个空闲页不存在, 但是, 分配失败。</p><p>其他用来代替或者增添 GFP_KERNEL 和 GFP_ATOMIC 的标志, 尽管它们 2 个涵盖大部分设备驱动的需要. 所有的标志定义在 &lt;linux&#x2F;gfp.h&gt;, 并且每个标志用一个双下划线做前缀, 例如 __GFP_DMA. 另外, 有符号代表常常使用的标志组合; 这些缺乏前缀并且有时被称为分配优先级。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span></span><br><span class="line"><span class="comment">//objp：内存地址，通常是kmalloc( )函数的返回值，即是指向分配的内存块起始地址的地址指针。</span></span><br></pre></td></tr></table></figure><h4 id="seek函数"><a href="#seek函数" class="headerlink" title="seek函数"></a>seek函数</h4><p>文件重定位函数，改变文件的读写偏移量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">globalmem_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> orig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">loff_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (orig) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)offset &gt; GLOBALMEM_SIZE) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">filp-&gt;f_pos = (<span class="type">unsigned</span> <span class="type">int</span>)offset;</span><br><span class="line">ret = filp-&gt;f_pos;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((filp-&gt;f_pos + offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">filp-&gt;f_pos += offset;</span><br><span class="line">ret = filp-&gt;f_pos;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件重定位的起始地址有三种情况:同时该函数具有检测定位的合法性<br>        ①0:从文件开头进行定位<br>        ②1:从文件当前位置进行定位<br>        ③2:定位到文件末尾</p><h4 id="ioctl函数"><a href="#ioctl函数" class="headerlink" title="ioctl函数"></a>ioctl函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">globalmem_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line"><span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, GLOBALMEM_SIZE);</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;globalmem is set to zero\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ioctl()函数可以接收用户空间的MEM_CLEAR命令实现对内存的数据清0. </p><p>驱动代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linxu/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_SIZE0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR 0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_MAJOR230</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmemdev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">  <span class="type">int</span> major;</span><br><span class="line">  <span class="type">int</span> minor;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> mem[GLOBALMEM_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmemdev</span> *<span class="title">globalmem_devp</span>;</span></span><br><span class="line">module_param(globalmem_devp-&gt;major, <span class="type">int</span> , S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalmem_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = globalmem_devp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalmem_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">globalmem_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmemdev</span> *<span class="title">dev</span> =</span> filp -&gt; private_data;</span><br><span class="line">  <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line">      <span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, GLOBALMEM_SIZE);</span><br><span class="line">      printk(KERN_INFO <span class="string">&quot;globalmem is set to zero \n&quot;</span>);<span class="comment">//KERN_INFO提示信息</span></span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalmem_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> p = *offt;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> count = cnt;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">globalmemdev</span> *<span class="title">dev</span> =</span> filp -&gt; private_data;</span><br><span class="line">  <span class="keyword">if</span>(p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count &gt; GLOBALMEM_SIZE - p)</span><br><span class="line">    count = GLOBALMEM_SIZE-p;</span><br><span class="line">  <span class="keyword">if</span>(copy_to_user(buf, dev-&gt;mem + p, count))</span><br><span class="line">    ret = -EFAULT；</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">  *ppos += count;</span><br><span class="line">    ret = count;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;read %u bytes(s) from %lu\n&quot;</span>, count , p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalmem_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> p = *offt;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> count  = cnt ;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">globalmemdev</span> *<span class="title">dev</span> =</span> filp -&gt; private_data;</span><br><span class="line">  <span class="keyword">if</span>(p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(count &gt; GLOBALMEM_SIZE - p)</span><br><span class="line">    count = GLOBALMEM_SIZE - p;</span><br><span class="line">  <span class="keyword">if</span>(copy_from_user(dev-&gt;mem + p, buf, count))</span><br><span class="line">    ret = -EFAULT;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">  *offt += count;</span><br><span class="line">    ret = count;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;written %u bytes(s) from %lu\n&quot;</span>, count, p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">globalmem_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> orig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">loff_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (orig) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)offset &gt; GLOBALMEM_SIZE) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">filp-&gt;f_pos = (<span class="type">unsigned</span> <span class="type">int</span>)offset;</span><br><span class="line">ret = filp-&gt;f_pos;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((filp-&gt;f_pos + offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">filp-&gt;f_pos += offset;</span><br><span class="line">ret = filp-&gt;f_pos;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">globalmem_ops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">  .llseek = globalmem_llseek,</span><br><span class="line">  .read = globalmem_read,</span><br><span class="line">  .write = globalmem_write,</span><br><span class="line">  .unlocked_ioctl = globalmem_ioctl,</span><br><span class="line">  .open = globalmem_open,</span><br><span class="line">  .release = globalmem_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">globalmem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(globalmem_devp.major)</span><br><span class="line">  &#123;</span><br><span class="line">  globalmem_devp.devid = MKDEV(globalmem_devp.major, <span class="number">0</span>);</span><br><span class="line">    register_chrdev_region(globalmem_devp.devid, <span class="number">1</span>, <span class="string">&quot;globalmem&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  alloc_chrdev_region(&amp;globalmem_devp.devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;globalmem&quot;</span>);</span><br><span class="line">    globalmem_devp.major = MAJOR(globalmem_devp.devid);</span><br><span class="line">    globalmem_devp.minor = MINOR(globalmem_devp.devid);</span><br><span class="line">  &#125;</span><br><span class="line">  cdev_init(&amp;globalmem_devp.cdev, &amp;globalmem_ops);</span><br><span class="line">  dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">  cdev_add(&amp;globalmem_dep.cdev, globalmem_devp.devid, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  globalmem_devp = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> globalmem_dev), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!globalmem_devp) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> fail_malloc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> fail_malloc:</span><br><span class="line">unregister_chrdev_region(devno, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">globalmem_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">cdev_del(&amp;globalmem_devp-&gt;cdev);</span><br><span class="line">  kfree(globalmem_devp)</span><br><span class="line">  unregister_chrdev_region(globalmem_devp.devid, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">module_init(globalmem_init);</span><br><span class="line">module_exit(globalmem_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux并发与竞争</title>
      <link href="/2023/04/20/2023-4-21-linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/"/>
      <url>/2023/04/20/2023-4-21-linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/</url>
      
        <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>若我们谈及计算机系统中的并发，则是指同一个系统中，多个独立活动同时进行，而非依次进行。起初的计算机并发只是一种制造并发的假象，因为只有一个处理器，在同一时刻实质只能处理一个任务，不过是一秒钟内进行多个任务的切换。看起来是同时进行的，因此叫做任务交换。</p><p>多年来，配备了多处理器的计算机一直被用作服务器，它要承担高性能的计算任务；现今，基于一芯多核处理器（简称多核处理器）的计算机日渐普及，多核处理器也用在台式计算机上。</p><p>无论是装配多个处理器，还是单个多核处理器，或是多个多核处理器，这些计算机都能真正并行运作多个任务，我们称之为硬件并发（hardware concurrency）。</p><h3 id="并发方式"><a href="#并发方式" class="headerlink" title="并发方式"></a>并发方式</h3><h4 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h4><p>在应用软件内部，一种并发方式是，将一个应用软件拆分成多个独立进程同时运行，它们都只含单一线程，非常类似于同时运行浏览器和文字处理软件。这些独立进程可以通过所有常规的进程间通信途径相互传递信息（信号、套接字、文件、管道等）。</p><h4 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h4><p>另一种并发方式是在单一进程内运行多线程。线程非常像轻量级进程，每个线程都独立运行，并能各自执行不同的指令序列。</p><p>不过，同一进程内的所有线程都共用相同的地址空间，且所有线程都能直接访问大部分数据。全局变量依然全局可见，指向对象或数据的指针和引用能在线程间传递。</p><p>尽管进程间共享内存通常可行，但这种做法设置复杂，往往难以驾驭，原因是同一数据的地址在不同进程中不一定相同。</p><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><ul><li>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。</li><li>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。</li></ul><h3 id="并发产生的原因"><a href="#并发产生的原因" class="headerlink" title="并发产生的原因"></a>并发产生的原因</h3><p>现在的 Linux 系统并发产生的原因很复杂，总结一下有下面几个主要原<br>因：<br>①、多线程并发访问， Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。<br>②、抢占式并发访问，从 2.6 版本内核开始， Linux 内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。<br>③、中断程序并发访问。<br>④、 SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并发访问 </p><p>并发访问带来的问题就是竞争，对于临界区必须保证一次只有一个线程访问，也就是要保证临界区是原子访问的，原子访问就表示这一个访问是一个步骤，不能再进行拆分。 </p><p>任意时刻，单处理器系统都只能执行一个进程的代码，当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文转换，即保存当前进程的上下文，回复进程的上下文，然后将控制权传递到新进程，新进程就会从它上次停止的地方开始。</p><p>从一个进程到另一个进程的转换是由操作系统内核管理的，内核是操作系统代码常驻主存的部分。</p><h4 id="临界资源和临界区"><a href="#临界资源和临界区" class="headerlink" title="临界资源和临界区"></a>临界资源和临界区</h4><p>1.临界资源<br>  临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。</p><p>2.临界区：<br>  每个进程中访问临界资源的那段代码称为临界区（criticalsection），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。</p><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><h4 id="原子整形操作API函数"><a href="#原子整形操作API函数" class="headerlink" title="原子整形操作API函数"></a>原子整形操作API函数</h4><p>Linux 内核定义了叫做 atomic_t 的结构体来完成整形数据的原子操作，在使用中用原子变量来代替整形变量，此结构体定义在 include&#x2F;linux&#x2F;types.h 文件中，定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">175</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="number">176</span> <span class="type">int</span> counter;</span><br><span class="line"><span class="number">177</span> &#125; <span class="type">atomic_t</span>;</span><br></pre></td></tr></table></figure><p>如果要使用原子操作 API 函数，首先要先定义一个 atomic_t 的变量 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> a;<span class="comment">//定义a</span></span><br><span class="line"><span class="type">atomic_t</span> b = ATOMIC_INIT(<span class="number">0</span>);<span class="comment">//定义原子变量b并赋值0；使用的是ATOMIC_INIT宏</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-19%20153803.png"></p><p>如果使用 64 位的 SOC 的话，就要用到 64 位的原子变量， Linux 内核也定义了 64 位原子结构体，如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;</span><br></pre></td></tr></table></figure><p>相应的也提供了 64 位原子变量的操作 API 函数，这里我们就不详细讲解了，和表 47.2.1.1中的 API 函数有用法一样，只是将“atomic_”前缀换为“atomic64_”，将 int 换为 long long。如果使用的是 64 位的 SOC，那么就要使用 64 位的原子操作函数。 </p><h4 id="原子位操作-API-函数"><a href="#原子位操作-API-函数" class="headerlink" title="原子位操作 API 函数"></a>原子位操作 API 函数</h4><p>Linux 内核也提供了一系列的原子位操作 API 函数，只不过原子位操作不像原子整形变量那样有个 atomic_t 的数据结构，原子位操作是直接对内存进行操作 .</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void set_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位置 1</td></tr><tr><td align="center">void clear_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位清零。</td></tr><tr><td align="center">void change_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位进行翻转</td></tr><tr><td align="center">int test_bit(int nr, void *p)</td><td align="center">获取 p 地址的第 nr 位的值。</td></tr><tr><td align="center">int test_and_set_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值</td></tr><tr><td align="center">int test_and_clear_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位清零，并且返回 nr 位原来的值</td></tr><tr><td align="center">int test_and_change_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值</td></tr></tbody></table><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>当一个线程要访问某个共享资源的时候首先要先获取相应的锁， 锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线程就不能获取此锁。对于自旋锁而言，如果自旋锁正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线程 B 不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁可用。 </p><p>自旋锁的一个缺点：那就等待自旋锁的线程会一直处于自旋状态，这样会浪费处理器时间，降低系统性能，所以自旋锁的持有时间不能太长。所以自旋锁适用于短时期的轻量级加锁，如果遇到需要长时间持有锁的场景那就需要换其他的方法了， </p><p>Linux 内核使用结构体 spinlock_t 表示自旋锁 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line"><span class="number">65</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="number">66</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"><span class="number">67</span></span><br><span class="line"><span class="number">68</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="number">69</span> <span class="meta"># <span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line"><span class="number">70</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="number">71</span> u8 __padding[LOCK_PADSIZE];</span><br><span class="line"><span class="number">72</span> <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="number">73</span> &#125;;</span><br><span class="line"><span class="number">74</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">75</span> &#125;;</span><br><span class="line"><span class="number">76</span> &#125; <span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">spinlock_t</span> lock;<span class="comment">//定义自旋锁</span></span><br></pre></td></tr></table></figure><h3 id="自旋锁API函数"><a href="#自旋锁API函数" class="headerlink" title="自旋锁API函数"></a>自旋锁API函数</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-19%20162257.png"></p><p>表中的自旋锁API 函数适用于SMP或支持抢占的单CPU下线程之间的并发访问，也就是用于线程与线程之间，被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数，否则的话会可能会导致死锁现象的发生。自旋锁会自动禁止抢占，也就说当线程 A得到锁以后会暂时禁止内核抢占。如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而<br>且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，好了，死锁发生了！ </p><p>表 中的 API 函数用于线程之间的并发访问，如果此时中断也要插一脚，中断也想访问共享资源，那该怎么办呢？首先可以肯定的是，中断里面可以使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要先禁止本地中断(也就是本 CPU 中断，对于多核 SOC来说会有多个 CPU 核)，否则可能导致锁死现象的发生。</p><p>线程 A 先运行，并且获取到了 lock 这个锁，当线程 A 运行 functionA 函数的时候中断发生了，中断抢走了 CPU 使用权。右边的中断服务函数也要获取 lock 这个锁，但是这个锁被线程 A 占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程 A 是不可能执行的，线程 A 说“你先放手”，中断说“你先放手”，场面就这么僵持着，死锁发生！</p><p>最好的解决方法就是获取锁之前关闭本地中断， Linux 内核提供了相应的 API 函数 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-20%20162230.png"></p><p>建议使用 spin_lock_irqsave&#x2F; spin_unlock_irqrestore，因为这一组函<br>数会保存中断状态，在释放锁的时候会恢复中断状态。一般在线程中使用 spin_lock_irqsave&#x2F;spin_unlock_irqrestore，在中断中使用spin_lock&#x2F;spin_unlock， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> DEFINE_SPINLOCK(lock) <span class="comment">/* 定义并初始化一个锁 */</span></span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span><span class="comment">/* 线程 A */</span></span><br><span class="line"><span class="number">4</span> <span class="type">void</span> <span class="title function_">functionA</span> <span class="params">()</span>&#123;</span><br><span class="line"><span class="number">5</span> <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* 中断状态 */</span></span><br><span class="line"><span class="number">6</span> spin_lock_irqsave(&amp;lock, flags) <span class="comment">/* 获取锁 */</span></span><br><span class="line"><span class="number">7</span> <span class="comment">/* 临界区 */</span></span><br><span class="line"><span class="number">8</span> spin_unlock_irqrestore(&amp;lock, flags) <span class="comment">/* 释放锁 */</span></span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="comment">/* 中断服务函数 */</span></span><br><span class="line"><span class="number">12</span> <span class="type">void</span> <span class="title function_">irq</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">13</span> spin_lock(&amp;lock) <span class="comment">/* 获取锁 */</span></span><br><span class="line"><span class="number">14</span> <span class="comment">/* 临界区 */</span></span><br><span class="line"><span class="number">15</span> spin_unlock(&amp;lock) <span class="comment">/* 释放锁 */</span></span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="自旋锁使用注意事项"><a href="#自旋锁使用注意事项" class="headerlink" title="自旋锁使用注意事项"></a>自旋锁使用注意事项</h4><p>①、因为在等待自旋锁的时候处于“自旋”状态，因此锁的持有时间不能太长，一定要短，否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处理方式，比如稍后要讲的信号量和互斥体。<br>②、自旋锁保护的临界区内不能调用任何可能导致线程休眠的 API 函数，否则的话可能导致死锁。<br>③、不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了！<br>④、在编写驱动程序的时候我们必须考虑到驱动的可移植性，因此不管你用的是单核的还是多核的 SOC，都将其当做多核 SOC 来编写驱动程序。 </p><h4 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h4><p><u><strong>使用自旋锁来实现对实现设备的互斥访问 ，其实是使用定义的自旋锁来保护设备状态的变量，在改变设备状态的变量前后使用上锁和解锁的操作，主要是通过判断自旋锁的设备状态变量实现设备的互斥访问。</strong></u></p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量（<a href="https://so.csdn.net/so/search?q=semaphore&spm=1001.2101.3001.7020">semaphore</a>）是操作系统用来解决并发中的互斥和同步问题的一种方法。<br>信号量是一个与队列有关的整型变量，你可以把它想象成一个数后面拖着一条排队的队列。</p><p>那信号量上面值n代表什么意思呢？<br>n&gt;0：当前有可用资源，可用资源数量为n<br>n&#x3D;0：资源都被占用，可用资源数量为0<br>n&lt;0：资源都被占用，并且还有n个进程正在排队<br>那信号量拖着的那个队列就是用来放正在排队想要使用这一资源的进程。</p><p>信号量的特点：<br>①、因为信号量可以使等待资源线程进入休眠状态，因此适用于那些占用资源比较久的场合。<br>②、因此信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。<br>③、如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势。 </p><p>信号量API函数</p><p>Linux 内核使用 semaphore 结构体表示信号量 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line"><span class="type">raw_spinlock_t</span> lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-20%20185124.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span> <span class="comment">/* 定义信号量 */</span></span><br><span class="line">sema_init(&amp;sem, <span class="number">1</span>); <span class="comment">/* 初始化信号量 */</span></span><br><span class="line">down(&amp;sem); <span class="comment">/* 申请信号量 */</span></span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">up(&amp;sem); <span class="comment">/* 释放信号量 */</span></span><br></pre></td></tr></table></figure><h3 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h3><p>将信号量的值设置为 1 就可以使用信号量进行互斥访问了，虽然可以通过信号量实现互斥，但是 Linux 提供了一个比信号量更专业的机制来进行互斥，它就是互斥体—mutex。互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥体。在我们编写 Linux 驱动的时候遇到需要互斥访问的地方建议使用 mutex。  </p><p>linux内核使用mutex结构体表示互斥体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line"><span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line"><span class="type">atomic_t</span> count;</span><br><span class="line"><span class="type">spinlock_t</span> wait_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在使用 mutex 之前要先定义一个 mutex 变量。在使用 mutex 的时候要注意如下几点：<br>①、 mutex 可以导致休眠，因此不能在中断中使用 mutex，中断中只能使用自旋锁。<br>②、和信号量一样， mutex 保护的临界区可以调用引起阻塞的 API 函数。<br>③、因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁 </p><p><strong>API函数</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-20%20190738.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* 定义一个互斥体 */</span></span><br><span class="line"><span class="number">2</span> mutex_init(&amp;lock); <span class="comment">/* 初始化互斥体 */</span></span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> mutex_lock(&amp;lock); <span class="comment">/* 上锁 */</span></span><br><span class="line"><span class="number">5</span> <span class="comment">/* 临界区 */</span></span><br><span class="line"><span class="number">6</span> mutex_unlock(&amp;lock); <span class="comment">/* 解锁 */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gpio子系统</title>
      <link href="/2023/04/14/2023-4-14-pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/04/14/2023-4-14-pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="GPIO子系统"><a href="#GPIO子系统" class="headerlink" title="GPIO子系统"></a>GPIO子系统</h3><h4 id="GPIO子系统API函数"><a href="#GPIO子系统API函数" class="headerlink" title="GPIO子系统API函数"></a>GPIO子系统API函数</h4><p>对于驱动开发人员，<strong>设置好设备树以后就可以使用 gpio 子系统提供的 API 函数来操作指定的 GPIO， gpio 子系统向驱动开发人员屏蔽了具体的读写寄存器过程。</strong>这就是驱动分层与分离的好处，大家各司其职，做好自己的本职工作即可。 gpio 子系统提供的常用的 API 函数有下面几个： </p><ol><li><p>gpio_request函数，用于申请一个 GPIO 管脚 </p><p>在使用一个 GPIO 之前一定要使用 gpio_request进行申请 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span> *label)</span></span><br></pre></td></tr></table></figure><p>gpio:要申请的gpio号，使用of_get_named_gpio函数从设备树获取指定gpio属性</p><p>label: gpio的名字</p><p>返回值：0申请成功，其他值失败</p></li><li><p>gpio_free函数， 释放gpio</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_free</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br></pre></td></tr></table></figure><p>gpio: 释放的gpio</p><p>返回值无</p></li><li><p>gpio_direction_input函数 ， 设置gpio为输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_direction_input</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br></pre></td></tr></table></figure><p>gpio:要设置的gpio</p><p>返回值：设置成功，负值设置失败</p></li><li><p>gpio_direction_output函数 ，设置某个 GPIO 为输出 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure><p>gpio：要设置为输出的 GPIO 标号。<br>value： GPIO 默认输出值。<br>返回值： 0，设置成功；负值，设置失败。 </p></li><li><p>gpio_get_value函数， 于获取某个 GPIO 的值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> gpio_get_value __gpio_get_value</span></span><br><span class="line"><span class="type">int</span> __gpio_get_value(<span class="type">unsigned</span> gpio)</span><br></pre></td></tr></table></figure><p>gpio：要获取的 GPIO 标号。<br>返回值： 非负值，得到的 GPIO 值；负值，获取失败。 </p></li><li><p>gpio_set_value函数， 设置某个 GPIO 的值</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> gpio_set_value __gpio_set_value</span></span><br><span class="line"><span class="type">void</span> __gpio_set_value(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span><br></pre></td></tr></table></figure><p>​gpio：要设置的 GPIO 标号。<br>​value： 要设置的值。<br>​返回值： 无 </p><h3 id="设备树中添加GPIO节点模板"><a href="#设备树中添加GPIO节点模板" class="headerlink" title="设备树中添加GPIO节点模板"></a>设备树中添加GPIO节点模板</h3><ul><li>创建设备节点</li><li>添加pinctrl信息</li><li>添加GPIO属性信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">gpio&#123;<span class="comment">/*把gpio节点添加到根节点下*/</span></span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;<span class="comment">/*添加 pinctrl-names 属性*/</span></span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_gpio&gt;;<span class="comment">/*添加 pinctrl-0 节点，使用的 PIN 信息保存在 pinctrl_gpio 节点中*/</span></span><br><span class="line">gpio = &lt;&amp;gpio1 <span class="number">0</span> GPIO_ACTIVE_LOW&gt;;<span class="comment">/*设备用的gpio*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gpio-相关的-OF-函数"><a href="#gpio-相关的-OF-函数" class="headerlink" title="gpio 相关的 OF 函数"></a>gpio 相关的 OF 函数</h4><p>在驱动程序中需要读取 gpio 属性内容， Linux 内核提供了几个与 GPIO 有关的 OF 函数，常用的几个 OF 函数如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_gpio_named_count</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname)</span><span class="comment">//获取设备树某个属性定义了几个gpio信息</span></span><br></pre></td></tr></table></figure><p>np：设备节点。<br>propname：要统计的 GPIO 属性。<br>返回值： 正值，统计到的 GPIO 数量；负值，失败。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_gpio_count</span><span class="params">(<span class="keyword">struct</span> device_node *np)</span><span class="comment">//统计的是“gpios”这个属性的 GPIO 数量</span></span><br></pre></td></tr></table></figure><p>np：设备节点。<br>返回值： 正值，统计到的 GPIO 数量；负值，失败。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_get_named_gpio</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params"><span class="type">int</span> index)</span><span class="comment">//此函数会将设备树中类似&lt;&amp;gpio5 7 GPIO_ACTIVE_LOW&gt;的属性信息转换为对应的 GPIO 编</span></span><br><span class="line">号</span><br></pre></td></tr></table></figure><p>np：设备节点。</p><p>propname：包含要获取 GPIO 信息的属性名。</p><p>index： GPIO 索引，因为一个属性里面可能包含多个 GPIO，此参数指定要获取哪个 GPIO的编号，如果只有一个 GPIO 信息的话此参数为 0。<br>返回值： 正值，获取到的 GPIO ；负值，失败。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> off0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> on1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="type">int</span> major;</span><br><span class="line"><span class="type">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"><span class="type">int</span> led_gpio;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> <span class="title">gpioled</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_open</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;gpioled;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_release</span><span class="params">(<span class="keyword">struct</span> inode *inode , <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">val = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(val &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kernl write failed \r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">state = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(state == on)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, <span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == off)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpioled_ops</span> =</span>&#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = gpio_open,</span><br><span class="line">.read = gpio_read,</span><br><span class="line">.write = gpio_write,</span><br><span class="line">.release = gpio_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">gpioled.nd = of_find_node_by_path(<span class="string">&quot;/gpioled&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(gpioled.nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;gpioled node can not found\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">printk(<span class="string">&quot;gpioled node found\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">&quot;led-gpio&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(gpioled.led_gpio &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;can not led-gpio\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">ret = gpio_direction_output(gpioled.led_gpio, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t see gpio\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(gpioled.major)</span><br><span class="line">&#123;</span><br><span class="line">gpioled.devid = MKDEV(gpioled.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(gpioled.devid, <span class="number">1</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">alloc_chrdev_region(&amp;gpioled.devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">gpioled.major = MAJOR(gpioled.devid);</span><br><span class="line">gpioled.minor = MINOR(gpioled.devid);</span><br><span class="line">&#125;</span><br><span class="line">gpioled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;gpioled.cdev, &amp;gpioled_ops);</span><br><span class="line">cdev_add(&amp;gpioled.cdev, gpioled.devid, <span class="number">1</span>);</span><br><span class="line">gpioled.class = class_create(THIS_MODULE, <span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(gpioled.class))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(gpioled.class);</span><br><span class="line">&#125;</span><br><span class="line">gpioled.device = device_create(gpioled.class, <span class="literal">NULL</span>,gpioled.devid, <span class="literal">NULL</span>,<span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(gpioled.device))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(gpioled.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">cdev_del(&amp;gpioled.cdev);</span><br><span class="line">unregister_chrdev_region(gpioled.devid, <span class="number">1</span>);</span><br><span class="line">device_destroy(gpioled.class, gpioled.devid);</span><br><span class="line">class_destroy(gpioled.class);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_init);</span><br><span class="line">module_exit(gpio_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树上的驱动开发</title>
      <link href="/2023/04/11/2023-4-11-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8A%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/04/11/2023-4-11-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8A%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="设备树驱动编写框架"><a href="#设备树驱动编写框架" class="headerlink" title="设备树驱动编写框架"></a>设备树驱动编写框架</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20180457.png"></p><h3 id="编写设备树节点"><a href="#编写设备树节点" class="headerlink" title="编写设备树节点"></a>编写设备树节点</h3><p>首先是将节点编写在使用的开发板的dts文件中，比如编写led的节点。首先将节点编写在根节点下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">alphaled<span class="comment">//节点名字&#123;</span></span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  compatible = <span class="string">&quot;atkalpha-led&quot;</span>;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">reg = &#123;</span><br><span class="line">  <span class="number">0X020C406C</span> <span class="number">0X04</span> <span class="comment">//CCM_CCGR1_BASE</span></span><br><span class="line">        <span class="number">0X020E0068</span> <span class="number">0X04</span> <span class="comment">//SW_MUX_GPIO103_BASE</span></span><br><span class="line">        <span class="number">0X020E02F4</span> <span class="number">0X04</span> <span class="comment">//SW_PAD_GPIO103_BASE</span></span><br><span class="line">        <span class="number">0X0209C000</span> <span class="number">0X04</span> <span class="comment">//GPIO1_DR_BASE</span></span><br><span class="line">  <span class="number">0X0209C004</span> <span class="number">0X04</span> <span class="comment">//GPIO1_GDIR_BASE      </span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在节点中已经写入物理地址，所以驱动程序进行获取就行不用写了，设备树修改完重新编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make dtbs</span><br></pre></td></tr></table></figure><h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> on 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> off 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">led_switch</span><span class="params">(u8 state)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 val;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line"><span class="keyword">if</span>(state == on)</span><br><span class="line">&#123;</span><br><span class="line">val |= (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == off)</span><br><span class="line">&#123;</span><br><span class="line">val |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devtree</span> &#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="type">int</span> major;</span><br><span class="line"><span class="type">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devtree</span> <span class="title">chrled</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode , <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;chrled;<span class="comment">//设置私有数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line"></span><br><span class="line">val = copy_from_user(databuf, buf, cnt);</span><br><span class="line">state = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(state == on)</span><br><span class="line">&#123;</span><br><span class="line">led_switch(on);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == off)</span><br><span class="line">&#123;</span><br><span class="line">led_switch(off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">chrops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_open,</span><br><span class="line">.read = led_read,</span><br><span class="line">.write = led_write,</span><br><span class="line">.release = led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrled_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">proper</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line">u32 regdata[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line">chrled.nd = of_find_node_by_path(<span class="string">&quot;/alphaled&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(chrled.nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;error: node don&#x27;t find \r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">proper = of_find_property(chrled.nd, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(proper == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;compatible property find failed\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ret = of_property_read_string(chrled.nd, <span class="string">&quot;status&quot;</span>, &amp;str);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;status read failed\r\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">printk(<span class="string">&quot;status = %s\r\n&quot;</span>,str);</span><br><span class="line">&#125;</span><br><span class="line">ret = of_property_read_u32_array(chrled.nd , <span class="string">&quot;reg&quot;</span>, regdata, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;reg property read failed!\r\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">u8 i = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">&quot;reg data: \r\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)</span><br><span class="line">printk(<span class="string">&quot;%#X &quot;</span>, regdata[i]);</span><br><span class="line">printk(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">CCM_CCGR1 = of_iomap(chrled.nd, <span class="number">0</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = of_iomap(chrled.nd, <span class="number">1</span>);</span><br><span class="line">SW_PAD_GPIO1_IO03 = of_iomap(chrled.nd, <span class="number">2</span>);</span><br><span class="line">GPIO1_DR = of_iomap(chrled.nd, <span class="number">3</span>);</span><br><span class="line">GPIO1_GDIR = of_iomap(chrled.nd, <span class="number">4</span>);</span><br><span class="line"><span class="comment">/*设备驱动*/</span></span><br><span class="line">val = readl(CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">val |= (<span class="number">3</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">writel(val, CCM_CCGR1);</span><br><span class="line">writel(<span class="number">5</span>, SW_MUX_GPIO1_IO03);</span><br><span class="line">writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">val |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_GDIR);</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(chrled.major)</span><br><span class="line">&#123;</span><br><span class="line">chrled.devid = MKDEV(chrled.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(chrled.devid, <span class="number">1</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">alloc_chrdev_region(&amp;chrled.devid, <span class="number">0</span>, <span class="number">1</span>,<span class="string">&quot;led&quot;</span>);</span><br><span class="line">chrled.major = MAJOR(chrled.devid);</span><br><span class="line">chrled.minor = MINOR(chrled.devid);</span><br><span class="line">&#125;</span><br><span class="line">cdev_init(&amp;chrled.cdev, &amp;chrops);</span><br><span class="line">chrled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_add(&amp;chrled.cdev, chrled.devid, <span class="number">1</span>);</span><br><span class="line">chrled.class = class_create(THIS_MODULE, <span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(chrled.class))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chrled.class);</span><br><span class="line">&#125;</span><br><span class="line">chrled.device = device_create(chrled.class, <span class="literal">NULL</span>,chrled.devid, <span class="literal">NULL</span>,<span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(chrled.device))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chrled.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrled_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">iounmap(CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line"></span><br><span class="line">cdev_del(&amp;chrled.cdev);</span><br><span class="line">unregister_chrdev_region(chrled.devid, <span class="number">1</span>);</span><br><span class="line">device_destroy(chrled.class, chrled.devid);</span><br><span class="line">class_destroy(chrled.class);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">module_init(chrled_init);</span><br><span class="line">module_exit(chrled_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nfs挂载设备树失败</title>
      <link href="/2023/04/10/2023-4-10-nfs%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87%E6%A0%91%E5%A4%B1%E8%B4%A5/"/>
      <url>/2023/04/10/2023-4-10-nfs%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87%E6%A0%91%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="VFS-Cannot-open-root-device-“nfs”-or-unknown-block-2-0"><a href="#VFS-Cannot-open-root-device-“nfs”-or-unknown-block-2-0" class="headerlink" title="VFS: Cannot open root device “nfs” or unknown-block(2,0)"></a>VFS: Cannot open root device “nfs” or unknown-block(2,0)</h3><p>首先说明一下问题，之前根文件系统一直正常使用，突然今天进行了以上报错，首先是搜索了一下问题，说是开发板内核和Ubuntu的nfs版本不匹配，之前遇到过，系统换成Ubuntu16版本的了，应该可以排除，但是也试了一下不好使。</p><p>感觉是ip地址的变化将bootargs变量里的服务器ip地址的数值进行了相应的改变，但是还是没有变化。</p><p>查了相关的问题搜索发现，没有解决方案，我先是进行了开发板的固化系统，使用了emmc中的根文件系统，发现没有问题，但是使用网络nfs挂载还是出现了问题，最后通过装载了第二个系统进行挂载发现了问题所在。</p><p>问题是：板子的ip地址和别的设备的ip地址冲突了（虽然之前也dhcp了但当时没好使），加上了服务器ip地址的变化导致的。</p><p>所以为了一劳永逸，将Ubuntu的动态分配ip地址进行了更改，改为静态分配ip地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipaddr</span><br></pre></td></tr></table></figure><p>可以查看发现网卡的名字。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-10%20210629.png"></p><p>网卡名字叫做ens33</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/network/interfaces</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"> </span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line">auto ens33</span><br><span class="line"> </span><br><span class="line">iface ens33 inet static</span><br><span class="line">address  192.168.1.128</span><br><span class="line">netmask  255.255.255.0</span><br><span class="line">gateway  192.168.1.1</span><br></pre></td></tr></table></figure><p>之后进行重启网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/networking start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树常用的of操作树</title>
      <link href="/2023/04/09/2023-4-9-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%B8%B8%E7%94%A8%E7%9A%84of%E6%93%8D%E4%BD%9C%E6%A0%91/"/>
      <url>/2023/04/09/2023-4-9-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%B8%B8%E7%94%A8%E7%9A%84of%E6%93%8D%E4%BD%9C%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="设备树常用-OF-操作函数"><a href="#设备树常用-OF-操作函数" class="headerlink" title="设备树常用 OF 操作函数"></a>设备树常用 OF 操作函数</h3><p>设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，在编写驱动的时候需要获取到这些信息。比如设备树使用 reg 属性描述了某个外设的寄存器地址为 0X02005482，长度为 0X400，我们在编写驱动的时候需要获取到 reg 属性0X02005482和 0X400 这两个值，然后初始化外设。 </p><p>Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 include&#x2F;linux&#x2F;of.h 文件中。</p><p>linux内核使用device_code结构体来描述一个节点，此结构体定义在include&#x2F;linux&#x2F;of.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/* 节点名字 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *type; <span class="comment">/* 设备类型 */</span></span><br><span class="line">phandle phandle;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *full_name; <span class="comment">/* 节点全名 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">properties</span>;</span> <span class="comment">/* 属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">deadprops</span>;</span> <span class="comment">/* removed 属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span> <span class="comment">/* 父节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span> <span class="comment">/* 子节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line"><span class="type">void</span> *data;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *path_component_name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="查找节点of函数"><a href="#查找节点of函数" class="headerlink" title="查找节点of函数"></a>查找节点of函数</h3><p>1、通过节点名字查找指定节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_name</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line"><span class="comment">//from开始查找的节点 </span></span><br><span class="line"><span class="comment">//name要查找的节点名字返回找到的节点，NULL表示失败</span></span><br></pre></td></tr></table></figure><p>2、通过device_type属性查找指定的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_type</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type)</span></span><br><span class="line"><span class="comment">//from开始查找的节点，NULL表示从根节点查找整个设备树 </span></span><br><span class="line"><span class="comment">//type要查找的节点对应的type字符串，</span></span><br><span class="line"><span class="comment">//返回值为找到的节点，NULL失败</span></span><br></pre></td></tr></table></figure><p>3、根据device_type和compatible两个属性查找指定的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_compatible_node</span><span class="params">(<span class="keyword">struct</span> device_node *from,<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *compatible)</span></span><br><span class="line"><span class="comment">//from 开始查找的节点NULL表示从根节点查找整个设备树</span></span><br><span class="line"><span class="comment">//type 要查找的节点对应的type字符串（device_type属性值），NULL表示忽略device_type属性</span></span><br><span class="line"><span class="comment">//compatible 要查找的节点所对应的compatible属性列表</span></span><br><span class="line"><span class="comment">//返回值： 找到的节点，如果为 NULL 表示查找失败</span></span><br></pre></td></tr></table></figure><p>4、通过of_device_id匹配表来查找节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_matching_node_and_match</span><span class="params">(<span class="keyword">struct</span> device_node *from, </span></span><br><span class="line"><span class="params">                                                    <span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">                                                    <span class="type">const</span> <span class="keyword">struct</span> of_device_id **match)</span></span><br><span class="line"><span class="comment">//from开始查找的节点，NULL代表从根节点查找整个设备树</span></span><br><span class="line"><span class="comment">//matches of_device_id匹配表，在匹配表里查找节点</span></span><br><span class="line"><span class="comment">//match 找到的匹配的of_device_id</span></span><br><span class="line"><span class="comment">//返回值：找到的节点，NULL表示失败，</span></span><br></pre></td></tr></table></figure><p>5、通过路径来查找指定的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line"><span class="comment">//path:带有全路径的节点名</span></span><br><span class="line"><span class="comment">//返回值找到的节点，NULL表示失败</span></span><br></pre></td></tr></table></figure><h4 id="查找父-x2F-子节点的of函数"><a href="#查找父-x2F-子节点的of函数" class="headerlink" title="查找父&#x2F;子节点的of函数"></a>查找父&#x2F;子节点的of函数</h4><p>1、获取指定节点的父节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_parent</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node)</span></span><br><span class="line"><span class="comment">//node：要查找的父节点的节点。</span></span><br><span class="line"><span class="comment">//返回值： 找到的父节点。</span></span><br></pre></td></tr></table></figure><p>2、用迭代方式查找子节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_child</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node , <span class="keyword">struct</span> device_node *prev)</span></span><br><span class="line"><span class="comment">//node父节点</span></span><br><span class="line"><span class="comment">//prev前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。</span></span><br><span class="line"><span class="comment">//返回值： 找到的下一个子节点。</span></span><br></pre></td></tr></table></figure><h3 id="提取属性值的of函数"><a href="#提取属性值的of函数" class="headerlink" title="提取属性值的of函数"></a>提取属性值的of函数</h3><p>节点的属性信息里面保存了驱动所需要的内容，因此对于属性值的提取非常重要， Linux 内核中使用结构体 property 表示属性，此结构体同样定义在文件 include&#x2F;linux&#x2F;of.h 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *name; <span class="comment">/* 属性名字 */</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">/* 属性长度 */</span></span><br><span class="line"><span class="type">void</span> *value; <span class="comment">/* 属性值 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">next</span>;</span> <span class="comment">/* 下一个属性 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1、用于查找指定的属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">property *<span class="title function_">of_find_property</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> *lenp)</span></span><br><span class="line"><span class="comment">//np 设备节点</span></span><br><span class="line"><span class="comment">//name 属性名字</span></span><br><span class="line"><span class="comment">//lenp 属性值的字节树</span></span><br><span class="line"><span class="comment">//返回值找到的属性</span></span><br></pre></td></tr></table></figure><p>2、用于获取属性中元素的数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_count_elems_of_size</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,<span class="type">const</span> <span class="type">char</span> *propname，<span class="type">int</span> elem_size)</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//proname： 需要统计元素数量的属性名字。</span></span><br><span class="line"><span class="comment">//elem_size：元素长度。</span></span><br><span class="line"><span class="comment">//返回值： 得到的属性元素数量</span></span><br></pre></td></tr></table></figure><p>3、用于从属性中获取指定标号的 u32 类型数据值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u32_index</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">                               u32 index,</span></span><br><span class="line"><span class="params">                               u32 *out_value               )</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//proname： 要读取的属性名字。</span></span><br><span class="line"><span class="comment">//index：要读取的值标号。</span></span><br><span class="line"><span class="comment">//out_value：读取到的值</span></span><br><span class="line"><span class="comment">//返回值： 0 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</span></span><br></pre></td></tr></table></figure><p>4、读取属性中 u8、 u16、 u32 和 u64 类型的数组数据 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u8_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">u8 *out_values,</span></span><br><span class="line"><span class="params"><span class="type">size_t</span> sz)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u16_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">  u16 *out_values,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> sz)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u32_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params"> u32 *out_values,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> sz)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u64_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params"> u64 *out_values,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> sz)</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//proname： 要读取的属性名字。</span></span><br><span class="line"><span class="comment">//out_value：读取到的数组值，分别为 u8、 u16、 u32 和 u64。</span></span><br><span class="line"><span class="comment">//sz： 要读取的数组元素数量。</span></span><br><span class="line"><span class="comment">//返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</span></span><br></pre></td></tr></table></figure><p>5、用于读取这种只有一个整形值的属性，分别用于读取 u8、 u16、 u32 和 u64 类型属性值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u8</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">u8 *out_value)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u16</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">u16 *out_value)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u32</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">  u32 *out_value)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u64</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params"> u64 *out_value)</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//proname： 要读取的属性名字。</span></span><br><span class="line"><span class="comment">//out_value：读取到的数组值。</span></span><br><span class="line"><span class="comment">//返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</span></span><br></pre></td></tr></table></figure><p>6、用于读取属性中字符串值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_string</span><span class="params">(<span class="keyword">struct</span> device_node *np,<span class="type">const</span> <span class="type">char</span> *propname,<span class="type">const</span> <span class="type">char</span> **out_string)</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//proname： 要读取的属性名字。</span></span><br><span class="line"><span class="comment">//out_string：读取到的字符串值。</span></span><br><span class="line"><span class="comment">//返回值： 0，读取成功，负值，读取失败。</span></span><br></pre></td></tr></table></figure><p>7、用于获取#address-cells 属性值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_n_addr_cells</span><span class="params">(<span class="keyword">struct</span> device_node *np)</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//返回值： 获取到的#address-cells 属性值。</span></span><br></pre></td></tr></table></figure><p>8、用于获取#size-cells 属性值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_n_size_cells</span><span class="params">(<span class="keyword">struct</span> device_node *np)</span></span><br><span class="line"><span class="comment">//np 设备节点</span></span><br><span class="line"><span class="comment">//获取到的size-cells</span></span><br></pre></td></tr></table></figure><h4 id="其他常用的-OF-函数"><a href="#其他常用的-OF-函数" class="headerlink" title="其他常用的 OF 函数"></a>其他常用的 OF 函数</h4><p>1、查看节点的compatible属性是否包含compat指定的字符串，也就是检查设备节点的兼容性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_device_is_compatible</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *device,<span class="type">const</span> <span class="type">char</span> *compat)</span></span><br><span class="line"><span class="comment">//device：设备节点</span></span><br><span class="line"><span class="comment">//compat：要查看的字符串</span></span><br><span class="line"><span class="comment">//返回值： 0，节点的 compatible 属性中不包含 compat 指定的字符串； 正数，节点的 compatible属性中包含 compat 指定的字符串。</span></span><br></pre></td></tr></table></figure><p>2、用于获取地址相关属性，主要是reg和assigned-address属性值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> __be32 *<span class="title function_">of_get_address</span><span class="params">(<span class="keyword">struct</span> device_node *dev,<span class="type">int</span> index,u64 *size,<span class="type">unsigned</span> <span class="type">int</span> *flags)</span></span><br><span class="line"><span class="comment">//dev设备节点</span></span><br><span class="line"><span class="comment">//index：要读取的地址标号。</span></span><br><span class="line"><span class="comment">//size：地址长度。</span></span><br><span class="line"><span class="comment">//flags：参数，比如 IORESOURCE_IO、 IORESOURCE_MEM 等</span></span><br><span class="line"><span class="comment">//返回值： 读取到的地址数据首地址，为 NULL 的话表示读取失败。</span></span><br></pre></td></tr></table></figure><p>3、负责将从设备树读取到的地址转换为物理地址 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u64 <span class="title function_">of_translate_address</span><span class="params">(<span class="keyword">struct</span> device_node *dev，const__be32*in_addr)</span></span><br><span class="line"><span class="comment">//dev：设备节点。</span></span><br><span class="line"><span class="comment">//in_addr：要转换的地址。</span></span><br><span class="line"><span class="comment">//返回值： 得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败</span></span><br></pre></td></tr></table></figure><p>4、IIC、 SPI、 GPIO 等这些外设都有对应的寄存器，这些寄存器其实就是一组内存空间， Linux内核使用 resource 结构体来描述一段内存空间，“resource”翻译出来就是“资源”，因此用 resource结构体描述的都是设备资源信息， resource 结构体定义在文件 include&#x2F;linux&#x2F;ioport.h 中，定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line"><span class="type">resource_size_t</span> start;</span><br><span class="line"><span class="type">resource_size_t</span> end;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 32 位的 SOC 来说， resource_size_t 是 u32 类型的。其中 start 表示开始地址， end 表示结束地址， name 是这个资源的名字， flags 是资源标志位，一般表示资源类型，可选的资源标志定义在文件 include&#x2F;linux&#x2F;ioport.h 中 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_BITS 0x000000ff</span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_TYPE_BITS 0x00001f00</span></span><br><span class="line"><span class="number">3</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_IO 0x00000100</span></span><br><span class="line"><span class="number">4</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM 0x00000200</span></span><br><span class="line"><span class="number">5</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_REG 0x00000300</span></span><br><span class="line"><span class="number">6</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_IRQ 0x00000400</span></span><br><span class="line"><span class="number">7</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_DMA 0x00000800</span></span><br><span class="line"><span class="number">8</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_BUS 0x00001000</span></span><br><span class="line"><span class="number">9</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_PREFETCH 0x00002000</span></span><br><span class="line"><span class="number">10</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_READONLY 0x00004000</span></span><br><span class="line"><span class="number">11</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_CACHEABLE 0x00008000</span></span><br><span class="line"><span class="number">12</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_RANGELENGTH 0x00010000</span></span><br><span class="line"><span class="number">13</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_SHADOWABLE 0x00020000</span></span><br><span class="line"><span class="number">14</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_SIZEALIGN 0x00040000</span></span><br><span class="line"><span class="number">15</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_STARTALIGN 0x00080000</span></span><br><span class="line"><span class="number">16</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM_64 0x00100000</span></span><br><span class="line"><span class="number">17</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_WINDOW 0x00200000</span></span><br><span class="line"><span class="number">18</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_MUXED 0x00400000</span></span><br><span class="line"><span class="number">19</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_EXCLUSIVE 0x08000000</span></span><br><span class="line"><span class="number">20</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_DISABLED 0x10000000</span></span><br><span class="line"><span class="number">21</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_UNSET 0x20000000</span></span><br><span class="line"><span class="number">22</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_AUTO 0x40000000</span></span><br><span class="line"><span class="number">23</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_BUSY 0x80000000</span></span><br></pre></td></tr></table></figure><p>将 reg 属性值，然后将其转换为 resource 结构体类型， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev,<span class="type">int</span> index,<span class="keyword">struct</span> resource *r)</span></span><br><span class="line"><span class="comment">//dev：设备节点。</span></span><br><span class="line"><span class="comment">//index：地址资源标号。</span></span><br><span class="line"><span class="comment">//r：得到的 resource 类型的资源值。</span></span><br><span class="line"><span class="comment">//返回值： 0，成功；负值，失败</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux设备树</title>
      <link href="/2023/04/08/2023-4-8-linux%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
      <url>/2023/04/08/2023-4-8-linux%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="设备树定义"><a href="#设备树定义" class="headerlink" title="设备树定义"></a>设备树定义</h3><p>设备树（Device tree），描述设备树的文件叫做DTS（Tree Source），这个DTS采用树形结构描述板级设备（开发板上的设备信息）。树的主干就是系统总线， IIC 控制器、 GPIO 控制器、 SPI 控制器等都是接到系统主线上的分支。 </p><p>设备树源文件扩展名为.dts， DTS 是设备树源码文件， DTB 是将DTS 编译以后得到的二进制文件。将.c 文件编译为.o 需要用到 gcc 编译器，那么将.dts 编译为.dtb需要什么工具呢？需要用到 DTC 工具！ </p><h3 id="DTS语法"><a href="#DTS语法" class="headerlink" title="DTS语法"></a>DTS语法</h3><p>设备树也支持头文件，设备树的头文件扩展名为.dtsi。例如：在imx6ull-14x14-evk.dts中有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ulll-14x14-evk.dsti&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="设备点"><a href="#设备点" class="headerlink" title="设备点"></a>设备点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">示例代码 <span class="number">43.3</span><span class="number">.2</span><span class="number">.1</span> 设备树模板</span><br><span class="line"><span class="number">1</span> / &#123;</span><br><span class="line"><span class="number">2</span> aliases &#123;</span><br><span class="line"><span class="number">3</span> can0 = &amp;flexcan1;</span><br><span class="line"><span class="number">4</span> &#125;;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> cpus &#123;</span><br><span class="line"><span class="number">7</span> <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="number">8</span> <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> cpu0: cpu@<span class="number">0</span> &#123;</span><br><span class="line"><span class="number">11</span> compatible = <span class="string">&quot;arm,cortex-a7&quot;</span>;</span><br><span class="line"><span class="number">12</span> device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line"><span class="number">13</span> reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line"><span class="number">14</span> &#125;;</span><br><span class="line"><span class="number">15</span> &#125;;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> intc: interrupt-controller@<span class="number">00</span>a01000 &#123;</span><br><span class="line"><span class="number">18</span> compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>;</span><br><span class="line"><span class="number">19</span> <span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;</span></span><br><span class="line"><span class="number">20</span> interrupt-controller;</span><br><span class="line"><span class="number">21</span> reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line"><span class="number">22</span> &lt;<span class="number">0x00a02000</span> <span class="number">0x100</span>&gt;;</span><br><span class="line"><span class="number">23</span> &#125;;</span><br><span class="line"><span class="number">24</span> &#125;</span><br></pre></td></tr></table></figure><p>第 2、6 和 17 行，aliases、cpus 和 intc 是三个子节点，在设备树中节点命名格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node-name@unit-address</span><br></pre></td></tr></table></figure><p>其中“node-name”是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如“uart1”就表示这个节点是 UART1 外设。“unit-address”一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话“unit-address”可以不要，比如“cpu@0”、“interrupt-controller@00a01000”。</p><p>但是我们在示例代码 43.3.2.1 中我们看到的节点命名却如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu0:cpu@0</span><br></pre></td></tr></table></figure><p>上述命令并不是“node-name@unit-address”这样的格式，而是用“：”隔开成了两部分，“：”<br>前面的是节点标签(label)，“：”后面的才是节点名字，格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label: node-name@unit-address</span><br></pre></td></tr></table></figure><h4 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-07%20201941.png"></p><p>设备树源码中常用的几种数据形式如下所示：</p><p>①、字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = &quot;arm,cortex-a7&quot;;</span><br></pre></td></tr></table></figure><p>上述代码设置 compatible 属性的值为字符串“arm,cortex-a7”。<br>②、32 位无符号整数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg = &lt;0&gt;;</span><br></pre></td></tr></table></figure><p>上述代码设置 reg 属性的值为 0，reg 的值也可以设置为一组值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg = &lt;0 0x123456 100&gt;;</span><br></pre></td></tr></table></figure><p>③、字符串列表<br>属性值也可以为字符串列表，字符串和字符串之间采用“,”隔开，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = &quot;fsl,imx6ull-gpmi-nand&quot;, &quot;fsl, imx6ul-gpmi-nand&quot;;</span><br></pre></td></tr></table></figure><h4 id="标准属性"><a href="#标准属性" class="headerlink" title="标准属性"></a>标准属性</h4><p>节点是由一堆的属性组成，节点都是具体的设备，不同的设备需要的属性不同，用户可以自定义属性。除了用户自定义属性，有很多属性是标准属性， Linux 下的很多外设驱动都会使用这些标准属性。</p><p><strong>1、compatible属性</strong></p><p>compatible 属性也叫做“兼容性”属性，这是非常重要的一个属性！ compatible 属性的值是一个字符串列表， compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程序， compatible 属性的值格式如下所示： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;manufacturer,model&quot;</span><br></pre></td></tr></table></figure><p>其中 manufacturer 表示厂商， model 一般是模块对应的驱动名字。 </p><p>I.MX6U-ALPHA 开发板上的音频芯片采用的欧胜(WOLFSON)出品的 WM8960， sound 节点的 compatible 属性值如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = &quot;fsl,imx6ul-evk-wm8960&quot;,&quot;fsl,imx-audio-wm8960&quot;;</span><br></pre></td></tr></table></figure><p>属性值有两个，分别为“fsl,imx6ul-evk-wm8960”和“fsl,imx-audio-wm8960” ,sound这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。 </p><p><strong><u>一般驱动程序文件都会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。</u></strong> </p><p><strong>2、model属性</strong></p><p>model属性值也是一个字符串，一般model属性描述设备模块信息，比如名字，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = &quot;wm8960-audio&quot;;</span><br></pre></td></tr></table></figure><p><strong>3、status属性</strong></p><p>status 属性看名字就知道是和设备状态有关的， status 属性值也是字符串，字符串是设备的状态信息，可选的状态如表 :</p><table><thead><tr><th align="center">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">”okey“</td><td align="left">表明设备是可操作的。</td></tr><tr><td align="center">”disabled“</td><td align="left">表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备插入以后。具体含义看设备绑定的文档。</td></tr><tr><td align="center">”fail“</td><td align="left">表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得操作。</td></tr><tr><td align="center">”fail-sss“</td><td align="left">含义和“fail”相同，后面的 sss 部分是检测到的错误内容。</td></tr></tbody></table><p><strong>4、#address-cells和#size-cells属性</strong></p><p>这两个属性的值都是无符号 32 位整形， #address-cells 和#size-cells 这两个属性可以用在任何拥有子节点的设备中，用于描述子节点的地址信息。 #address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)， </p><p>#size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。 #address-cells 和#size-cells 表明了子节点应该如何编写 reg 属性值，一般 reg 属性都是和地址有关的内容，和地址相关的信息有两种：起始地址和地址长度。reg格式一般为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg = &lt;address1 length1 address2 length2 address3 length3……&gt;</span><br></pre></td></tr></table></figure><p>每个“address length”组合表示一个地址范围，其中 address 是起始地址， length 是地址长度， #address-cells 表明 address 这个数据所占用的字长， #size-cells 表明 length 这个数据所占用的字长 </p><p><strong>5、reg属性</strong></p><p>reg 属性的值一般是(address， length)对。 reg 属性一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息。</p><p><strong>6、 ranges 属性</strong><br>ranges属性值可以为空或者按照(child-bus-address,parent-bus-address,length)格式编写的数字矩阵， ranges 是一个地址映射&#x2F;转换表， ranges 属性每个项目由子地址、父地址和地址空间长度。<br>这三部分组成：<br>    child-bus-address：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址所占用的字长。<br>    parent-bus-address： 父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物理地址所占用的字长。<br>    length： 子地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长 </p><p><strong>7、 name 属性</strong><br>name 属性值为字符串， name 属性用于记录节点名字， name 属性已经被弃用，不推荐使用name 属性，一些老的设备树文件可能会使用此属性。<br><strong>8、 device_type 属性</strong><br>device_type 属性值为字符串， IEEE 1275 会用到此属性，用于描述设备的 FCode，但是设备树没有 FCode，所以此属性也被抛弃了。<u>此属性只能用于 cpu 节点或者 memory 节点</u>。imx6ull.dtsi 的 cpu0 节点用到了此属性 。</p><h4 id="根节点-compatible-属性"><a href="#根节点-compatible-属性" class="headerlink" title="根节点 compatible 属性"></a>根节点 compatible 属性</h4><p>设备节点的 compatible 属性值是为了匹配 Linux 内核中的驱动程序，通过根节点的 compatible 属性可以知道我们所使用的设备，一般第<br>一个值描述了所使用的硬件设备名字，第二个值描述了设备所使用的 SOC。 <u>Linux 内核会通过根节点的 compoatible 属性查看是否支持此设备，如果支持的话设备就会启动 Linux 内核。</u> </p><p><strong>1、使用设备树之前的设备匹配方法</strong></p><p>在没有使用设备树以前， uboot 会向 Linux 内核传递一个叫做 machine id 的值， machine id也就是设备 ID，告诉 Linux 内核自己是个什么设备，看看 Linux 内核是否支持。 </p><p>uboot 会给 Linux 内核传递 machine id 这个参数， Linux 内核会检查这个 machine id，其实就是将 machine id 与MACH_TYPE_XXX 宏进行对比，看看有没有相等的，如果相等的话就表示 Linux 内核支持这个设备，如果不支持的话那么这个设备就没法启动 Linux 内核。 </p><p><strong>2、使用设备树以后的设备匹配方法</strong></p><p>当 Linux 内 核 引 入 设 备 树 以 后 就 不 再 使 用 MACHINE_START 了 ， 而 是 换 为 了DT_MACHINE_START。 DT_MACHINE_START 也定义在文件 arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h里面，定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DT_MACHINE_START(_name, _namestr) \</span></span><br><span class="line"><span class="meta">static const struct machine_desc __mach_desc_##_name \</span></span><br><span class="line"><span class="meta">__used \</span></span><br><span class="line"><span class="meta">__attribute__((__section__(<span class="string">&quot;.arch.info.init&quot;</span>))) = &#123; \</span></span><br><span class="line"><span class="meta">.nr = ~0, \</span></span><br><span class="line"><span class="meta">.name = _namestr,</span></span><br></pre></td></tr></table></figure><p>可以看出， DT_MACHINE_START 和 MACHINE_START 基本相同，只是.nr 的设置不同，在 DT_MACHINE_START 里面直接将.nr 设置为~0。说明引入设备树以后不会再根据 machineid 来检查 Linux 内核是否支持某个设备了。 </p><p>打开文件 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-imx6ul.c，有如下所示内容： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">208</span> <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *imx6ul_dt_compat[] __initconst = &#123;</span><br><span class="line"><span class="number">209</span> <span class="string">&quot;fsl,imx6ul&quot;</span>,</span><br><span class="line"><span class="number">210</span> <span class="string">&quot;fsl,imx6ull&quot;</span>,</span><br><span class="line"><span class="number">211</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="number">212</span> &#125;;</span><br><span class="line"><span class="number">213</span></span><br><span class="line"><span class="number">214</span> DT_MACHINE_START(IMX6UL, <span class="string">&quot;Freescale i.MX6 Ultralite (Device Tree)&quot;</span>)</span><br><span class="line"><span class="number">215</span> .map_io = imx6ul_map_io,</span><br><span class="line"><span class="number">216</span> .init_irq = imx6ul_init_irq,</span><br><span class="line"><span class="number">217</span> .init_machine = imx6ul_init_machine,</span><br><span class="line"><span class="number">218</span> .init_late = imx6ul_init_late,</span><br><span class="line"><span class="number">219</span> .dt_compat = imx6ul_dt_compat,</span><br><span class="line"><span class="number">220</span> MACHINE_END</span><br></pre></td></tr></table></figure><p>machine_desc 结构体中有个.dt_compat 成员变量，此成员变量保存着本设备兼容属性，设置.dt_compat &#x3D; imx6ul_dt_compat， imx6ul_dt_compat 表里面有”fsl,imx6ul”和”fsl,imx6ull”这两个兼容值。只要某个设备(板子)根节点“ &#x2F;”的 compatible 属性值与imx6ul_dt_compat 表中的任何一个值相等，那么就表示 Linux 内核支持此设备。 </p><p>imx6ull-alientekemmc.dts 中根节点的 compatible 属性值如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="string">&quot;fsl,imx6ull&quot;</span>;</span><br></pre></td></tr></table></figure><p>其中“fsl,imx6ull”与 imx6ul_dt_compat 中的“fsl,imx6ull”匹配，因此 I.MX6U-ALPHA 开发板可以正常启动 Linux 内核。 </p><p>Linux 内核调用 start_kernel 函数来启动内核， start_kernel 函数会调用setup_arch 函数来匹配 machine_desc， setup_arch 函数定义在文件 arch&#x2F;arm&#x2F;kernel&#x2F;setup.c 中 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">913</span> <span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">914 &#123;</span><br><span class="line"><span class="number">915</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">mdesc</span>;</span></span><br><span class="line"><span class="number">916</span></span><br><span class="line"><span class="number">917</span> setup_processor();</span><br><span class="line"><span class="number">918</span> mdesc = setup_machine_fdt(__atags_pointer);</span><br><span class="line"><span class="number">919</span> <span class="keyword">if</span> (!mdesc)</span><br><span class="line"><span class="number">920</span> mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type);</span><br><span class="line"><span class="number">921</span> machine_desc = mdesc;</span><br><span class="line"><span class="number">922</span> machine_name = mdesc-&gt;name;</span><br><span class="line">......</span><br><span class="line"><span class="number">986</span> &#125;</span><br></pre></td></tr></table></figure><p>第 918 行，调用 setup_machine_fdt 函数来获取匹配的 machine_desc，参数就是 atags 的首地址，也就是 uboot 传递给 Linux 内核的 dtb 文件首地址， setup_machine_fdt 函数的返回值就是找到的最匹配的 machine_desc。 </p><p>函数 setup_machine_fdt 定义在文件 arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c 中，内容如下 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">204</span> <span class="type">const</span> <span class="keyword">struct</span> machine_desc * __init <span class="title function_">setup_machine_fdt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> dt_phys)</span></span><br><span class="line">205 &#123;</span><br><span class="line"><span class="number">206</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">mdesc</span>, *<span class="title">mdesc_best</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">214</span></span><br><span class="line"><span class="number">215</span> <span class="keyword">if</span> (!dt_phys || !early_init_dt_verify(phys_to_virt(dt_phys)))</span><br><span class="line"><span class="number">216</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">217</span></span><br><span class="line"><span class="number">218</span> mdesc = of_flat_dt_match_machine(mdesc_best,arch_get_next_mach);</span><br><span class="line"><span class="number">219</span></span><br><span class="line">......</span><br><span class="line"><span class="number">247</span> __machine_arch_type = mdesc-&gt;nr;</span><br><span class="line"><span class="number">248</span></span><br><span class="line"><span class="number">249</span> <span class="keyword">return</span> mdesc;</span><br><span class="line"><span class="number">250</span> &#125;</span><br></pre></td></tr></table></figure><p>第 218 行，调用函数 of_flat_dt_match_machine 来获取匹配的 machine_desc，参数 mdesc_best是 默 认 的 machine_desc ， 参 数 arch_get_next_mach 是 个 函 数 ， 此 函 数 定 义 在 定 义 在arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c 文件中。找到匹配的 machine_desc 的过程就是用设备树根节点的compatible 属性值和 Linux 内核中 machine_desc 下.dt_compat 的值比较，看看那个相等，如果相等的话就表示找到匹配的 machine_desc， arch_get_next_mach 函数的工作就是获取 Linux 内核中下一个 machine_desc 结构体。 </p><p>最后再来看一下 of_flat_dt_match_machine 函数，此函数定义在文件 drivers&#x2F;of&#x2F;fdt.c 中 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">705</span> <span class="type">const</span> <span class="type">void</span> * __init <span class="title function_">of_flat_dt_match_machine</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *default_match,</span></span><br><span class="line"><span class="params"><span class="number">706</span> <span class="type">const</span> <span class="type">void</span> * (*get_next_compat)(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span>**))</span></span><br><span class="line">707 &#123;</span><br><span class="line"><span class="number">708</span> <span class="type">const</span> <span class="type">void</span> *data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">709</span> <span class="type">const</span> <span class="type">void</span> *best_data = default_match;</span><br><span class="line"><span class="number">710</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> *compat;</span><br><span class="line"><span class="number">711</span> <span class="type">unsigned</span> <span class="type">long</span> dt_root;</span><br><span class="line"><span class="number">712</span> <span class="type">unsigned</span> <span class="type">int</span> best_score = ~<span class="number">1</span>, score = <span class="number">0</span>;</span><br><span class="line"><span class="number">713</span></span><br><span class="line"><span class="number">714</span> dt_root = of_get_flat_dt_root();</span><br><span class="line"><span class="number">715</span> <span class="keyword">while</span> ((data = get_next_compat(&amp;compat))) &#123;</span><br><span class="line"><span class="number">716</span> score = of_flat_dt_match(dt_root, compat);</span><br><span class="line"><span class="number">717</span> <span class="keyword">if</span> (score &gt; <span class="number">0</span> &amp;&amp; score &lt; best_score) &#123;</span><br><span class="line"><span class="number">718</span> best_data = data;</span><br><span class="line"><span class="number">719</span> best_score = score;</span><br><span class="line"><span class="number">720</span> &#125;</span><br><span class="line"><span class="number">721</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">739</span></span><br><span class="line"><span class="number">740</span> pr_info(<span class="string">&quot;Machine model: %s\n&quot;</span>, of_flat_dt_get_machine_name());</span><br><span class="line"><span class="number">741</span></span><br><span class="line"><span class="number">742</span> <span class="keyword">return</span> best_data;</span><br><span class="line"><span class="number">743</span> &#125;</span><br></pre></td></tr></table></figure><p>第 714 行，通过函数 of_get_flat_dt_root 获取设备树根节点。<br>第 715~720 行，此循环就是查找匹配的 machine_desc 过程，第 716 行的 of_flat_dt_match 函数会将根节点 compatible 属性的值和每个 machine_desc 结构体中. dt_compat 的值进行比较，直至找到匹配的那个 machine_desc。 </p><p>Linux 内核通过根节点 compatible 属性找到对应的设备的函数调用过程 如下：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-08%20105607.png"></p><h4 id="向节点追加或修改内容"><a href="#向节点追加或修改内容" class="headerlink" title="向节点追加或修改内容"></a>向节点追加或修改内容</h4><p>打开imx6ull.dtsi文件进行追加内容，因为imx6ull.dtsi是设备头文件，所有使用IMX6ULL这个soc的板子都会引用这个文件，向文件中添加一个设备节点，相当于所有的板子都会添加这个设备，所以要在自己板子的.dts文件进行数据追加内容。</p><p>比如要向I2C1节点追加一个fxls8471的子节点，需要在imx6ull-alientek-emmc.dts 文件中完成数据追加的内容，方式如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;i2c1 &#123;</span><br><span class="line"><span class="number">2</span> <span class="comment">/* 要追加或修改的内容 */</span></span><br><span class="line"><span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p>第 1 行， &amp;i2c1 表示要访问 i2c1 这个 label 所对应的节点，也就是 imx6ull.dtsi 中的“i2c1:i2c@021a0000”。<br>第 2 行，花括号内就是要向 i2c1 这个节点添加的内容，包括修改某些属性的值。 </p><p>打开 imx6ull-alientek-emmc.dts，找到如下所示内容： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">224</span> &amp;i2c1 &#123;</span><br><span class="line"><span class="number">225</span> clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line"><span class="number">226</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">227</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line"><span class="number">228</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">229</span></span><br><span class="line"><span class="number">230</span> mag3110@<span class="number">0</span>e &#123;</span><br><span class="line"><span class="number">231</span> compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line"><span class="number">232</span> reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line"><span class="number">233</span> position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line"><span class="number">234</span> &#125;;</span><br><span class="line"><span class="number">235</span></span><br><span class="line"><span class="number">236</span> fxls8471@<span class="number">1</span>e &#123;</span><br><span class="line"><span class="number">237</span> compatible = <span class="string">&quot;fsl,fxls8471&quot;</span>;</span><br><span class="line"><span class="number">238</span> reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line"><span class="number">239</span> position = &lt;<span class="number">0</span>&gt;;</span><br><span class="line"><span class="number">240</span> interrupt-parent = &lt;&amp;gpio5&gt;;</span><br><span class="line"><span class="number">241</span> interrupts = &lt;<span class="number">0</span> <span class="number">8</span>&gt;;</span><br><span class="line"><span class="number">242</span> &#125;;</span><br><span class="line"><span class="number">243</span>&#125;</span><br></pre></td></tr></table></figure><p>本代码就是向 i2c1 节点添加&#x2F;修改数据，比如第 225 行的属性“clock-frequency”就表示 i2c1 时钟为 100KHz。“clock-frequency”就是新添加的属性。<br>第 228 行，将 status 属性的值由原来的 disabled 改为 okay。<br>第 230<del>234 行， i2c1 子节点 mag3110，因为 NXP 官方开发板在 I2C1 上接了一个磁力计芯片 mag3110，正点原子的 I.MX6U-ALPHA 开发板并没有使用 mag3110。<br>第 236</del>242 行， i2c1 子节点 fxls8471，同样是因为 NXP 官方开发板在 I2C1 上接了 fxls8471这颗六轴芯片 。</p><h3 id="创建小型模板设备树"><a href="#创建小型模板设备树" class="headerlink" title="创建小型模板设备树"></a>创建小型模板设备树</h3><p>以 I.MX6ULL 这个 SOC 为例，我们需要在设备树里面描述的内容如下：<br>①、 I.MX6ULL 这个 Cortex-A7 架构的 32 位 CPU。<br>②、 I.MX6ULL 内部 ocram，起始地址 0x00900000，大小为 128KB(0x20000)。<br>③、 I.MX6ULL 内部 aips1 域下的 ecspi1 外设控制器，寄存器起始地址为 0x02008000，大小为 0x4000。<br>④、 I.MX6ULL 内部 aips2 域下的 usbotg1 外设控制器，寄存器起始地址为 0x02184000，大小为 0x4000。<br>⑤、 I.MX6ULL 内部 aips3 域下的 rngb 外设控制器，寄存器起始地址为 0x02284000，大小为 0x4000。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-09%20151328.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">compatible = <span class="string">&quot;fsl, imx6ull-alientek-evk&quot;</span>, <span class="string">&quot;fsl, imx6ull&quot;</span>;</span><br><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;<span class="comment">//基地址、片选号等绝对起始地址所占字长</span></span></span><br><span class="line">      <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;<span class="comment">//长度所占字长</span></span></span><br><span class="line">    cpu0 : cpu@<span class="number">0</span>&#123;</span><br><span class="line">      compatible = <span class="string">&quot;arm ,cortex-a7&quot;</span>;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  soc &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">      <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">      compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">      ranges;</span><br><span class="line">      ocram: sram@<span class="number">00900000</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;fsl, lpm-sram&quot;</span>;</span><br><span class="line">      reg = &lt;<span class="number">0x00900000</span> <span class="number">0x20000</span>&gt;;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      apis1: aips-bus@<span class="number">02000000</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;fsl, aip-bus&quot;</span>, <span class="string">&quot;simble-bus&quot;</span>;</span><br><span class="line">        <span class="meta">#address-cells  = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        reg = &lt;<span class="number">0x2000000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line">        ranges;</span><br><span class="line">      </span><br><span class="line">        ecspi1: ecspi@<span class="number">02008000</span> &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">          <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">          compatible = <span class="string">&quot;fsl, imx6ul-ecspi&quot;</span>, <span class="string">&quot;fsl, imx5-ecspi&quot;</span>;</span><br><span class="line">          reg = &lt;<span class="number">0x02008000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">          status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      apis2: aips-bus@<span class="number">02100000</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;fsl, apis-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        reg = &lt;<span class="number">0x02100000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line">        ranges;</span><br><span class="line">        </span><br><span class="line">        usbotg1: usb@<span class="number">02184000</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;fsl, imx6ul-usb&quot;</span> , <span class="string">&quot;fsl, imx27-usb&quot;</span>;</span><br><span class="line">          reg = &lt;<span class="number">0x02184000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">          status  = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      aips3: aips-bus@<span class="number">02200000</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">reg = &lt;<span class="number">0x02200000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line">ranges;</span><br><span class="line"></span><br><span class="line">rngb: rngb@<span class="number">02284000</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;fsl,imx6sl-rng&quot;</span>, <span class="string">&quot;fsl,imx-rng&quot;</span>, <span class="string">&quot;imxrng&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x02284000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设备树在系统中的体现"><a href="#设备树在系统中的体现" class="headerlink" title="设备树在系统中的体现"></a>设备树在系统中的体现</h3><p>Linux 内核启动的时候会解析设备树中各个节点的信息，并且在根文件系统的&#x2F;proc&#x2F;devicetree 目录下根据节点名字创建不同文件夹， 可以使用cat命令来查看model和compatible文件信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd proc/devicetree</span><br><span class="line">cat model</span><br><span class="line">cat compatible</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;device-tree 目录就是设备树在根文件系统中的体现，同样是按照树形结构组织的，进入&#x2F;proc&#x2F;device-tree&#x2F;soc 目录中就可以看到 soc 节点的所有子节点 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd soc</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><h3 id="Linux内核解析DTB文件"><a href="#Linux内核解析DTB文件" class="headerlink" title="Linux内核解析DTB文件"></a>Linux内核解析DTB文件</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-09%20154941.png"></p><h3 id="如何添加节点"><a href="#如何添加节点" class="headerlink" title="如何添加节点"></a>如何添加节点</h3><p>可以查看Linux的源码下的&#x2F;Documentation&#x2F;devicetree&#x2F;bindings，添加哪个就看哪个文件。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-09%20155142.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新字符设备驱动开发</title>
      <link href="/2023/04/06/2023-4-7-%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/04/06/2023-4-7-%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h3><p>Linux的设备管理是和文件系统紧密结合的，各种设备都以文件的形式存放在&#x2F;dev目录下，称为设备文件。应用程序可以打开、关闭和读写这些设备文件，完成对设备的操作，就像操作普通的数据文件一样。为了管理这些设备，系统为设备编了号，每个设备号又分为主设备号和次设备号。<strong>主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。</strong>对于常用设备，Linux有约定俗成的编号，如硬盘的主设备号是3。</p><p>一个字符设备或者块设备都有一个主设备号和次设备号。主设备号和次设备号统称为设备号。主设备号用来表示一个特定的驱动程序。次设备号用来表示使用该驱动程序的各设备。例如一个嵌入式系统，有两个LED指示灯，LED灯需要独立的打开或者关闭。那么，可以写一个LED灯的字符设备驱动程序，可以将其主设备号注册成5号设备，次设备号分别为1和2。这里，次设备号就分别表示两个LED灯。</p><p> 函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysmacros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line">MKDEV(<span class="type">int</span> major,<span class="type">int</span> minor) <span class="comment">//major为主设备号 minor为次设备号。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(major,minor) (((major) &lt;&lt; MINORBITS) | (minor))。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">major</span><span class="params">(<span class="type">dev_t</span> dev)</span>;<span class="comment">//获取主设备号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">minor</span><span class="params">(<span class="type">dev_t</span> dev)</span>;<span class="comment">//获取次设备号</span></span><br></pre></td></tr></table></figure><p>在程序中用宏MAJOR(dev_t  dev)可以解析出主设备号，用宏MINOR(dev_t dev)可以解析出次设备号</p><h4 id="申请设备号"><a href="#申请设备号" class="headerlink" title="申请设备号"></a>申请设备号</h4><p>动态申请设备号，没有指定设备号用以下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure><p>dev :alloc_chrdev_region函数向内核申请下来的设备号</p><p>baseminor :次设备号的起始</p><p>count: 申请次设备号的个数</p><p>name :执行 cat &#x2F;proc&#x2F;devices显示的名称</p><p>静态申请设备号，给定了设备的主设备号和次设备号就使用如下所示函数来注册设备号即可： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure><p>from:起始设备号</p><p>count：数量设备</p><p>name：设备名字</p><p>注 销 字 符 设 备 之 后 要 释 放 掉 设 备 号 ， 不 管 是 通 过 alloc_chrdev_region 函 数 还 是register_chrdev_region 函数申请的设备号，统一使用如下释放函数： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count)</span></span><br></pre></td></tr></table></figure><p>新字符设备驱动下，设备号分配如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> major; <span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="type">int</span> minor; <span class="comment">/* 次设备号 */</span></span><br><span class="line"><span class="type">dev_t</span> devid; <span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="keyword">if</span> (major) </span><br><span class="line">&#123; <span class="comment">/* 定义了主设备号 */</span></span><br><span class="line">  devid = MKDEV(major, <span class="number">0</span>); <span class="comment">/* 大部分驱动次设备号都选择 0*/</span></span><br><span class="line">register_chrdev_region(devid, <span class="number">1</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">alloc_chrdev_region(&amp;devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">/* 申请设备号 */</span></span><br><span class="line">major = MAJOR(devid); <span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">minor = MINOR(devid); <span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符设备结构"><a href="#字符设备结构" class="headerlink" title="字符设备结构"></a>字符设备结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span><span class="comment">//是一个嵌入在该结构中的内核对象。它用于该数据结构的一般管理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">//owner指向提供驱动程序的模块</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span><span class="comment">//ops是一组文件操作，实现了与硬件通信的具体操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">//list用来实现一个链表，其中包含所有表示该设备的设备特殊文件的inode</span></span><br><span class="line"><span class="type">dev_t</span> dev;<span class="comment">//dev指定了设备号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;<span class="comment">//表示与该设备关联的从设备的数目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>cdev两种定义初始化方式：<a href="https://blog.csdn.net/daocaokafei/article/details/119720422"> Linux驱动|cdev_init、cdev_alloc区别_一口Linux的博客-CSDN博客</a></p><p><strong>静态初始化：cdev_init函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span> </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">my_cdev</span>;</span></span><br><span class="line">cdev_init(&amp;my_cdev, &amp;fops);</span><br><span class="line">my_cdev.owner = THIS_MODULE;</span><br><span class="line">my_cdev.ops = &amp;fops;</span><br></pre></td></tr></table></figure><p><strong>动态初始化：cdev_alloc函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">my_cdev</span> =</span> cdev_alloc();</span><br><span class="line">my_cdev-&gt;ops = &amp;fops;</span><br><span class="line">my_cdev-&gt;owner = THIS_MODULE;</span><br></pre></td></tr></table></figure><p>将cdev添加到系统中去 <strong>cdev_add函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">testcdev</span>;</span></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">test_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line"> <span class="comment">/* 其他具体的初始项 */</span></span><br><span class="line">&#125;;</span><br><span class="line">testcdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;testcdev, &amp;test_fops); <span class="comment">/* 初始化 cdev 结构体变量 */</span></span><br><span class="line">cdev_add(&amp;testcdev, devid, <span class="number">1</span>); <span class="comment">/* 添加字符设备 */</span></span><br></pre></td></tr></table></figure><p><strong>cdev_del 函数</strong> </p><p>卸载驱动的时候一定要使用 cdev_del 函数从 Linux 内核中删除相应的字符设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span></span><br></pre></td></tr></table></figure><p>参数 p 就是要删除的字符设备。如果要删除字符设备，参考如下代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdev_del(&amp;testcdev); <span class="comment">/* 删除 cdev */</span></span><br></pre></td></tr></table></figure><p>cdev_del 和 unregister_chrdev_region 这两个函数合起来的功能相当于 unregister_chrdev 函数。 </p><h3 id="自动创建设备节点"><a href="#自动创建设备节点" class="headerlink" title="自动创建设备节点"></a>自动创建设备节点</h3><p>早期的Linux内核（版本2.4之前）并没有实现一个统一的设备模型，设备节点的创建一般是mknod命令手动创建或利用devfs文件系统创建。早期的Linux发行版一般会采用手动创建的方式预先把通常用到的节点都创建出来，而嵌入式系统则会采用devfs的方式。起初Linux2.6 内核还支持devfs，但从2.6.18开始，内核完全移除了devfs系统而采用的udev的方式动态的创建设备节点。因此，新的Linux发行版都采用udev的方式管理设备节点文件。<br>class可以自动创建设备节点，不需要udev，而udev自动创建节点需要用到class。</p><h4 id="创建和删除类"><a href="#创建和删除类" class="headerlink" title="创建和删除类"></a>创建和删除类</h4><p>自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添加自动创建设备节点相关代码。首先要创建一个 class 类， class 是个结构体，定义在文件include&#x2F;linux&#x2F;device.h 里面。 class_create 是类创建函数， class_create 是个宏定义。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> class_create(owner, name) \</span></span><br><span class="line"><span class="meta">(&#123; \</span></span><br><span class="line"><span class="meta">static struct lock_class_key __key; \</span></span><br><span class="line"><span class="meta">__class_create(owner, name, &amp;__key); \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *__<span class="title">class_create</span>(<span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>,<span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>)</span></span><br></pre></td></tr></table></figure><p>根据上述代码，将宏 class_create 展开以后内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class *<span class="title function_">class_create</span> <span class="params">(<span class="keyword">struct</span> module *owner, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure><p>class_create 一共有两个参数，参数 owner 一般为 THIS_MODULE，参数 name 是类名字。<br>返回值是个指向结构体 class 的指针，也就是创建的类。<br>卸载驱动程序的时候需要删除掉类，类删除函数为 class_destroy，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">class_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls)</span>;</span><br></pre></td></tr></table></figure><p>参数 cls 就是要删除的类。 </p><h4 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h4><p>使用 device_create 函数在类下面创建设备， device_create 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="keyword">struct</span> class *class,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> device *parent,</span></span><br><span class="line"><span class="params">                                <span class="type">dev_t</span> devt,</span></span><br><span class="line"><span class="params">                                <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br></pre></td></tr></table></figure><p>device_create 是个可变参数函数，参数 class 就是设备要创建哪个类下面；参数 parent 是父设备，一般为 NULL，也就是没有父设备；参数 devt 是设备号；参数 drvdata 是设备可能会使用的一些数据，一般为 NULL；参数 fmt 是设备名字，如果设置 fmt&#x3D;xxx 的话，就会生成&#x2F;dev&#x2F;xxx这个设备文件。返回值就是创建好的设备。<br>同样的，卸载驱动的时候需要删除掉创建的设备，设备删除函数为 device_destroy，函数原型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">device_destroy</span><span class="params">(<span class="keyword">struct</span> class *class, <span class="type">dev_t</span> devt)</span></span><br></pre></td></tr></table></figure><p>参数 class 是要删除的设备所处的类，参数 devt 是要删除的设备号。</p><h3 id="设置文件私有数据"><a href="#设置文件私有数据" class="headerlink" title="设置文件私有数据"></a>设置文件私有数据</h3><p>每个硬件设备都有一些属性，比如主设备号(dev_t)，类(class)、设备(device)、开关状态(state)等等，在编写驱动的时候你可以将这些属性全部写成变量的形式 ，一般以设备的所有属性来作为一个结构体。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid; <span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span> <span class="comment">/* cdev */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span> <span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">/* 设备 */</span></span><br><span class="line"><span class="type">int</span> major; <span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="type">int</span> minor; <span class="comment">/* 次设备号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_dev</span> <span class="title">testdev</span>;</span></span><br><span class="line"><span class="comment">/* open 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;testdev; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 open 函数里面设置好私有数据以后，在 write、 read、 close 等函数中直接读取 private_data即可得到设备结构体。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-07%20100106.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>NEWCHRLED_CNT1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>NEWCHRLED_NAME<span class="string">&quot;newchrled&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_MAJOR200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>LED_NAME<span class="string">&quot;led&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>CCM_CCGR1_BASE(0X020C406C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_DR_BASE(0X0209C000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_GDIR_BASE(0X0209C004)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> on1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>off0</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"><span class="comment">//设备属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newchrled_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span><span class="title">cdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="type">int</span> major;</span><br><span class="line"><span class="type">int</span> minor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newchrled_dev</span> <span class="title">newchrled</span>;</span><span class="comment">//led 设备</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 num;</span><br><span class="line"><span class="keyword">if</span>(sta == on)</span><br><span class="line">&#123;</span><br><span class="line">num =readl(GPIO1_DR);</span><br><span class="line">num &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( num, GPIO1_DR);</span><br><span class="line">printk(<span class="string">&quot;on\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sta == off)</span><br><span class="line">&#123;</span><br><span class="line">num = readl(GPIO1_DR);</span><br><span class="line">num |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( num, GPIO1_DR);</span><br><span class="line">printk(<span class="string">&quot;off\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_dev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;newchrled;<span class="comment">//设置私有数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_dev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_dev_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_dev_write</span><span class="params">(<span class="keyword">struct</span> file *filp,<span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state ;</span><br><span class="line"></span><br><span class="line">val = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(val &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kernl write failed \r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">state = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(state == on)</span><br><span class="line">led_switch(on);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state == off)</span><br><span class="line">led_switch(off);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_dev_open,</span><br><span class="line">.read = led_dev_read,</span><br><span class="line">.write = led_dev_write,</span><br><span class="line">.release = led_dev_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//int value = 0;</span></span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line">CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="number">4</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="number">4</span>); </span><br><span class="line">GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">val = readl(CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);<span class="comment">//CCM_CCGR1的第27和26位控制GPIO1 clock的使能</span></span><br><span class="line">val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">writel(val, CCM_CCGR1);</span><br><span class="line"><span class="comment">//GPIO复位</span></span><br><span class="line">writel(<span class="number">5</span>,SW_MUX_GPIO1_IO03);</span><br><span class="line"><span class="comment">//配置电器属性 </span></span><br><span class="line">writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line"><span class="comment">//配置输出模式</span></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_GDIR);</span><br><span class="line">    <span class="comment">//默认关闭led</span></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( val , GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册设备驱动</span></span><br><span class="line"><span class="keyword">if</span>(newchrled.major)</span><br><span class="line">&#123;</span><br><span class="line">newchrled.devid = MKDEV(newchrled.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(newchrled.devid, <span class="number">1</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">alloc_chrdev_region(&amp;newchrled.devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">newchrled.major = MAJOR(newchrled.devid);</span><br><span class="line">newchrled.minor = MINOR(newchrled.devid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">cdev_init(&amp;newchrled.cdev, &amp;led_fops);</span><br><span class="line">newchrled.cdev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加到系统中</span></span><br><span class="line">cdev_add(&amp;newchrled.cdev, newchrled.devid, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//创建类</span></span><br><span class="line">newchrled.class = class_create(THIS_MODULE , <span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(newchrled.class))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建设备</span></span><br><span class="line">newchrled.device = device_create(newchrled.class, <span class="literal">NULL</span>, newchrled.devid, <span class="literal">NULL</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(newchrled.device))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">iounmap(CCM_CCGR1);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line"><span class="comment">//注销led设备</span></span><br><span class="line">cdev_del(&amp;newchrled.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">unregister_chrdev_region(newchrled.devid, NEWCHRLED_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">device_destroy(newchrled.class, newchrled.devid);</span><br><span class="line">class_destroy(newchrled.class);</span><br><span class="line">printk(<span class="string">&quot;led exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LED驱动开发</title>
      <link href="/2023/04/04/2023-4-4-LED%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/04/04/2023-4-4-LED%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><p>MMU(Memory Manage Unit)为内存管理单元，Linux内核2.6以前必须要有MMU，之后支持无MMU的处理器。MMU的功能有：</p><p>①完成虚拟空间到物理空间的映射。②内存保护，设置存储器的访问权限，设置虚拟存储空间的缓冲特性。Linux 内核启动的时候会初始化 MMU，设置好内存映射，设置好以后 CPU 访问的都是虚拟 地 址 。 比 如 I.MX6ULL 的GPIO1_IO03 引 脚 的 复 用 寄 存 器IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 的地址为 0X020E0068。如果没有开启MMU 的话直接向 0X020E0068 这个寄存器地址写入数据就可以配置 GPIO1_IO03 的复用功能。现在开启了 MMU，并且设置了内存映射，因此就不能直接向 0X020E0068 这个地址写入数据了。我们必须得到 0X020E0068 这个物理地址在 Linux 系统里面对应的虚拟地址，这里就涉及到了物理内存和虚拟内存之间的转换，需要用到两个函数： ioremap 和 iounmap。 </p><h4 id="ioremap函数"><a href="#ioremap函数" class="headerlink" title="ioremap函数"></a>ioremap函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ioremap(cookie,size) __arm_ioremap((cookie), (size),MT_DEVICE)</span></span><br><span class="line"><span class="type">void</span> __iomem * __arm_ioremap(<span class="type">phys_addr_t</span> phys_addr, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> mtype)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> arch_ioremap_caller(phys_addr, size,mtype,__builtin_return_address(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>phys_addr：要映射的物理起始地址。<br>size：要映射的内存空间大小。<br>mtype： ioremap 的类型，可以选择 MT_DEVICE、MT_DEVICE_NONSHARED、MT_DEVICE_CACHED 和 MT_DEVICE_WC， ioremap 函数选择 MT_DEVICE。<br>返回值： __iomem 类型的指针，指向映射后的虚拟空间首地址。 </p><p>假如我们要获取 I.MX6ULL 的 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 寄存器对应的虚拟地址，使用如下代码即可： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SW_MUX_GPIO1_IO03_BASE (0X020E0068)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem* SW_MUX_GPIO1_IO03;</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>宏 SW_MUX_GPIO1_IO03_BASE 是寄存器物理地址， SW_MUX_GPIO1_IO03 是映射后的虚拟地址。对于 I.MX6ULL 来说一个寄存器是 4 字节(32 位)的，因此映射的内存长度为 4。映射完成以后直接对 SW_MUX_GPIO1_IO03 进行读写操作即可。 </p><h4 id="iounmap函数"><a href="#iounmap函数" class="headerlink" title="iounmap函数"></a>iounmap函数</h4><p>卸载驱动的时候需要使用 iounmap 函数释放掉 ioremap 函数所做的映射， iounmap 函数原型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iounmap</span> <span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br></pre></td></tr></table></figure><p>iounmap 只有一个参数 addr，此参数就是要取消映射的虚拟地址空间首地址。 </p><h3 id="I-x2F-O内存访问"><a href="#I-x2F-O内存访问" class="headerlink" title="I&#x2F;O内存访问"></a>I&#x2F;O内存访问</h3><p><strong>当外部寄存器或内存映射到 IO 空间时，称为 I&#x2F;O 端口。</strong><br><strong>当外部寄存器或内存映射到内存空间时，称为 I&#x2F;O 内存。</strong> </p><p><u>但是对于 ARM 来说没有 I&#x2F;O 空间这个概念，因此 ARM 体系下只有 I&#x2F;O 内存(可以直接理解为内存)。</u> </p><h4 id="读操作函数"><a href="#读操作函数" class="headerlink" title="读操作函数"></a>读操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">readb</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">u16 <span class="title function_">readw</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">u32 <span class="title function_">readl</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br></pre></td></tr></table></figure><p>参数 addr 就是要读取写内存地址，返回值就是读取到的数据。 </p><h4 id="写操作函数"><a href="#写操作函数" class="headerlink" title="写操作函数"></a>写操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">writeb</span><span class="params">(u8 value, <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writew</span><span class="params">(u16 value, <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writel</span><span class="params">(u32 value, <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br></pre></td></tr></table></figure><p>参数 value 是要写入的数值， addr 是要写入的地址。 </p><h3 id="写LED驱动程序"><a href="#写LED驱动程序" class="headerlink" title="写LED驱动程序"></a>写LED驱动程序</h3><p>首先在汇编点亮LED的程序里面使能了imx6ull的外设时钟，使能GPIO1_03,配置了IO口的属性，之后进行了初始化，DR寄存器置位点灯。</p><p>LED的驱动开发首先要查出所要用到的寄存器的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CCGR1的地址</span></span><br><span class="line">CCM_CCGR1<span class="number">20</span>C_406Ch</span><br><span class="line"><span class="comment">//GPIO1_03的地址</span></span><br><span class="line">IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03<span class="number">20</span>E_02F4h</span><br><span class="line">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03<span class="number">20</span>E_0068h</span><br><span class="line">GPIO1_DR<span class="number">209</span>_C000h</span><br><span class="line">GPIO1_GDIR<span class="number">20</span>A_0004h</span><br></pre></td></tr></table></figure><p>GPIO1_DR和GPIO1_GPIR的地址实在GPIO memory map（GPIO的地址映射）中寻找。</p><p><strong>DR（data register）</strong>，即数据寄存器，它是32位的，一个GPIO组最大只有32个IO，因此DR寄存器中的每个位都对应一个 GPIO。</p><ul><li>当GPIO被配置为<strong>输出模式</strong>后，向指定的位写入数据那么相应的IO就会输出相应的高低电平，例如，要设置GPIO5_IO03输出低电平，那么就应该设置 GPIO5.DR&#x3D;0x08。</li><li>当 GPIO被配置为<strong>输入模式</strong>后，此寄存器就保存着对应IO的电平值，每个位对对应一个GPIO，例如，当GPIO5_IO03这个引脚接地的话，那么 GPIO5.DR 的bit3就是0。</li></ul><p><strong>GDIR（GPIO direction register）</strong>，即方向寄存器，也是32位的，用来设置某个GPIO的工作方向的，即输入&#x2F;输出。</p><p>同样的，每个IO对应一个位，如果要设置GPIO为输入，就设置相应的位为0，如果要设置为输出，就设置为 1。</p><h3 id="程序以及搭建思路"><a href="#程序以及搭建思路" class="headerlink" title="程序以及搭建思路"></a>程序以及搭建思路</h3><h4 id="led驱动步骤："><a href="#led驱动步骤：" class="headerlink" title="led驱动步骤："></a>led驱动步骤：</h4><p>①、书写字符设备驱动框架，添加头文件，定义file_operations，以及相关函数框架。<br>②、添加地址宏定义创建指针，以及在入口函数中实现虚拟地址的映射，注册设备。<br>③、在出接口地址中取消虚拟地址的映射，注销设备。<br>④、在open函数中实现GPIO的使能，以及IO引脚的配置。<br>⑤、在write函数中从应用层获取数据，来根据数据来进行GPIO的输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_MAJOR200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>LED_NAME<span class="string">&quot;led&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>CCM_CCGR1_BASE(0X020C406C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_DR_BASE(0X0209C000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_GDIR_BASE(0X0209C004)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> on1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>off0</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 num;</span><br><span class="line"><span class="keyword">if</span>(sta == on)</span><br><span class="line">&#123;</span><br><span class="line">num =readl(GPIO1_DR);</span><br><span class="line">num &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( num, GPIO1_DR);</span><br><span class="line">printk(<span class="string">&quot;on\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sta == off)</span><br><span class="line">&#123;</span><br><span class="line">num = readl(GPIO1_DR);</span><br><span class="line">num |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( num, GPIO1_DR);</span><br><span class="line">printk(<span class="string">&quot;off\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_dev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_dev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_dev_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_dev_write</span><span class="params">(<span class="keyword">struct</span> file *filp,<span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state ;</span><br><span class="line"></span><br><span class="line">val = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(val &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kernl write failed \r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">state = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(state == on)</span><br><span class="line">led_switch(on);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state == off)</span><br><span class="line">led_switch(off);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_dev_open,</span><br><span class="line">.read = led_dev_read,</span><br><span class="line">.write = led_dev_write,</span><br><span class="line">.release = led_dev_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line">CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="number">4</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="number">4</span>); </span><br><span class="line">GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="number">4</span>);    </span><br><span class="line">val = readl(CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);<span class="comment">//CCM_CCGR1的第27和26位控制GPIO1 clock的使能</span></span><br><span class="line">val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">writel(val, CCM_CCGR1);</span><br><span class="line"><span class="comment">//GPIO复位</span></span><br><span class="line">writel(<span class="number">5</span>,SW_MUX_GPIO1_IO03);</span><br><span class="line"><span class="comment">//配置电器属性 </span></span><br><span class="line">writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line"><span class="comment">//配置输出模式</span></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_GDIR);</span><br><span class="line">    <span class="comment">//默认关闭led</span></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( val , GPIO1_DR);</span><br><span class="line">value = register_chrdev(LED_MAJOR, LED_NAME, &amp;led_fops);</span><br><span class="line"><span class="keyword">if</span>(value &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;led register failed\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">iounmap(CCM_CCGR1);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line"><span class="comment">//注销led设备</span></span><br><span class="line">unregister_chrdev(LED_MAJOR, LED_NAME);</span><br><span class="line">printk(<span class="string">&quot;led exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="应用层程序"><a href="#应用层程序" class="headerlink" title="应用层程序"></a>应用层程序</h4><p>搭建思路：</p><p>①、获取命令行的数据<br>②、打开设备<br>③、写入指令<br>④、关闭设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  value;</span><br><span class="line">    FILE *fp == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *filename</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">    filename = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(filename, <span class="string">&quot;w+&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen error:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功!\n&quot;</span>);</span><br><span class="line">    databuf[<span class="number">0</span>] = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">sizeof</span>(buf) &gt; fwrite(databuf, <span class="number">1</span>, <span class="keyword">sizeof</span>(databuf), fp))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fwrite error\n&quot;</span>);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据写入成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Makefile文件编写，跟之前一样。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KERNELDIR := /home/moss/linux/imx-kernel/linux-fslc-4.9-2.0.x-imx</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line">obj-m := led.o</span><br><span class="line"></span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符设备驱动开发</title>
      <link href="/2023/04/01/2023-4-1-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/04/01/2023-4-1-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="字符设备驱动简介"><a href="#字符设备驱动简介" class="headerlink" title="字符设备驱动简介"></a>字符设备驱动简介</h3><p>字符设备是Linux驱动基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的；数据是实时传输的，没有缓存，字符设备是没有文件系统的。</p><p>绝大部分设备驱动是字符设备：LED、按键、声卡、IIC、SPI、LCD、摄像头等都是字符设备。这些设备的驱动都是字符设备驱动。</p><p>在 Linux 中一切皆为文件，驱动加载成功以后会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx” (xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。 </p><p>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间。当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开&#x2F;dev&#x2F;led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入” 到内核空间，这样才能实现对底层驱动的操作。 </p><h3 id="驱动模块加载和卸载"><a href="#驱动模块加载和卸载" class="headerlink" title="驱动模块加载和卸载"></a>驱动模块加载和卸载</h3><p>Linux 驱动有两种运行方式，第一种就是将驱动编译进 Linux 内核中，这样当 Linux 内核启动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)，在Linux 内核启动以后使用“insmod”命令加载驱动模块，或者使用modprobe命令来加载驱动模块，modprobe命令的好处是将这个驱动的依赖项同时加载上，但是要在特定的目录下才能执行（后续再说）。</p><p>模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和卸载注册函数如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(xxx_init); <span class="comment">//注册模块加载函数</span></span><br><span class="line">module_exit(xxx_exit); <span class="comment">//注册模块卸载函数</span></span><br></pre></td></tr></table></figure><p>module_init 函数用来向 Linux 内核注册一个模块加载函数，xxx_init 就是需要注册的具体函数，当使用“insmod”命令加载驱动的时候， xxx_init 这个函数就会被调用。 module_exit()函数用来向 Linux 内核注册一个模块卸载函数，参数 xxx_exit 就是需要注册的具体函数，当使用“rmmod”命令卸载具体驱动的时候 xxx_exit 函数就会被调用。 </p><blockquote><p>编写一个chrdevbase的驱动</p></blockquote><p>首先根据加载模板写出chrdevabase.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdevbase_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动字符入口函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdevbase_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">module_init(chrdevbase_init);</span><br><span class="line">module_exit(chrdevbase_exit);</span><br></pre></td></tr></table></figure><p>编写Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">KERNELDIR := /home/moss/linux/imx-kernel/linux-fslc-4.9-2.0.x-imx</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">obj-m := chrdevbase.o</span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure><p>第 1 行， KERNELDIR 表示开发板所使用的 Linux 内核源码目录，使用绝对路径，大家根据自己的实际情况填写即可。可以在内核目录中使用pwd来进行查询。<br>第 2 行， CURRENT_PATH 表示当前路径，直接通过运行“pwd”命令来获取当前所处路径。<br>第 3 行， obj-m 表示将 chrdevbase.c 这个文件作为模块进行编译（用来获取.ko驱动模块文件），如果是编译到内核是obj -y。<br>第 86行，具体的编译命令，后面的 modules 表示编译模块， -C 表示将当前的工作目录切换到指定目录中，也就是 KERNERLDIR 目录。 M 表示模块源码目录，“make modules”命令中加入 M&#x3D;dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件。 </p><p>之后在根文件系统中使用modprobe加载模块命令来看缺失的文件，之后都创立好，将编译好的.ko文件复制到下面，之后可使用modprobe命令加载设备，或者使用rmmod卸载设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe chrdevbase.ko</span><br><span class="line">rmmod chrdevbase.ko</span><br></pre></td></tr></table></figure><p>在板子的命令终端使用（推荐使用软件MobaXterm来查看串口）。</p><h3 id="字符设备注册与注销"><a href="#字符设备注册与注销" class="headerlink" title="字符设备注册与注销"></a>字符设备注册与注销</h3><p>对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备。字符设备的注册和注销函数原型如下所示: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name,<span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">unregister_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure><p>major： 主设备号， Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分，关于设备号后面会详细讲解。<br>name：设备名字，指向一串字符串。查看设备中的设备号可以使用“<strong>cat &#x2F;proc&#x2F;devices</strong> ”来查看。<br>fops： 结构体 file_operations 类型指针，指向设备的操作函数集合变量。 （每个驱动都是运用一部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">                                        <span class="comment">/*file_operations结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">int</span> (*mremap)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line"><span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, unsignedlong)</span>;</span><br><span class="line"><span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line"><span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,<span class="type">loff_t</span> len);</span><br><span class="line"><span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line"><span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="字符设备驱动框架"><a href="#字符设备驱动框架" class="headerlink" title="字符设备驱动框架"></a>字符设备驱动框架</h3><p>设备的具体操作函数就是通过file_operations结构体来进行设置，首先初始化之前要进行分析需求，也就是对chrtest这个设备进行哪些操作，才知道要实现哪些操作函数。此设置是假设对字符设备进行打开和关闭操作（基本设备都要打开关闭），对字符设备进行读写（假设  这个设备控制着一段缓冲区(内存)，应用程序需要通过 read 和 write 这两个函数对 chrtest 的缓冲区进行读写操作 ）。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-03%20172521.png"></p><p>所以进行修改chrdevbase.c文件内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrtest_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrtest_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrtest_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf , <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrtest_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">test_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = chrtest_open,</span><br><span class="line">.read = chrtest_read,</span><br><span class="line">.write = chrtest_write,</span><br><span class="line">.release = chrtest_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdevbase_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动字符入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    value = register_chrdev(<span class="number">200</span>, <span class="string">&quot;chrtest&quot;</span>, &amp;test_fops);</span><br><span class="line">    <span class="keyword">if</span>(value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    printk(<span class="string">&quot;注册失败\n&quot;</span>);<span class="comment">//内核空间的printf</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdevbase_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev(<span class="number">200</span>, <span class="string">&quot;chrtest&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(chrdevbase_init);</span><br><span class="line">module_exit(chrdevbase_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//防止加载模块警告</span></span><br></pre></td></tr></table></figure><h3 id="关于设备号码"><a href="#关于设备号码" class="headerlink" title="关于设备号码"></a>关于设备号码</h3><h4 id="静态分配设备号"><a href="#静态分配设备号" class="headerlink" title="静态分配设备号"></a>静态分配设备号</h4><p>注册字符设备的时候需要给设备指定一个设备号，这个设备号可以是驱动开发者静态的指定一个设备号，比如选择 200 这个主设备号。有一些常用的设备号已经被 Linux 内核开发者给分配掉了，具体分配的内容可以查看文档 Documentation&#x2F;devices.txt。并不是说内核开发者已经分配掉的主设备号我们就不能用了，具体能不能用还得看我们的硬件平台运行过程中有没有使用这个主设备号，。</p><h4 id="动态分配设备号"><a href="#动态分配设备号" class="headerlink" title="动态分配设备号"></a>动态分配设备号</h4><p>静态分配设备号需要我们检查当前系统中所有被使用了的设备号，然后挑选一个没有使用的。而且静态分配设备号很容易带来冲突问题， Linux 社区推荐使用动态分配设备号，在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。卸载驱动的时候释放掉这个设备号即可， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span><span class="comment">//申请函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count)</span><span class="comment">//释放函数</span></span><br></pre></td></tr></table></figure><p>申请设备函数有 4 个参数：<br>dev：保存申请到的设备号。<br>baseminor： 次设备号起始地址， alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。<br>count： 要申请的设备号数量。<br>name：设备名字。<br>释放函数有两个参数：<br>from：要释放的设备号。<br>count： 表示从 from 开始，要释放的设备号数量。 </p><h3 id="实现例程"><a href="#实现例程" class="headerlink" title="实现例程"></a>实现例程</h3><p>应用程序调用 open 函数打开 chrdevbase 这个设备，打开以后可以使用 write 函数向chrdevbase 的写缓冲区 writebuf 中写入数据(不超过 100 个字节)，也可以使用 read 函数读取读缓冲区 readbuf 中的数据操作，操作完成以后应用程序使用 close 函数关闭 chrdevbase 设备。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="type">static</span><span class="type">char</span> readbuf[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span><span class="type">char</span>writebuf[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span><span class="type">char</span>kerneldata[] = &#123;<span class="string">&quot;kernel data&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;open devices\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;release devices\n&quot;</span>)；</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//向用户空间发送信息</span></span><br><span class="line">    <span class="built_in">memcpy</span>(readbuf, kerneldata, <span class="keyword">sizeof</span>(kerneldata));<span class="comment">//将kerneldata的sizeof个数据复制readbuf</span></span><br><span class="line">value = copy_to_user(buf, readbuf, cnt);</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="number">0</span>)</span><br><span class="line">        printk(<span class="string">&quot;kernel senddata ok\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(<span class="string">&quot;kernel senddata failed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retvalue = <span class="number">0</span>;</span><br><span class="line">    retvalue  = copy_from_user(writebuf, buf, cnt);</span><br><span class="line">    <span class="keyword">if</span>(retvalue == <span class="number">0</span>)</span><br><span class="line">        printk(<span class="string">&quot;kernel recedata :%s ok\n&quot;</span>, writebuf);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(<span class="string">&quot;kernel recedata failed\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">chrdevbase_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = chrdev_open,</span><br><span class="line">    .read = chrdev_read,</span><br><span class="line">    .write = chrdev_write,</span><br><span class="line">    .release = chrdev_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdevbase_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line">retvalue = register_chrdev(<span class="number">200</span>, <span class="string">&quot;chrdevbase&quot;</span>, &amp;chrdevbase_fops);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)&#123;</span><br><span class="line">printk(<span class="string">&quot;chrdevbase driver register failed\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdevbase_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//卸载驱动</span></span><br><span class="line">    unregister_chrdev(<span class="number">200</span>, <span class="string">&quot;chrdevbase&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">module_init(chrdevbase_init);</span><br><span class="line">module_exit(chrdevbase_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="copy-to-user-x2F-copy-from-user函数解析"><a href="#copy-to-user-x2F-copy-from-user函数解析" class="headerlink" title="copy_to_user&#x2F;copy_from_user函数解析"></a>copy_to_user&#x2F;copy_from_user函数解析</h4><p>copy_to_user和copy_from_user是在进行驱动相关程序设计的时候，要经常遇到的函数。<strong>由于内核空间与用户空间的内存不能直接互访，因此借助函数copy_to_user()完成内核空间到用户空间的复制，函数copy_from_user()完成用户空间到内核空间的复制。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_to_user</span> <span class="params">(<span class="type">void</span> __user * to, <span class="type">const</span> <span class="type">void</span> * from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line">to目标地址，这个地址是用户空间的地址</span><br><span class="line">from源地址  ，这个地址是内核空间的地址</span><br><span class="line">n要拷贝数据的字节数</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_from_user</span> <span class="params">(<span class="type">void</span> * to, <span class="type">const</span> <span class="type">void</span> __user * from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line">to目标地址，这个地址是用户空间的地址</span><br><span class="line">from源地址  ，这个地址是内核空间的地址</span><br><span class="line">n要拷贝数据的字节数</span><br></pre></td></tr></table></figure><h3 id="编写测试APP"><a href="#编写测试APP" class="headerlink" title="编写测试APP"></a>编写测试APP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> usrdata[] = &#123;<span class="string">&quot;usr data!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : main 主程序</span></span><br><span class="line"><span class="comment"> * @param - argc : argv 数组元素个数</span></span><br><span class="line"><span class="comment"> * @param - argv : 具体参数</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd, retvalue;</span><br><span class="line"><span class="type">char</span> *filename;</span><br><span class="line"><span class="type">char</span> readbuf[<span class="number">100</span>], writebuf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filename = argv[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* 打开驱动文件 */</span></span><br><span class="line">fd = open(filename, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(atoi(argv[<span class="number">2</span>]) == <span class="number">1</span>)&#123; <span class="comment">/* 从驱动文件读取数据 */</span></span><br><span class="line">retvalue = read(fd, readbuf, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read file %s failed!\r\n&quot;</span>, filename);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="comment">/* 读取成功，打印出读取成功的数据 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read data:%s\r\n&quot;</span>,readbuf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(atoi(argv[<span class="number">2</span>]) == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">/* 向设备驱动写数据 */</span></span><br><span class="line"><span class="built_in">memcpy</span>(writebuf, usrdata, <span class="keyword">sizeof</span>(usrdata));</span><br><span class="line">retvalue = write(fd, writebuf, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;write file %s failed!\r\n&quot;</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/* 关闭设备 */</span></span><br><span class="line">    retvalue = close(fd);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t close file %s\r\n&quot;</span>, filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用交叉编译器进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc chrdevbaseApp.c -o chrdevbaseApp</span><br></pre></td></tr></table></figure><p>把chrdevbaseApp也复制到那个文件夹中。</p><p><strong>创建设备设备节点</strong></p><p>驱动加载成功需要在&#x2F;dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操这个设备节点文件来完成对具体设备的操作。输入如下命令创建&#x2F;dev&#x2F;chrdevbase 这个设备节点文件 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mknod /dev/chrdevbase c 200 0</span><br><span class="line">ls /dev/chrdevbase -l</span><br><span class="line">./chrdevbaseApp /dev/chrdevbase 1 //进行测试</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驱动开发流程</title>
      <link href="/2023/03/31/2023-3-31-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/03/31/2023-3-31-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="嵌入式linux驱动开发流程"><a href="#嵌入式linux驱动开发流程" class="headerlink" title="嵌入式linux驱动开发流程"></a>嵌入式linux驱动开发流程</h3><p>嵌入式系统中，操作系统是通过各种驱动程序来驾驭硬件设备的。设备驱动程序是操作系统内核和硬件设备之间的接口，它为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件，可以像操作普通文件一样对硬件设备进行操作。设备驱动程序是内核的一部分，完成以下功能：<br>◇ 驱动程序的注册和注销。<br>◇ 设备的打开和释放。<br>◇ 设备的读写操作。<br>◇ 设备的控制操作。<br>◇ 设备的中断和轮询处理。</p><p>在 Linux 中一切皆为文件，驱动加载成功以后会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx” (xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。 </p><p><strong>应用程序对驱动程序的调用为：应用程序-&gt;库-&gt;内核-&gt;驱动程序-&gt;硬件</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/e588edd3300840379caa5357296b7c58.png"></p><p>Linux主要将设备分为三类：字符设备、块设备和网络设备。字符设备是指发送和接收数据以字符的形式进行，没有缓冲区的设备；块设备是指发送和接收数据以整个数据缓冲区的形式进行的设备；网络设备是指网络设备访问的BSD socket 接口。</p><p><strong>基于操作系统的驱动就是在无操作系统下的硬件接口函数加上操作系统外套</strong></p><p>实现一个嵌入式Linux设备驱动程序的大致流程如下:<br>(l)查看原理图，理解设备的工作原理。<br>(2)定义主设备号。设备由一个主设备号和一个次设备号来标识。主设备号唯一标识了设备类型，即设备驱动程序类型，它是块设备表或字符设备表中设备表项的索引。次设备号仅由设备驱动程序解释，区分被一个设备驱动控制下的某个独立的设备。<br>(3)实现初始化函数。在驱动程序中实现驱动的注册和卸载。<br>(4)设计所要实现的文件操作，定义file–operations结构。<br>(5)实现所需的文件操作调用，如read，write等。<br>(6)实现中断服务，并用request–irq向内核注册，中断并不是每个设备驱动所必需的。<br>(7)编译该驱动程序到内核中，或者用insmod命令加载模块。<br>(8)测试该设备，编写应用程序，对驱动程序进行测试。</p><h4 id="驱动开发套路"><a href="#驱动开发套路" class="headerlink" title="驱动开发套路"></a>驱动开发套路</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/20200227155905995.png"></p><h3 id="linux内存管理"><a href="#linux内存管理" class="headerlink" title="linux内存管理"></a>linux内存管理</h3><p><a href="https://blog.csdn.net/yusiguyuan/article/details/12045255?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168023029416800186520924%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168023029416800186520924&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-12045255-null-null.142%5Ev80%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&spm=1018.2226.3001.4187">linux内存管理–用户空间和内核空间_鱼思故渊的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根文件系统构建</title>
      <link href="/2023/03/30/2023-3-30-%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/03/30/2023-3-30-%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="根文件系统定义"><a href="#根文件系统定义" class="headerlink" title="根文件系统定义"></a>根文件系统定义</h3><p>根文件系统首先是内核启动时所 mount(挂载)的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。 </p><p>根文件系统是 Linux 内核启动以后挂载(mount)的第一个文件系统，然后从根文件系统中读取初始化脚本，比如 rcS， inittab 等。根文件系统和 Linux 内核是分开的，单独的 Linux 内核是没法正常工作的，必须要搭配根文件系统。 </p><h4 id="常用子目录"><a href="#常用子目录" class="headerlink" title="常用子目录"></a>常用子目录</h4><table><thead><tr><th align="left">目录</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">&#x2F;bin</td><td align="center">存放可执行文件一般都是命令</td></tr><tr><td align="left">&#x2F;dev</td><td align="center">设备文件</td></tr><tr><td align="left">&#x2F;etc</td><td align="center">各种配置文件</td></tr><tr><td align="left">&#x2F;lib</td><td align="center">linux所需的必备库文件（共享库）</td></tr><tr><td align="left">&#x2F;mnt</td><td align="center">临时挂载目录（一般为空）</td></tr><tr><td align="left">&#x2F;proc</td><td align="center">作为 proc 文件系统的挂载点（文件是临时存在的，一般存储系统运行信息文件）</td></tr><tr><td align="left">&#x2F;usr</td><td align="center">Unix 操作系统软件资源目录</td></tr><tr><td align="left">&#x2F;var</td><td align="center">存放一些可以改变的数据</td></tr><tr><td align="left">&#x2F;sbin</td><td align="center">此目录页用户存放一些可执行文件</td></tr><tr><td align="left">&#x2F;sys</td><td align="center">此目录作为 sysfs 文件系统的挂载点</td></tr><tr><td align="left">&#x2F;opt</td><td align="center">可选的文件、软件存放区（用户选择放哪些）</td></tr></tbody></table><h3 id="BusyBox构建根文件系统"><a href="#BusyBox构建根文件系统" class="headerlink" title="BusyBox构建根文件系统"></a>BusyBox构建根文件系统</h3><h4 id="顶层Makefile修改"><a href="#顶层Makefile修改" class="headerlink" title="顶层Makefile修改"></a>顶层Makefile修改</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">164 CROSS_COMPILE ?= /usr/local/arm/gcc/bin/arm-linux-gnueabihf-</span><br><span class="line">......</span><br><span class="line">190 ARCH ?= arm</span><br></pre></td></tr></table></figure><h4 id="修改busybox支持中文字符"><a href="#修改busybox支持中文字符" class="headerlink" title="修改busybox支持中文字符"></a>修改busybox支持中文字符</h4><p>打开&#x2F;libbb&#x2F;printable_string.c </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> <span class="type">const</span> <span class="type">char</span>* FAST_FUNC <span class="title function_">printable_string</span><span class="params">(<span class="type">uni_stat_t</span> *stats, <span class="type">const</span> <span class="type">char</span></span></span><br><span class="line"><span class="params">*str)</span></span><br><span class="line">13 &#123;</span><br><span class="line"><span class="number">14</span> <span class="type">char</span> *dst;</span><br><span class="line"><span class="number">15</span> <span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> s = str;</span><br><span class="line"><span class="number">18</span> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="number">30</span> <span class="keyword">if</span> (c &lt; <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">31</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="number">32</span> <span class="comment">/* 注释掉下面这个两行代码 */</span></span><br><span class="line"><span class="number">33</span> <span class="comment">/* if (c &gt;= 0x7f)</span></span><br><span class="line"><span class="comment">34 break; */</span></span><br><span class="line"><span class="number">35</span> s++;</span><br><span class="line"><span class="number">36</span> &#125;</span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">38</span> <span class="meta">#<span class="keyword">if</span> ENABLE_UNICODE_SUPPORT</span></span><br><span class="line"><span class="number">39</span> dst = unicode_conv_to_printable(stats, str);</span><br><span class="line"><span class="number">40</span> <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="number">41</span> &#123;</span><br><span class="line"><span class="number">42</span> <span class="type">char</span> *d = dst = xstrdup(str);</span><br><span class="line"><span class="number">43</span> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="number">44</span> <span class="type">unsigned</span> <span class="type">char</span> c = *d;</span><br><span class="line"><span class="number">45</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="number">46</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="number">47</span> <span class="comment">/* 修改下面代码 */</span></span><br><span class="line"><span class="number">48</span> <span class="comment">/* if (c &lt; &#x27; &#x27; || c &gt;= 0x7f) */</span></span><br><span class="line"><span class="number">49</span> <span class="keyword">if</span>( c &lt; <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">50</span> *d = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="number">51</span> d++;</span><br><span class="line"><span class="number">52</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">59</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">60</span> <span class="keyword">return</span> auto_string(dst);</span><br><span class="line"><span class="number">61</span> &#125;</span><br></pre></td></tr></table></figure><p>接着打开文件 busybox-1.29.0&#x2F;libbb&#x2F;unicode.c </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1003</span> <span class="type">static</span> <span class="type">char</span>* FAST_FUNC <span class="title function_">unicode_conv_to_printable2</span><span class="params">(<span class="type">uni_stat_t</span> *stats, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">unsigned</span> width, <span class="type">int</span> flags)</span></span><br><span class="line">1004 &#123;</span><br><span class="line"><span class="number">1005</span> <span class="type">char</span> *dst;</span><br><span class="line"><span class="number">1006</span> <span class="type">unsigned</span> dst_len;</span><br><span class="line"><span class="number">1007</span> <span class="type">unsigned</span> uni_count;</span><br><span class="line"><span class="number">1008</span> <span class="type">unsigned</span> uni_width;</span><br><span class="line"><span class="number">1009</span></span><br><span class="line"><span class="number">1010</span> <span class="keyword">if</span> (unicode_status != UNICODE_ON) &#123;</span><br><span class="line"><span class="number">1011</span> <span class="type">char</span> *d;</span><br><span class="line"><span class="number">1012</span> <span class="keyword">if</span> (flags &amp; UNI_FLAG_PAD) &#123;</span><br><span class="line"><span class="number">1013</span> d = dst = xmalloc(width + <span class="number">1</span>);</span><br><span class="line">......</span><br><span class="line"><span class="number">1022</span> <span class="comment">/* 修改下面一行代码 */</span></span><br><span class="line"><span class="number">1023</span> <span class="comment">/* *d++ = (c &gt;= &#x27; &#x27; &amp;&amp; c &lt; 0x7f) ? c : &#x27;?&#x27;; */</span></span><br><span class="line"><span class="number">1024</span> *d++ = (c &gt;= <span class="string">&#x27; &#x27;</span>) ? c : <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="number">1025</span> src++;</span><br><span class="line"><span class="number">1026</span> &#125;</span><br><span class="line"><span class="number">1027</span> *d = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="number">1028</span> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1029</span> d = dst = xstrndup(src, width);</span><br><span class="line"><span class="number">1030</span> <span class="keyword">while</span> (*d) &#123;</span><br><span class="line"><span class="number">1031</span> <span class="type">unsigned</span> <span class="type">char</span> c = *d;</span><br><span class="line"><span class="number">1032</span> <span class="comment">/* 修改下面一行代码 */</span></span><br><span class="line"><span class="number">1033</span> <span class="comment">/* if (c &lt; &#x27; &#x27; || c &gt;= 0x7f) */</span></span><br><span class="line"><span class="number">1034</span> <span class="keyword">if</span>(c &lt; <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">1035</span> *d = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="number">1036</span> d++;</span><br><span class="line"><span class="number">1037</span> &#125;</span><br><span class="line"><span class="number">1038</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">1044</span> <span class="keyword">return</span> dst;</span><br><span class="line"><span class="number">1045</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">1047</span></span><br><span class="line"><span class="number">1048</span> <span class="keyword">return</span> dst;</span><br><span class="line"><span class="number">1049</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="配置busybox"><a href="#配置busybox" class="headerlink" title="配置busybox"></a>配置busybox</h4><p>要先对 busybox 进行默认的配置，有以下几种配置选项： </p><p>①defconfig，缺省配置，也就是默认配置选项。<br>②allyesconfig，全选配置，也就是选中 busybox 的所有功能。<br>③allnoconfig，最小配置。 </p><p>也可以图形化配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>配置路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line">-&gt; Settings</span><br><span class="line">-&gt; Build static binary (no shared libs)</span><br></pre></td></tr></table></figure><p><strong>这个选项不选。</strong></p><p>选项“Build static binary (no shared libs)”用来决定是静态编译 busybox 还是动态编译，静态编译的话就不需要库文件，但是编译出来的库会很大。动态编译的话要求根文件系统中有库文件，但是编译出来的 busybox 会小很多。不能采用静态编译！因为采用静态编译的话 DNS 会出问题！无法进行域名解析 。</p><p>继续配置，选上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line">-&gt; Settings</span><br><span class="line">-&gt; vi-style line editing commands</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line">-&gt; Linux Module Utilities</span><br><span class="line">-&gt; Simplified modutils</span><br></pre></td></tr></table></figure><p>不选simplified modutils</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line">-&gt; Linux System Utilities</span><br><span class="line">-&gt; mdev (16 kb) //确保下面的全部选中，默认都是选中的</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-28%20212143.png"></p><p>最后使能busybox的unicode编码支持中文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line">-&gt; Settings</span><br><span class="line">-&gt; Support Unicode //选中</span><br><span class="line">-&gt; Check $LC_ALL, $LC_CTYPE and $LANG environment variables //选中</span><br></pre></td></tr></table></figure><h4 id="编译busybox"><a href="#编译busybox" class="headerlink" title="编译busybox"></a>编译busybox</h4><p>要将编译结果存放到前面创建的 rootfs 目录中 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install CONFIG_PREFIX=/home/moss/linux/nfs/rootfs</span><br></pre></td></tr></table></figure><p>busybox 的工作就完成了，但是此时的根文件系统还不能使用，还需要一些其他的文件，我们继续来完善 rootfs。 </p><h4 id="向根文件系统添加-lib-库"><a href="#向根文件系统添加-lib-库" class="headerlink" title="向根文件系统添加 lib 库"></a>向根文件系统添加 lib 库</h4><p>Linux 中的应用程序一般都是需要动态库的 。所以在rootfs中创建一个lib文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir lib</span><br></pre></td></tr></table></figure><p>库文件从哪里来呢？ lib 库文件从交叉编译器中获取，前面我们搭建交叉编译环境的时候将交叉编译器存放到了“&#x2F;usr&#x2F;local&#x2F;arm&#x2F;”目录中。 </p><p>进入对应路径的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd/usr/local/arm/gcc/arm-linux-gnueabihf/libc/lib</span><br></pre></td></tr></table></figure><p>此目录下有很多的* <strong>so</strong>*(*<em>是通配符)和.a 文件，这些就是库文件，将此目录下所有的</em>so*和.a文件都拷贝到 rootfs&#x2F;lib 目录中，拷贝命令如下： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp *so* *.a /home/moss/linux/nfs/rootfs/lib/ -d</span><br></pre></td></tr></table></figure><p>后面的“-d”表示拷贝符号链接，这里有个比较特殊的库文件： ld-linux-armhf.so.3，此库文件也是个符号链接，</p><p>要把它变成本身的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm ld-linux-armhf.so.3</span><br></pre></td></tr></table></figure><p>然 后 重  进 入 到 &#x2F;usr&#x2F;local&#x2F;arm&#x2F;gcc&#x2F;armlinux-gnueabihf&#x2F;libc&#x2F;lib 目录中，重新拷贝 ld-linux-armhf.so.3，命令： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ld-linux-armhf.so.3 /home/moss/linux/nfs/rootfs/lib/</span><br></pre></td></tr></table></figure><p>继续进入如下目录中： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd/usr/local/arm/gcc/arm-linux-gnueabihf/libc/lib</span><br><span class="line">cp *so* *.a /home/moss/linux/nfs/rootfs/lib/ -d</span><br></pre></td></tr></table></figure><p><strong>向rootfs的usr&#x2F;lib目录添加库文件</strong></p><p>在 rootfs 的 usr 目录下创建一个名为 lib 的目录 ，之前arm-linux-gnueabihf&#x2F;usr&#x2F;lib的so和.a库文件复制到rootfs&#x2F;usr&#x2F;lib目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp *so* *.a /home/moss/linux/nfs/rootfs/usr/lib/ -d</span><br><span class="line">cd /home/moss/linux/nfs/rootfs//进入根文件系统目录</span><br><span class="line">du ./lib ./usr/lib/ -sh//查看 lib 和 usr/lib 这两个目录的大小</span><br></pre></td></tr></table></figure><p>在根文件系统中创建其他文件夹，如 dev、 proc、 mnt、 sys、 tmp 和 root 等 .</p><h3 id="初步测试根文件系统"><a href="#初步测试根文件系统" class="headerlink" title="初步测试根文件系统"></a>初步测试根文件系统</h3><p>首先使用nfs挂载根文件系统，首先熟悉bootargs环境变量的root值的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root=/dev/nfs nfsroot=[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gwip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;:&lt;dns0-ip&gt;:&lt;dns1-ip&gt;</span><br></pre></td></tr></table></figure><p><server-ip>：服务器IP地址。（也就是Ubuntu的IP）</p><p><root-dir>：根文件系统存放路径，也就是rootfs的绝对路径，可用pwd命令查询。</p><p><nfs-options>：NFS的其他选项一般不用。</p><p><client-ip>：开发板IP地址</p><p><server-ip>：服务器IP</p><p><gw-ip>：网关地址，我的是192.168.1.1</p><p><netmask>：子网掩码，255.255.255.0</p><p><hostname>：客户机名字，一般不用</p><p><device>：网卡名字：一般eth0,eht1,之类的</p><p><autoconf>：自动配置，一般为off</p><p><dns0-ip>：DNS0服务器IP地址，不使用</p><p><dns1-ip>：DNS1服务器IP地址，不使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.115:</span><br><span class="line">/home/moss/linux/nfs/rootfs,proto=tcp rw ip=192.168.1.114:192.168.1.115:192.168.1.1:</span><br><span class="line">255.255.255.0::eth0:off&#x27; </span><br></pre></td></tr></table></figure><h3 id="完善根文件系统"><a href="#完善根文件系统" class="headerlink" title="完善根文件系统"></a>完善根文件系统</h3><p>Linux 内核启动以后需要启动一些服务，<u>而 rcS 就是规定启动哪些文件的脚本文件</u>。在 rootfs 中创建&#x2F;etc&#x2F;init.d&#x2F;rcS 文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 #!/bin/sh</span><br><span class="line">2 </span><br><span class="line">3 PATH=/sbin:/bin:/usr/sbin:/usr/bin:$PATH</span><br><span class="line">4 LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/lib</span><br><span class="line">5 export PATH LD_LIBRARY_PATH</span><br><span class="line">6</span><br><span class="line">7 mount -a</span><br><span class="line">8 mkdir /dev/pts</span><br><span class="line">9 mount -t devpts devpts /dev/pts</span><br><span class="line">10</span><br><span class="line">11 echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">12 mdev -s</span><br></pre></td></tr></table></figure><p>第 1 行，表示这是一个 shell 脚本。<br>第 3 行， PATH 环境变量保存着可执行文件可能存在的目录，这样我们在执行一些命令或者可执行文件的时候就不会提示找不到文件这样的错误。<br>第 4 行， LD_LIBRARY_PATH 环境变量保存着库文件所在的目录。<br>第 5 行，使用 export 来导出上面这些环境变量，相当于声明一些“全局变量”。<br>第 7 行，使用 mount 命令来挂载所有的文件系统，这些文件系统由文件&#x2F;etc&#x2F;fstab 来指定，所以我们一会还要创建&#x2F;etc&#x2F;fstab 文件。<br>第 8 和 9 行，创建目录&#x2F;dev&#x2F;pts，然后将 devpts 挂载到&#x2F;dev&#x2F;pts 目录中。<br>第 11 和 12 行，使用 mdev 来管理热插拔设备，通过这两行， Linux 内核就可以在&#x2F;dev 目录下自动创建设备节点。 </p><p>使用chmod给予&#x2F;ec&#x2F;init.d&#x2F;rcS 可执行权限</p><h4 id="创建-x2F-etc-x2F-fstab-文件"><a href="#创建-x2F-etc-x2F-fstab-文件" class="headerlink" title="创建&#x2F;etc&#x2F;fstab 文件"></a>创建&#x2F;etc&#x2F;fstab 文件</h4><p><u>fstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区</u>，格式如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br></pre></td></tr></table></figure><p><file system>：要挂载的特殊的设备，也可以是块设备，比如&#x2F;dev&#x2F;sda </p><p><mount point>：挂载点。</p><p><type>：文件系统类型，比如 ext2、 ext3、 proc、 romfs、 tmpfs 等等。</p><p><options>：挂载选项，在 Ubuntu 中输入“man mount”命令可以查看具体的选项。一般使用 defaults，也就是默认选项， </p><p>defaults 包含了 rw、 suid、 dev、 exec、 auto、 nouser 和 async。</p><p><dump>：为 1 的话表示允许备份，为 0 不备份，一般不备份，因此设置为 0。</p><p><pass>：磁盘检查设置，为 0 表示不检查。根目录‘&#x2F;’设置为 1，其他的都不能设置为 1，其他的分区从 2 开始。一般不在 </p><p>fstab 中挂载根目录，因此这里一般设置为 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br><span class="line">proc /proc  proc defaults  0  0</span><br><span class="line">tmpfs /tmp  tmpfs defaults  0  0</span><br><span class="line">sysfs /sys  sysfs defaults  0  0</span><br></pre></td></tr></table></figure><h4 id="创建-x2F-etc-x2F-inittab-文件"><a href="#创建-x2F-etc-x2F-inittab-文件" class="headerlink" title="创建&#x2F;etc&#x2F;inittab 文件"></a>创建&#x2F;etc&#x2F;inittab 文件</h4><p>init 程序会读取&#x2F;etc&#x2F;inittab这个文件， inittab 由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的 4 个段组成，格式如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br></pre></td></tr></table></figure><p><id>：每个指令的标识符，不能重复。但是对于 busybox 的 init 来说， <id>有着特殊意义。对于 busybox 而言<id>用来指定启动进程的控制 tty，一般我们将串口或者 LCD 屏幕设置为控制 tty。</p><p><runlevels>： 对 busybox 来说此项完全没用，所以空着。</p><p><action>：动作，用于指定<process>可能用到的动作。 <process>： 具体的动作，比如程序、脚本或命令等。动作表如下：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-29%20211432.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例代码 38.4.3.1 /etc/inittab 文件</span><br><span class="line">1 #etc/inittab</span><br><span class="line">2 ::sysinit:/etc/init.d/rcS</span><br><span class="line">3 console::askfirst:-/bin/sh</span><br><span class="line">4 ::restart:/sbin/init</span><br><span class="line">5 ::ctrlaltdel:/sbin/reboot</span><br><span class="line">6 ::shutdown:/bin/umount -a -r</span><br><span class="line">7 ::shutdown:/sbin/swapoff -a</span><br></pre></td></tr></table></figure><p>第 2 行，系统启动以后运行&#x2F;etc&#x2F;init.d&#x2F;rcS 这个脚本文件。<br>第 3 行，将 console 作为控制台终端，也就是 ttymxc0。<br>第 4 行，重启的话运行&#x2F;sbin&#x2F;init。<br>第 5 行，按下 ctrl+alt+del 组合键的话就运行&#x2F;sbin&#x2F;reboot，看来 ctrl+alt+del 组合键用于重启系统。<br>第 6 行，关机的时候执行&#x2F;bin&#x2F;umount，也就是卸载各个文件系统。<br>第 7 行，关机的时候执行&#x2F;sbin&#x2F;swapoff，也就是关闭交换分区。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核移植</title>
      <link href="/2023/03/28/2023-3-28-%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D/"/>
      <url>/2023/03/28/2023-3-28-%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="内核移植"><a href="#内核移植" class="headerlink" title="内核移植"></a>内核移植</h3><p>首先是要将官方的板载内核进行下载，在其之上进行改动来支持自己的板子。</p><p>例如可以下载nxp关于imx6ull的linux内核，github的地址<a href="https://github.com/Freescale/linux-fslc/tree/5.4-2.1.x-imx">GitHub - Freescale&#x2F;linux-fslc at 5.4-2.1.x-imx</a></p><p>交叉编译器使用的为arm-linux-gnueabihf-</p><p>随便弄一个内核下来，编译顶层的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH?= arm</span><br><span class="line">CROSS_COMPILE?=arm-linux-gnueabihf-</span><br></pre></td></tr></table></figure><p>这两个后面不要加空格直接回车，不然找不到交叉编译器。</p><h4 id="添加自己的板子"><a href="#添加自己的板子" class="headerlink" title="添加自己的板子"></a>添加自己的板子</h4><p>之后复制一份自己的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cdarch/arm/configs</span><br><span class="line">ls</span><br><span class="line">cpimx_v7_mfg_defonfig imx_alientek_emmc_defconfig</span><br></pre></td></tr></table></figure><p>之后进入arch&#x2F;arm&#x2F;boot&#x2F;dts，复制一份imx6ull-14x14-evk.dts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp imx6ull-14x14-evk.dts imx6ull-alientek-emmc.dts</span><br></pre></td></tr></table></figure><p>修改makefile的dtb-$(CONFIG_SOC_IMX6ULL)的内容，添加设备树</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-28%20103201.png"></p><p>之后返回顶层编译工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makedistclean</span><br><span class="line">makeimx_alientek_emmc_defconfig</span><br><span class="line">make-j8</span><br></pre></td></tr></table></figure><p>这里的-j8是因为我的虚拟机就只有8个处理器</p><h4 id="修改板子主频"><a href="#修改板子主频" class="headerlink" title="修改板子主频"></a>修改板子主频</h4><p>在串口软件例如我的是Mobaxterm，查看cpu信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><p>BogoMIPS 是 Linux 系统中衡量处理器运行速度的一个“尺子”，处理器性能越强，主频越高， BogoMIPS 值就越大。BogoMIPS 只是粗略的计算 CPU 性能，并不十分准确。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/bus/cpu/devices/cpu0/cpufreq</span><br><span class="line">cat cpuinfo_cur_freq</span><br></pre></td></tr></table></figure><p>此目录中记录了 CPU 频率等信息，这些文件的含义如下：<br>cpuinfo_cur_freq：当前 cpu 工作频率，从 CPU 寄存器读取到的工作频率。<br>cpuinfo_max_freq：处理器所能运行的最高工作频率(单位: KHz）。<br>cpuinfo_min_freq ：处理器所能运行的最低工作频率(单位: KHz）。<br>cpuinfo_transition_latency：处理器切换频率所需要的时间(单位:ns)。<br>scaling_available_frequencies：处理器支持的主频率列表(单位: KHz）。<br>scaling_available_governors：当前内核中支持的所有 governor(调频)类型。<br>scaling_cur_freq：保存着 cpufreq 模块缓存的当前 CPU 频率，不会对 CPU 硬件寄存器进行检查。<br>scaling_driver：该文件保存当前 CPU 所使用的调频驱动。<br>scaling_governor： governor(调频)策略， Linux 内核一共有 5 中调频策略，<br>①、 Performance，最高性能，直接用最高频率，不考虑耗电。<br>②、 Interactive，一开始直接用最高频率，然后根据 CPU 负载慢慢降低。<br>③、 Powersave，省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！<br>④、 Userspace，可以在用户空间手动调节频率。<br>⑤、 Ondemand，定时检查负载，然后根据负载来调节频率。负载低的时候降低 CPU 频率，这样省电，负载高的时候提高 CPU 频率，增加性能。<br>scaling_max_freq： governor(调频)可以调节的最高频率。<br>cpuinfo_min_freq： governor(调频)可以调节的最低频率。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat scaling_governor = ondemand</span><br></pre></td></tr></table></figure><p>ondmand是定期检查负载，调整功率，一般用这个。</p><p>查看 stats 目录下的 time_in_state 文件可以看到 CPU 在各频率下的工作时间，命令如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/bus/cpu/devices/cpu0/cpufreq/stats/time_in_state</span><br></pre></td></tr></table></figure><p>如果想一直高频就在内核文件的imx_alientek_emmc_defconfig文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y//屏蔽掉</span><br><span class="line">CONFIG_CPU_FREQ_GOV_ONDEMAND=y//添加</span><br></pre></td></tr></table></figure><h4 id="EMMC驱动修改"><a href="#EMMC驱动修改" class="headerlink" title="EMMC驱动修改"></a>EMMC驱动修改</h4><p>修改imx6ull-alientek-emmc.dts的usdhc2部分，将其修改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">734</span> &amp;usdhc2 &#123;</span><br><span class="line"><span class="number">735</span> pinctrl-names = <span class="string">&quot;default&quot;</span>, <span class="string">&quot;state_100mhz&quot;</span>, <span class="string">&quot;state_200mhz&quot;</span>;</span><br><span class="line"><span class="number">736</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_usdhc2_8bit&gt;;</span><br><span class="line"><span class="number">737</span> pinctrl<span class="number">-1</span> = &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;;</span><br><span class="line"><span class="number">738</span> pinctrl<span class="number">-2</span> = &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;;</span><br><span class="line"><span class="number">739</span> bus-width = &lt;<span class="number">8</span>&gt;;</span><br><span class="line"><span class="number">740</span> non-removable;</span><br><span class="line"><span class="number">741</span> no<span class="number">-1</span><span class="number">-8</span>-v;</span><br><span class="line"><span class="number">742</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">743</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="网络驱动修改"><a href="#网络驱动修改" class="headerlink" title="网络驱动修改"></a>网络驱动修改</h4><h5 id="修改LAN8720的复位以及网络时钟引脚驱动"><a href="#修改LAN8720的复位以及网络时钟引脚驱动" class="headerlink" title="修改LAN8720的复位以及网络时钟引脚驱动"></a>修改LAN8720的复位以及网络时钟引脚驱动</h5><p>ENET1 复位引脚 ENET1_RST 连接在 I.M6ULL 的 SNVS_TAMPER7 这个引脚上。 ENET2的复位引脚 ENET2_RST 连接在 I.MX6ULL 的 SNVS_TAMPER8 上。打开设备树文件 imx6ullalientek-emmc.dts，找到如下代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">584</span> pinctrl_spi4: spi4grp &#123;</span><br><span class="line"><span class="number">585</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">586</span> MX6ULL_PAD_BOOT_MODE0__GPIO5_IO10 <span class="number">0x70a1</span></span><br><span class="line"><span class="number">587</span> MX6ULL_PAD_BOOT_MODE1__GPIO5_IO11 <span class="number">0x70a1</span></span><br><span class="line"><span class="number">588</span> MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07 <span class="number">0x70a1</span></span><br><span class="line"><span class="number">589</span> MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08 <span class="number">0x80000000</span></span><br><span class="line"><span class="number">590</span> &gt;;</span><br><span class="line"><span class="number">591</span> &#125;;</span><br></pre></td></tr></table></figure><p>删除原有的588和589行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">125</span> spi4 &#123;</span><br><span class="line"><span class="number">126</span> compatible = <span class="string">&quot;spi-gpio&quot;</span>;</span><br><span class="line"><span class="number">127</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">128</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_spi4&gt;;</span><br><span class="line"><span class="number">129</span> pinctrl-assert-gpios = &lt;&amp;gpio5 <span class="number">8</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">......</span><br><span class="line"><span class="number">133</span> cs-gpios = &lt;&amp;gpio5 <span class="number">7</span> <span class="number">0</span>&gt;;</span><br></pre></td></tr></table></figure><p>GPIO5_IO07 和 GPIO5_IO08 分别作为 ENET1 和 ENET2 的复位引脚，而不是 SPI4 的什么功能引脚，因此将示例代码 37.4.3.2 中的第 129 行和第 133 行处的代码删除掉！！ 否则会干扰到网络复位引脚！ </p><p>在 imx6ull-alientek-emmc.dts 里面找到名为“iomuxc_snvs”的节点(就是直接搜索)，然后在此节点下添加网络复位引脚信息，添加完成以后的“iomuxc_snvs”的节点内容如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;iomuxc_snvs &#123;</span><br><span class="line"><span class="number">2</span> pinctrl-names = <span class="string">&quot;default_snvs&quot;</span>;</span><br><span class="line"><span class="number">3</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_hog_2&gt;;</span><br><span class="line"><span class="number">4</span> imx6ul-evk &#123;</span><br><span class="line"><span class="number">5</span></span><br><span class="line">...... <span class="comment">/*省略掉其他*/</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">44</span> <span class="comment">/*enet1 reset zuozhongkai*/</span></span><br><span class="line"><span class="number">45</span> pinctrl_enet1_reset: enet1resetgrp &#123;</span><br><span class="line"><span class="number">46</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">47</span> <span class="comment">/* used for enet1 reset */</span></span><br><span class="line"><span class="number">48</span> MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07 <span class="number">0x10B0</span></span><br><span class="line"><span class="number">49</span> &gt;;</span><br><span class="line"><span class="number">50</span> &#125;;</span><br><span class="line"><span class="number">51</span></span><br><span class="line"><span class="number">52</span> <span class="comment">/*enet2 reset zuozhongkai*/</span></span><br><span class="line"><span class="number">53</span> pinctrl_enet2_reset: enet2resetgrp &#123;</span><br><span class="line"><span class="number">54</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">55</span> <span class="comment">/* used for enet2 reset */</span></span><br><span class="line"><span class="number">56</span> MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08 <span class="number">0x10B0</span></span><br><span class="line"><span class="number">57</span> &gt;;</span><br><span class="line"><span class="number">58</span> &#125;;</span><br><span class="line"><span class="number">59</span> &#125;;</span><br><span class="line"><span class="number">60</span> &#125;;</span><br></pre></td></tr></table></figure><p>最后还需要修改一下 ENET1 和 ENET2 的网络时钟引脚配置， 继续在 imx6ull-alientekemmc.dts 中找到如下所示代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">309</span> pinctrl_enet1: enet1grp &#123;</span><br><span class="line"><span class="number">310</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">311</span> MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">312</span> MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">313</span> MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">314</span> MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">315</span> MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">316</span> MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">317</span> MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">318</span> MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 <span class="number">0x4001b009</span></span><br><span class="line"><span class="number">319</span> &gt;;</span><br><span class="line"><span class="number">320</span> &#125;;</span><br><span class="line"><span class="number">321</span></span><br><span class="line"><span class="number">322</span> pinctrl_enet2: enet2grp &#123;</span><br><span class="line"><span class="number">323</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">324</span> MX6UL_PAD_GPIO1_IO07__ENET2_MDC <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">325</span> MX6UL_PAD_GPIO1_IO06__ENET2_MDIO <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">326</span> MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">327</span> MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">328</span> MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">329</span> MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">330</span> MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">331</span> MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">332</span> MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">333</span> MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 <span class="number">0x4001b009</span></span><br><span class="line"><span class="number">334</span> &gt;;</span><br><span class="line"><span class="number">335</span> &#125;;</span><br></pre></td></tr></table></figure><p>第 318 和 333 行， 分别为 ENET1 和 ENET2 的网络时钟引脚配置信息，将这两个引脚的电气属性值改为 0x4001b009，原来默认值为 0x4001b031。 </p><h5 id="修改-fec1-和-fec2-节点的-pinctrl-0-属性"><a href="#修改-fec1-和-fec2-节点的-pinctrl-0-属性" class="headerlink" title="修改 fec1 和 fec2 节点的 pinctrl-0 属性"></a>修改 fec1 和 fec2 节点的 pinctrl-0 属性</h5><p>在 imx6ull-alientek-emmc.dts 文件中找到名为“fec1”和“fec2”的这两个节点，修改其中的“pinctrl-0”属性值，修改以后如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;fec1 &#123;</span><br><span class="line"><span class="number">2</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">3</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet1&amp;pinctrl_enet1_reset&gt;;</span><br><span class="line"><span class="number">4</span> phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">9</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> &amp;fec2 &#123;</span><br><span class="line"><span class="number">13</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">14</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet2&amp;pinctrl_enet2_reset&gt;;</span><br><span class="line"><span class="number">15</span> phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">36</span> &#125;;</span><br></pre></td></tr></table></figure><p>第 3<del>4 行，修改后的 fec1 节点“pinctrl-0”属性值。<br>第 14</del>15 行，修改后的 fec2 节点“pinctrl-0”属性值 .</p><h5 id="修改-LAN8720A-的-PHY-地址"><a href="#修改-LAN8720A-的-PHY-地址" class="headerlink" title="修改 LAN8720A 的 PHY 地址"></a>修改 LAN8720A 的 PHY 地址</h5><p>ENET1 的 LAN8720A 地址为 0x0， ENET2 的 LAN8720A地址为 0x1 ，在 imx6ull-alientek-emmc.dts 中找到如下代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">171</span> &amp;fec1 &#123;</span><br><span class="line"><span class="number">172</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">175</span> phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line"><span class="number">176</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">177</span> &#125;;</span><br><span class="line"><span class="number">178</span></span><br><span class="line"><span class="number">179</span> &amp;fec2 &#123;</span><br><span class="line"><span class="number">180</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">183</span> phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line"><span class="number">184</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">185</span></span><br><span class="line"><span class="number">186</span> mdio &#123;</span><br><span class="line"><span class="number">187</span> <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="number">188</span> <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"><span class="number">189</span></span><br><span class="line"><span class="number">190</span> ethphy0: ethernet-phy@<span class="number">0</span> &#123;</span><br><span class="line"><span class="number">191</span> compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line"><span class="number">192</span> reg = &lt;<span class="number">2</span>&gt;;</span><br><span class="line"><span class="number">193</span> &#125;;</span><br><span class="line"><span class="number">194</span></span><br><span class="line"><span class="number">195</span> ethphy1: ethernet-phy@<span class="number">1</span> &#123;</span><br><span class="line"><span class="number">196</span> compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line"><span class="number">197</span> reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line"><span class="number">198</span> &#125;;</span><br><span class="line"><span class="number">199</span> &#125;;</span><br><span class="line"><span class="number">200</span> &#125;;</span><br></pre></td></tr></table></figure><p>第 171<del>177 行， ENET1 对应的设备树节点。<br>第 179</del>200 行， ENET2 对应的设备树节点。但是第 186~198 行的 mdio 节点描述了 ENET1和 ENET2 的 PHY 地址信息。 改为如下内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">171</span> &amp;fec1 &#123;</span><br><span class="line"><span class="number">172</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">173</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet1</span><br><span class="line"><span class="number">174</span> &amp;pinctrl_enet1_reset&gt;;</span><br><span class="line"><span class="number">175</span> phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line"><span class="number">176</span> phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line"><span class="number">177</span> phy-reset-gpios = &lt;&amp;gpio5 <span class="number">7</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line"><span class="number">178</span> phy-reset-duration = &lt;<span class="number">200</span>&gt;;</span><br><span class="line"><span class="number">179</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">180</span> &#125;;</span><br><span class="line"><span class="number">181</span></span><br><span class="line"><span class="number">182</span> &amp;fec2 &#123;</span><br><span class="line"><span class="number">183</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">184</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet2</span><br><span class="line"><span class="number">185</span> &amp;pinctrl_enet2_reset&gt;;</span><br><span class="line"><span class="number">186</span> phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line"><span class="number">187</span> phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line"><span class="number">188</span> phy-reset-gpios = &lt;&amp;gpio5 <span class="number">8</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line"><span class="number">189</span> phy-reset-duration = &lt;<span class="number">200</span>&gt;;</span><br><span class="line"><span class="number">190</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">191</span></span><br><span class="line"><span class="number">192</span> mdio &#123;</span><br><span class="line"><span class="number">193</span> <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="number">194</span> <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"><span class="number">195</span></span><br><span class="line"><span class="number">196</span> ethphy0: ethernet-phy@<span class="number">0</span> &#123;</span><br><span class="line"><span class="number">197</span> compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line"><span class="number">198</span> smsc,disable-energy-detect;</span><br><span class="line"><span class="number">199</span> reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line"><span class="number">200</span> &#125;;</span><br><span class="line"><span class="number">201</span></span><br><span class="line"><span class="number">202</span> ethphy1: ethernet-phy@<span class="number">1</span> &#123;</span><br><span class="line"><span class="number">203</span> compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line"><span class="number">204</span> smsc,disable-energy-detect;</span><br><span class="line"><span class="number">205</span> reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line"><span class="number">206</span> &#125;;</span><br><span class="line"><span class="number">207</span> &#125;;</span><br><span class="line"><span class="number">208</span> &#125;;</span><br></pre></td></tr></table></figure><h5 id="修改-fec-main-c-文件"><a href="#修改-fec-main-c-文件" class="headerlink" title="修改 fec_main.c 文件"></a>修改 fec_main.c 文件</h5><p>要 在 I.MX6ULL 上 使 用 LAN8720A ， 需 要 修 改 一 下 Linux 内 核 源 码 ， 打 开drivers&#x2F;net&#x2F;ethernet&#x2F;freescale&#x2F;fec_main.c，找到函数 fec_probe，在 fec_probe 中加入如下代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3438</span> <span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="number">3439</span> fec_probe(<span class="keyword">struct</span> platform_device *pdev)</span><br><span class="line"><span class="number">3440</span> &#123;</span><br><span class="line"><span class="number">3441</span> <span class="class"><span class="keyword">struct</span> <span class="title">fec_enet_private</span> *<span class="title">fep</span>;</span></span><br><span class="line"><span class="number">3442</span> <span class="class"><span class="keyword">struct</span> <span class="title">fec_platform_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="number">3443</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">ndev</span>;</span></span><br><span class="line"><span class="number">3444</span> <span class="type">int</span> i, irq, ret = <span class="number">0</span>;</span><br><span class="line"><span class="number">3445</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">r</span>;</span></span><br><span class="line"><span class="number">3446</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span>;</span></span><br><span class="line"><span class="number">3447</span> <span class="type">static</span> <span class="type">int</span> dev_id;</span><br><span class="line"><span class="number">3448</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node, *phy_node;</span><br><span class="line"><span class="number">3449</span> <span class="type">int</span> num_tx_qs;</span><br><span class="line"><span class="number">3450</span> <span class="type">int</span> num_rx_qs;</span><br><span class="line"><span class="number">3451</span></span><br><span class="line"><span class="number">3452</span> <span class="comment">/* 设置 MX6UL_PAD_ENET1_TX_CLK 和 MX6UL_PAD_ENET2_TX_CLK</span></span><br><span class="line"><span class="comment">3453 * 这两个 IO 的复用寄存器的 SION 位为 1。</span></span><br><span class="line"><span class="comment">3454 */</span></span><br><span class="line"><span class="number">3455</span> <span class="type">void</span> __iomem *IMX6U_ENET1_TX_CLK;</span><br><span class="line"><span class="number">3456</span> <span class="type">void</span> __iomem *IMX6U_ENET2_TX_CLK;</span><br><span class="line"><span class="number">3457</span></span><br><span class="line"><span class="number">3458</span> IMX6U_ENET1_TX_CLK = ioremap(<span class="number">0X020E00DC</span>, <span class="number">4</span>);</span><br><span class="line"><span class="number">3459</span> writel(<span class="number">0X14</span>, IMX6U_ENET1_TX_CLK);</span><br><span class="line"><span class="number">3460</span></span><br><span class="line"><span class="number">3461</span> IMX6U_ENET2_TX_CLK = ioremap(<span class="number">0X020E00FC</span>, <span class="number">4</span>);</span><br><span class="line"><span class="number">3462</span> writel(<span class="number">0X14</span>, IMX6U_ENET2_TX_CLK);</span><br><span class="line"><span class="number">3463</span></span><br><span class="line">......</span><br><span class="line"><span class="number">3656</span> <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">3657</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="配置-Linux-内核，使能-LAN8720-驱动"><a href="#配置-Linux-内核，使能-LAN8720-驱动" class="headerlink" title="配置 Linux 内核，使能 LAN8720 驱动"></a>配置 Linux 内核，使能 LAN8720 驱动</h5><p>输入命令“make menuconfig”，打开图形化配置界面，选择使能 LAN8720A 的驱动，路径如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">-&gt; Network device support</span><br><span class="line">-&gt; PHY Device support and infrastructure</span><br><span class="line">-&gt; Drivers for SMSC PHYs</span><br></pre></td></tr></table></figure><h5 id="修改-smsc-c-文件"><a href="#修改-smsc-c-文件" class="headerlink" title="修改 smsc.c 文件"></a>修改 smsc.c 文件</h5><p>LAN8720A 的驱动文件是 drivers&#x2F;net&#x2F;phy&#x2F;smsc.c， 修改SMSC PHY的复位函数 ，修改以后的 smsc_phy_reset函数内容如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">smsc_phy_reset</span><span class="params">(<span class="keyword">struct</span> phy_device *phydev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err, phy_reset;</span><br><span class="line"><span class="type">int</span> msec = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"><span class="type">int</span> timeout = <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">if</span>(phydev-&gt;addr == <span class="number">0</span>) <span class="comment">/* FEC1 */</span> </span><br><span class="line">    &#123;</span><br><span class="line">np = of_find_node_by_path(<span class="string">&quot;/soc/aips-bus@02100000/ethernet@02188000&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(np == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(phydev-&gt;addr == <span class="number">1</span>) <span class="comment">/* FEC2 */</span> </span><br><span class="line">    &#123;</span><br><span class="line">np = of_find_node_by_path(<span class="string">&quot;/soc/aips-bus@02000000/ethernet@020b4000&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(np == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = of_property_read_u32(np, <span class="string">&quot;phy-reset-duration&quot;</span>, &amp;msec);</span><br><span class="line"><span class="comment">/* A sane reset duration should not be longer than 1s */</span></span><br><span class="line"><span class="keyword">if</span> (!err &amp;&amp; msec &gt; <span class="number">1000</span>)</span><br><span class="line">msec = <span class="number">1</span>;</span><br><span class="line">phy_reset = of_get_named_gpio(np, <span class="string">&quot;phy-reset-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!gpio_is_valid(phy_reset))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">gpio_direction_output(phy_reset, <span class="number">0</span>);</span><br><span class="line">gpio_set_value(phy_reset, <span class="number">0</span>);</span><br><span class="line">msleep(msec);</span><br><span class="line">gpio_set_value(phy_reset, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> rc = phy_read(phydev, MII_LAN83C185_SPECIAL_MODES);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the SMSC PHY is in power down mode, then set it</span></span><br><span class="line"><span class="comment">* in all capable mode before using it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> ((rc &amp; MII_LAN83C185_MODE_MASK) == MII_LAN83C185_MODE_POWERDOWN) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set &quot;all capable&quot; mode and reset the phy */</span></span><br><span class="line">rc |= MII_LAN83C185_MODE_ALL;</span><br><span class="line">phy_write(phydev, MII_LAN83C185_SPECIAL_MODES, rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">phy_write(phydev, MII_BMCR, BMCR_RESET);</span><br><span class="line"><span class="comment">/* wait end of reset (max 500 ms) */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">udelay(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (timeout-- == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">rc = phy_read(phydev, MII_BMCR);</span><br><span class="line">&#125; <span class="keyword">while</span> (rc &amp; BMCR_RESET);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们还需要在 drivers&#x2F;net&#x2F;phy&#x2F;smsc.c 文件中添加两个头文件，因为修改后的smsc_phy_reset 函数用到了 gpio_direction_output 和 gpio_set_value 这两个函数，需要添加的头文件如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="网络驱动测试"><a href="#网络驱动测试" class="headerlink" title="网络驱动测试"></a>网络驱动测试</h4><p>修改好设备树和 Linux 内核以后重新编译一下，得到新的 zImage 镜像文件和 imx6ullalientek-emmc.dtb 设备树文件，使用网线将 I.MX6U-ALPHA 开发板的两个网口与路由器或者电脑连接起来，最后使用新的文件启动 Linux 内核。启动以后使用“ifconfig”命令查看一下当前活动的网卡有哪些 。</p><p>输入命令“ifconfig -a”来查看一下开发板中存在的所有网卡， </p><p>使用如下命令依次打开 eth0 和 eth1 这两个网卡： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth1 up</span><br></pre></td></tr></table></figure><p>使用命令给两个网卡配置IP地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.251</span><br><span class="line">ifconfig eth1 192.168.1.252</span><br></pre></td></tr></table></figure><p>一定要和自己的电脑处于同一个网段内 ，可以ping一下自己的主机地址。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内核分析</title>
      <link href="/2023/03/24/2023-3-24-Linux-%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/24/2023-3-24-Linux-%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="内核分析"><a href="#内核分析" class="headerlink" title="内核分析"></a>内核分析</h2><h3 id="linux内核组成部分"><a href="#linux内核组成部分" class="headerlink" title="linux内核组成部分"></a>linux内核组成部分</h3><p>linux内核主要由进程调度（SCHED）、内存管理（MM）、虚拟文件系统（VFS）、网络接口（NET）、进程间通信（IPC）5个子系统组成。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-03%20154334.png"></p><p>5个子系统依赖关系如下：</p><p>进程调度与内存管理之间的关系：这两个子系统相互依赖，在多程序环境下，程序要运行，则必须创建进程，而创建进程第一件事情就是将程序和数据装入内存。</p><p>进程间通信与内存管理的关系：进程间通信子系统要依赖内存管理支持共享内存通信机制，这种机制允许两个进程除了拥有自己的私有空间外，还可以存取共同的内存区域。</p><p>虚拟文件系统与网络接口之间的关系：虚拟文件系统利用网络接口支持网络文件系统（NFS），也利用内存管理支持RAMDISK设备。</p><p>内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程定期由调度程序调度，这也是内存管理依赖于进程调度的原因。</p><h3 id="详情参考"><a href="#详情参考" class="headerlink" title="详情参考"></a>详情参考</h3><p><a href="http://blog.csdn.net/lizuobin2/article/details/51447338">Makefile.txt文件翻译</a></p><h3 id="内核Makefile分类"><a href="#内核Makefile分类" class="headerlink" title="内核Makefile分类"></a>内核Makefile分类</h3><p>在Linux内核里，每个子目录都有一个makefile，它被称作Kbuilt-makefile，它将当前目录的文件编译成built-in.o、以及库文件、模块文件。然后顶层Makefile里指定这些built-in.o的路径，将它们连接在一起。</p><p><strong>将makefile分为 5部分，Kernel Makefile、ARCH Makefile、KBuild Makefile、.config文件以及scripts&#x2F;Makefile.</strong></p><p>①kernel Makefile(Top Makefile)位于Linux内核源代码的顶层目录，主要编译Linux Kernel目标文件（vmlinux）和模块（module）路径。它根据.config文件决定了内核根目录下的那些文件、子目录被编译进内核，是所有文件核心，从总体控制内核编译、链接。</p><p>②ARCH Makefile文件，是系统对应平台的Makefile。Kernel Top Makefile 会包含这个文件来指定平台相关信息。ARCH Makefile同样<strong>根据.config文件，决定了ARCH&#x2F;$(ARCH) 目录下 那些文件、子目录被编译进内核</strong> 只有平台开发人员会关心这个文件。</p><p>③Kbuild Makefile，从Linux 内核2.6 开始，Linux 内核的编译采用Kbuild 系统 ，这同过去的编译系统有很大的不同，Kbuild 系统使用Kbuild Makefile 来编译内核或模块。当Kernel Makefile 被解析完成后，Kbuild 会读取相关的Kbuild Makefile 进行内核或模块的编译。Kbuild Makefile 有特定的语法指定哪些编译进内核中、哪些编译为模块、及对应的源文件是什么等。内核及驱动开发人员需要编写这个Kbuild Makefile 文件。<br>④**scripts&#x2F;Makefile.* ，Makefile共用的通用规则、脚本等</p><p>⑤**.config**，来自配置过程，生成 auto.conf 以及 autoconf.h，被顶层Makefile所包含</p><h3 id="5大文件作用"><a href="#5大文件作用" class="headerlink" title="5大文件作用"></a>5大文件作用</h3><p>首先是顶层Makefile决定内核根目录下的哪些子目录将被编进内核。</p><p>arch&#x2F;$(ARCH)&#x2F;Makefile决定arch&#x2F;$(ARCH)目录下哪些文件、哪些目录被编进内核。</p><p>各级子目录下的Makefile决定所在目录下的哪些文件将被编进内核，哪些被编写成模块（驱动模块），进入哪些子目录继续调用它们的Makefile。</p><p>顶层Makefile和arch&#x2F;$(ARCH)&#x2F;Makefile设置了可以影响所有文件的编译、连接选项：CFLAGS、AFLAGS、LDFLAGS、ARFLAFGS。</p><p>各级子目录下的Makefile中可以设置成能够影响当前目录下所有文件的编译 、连接选项：EXTRA_CFLAGS、EXTRA_AFLAGS、EXTRA_LDFLAGS、EXTRA_ARFLAGS,还可以设置影响某个文件的编译选项。</p><p>顶层Makefile按照一定的顺序组织文件，根据连接脚本arch&#x2F;$(ARCH)&#x2F;kernel&#x2F;vmlinux.lds生成内核镜像文件vmlinux。</p><p>①、 vmlinux 是编译出来的最原始的内核文件，是未压缩的，比如正点原子提供的 Linux 源码编译出来的 vmlinux 差不多有 16MB，<br>②、 Image 是 Linux 内核镜像文件，但是 Image 仅包含可执行的二进制数据。 Image 就是使用 objcopy 取消掉 vmlinux 中的一些其他信息，比如符号表什么的。但是 Image 是没有压缩过的， Image 保存在 arch&#x2F;arm&#x2F;boot 目录下，其大小大概在 12MB 左右相比 vmlinux 的 16MB， Image 缩小到了 12MB。<br>③、 zImage 是经过 gzip 压缩后的 Image，经过压缩以后其大小大概在 6MB 左右 </p><h3 id="内核的配置"><a href="#内核的配置" class="headerlink" title="内核的配置"></a>内核的配置</h3><p> 1、Makefile：分布在 Linux 内核源代码根目录及各层目录中，定义 Linux 内核的编译规则；<br> 2、配置文件（config.in(2.4内核，2.6内核)）：给用户提供配置选择的功能；<br> 3、配置工具：包括配置命令解释器（对配置脚本中使用的配置命令进行解释）和配置用户界面</p><p>make menuconfig过程：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-23%20201421.png"></p><p> 1、scripts文件夹存放的是跟make menuconfig配置界面的图形绘制相关的文件，我们作为使用者无需关心这个文件夹的内容<br> 2、读取arch&#x2F;arch&#x2F;$ARCH&#x2F;Kconfig以及各子目录下的Kcondig文件，生成配置条目。<br>        $ARCH由linux内核根目录下的makefile文件决定<br>        ARCH            ?&#x3D; arm<br>        CROSS_COMPILE   ?&#x3D; arm-linux-<br>        Kconfig文件中为配置信息的宏定义，与我们在make menuconfig图形界面看到的信息一致。<br>        例如：<br>        config CPU_S3C2410_DMA<br>                bool<br>                depends on S3C2410_DMA &amp;&amp; (CPU_S3C2410 || CPU_S3C2442)<br>                default y if CPU_S3C2410 || CPU_S3C2442<br>                help<br>                   DMA device selection for S3C2410 and compatible CPUs<br>    <strong>因此，Kconfig文件很重要的作用就是：定义配置宏、相关依赖关系、帮助信息</strong><br>3、<strong>读取内核根目录下.config文件，生成配置选项:[*]编译进内核 [M]编译为模块 [ ]不编译</strong><br>        arch&#x2F;arm&#x2F;configs&#x2F;文件夹下存放了一些配置模板<br>        我们可以通过cp &#x2F;arch&#x2F;arm&#x2F;configs&#x2F;xx_defconfig .config来使用这些配置模板<br>        通过图形界面变更配置选项会自动更新到.config文件中<br>        make disclean 会删除.config<br>4、<strong>编译过程根据.config生成 Linux内核根目录下的 include&#x2F;config&#x2F;auto.conf文件</strong><br>        CONFIG_EEPROM_93CX6&#x3D;m<br>        CONFIG_DM9000&#x3D;y<br>        根目录Makefile以及子目录的Makefile根据auto.conf生成编译条件<br>        obj-$(CONFIG_DM9000) +&#x3D; dm9000.o &#x2F;&#x2F;obj-m +&#x3D; dm9000.o<br>5、<strong>编译过程根据.config生成Linux内核根目录下的 include&#x2F;linux&#x2F;autoconf.h文件</strong><br>        .config 或 auto.conf 中定义要编译为 m 模块的项，如：<br>        CONFIG_DEBUG_NX_TEST&#x3D;m<br>        在 autoconf.h 中会被定义为：<br>        #define CONFIG_DEBUG_NX_TEST_MODULE 1    </p><p>​.config或auto.conf 中定义为编译为 y 的选项,如：<br>​        CONFIG_DM9000&#x3D; y<br>​        在 autoconf.h 中会被定义为：<br>​        #define CONFIG_DM9000 1<br>​        autoconf.h中是.config或者auto.conf中配置信息的另一种体现形式，它是站在源码的角度，供源码使用的C语言宏定义。<br>   6、总结<br>​        我们在使用make menuconfig时，首先会确定架构arch，然后读取arch目录的Kconfig中的配置宏定义，生成编译条目，然后读取Linux内核根目录下的.config选项， 将.config中的配置信息显示在图形界面上[*] [M] or []。我们在图形界面中更改配置选项会自动保存到.config文件中。编译过程根据.config随后生成auto.conf文件，它决定了makefile中各个文件的编译类型，静态编译进内核、编译成模块、不编译;同时生成autoconf.h，它以C语言宏定义的形式表达了 各个文件是否被编译，源码中会判断某文件是否被编译进行不同的处理。</p><h2 id="内核启动流程"><a href="#内核启动流程" class="headerlink" title="内核启动流程"></a>内核启动流程</h2><p>linux启动前要求：</p><p>①、关闭 MMU。<br>②、关闭 D-cache。<br>③、 I-Cache 无所谓。<br>④、 r0&#x3D;0。<br>⑤、 r1&#x3D;machine nr(也就是机器 ID)。<br>⑥、 r2&#x3D;atags 或者设备树(dtb)首地址。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/20170315225401860.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootcmd和bootargs环境变量</title>
      <link href="/2023/03/22/2023-3-22-bootcmd%E5%92%8Cbootargs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2023/03/22/2023-3-22-bootcmd%E5%92%8Cbootargs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="环境变量bootcmd"><a href="#环境变量bootcmd" class="headerlink" title="环境变量bootcmd"></a>环境变量bootcmd</h2><p>bootcmd 保存着 uboot 默认命令， uboot 倒计时结束以后就会执行 bootcmd 中的命令。这些命令一般都是用来启动 Linux 内核的，比如读取 EMMC 或者 NAND Flash 中的 Linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 Linux 内核。 </p><p>如果 EMMC 或者 NAND 中没有保存 bootcmd 的值，那么 uboot 就会使用默认的值，板子第一次运行 uboot 的时候都会使用默认值来设置 bootcmd 环境变量。 </p><p>不设置bootcmd使用默认从emmc启动，<strong>先检查一下 EMMC 的分区 1 中有没有Image 文件和设备树文件，输入命令“ls mmc 1:1”</strong> 那么可以定义CONFIG_BOOTCOMMAND</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTCOMMAND \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;mmc dev 1;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fatload mmc 1:1 0x80800000 zImage;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fatload mmc 1:1 0x83000000 imx6ull-alientek-emmc.dtb;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootz 0x80800000 - 0x83000000;&quot;</span></span></span><br></pre></td></tr></table></figure><p>或者在uboot中设置bootcmd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000;&#x27;</span><br></pre></td></tr></table></figure><h2 id="环境变量bootargs"><a href="#环境变量bootargs" class="headerlink" title="环境变量bootargs"></a>环境变量bootargs</h2><p>bootargs 环境变量是由 mmcargs 设置的， mmcargs 环境变量如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; root=$&#123;mmcroot&#125;</span><br></pre></td></tr></table></figure><p>其中 console&#x3D;ttymxc0， baudrate&#x3D;115200， mmcroot&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw，因此将mmcargs 展开以后就是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmcargs=setenv bootargs console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw</span><br></pre></td></tr></table></figure><h4 id="console"><a href="#console" class="headerlink" title="console"></a>console</h4><p>console 用来设置 linux 终端(或者叫控制台)，也就是通过什么设备来和 Linux 进行交互，是串口还是 LCD 屏幕？如果是串口的话应该是串口几等等。一般设置串口作为 Linux 终端，这样我们就可以在电脑上通过 SecureCRT 来和 linux 交互了。 </p><p>设置 console 为 ttymxc0，因为 linux启动以后 I.MX6ULL 的串口 1 在 linux 下的设备文件就是&#x2F;dev&#x2F;ttymxc0 ，115200是波特率。</p><h4 id="root"><a href="#root" class="headerlink" title="root"></a>root</h4><p>root 用来设置根文件系统的位置， root&#x3D;&#x2F;dev&#x2F;mmcblk1p2 用于指明根文件系统存放在mmcblk1 设备的分区 2 中。emmc启动会存在两种文件，其中&#x2F;dev&#x2F;mmcblkx(x&#x3D;0<del>n)表示 mmc 设备，而&#x2F;dev&#x2F;mmcblkxpy(x&#x3D;0</del>n,y&#x3D;1~n)表示 mmc 设备x 的分区 y。在 I.MX6U-ALPHA 开发板中&#x2F;dev&#x2F;mmcblk1 表示 EMMC，而&#x2F;dev&#x2F;mmcblk1p2 表示EMMC 的分区 2。root 后面有“rootwait rw”， rootwait 表示等待 mmc 设备初始化完成以后再挂载，否则的话mmc 设备还没初始化完成就挂载根文件系统会出错的。 rw 表示根文件系统是可以读写的，不加rw 的话可能无法在根文件系统中进行写操作，只能进行读操作。 </p><h4 id="rootstype"><a href="#rootstype" class="headerlink" title="rootstype"></a>rootstype</h4><p>此选项一般配置 root 一起使用， rootfstype 用于指定根文件系统类型，如果根文件系统为ext 格式的话此选项无所谓。如果根文件系统是 yaffs、 jffs 或 ubifs 的话就需要设置此选项，指定根文件系统的类型。 </p><h2 id="网络启动Linux系统"><a href="#网络启动Linux系统" class="headerlink" title="网络启动Linux系统"></a>网络启动Linux系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz</span><br><span class="line">80800000 - 83000000&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>没网就完蛋。</p><h2 id="从emmc启动Linux系统"><a href="#从emmc启动Linux系统" class="headerlink" title="从emmc启动Linux系统"></a>从emmc启动Linux系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000</span><br><span class="line">imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000;&#x27;</span><br></pre></td></tr></table></figure><p>前提是设备树和镜像已经烧入emmc中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot移植</title>
      <link href="/2023/03/21/2023-3-21-U-Boot%E7%A7%BB%E6%A4%8D/"/>
      <url>/2023/03/21/2023-3-21-U-Boot%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="Uboot的移植"><a href="#Uboot的移植" class="headerlink" title="Uboot的移植"></a>Uboot的移植</h3><p>首先从官方下载一个Uboot，之后在此上面进行移植，可以进行使用脚本进行编译一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CORSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_evk_emmc_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><h3 id="在Uboot中添加使用的开发板"><a href="#在Uboot中添加使用的开发板" class="headerlink" title="在Uboot中添加使用的开发板"></a>在Uboot中添加使用的开发板</h3><h4 id="添加开发板默认配置文件"><a href="#添加开发板默认配置文件" class="headerlink" title="添加开发板默认配置文件"></a>添加开发板默认配置文件</h4><p>将cofigs目录下复制原有的mx6ull_14x14_evk_emmc_defconfig进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mx6ull_14x14_evk_emmc_defconfig mx6ull_alientek_emmc_defconfig</span><br></pre></td></tr></table></figure><p>修改mx6ull_alientek_emmc_defconfig文件，将原有的替换成mx6ull_alientek_emmc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYS_EXTRA_OPTIONS=&quot;IMX_CONFIG=board/freescale/mx6ull_alientek_emmc/imximage.cfg,MX6ULL_EVK_EMMC_REWORK&quot;</span><br><span class="line">CONFIG_ARM=y</span><br><span class="line">CONFIG_ARCH_MX6=y</span><br><span class="line">CONFIG_TARGET_MX6ULL_ALIENTEK_EMMC=y</span><br><span class="line">CONFIG_CMD_GPIO=y</span><br></pre></td></tr></table></figure><h4 id="添加开发板对应的头文件"><a href="#添加开发板对应的头文件" class="headerlink" title="添加开发板对应的头文件"></a>添加开发板对应的头文件</h4><p>在 目 录 include&#x2F;configs 下 添 加 I.MX6ULL-ALPHA 开 发 板 对 应 的 头 文 件 ， 复 制include&#x2F;configs&#x2F;mx6ullevk.h，并重命名为 mx6ull_alientek_emmc.h，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp include/configs/mx6ullevk.h mx6ull_alientek_emmc.h</span><br></pre></td></tr></table></figure><p>拷贝完成以后将：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __MX6ULLEVK_CONFIG_H</span><br><span class="line">#define __MX6ULLEVK_CONFIG_H</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __MX6ULL_ALIENTEK_EMMC_CONFIG_H</span><br><span class="line">#define __MX6ULL_ALIENTEK_EMMC_CONFIG_H </span><br></pre></td></tr></table></figure><p>此头文件主要功能就是配置或者裁剪 uboot。如果需要某个功能的话就在里面添加这个功能对应的 CONFIG_XXX 宏即可，如果不需要某个功能的话就删除掉对应的宏即可。 </p><h4 id="添加开发板对应的板级文件夹"><a href="#添加开发板对应的板级文件夹" class="headerlink" title="添加开发板对应的板级文件夹"></a>添加开发板对应的板级文件夹</h4><p>NXP 的 I.MX 系列芯片的所有板级文件夹都存放在 board&#x2F;freescale 目录下，在这个目录下有个名为 mx6ullevk 的文件夹，这个文件夹就是 NXP 官方 I.MX6ULL EVK 开发板的板级文件夹。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd board/freescale/</span><br><span class="line">cp mx6ullevk/ -r mx6ull_alientek_emmc</span><br><span class="line">cd mx6ull_alientek_emmc</span><br><span class="line">mv mx6ullevk.c mx6ull_alientek_emmc.c</span><br></pre></td></tr></table></figure><p>分别需要修改Makefile文件、imximage.cfg  文件、Kconfig 文件 、MAINTAINERS 文件 </p><p>Makefile要改编译的.o的文件名字。</p><p>imximage.cfg 需要修改PLUGIN 后面的板载二进制文件所在路径。</p><p>Kconfig 文件 需要改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if TARGET_MX6ULL_ALIENTEK_EMMC</span><br><span class="line"></span><br><span class="line">config SYS_BOARD</span><br><span class="line">default &quot;mx6ull_alientek_emmc&quot;</span><br><span class="line"></span><br><span class="line">config SYS_VENDOR</span><br><span class="line">default &quot;freescale&quot;</span><br><span class="line"></span><br><span class="line">config SYS_SOC</span><br><span class="line">default &quot;mx6&quot;</span><br><span class="line"></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line">default &quot;mx6ull_alientek_emmc&quot;</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>MAINTAINERS 文件需改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MX6ULL_ALIENTEK_EMMC BOARD</span><br><span class="line">M: Peng Fan &lt;peng.fan@nxp.com&gt;</span><br><span class="line">S: Maintained</span><br><span class="line">F: board/freescale/mx6ull_alientek_emmc/</span><br><span class="line">F: include/configs/mx6ull_alientek_emmc.h</span><br></pre></td></tr></table></figure><h4 id="修改U-boot图形化配置文件"><a href="#修改U-boot图形化配置文件" class="headerlink" title="修改U-boot图形化配置文件"></a>修改U-boot图形化配置文件</h4><p>修改文件arch&#x2F;arm&#x2F;cpu&#x2F;armv7&#x2F;mx6&#x2F;Kconfig ，207行加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config TARGET_MX6ULL_ALIENTEK_EMMC</span><br><span class="line">bool &quot;Support mx6ull_alientek_emmc&quot;</span><br><span class="line">select MX6ULL</span><br><span class="line">select DM</span><br><span class="line">select DM_THERMAL</span><br></pre></td></tr></table></figure><p>endif前加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &quot;board/freescale/mx6ull_alientek_emmc/Kconfig&quot;</span><br></pre></td></tr></table></figure><h3 id="LCD驱动修改"><a href="#LCD驱动修改" class="headerlink" title="LCD驱动修改"></a>LCD驱动修改</h3><p>一般 uboot 中修改驱动基本都是在 xxx.h 和 xxx.c 这两个文件中进行的， xxx 为板子名称，比如 mx6ull_alientek_emmc.h 和 mx6ull_alientek_emmc.c 这两个文件。<br>一般修改 LCD 驱动重点注意以下几点：<br>①、 LCD 所使用的 GPIO，查看 uboot 中 LCD 的 IO 配置是否正确。<br>②、 LCD 背光引脚 GPIO 的配置。<br>③、 LCD 配置参数是否正确。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20204212.png"></p><p>基于使用的lcd设置参数为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.mode= &#123;</span><br><span class="line">.name= &quot;TFT4384&quot;,</span><br><span class="line">.xres           = 800,</span><br><span class="line">.yres           = 480,</span><br><span class="line">.pixclock       = 31746,</span><br><span class="line">.left_margin    = 88,</span><br><span class="line">.right_margin   = 40,</span><br><span class="line">.upper_margin   = 32,</span><br><span class="line">.lower_margin   = 13,</span><br><span class="line">.hsync_len      = 48,</span><br><span class="line">.vsync_len      = 3,</span><br><span class="line">.sync           = 0,</span><br><span class="line">.vmode          = FB_VMODE_NONINTERLACED</span><br></pre></td></tr></table></figure><p>将mx6ull_alientek_emmc.h中的panel进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panel=TFT4384</span><br></pre></td></tr></table></figure><p>之后就可以编译烧录。正常显示出现以下东西。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-22%20133153.png"></p><p>如果没有出现效果，修改环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv panel TFT7016</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>如果只显示NXP没有uboot的版本号，并且报错<strong>no valid bmp image at 88000000</strong>，使用uboot命令清除一下环境变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env default -a</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><h3 id="网络驱动修改"><a href="#网络驱动修改" class="headerlink" title="网络驱动修改"></a>网络驱动修改</h3><p><strong>更换 PHY 芯片以后如何调整网络驱动</strong> </p><p>修改 ENET1 网络驱动的话重点就三点：<br>①、 ENET1 复位引脚初始化。<br>②、 LAN8720A 的器件 ID。<br>③、 LAN8720 驱动 </p><p>ENET2 网络驱动的修改也注意一下三点：<br>①、 ENET2 的复位引脚，从图 33.2.7.2 可以看出， ENET2 的复位引脚 ENET2_RST 接到了<br>I.MX6ULL 的 SNVS_TAMPER8 上。<br>②、 ENET2 所使用的 PHY 芯片器件地址，从图 33.2.7.2 可以看出， PHY 器件地址为 0X1。<br>③、 LAN8720 驱动， ENET1 和 ENET2 都使用的 LAN8720，所以驱动肯定是一样的。 </p><h4 id="网络PHY地址修改"><a href="#网络PHY地址修改" class="headerlink" title="网络PHY地址修改"></a>网络PHY地址修改</h4><p>修改ENETI和ENET2的PHY地址和驱动，ENET1和ENET2的PHY的地址存在mx6ull_alientek_emmc.h中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if (CONFIG_FEC_ENET_DEV == 0)</span><br><span class="line">#define CONFIG_FEC_MXC_PHYADDR 0x2//ENET1的地址改为0x0</span><br><span class="line">#elif (CONFIG_FEC_ENET_DEV == 1)</span><br><span class="line">#define CONFIG_FEC_MXC_PHYADDR 0x1//ENET2的地址相同不用改</span><br><span class="line">#define CONFIG_PHY_MICREL //使用 LAN8720A则改为CONFIG_PHY_SMSC</span><br></pre></td></tr></table></figure><p>因为两个板子的复位引脚不同。删除之前为了复位的扩展IO的代码，在mx6ull_alientek_emmc.c中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define IOX_SDI IMX_GPIO_NR(5, 10)</span><br><span class="line">#define IOX_STCP IMX_GPIO_NR(5, 7)</span><br><span class="line">#define IOX_SHCP IMX_GPIO_NR(5, 11)</span><br><span class="line">#define IOX_OE IMX_GPIO_NR(5, 8)</span><br></pre></td></tr></table></figure><p>替换为自己使用板子的网络复位IO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ENET1_RESET IMX_GPIO_NR(5, 7)</span><br><span class="line">#define ENET2_RESET IMX_GPIO_NR(5, 8)</span><br></pre></td></tr></table></figure><p>删除原有结构体和函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">iomux_v3_cfg_t</span> <span class="type">const</span> iox_pads[] = &#123;</span><br><span class="line"><span class="comment">/* IOX_SDI */</span></span><br><span class="line">MX6_PAD_BOOT_MODE0__GPIO5_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line"><span class="comment">/* IOX_SHCP */</span></span><br><span class="line">MX6_PAD_BOOT_MODE1__GPIO5_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line"><span class="comment">/* IOX_STCP */</span></span><br><span class="line">MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line"><span class="comment">/* IOX_nOE */</span></span><br><span class="line">MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">iox74lv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">gpio_direction_output(IOX_OE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">gpio_direction_output(IOX_SHCP, <span class="number">0</span>);</span><br><span class="line">gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="number">0</span>]);</span><br><span class="line">udelay(<span class="number">500</span>);</span><br><span class="line">gpio_direction_output(IOX_SHCP, <span class="number">1</span>);</span><br><span class="line">udelay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* shift register will be output to pins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">gpio_direction_output(IOX_STCP, <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iox74lv_set</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">gpio_direction_output(IOX_SHCP, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (i == index)</span><br><span class="line">gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="number">1</span>]);</span><br><span class="line">udelay(<span class="number">500</span>);</span><br><span class="line">gpio_direction_output(IOX_SHCP, <span class="number">1</span>);</span><br><span class="line">udelay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* shift register will be output to pins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">gpio_direction_output(IOX_STCP, <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>删掉板子初始化函数中的相关程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">board_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));<span class="comment">//删掉</span></span><br><span class="line">iox74lv_init();<span class="comment">//删掉</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加自己开发板的网络复位引脚驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">iomux_v3_cfg_t</span> <span class="type">const</span> fec1_pads[] = </span><br><span class="line">&#123;</span><br><span class="line">MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),</span><br><span class="line">MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">...</span><br><span class="line">MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL), <span class="comment">//新加的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">iomux_v3_cfg_t</span> <span class="type">const</span> fec2_pads[] = </span><br><span class="line">&#123;</span><br><span class="line">MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),</span><br><span class="line">MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">...</span><br><span class="line">MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),<span class="comment">//新加的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改初始化网络IO的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_iomux_fec</span><span class="params">(<span class="type">int</span> fec_id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fec_id == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">imx_iomux_v3_setup_multiple_pads(fec1_pads,ARRAY_SIZE(fec1_pads));</span><br><span class="line">gpio_direction_output(ENET1_RESET, <span class="number">1</span>);</span><br><span class="line">gpio_set_value(ENET1_RESET, <span class="number">0</span>);</span><br><span class="line">mdelay(<span class="number">20</span>);</span><br><span class="line">gpio_set_value(ENET1_RESET, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(fec2_pads,ARRAY_SIZE(fec2_pads));</span><br><span class="line">gpio_direction_output(ENET2_RESET, <span class="number">1</span>);</span><br><span class="line">gpio_set_value(ENET2_RESET, <span class="number">0</span>);</span><br><span class="line">mdelay(<span class="number">20</span>);</span><br><span class="line">gpio_set_value(ENET2_RESET, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 drivers&#x2F;net&#x2F;phy&#x2F;phy.c 文件中的函数 genphy_update_link </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">genphy_update_link</span><span class="params">(<span class="keyword">struct</span> phy_device *phydev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mii_reg;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PHY_SMSC</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lan8720_flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> bmcr_reg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (lan8720_flag == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);</span><br><span class="line">phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);</span><br><span class="line"><span class="keyword">while</span>(phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR) &amp; <span class="number">0X8000</span>) </span><br><span class="line">        &#123;</span><br><span class="line">udelay(<span class="number">100</span>);</span><br><span class="line"> &#125;</span><br><span class="line">phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg);</span><br><span class="line">lan8720_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait if the link is up, and autonegotiation is in progress</span></span><br><span class="line"><span class="comment"> * (ie - we&#x27;re capable and it&#x27;s not done)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就在Uboot中设置环境变量网址就可以应用了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot启动流程</title>
      <link href="/2023/03/17/2023-3-17-U-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/03/17/2023-3-17-U-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Uboot顶层Makefile详解"><a href="#Uboot顶层Makefile详解" class="headerlink" title="Uboot顶层Makefile详解"></a>Uboot顶层Makefile详解</h3><p><a href="https://blog.csdn.net/liurunjiang/article/details/107386600#:~:text=U-Boot%20%E9%A1%B6%E5%B1%82%20Makefile%20%E8%AF%A6%E8%A7%A3_River-D%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2%20U-Boot%20%E9%A1%B6%E5%B1%82%20Makefile%20%E8%AF%A6%E8%A7%A31%E3%80%81U-Boot,%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90%E6%88%91%E4%BB%AC%E5%9C%A8%E5%88%86%E6%9E%90%20uboot%20%E6%BA%90%E7%A0%81%E4%B9%8B%E5%89%8D%E4%B8%80%E5%AE%9A%E8%A6%81%E5%85%88%E5%9C%A8%20Ubuntu%20%E4%B8%AD%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%8B%20uboot%20%E6%BA%90%E7%A0%81%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%BC%9A%E7%94%9F%E6%88%90%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6%EF%BC%8C%E8%80%8C%E7%94%9F%E6%88%90%E7%9A%84%E8%BF%99%E4%BA%9B%E6%81%B0%E6%81%B0%E6%98%AF%E5%88%86%E6%9E%90uboot%20%E6%BA%90%E7%A0%81%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E6%96%87%E4%BB%B6%E3%80%82">(123条消息) U-Boot 顶层 Makefile 详解_River-D的博客-CSDN博客</a></p><table><thead><tr><th>名字</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>api</td><td>与硬件无关的 API 函数。</td><td>uboot 自带</td></tr><tr><td>arch</td><td>与架构体系有关的代码</td><td>uboot 自带</td></tr><tr><td>board</td><td>不同板子的代码</td><td>uboot 自带</td></tr><tr><td>cmd</td><td>命令相关的代码</td><td>uboot 自带</td></tr><tr><td>common</td><td>通用代码</td><td>uboot 自带</td></tr><tr><td>configs</td><td>配置文件</td><td>uboot 自带</td></tr><tr><td>disk</td><td>磁盘分区相关代码</td><td>uboot 自带</td></tr><tr><td>doc</td><td>文档</td><td>uboot 自带</td></tr><tr><td>drivers</td><td>驱动代码</td><td>uboot 自带</td></tr><tr><td>dts</td><td>设备树</td><td>uboot 自带</td></tr><tr><td>examples</td><td>示例代码</td><td>uboot 自带</td></tr><tr><td>fs</td><td>文件系统</td><td>uboot 自带</td></tr><tr><td>include</td><td>头文件</td><td>uboot 自带</td></tr><tr><td>lib</td><td>库文件</td><td>uboot 自带</td></tr><tr><td>Licenses</td><td>许可证相关代码</td><td>uboot 自带</td></tr><tr><td>net</td><td>网络相关代码</td><td>uboot 自带</td></tr><tr><td>post</td><td>上电自检代码</td><td>uboot 自带</td></tr><tr><td>scripts</td><td>脚本文件</td><td>uboot 自带</td></tr><tr><td>test</td><td>测试代码</td><td>uboot 自带</td></tr><tr><td>tools</td><td>工具文件夹</td><td>uboot 自带</td></tr><tr><td>.config配置文件</td><td>重要的文件</td><td>编译出来的文件</td></tr><tr><td>.gitignore git</td><td>工具相关文件</td><td>uboot 自带</td></tr><tr><td>.mailmap</td><td>邮件列表</td><td>uboot 自带</td></tr><tr><td>.u-boot.xxx.cmd(一系列)</td><td>这是一系列的文件，用于保存着一些命令</td><td>编译出来的文件</td></tr><tr><td>config.mk</td><td>某个Makefile 会调用此文件</td><td>uboot 自带</td></tr><tr><td>imxdownload</td><td>烧写软件</td><td></td></tr><tr><td>Kbuild</td><td>用于生成一些和汇编相关的文件</td><td>uboot 自带</td></tr><tr><td>Kconfig</td><td>图形配置界面描述文件</td><td>uboot 自带</td></tr><tr><td>MAINTAINERS</td><td>维护者联系方式文件</td><td>uboot 自带</td></tr><tr><td>MAKEALL</td><td>一个shell脚本文件，帮助编译uboot</td><td>uboot 自带</td></tr><tr><td>Makefile</td><td>主Makefile</td><td>uboot 自带</td></tr><tr><td>mx6ull_alientek_emmc.sh</td><td>编写的编译脚本文件</td><td></td></tr><tr><td>mx6ull_alientek_nand.sh</td><td>同上</td><td></td></tr><tr><td>README</td><td>帮助文档</td><td>uboot 自带</td></tr><tr><td>snapshot.commint</td><td>？</td><td>uboot 自带</td></tr><tr><td>System.map</td><td>系统映射文件</td><td>编译出来的文件</td></tr><tr><td>u-boot</td><td>编译出来的U-boot文件</td><td>编译出来的文件</td></tr><tr><td>u-boot.xxx(一系列)</td><td>生成一些u-boot相关的文件</td><td>编译出来的文件</td></tr></tbody></table><p>make命令的流程</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20110210.png"></p><h3 id="Uboot启动流程"><a href="#Uboot启动流程" class="headerlink" title="Uboot启动流程"></a>Uboot启动流程</h3><p>1)设置CPU为管理模式<br>2)关看门狗<br>3)关中断<br>4）设置时钟频率<br>5)关mmu,初始化各个bank<br>6)进入board_init_f()函数 (初始化定时器,GPIO,串口等,划分内存区域)<br>7)重定位     复制uboot,然后修改SDRAM上的uboot链接地址)<br>8)清bss<br>9)跳转到board_init_r()函数,启动流程结束<br><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/11c1d307acd641938a58a17230b05bbb.png"></p><p>bootz启动Linux内核过程</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20143309.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6ull SPI控制六轴</title>
      <link href="/2023/03/16/2023-3-15-imx6ull-SPI%E6%8E%A7%E5%88%B6%E5%85%AD%E8%BD%B4/"/>
      <url>/2023/03/16/2023-3-15-imx6ull-SPI%E6%8E%A7%E5%88%B6%E5%85%AD%E8%BD%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>SPI 全称是 Serial Perripheral Interface，也就是串行外围设备接口。是一种高速、<strong>全双工</strong>的同步通信总线，SPI 时钟频率相比 I2C 要高很多，最高可以工作在上百 MHz。</p><p><a href="https://shequ.stmicroelectronics.cn/forum.php?mod=viewthread&tid=627137">SPI原理超详细讲解-值得一看 (stmicroelectronics.cn)</a></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/e84057dcf8574933a3875761dd6002ef.png"></p><p>支持<strong>单主多从模式应用，时钟由Master控制，在时钟移位脉冲下，数据按位传输，高位在前，低位在后（MSB first）。</strong> <strong>4线SPI器件有四个信号：时钟(SPI CLK, SCLK)、主机输出从机输入(MOSI)、主机输入从机输出(MISO)、片选(CS&#x2F;NSS)。</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20150651.png"></p><h3 id="SPI数据传输"><a href="#SPI数据传输" class="headerlink" title="SPI数据传输"></a>SPI数据传输</h3><p>在MOSI、MISO和SPI主从机内部的<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2762981085%7D">数据寄存器</a>构成一个数据串行传输的环路，在时钟SCLK的控制下实现数据的环形传输。 <strong>要开始SPI通信，主机必须发送时钟信号，并通过使能NSS信号选择从机。</strong></p><p><u>SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。</u></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-14%20213838.png"></p><p>SPI 有四种工作模式，通过串行时钟极性(CPOL)和相位(CPHA)的搭配来得到四种工作模式：<br>①、CPOL&#x3D;0，串行时钟空闲状态为低电平。<br>②、CPOL&#x3D;1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具体的传输协议。<br>③、CPHA&#x3D;0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据。<br>④、CPHA&#x3D;1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据。</p><p>主从设备必须使用相同的工作模式——SCLK、CPOL 和 CPHA，才能正常工作。如果有多个从设备，并且它们使用了不同的工作模式，那么主设备必须在读写不同从设备时需要重新修改对应从设备的模式。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20151311.png"></p><p>I.MX6U 自带的 SPI 外设叫做 ECSPI，ESPI特性：</p><p>①、全双工同步串行接口。<br>②、可配置的主&#x2F;从模式。<br>③、四个片选信号，支持多从机。<br>④、发送和接收都有一个 32x64 的 FIFO。<br>⑤、片选信号 SS&#x2F;CS，时钟信号 SCLK 极性可配置。<br>⑥、支持 DMA。</p><p>This section provides initialization information for ECSPI.<br>To initialize the block:</p><ol><li>Clear the EN bit in ECSPI_CONREG to reset the block.</li><li>Enable the clocks for ECSPI within the CCM.</li><li>Configure the Control Register and then set the EN bit in the ECSPI_CONREG to put ECSPI out of reset.</li><li>Configure corresponding IOMUX for ECSPI external signals.</li><li>Configure registers of ECSPI properly according to the specifications of the external SPI device.</li></ol><h3 id="使用的寄存器："><a href="#使用的寄存器：" class="headerlink" title="使用的寄存器："></a>使用的寄存器：</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20161914.png"></p><h3 id="ICM-20608传感器"><a href="#ICM-20608传感器" class="headerlink" title="ICM-20608传感器"></a>ICM-20608传感器</h3><p>陀螺仪具有两个特性：一个空间的刚性，一个行进性。<em><strong>螺仪就是测角速度的，加速度传感器就是测角加速度的，二者数据通过算法就可以得到PITCH、YAW、ROLL角了。</strong></em>关于陀螺仪传感器原理可看以下链接<a href="https://www.bilibili.com/video/BV1YK411A7HU/?spm_id_from=333.337.search-card.all.click&vd_source=a29cba237e61c1d3e1d8193673a58e41">解密手机陀螺仪原理_哔哩哔哩_bilibili</a></p><p>ICM-20608 内部有一个 512字节的 FIFO。陀螺仪的量程范围可以编程设置，可选择±250，±500，±1000 和±2000°&#x2F;s，加速度的量程范围也可以编程设置，可选择±2g，±4g，±8g 和±16g。陀螺仪和加速度计都是 16 位的 ADC，并且支持 I2C 和 SPI 两种协议，具有以下特点：</p><p>①、陀螺仪支持 X,Y 和 Z 三轴输出，内部集成 16 位 ADC，测量范围可设置：±250，±500，±1000 和±2000°&#x2F;s。<br>②、加速度计支持 X,Y 和 Z 轴输出，内部集成 16 位 ADC，测量范围可设置：±2g，±4g，±4g，±8g 和±16g。<br>③、用户可编程中断。<br>④、内部包含 512 字节的 FIFO。<br>⑤、内部包含一个数字温度传感器。<br>⑥、耐 10000g 的冲击。<br>⑦、支持快速 I2C，速度可达 400KHz。<br>⑧、支持 SPI，速度可达 8MHz。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-16%20142813.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git提交代码到远程仓库</title>
      <link href="/2023/03/16/2023-3-16-git%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2023/03/16/2023-3-16-git%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="git如何提交代码到远程仓库"><a href="#git如何提交代码到远程仓库" class="headerlink" title="git如何提交代码到远程仓库"></a>git如何提交代码到远程仓库</h2><p>使用这个的原因的是看到有的嵌入式就职询问会问道，而且使用git可以将本地代码部署到github，可以备份，多台电脑开发一个工程很方便。</p><p>首先是进行安装git再Linux的系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>注册用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>检查配置信息的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p><strong>下载代码</strong></p><p>使用git clone从现有的git仓库中拷贝项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-16%20132517.png"></p><p>如果克隆到指定目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址 目录</span><br></pre></td></tr></table></figure><p>如果git clone卡住了，可以参考以下链接<a href="https://zhuanlan.zhihu.com/p/557331130#:~:text=git%20clone%20%E7%89%B9%E5%88%AB%E6%85%A2%E6%98%AF%E7%94%B1%E4%BA%8E%20github.global.ssl.fastly.net%20%E5%92%8C%20github.com%20%E5%9F%9F%E5%90%8D%E8%A2%AB%E9%99%90%E5%88%B6%E4%BA%86%EF%BC%8C%E6%89%80%E4%BB%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%9D%E8%B7%AF%E5%B0%B1%E6%98%AF,%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%AA%E5%9F%9F%E5%90%8D%E5%AF%B9%E5%BA%94%E7%9A%84ip%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%88%91%E4%BB%AC%E6%9C%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%8A%A0%E4%B8%8A%20ip%20-%3E%20%E5%9F%9F%E5%90%8D%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%88%B7%E6%96%B0%20DNS%20%E7%BC%93%E5%AD%98%E5%8D%B3%E5%8F%AF%20%E3%80%82">极智开发 | 解决 linux 上 git clone 慢或失败的方法 - 知乎 (zhihu.com)</a></p><p><strong>上传代码</strong></p><p>初始化本地仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>之后就可以往这个目录中写入文件，之后使用以下命令进行部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">这个命令是将目录下的所有文件添加到暂存区域</span><br><span class="line">git add 文件名</span><br><span class="line">添加文件到暂存库</span><br><span class="line">git status</span><br><span class="line">查看仓库当前的状态，显示变更的文件</span><br><span class="line">git log</span><br><span class="line">查看提交历史</span><br><span class="line">git commit</span><br><span class="line">添加文件到本地库</span><br><span class="line">git commit -m &quot;备注&quot;</span><br><span class="line">添加文件到本地库并写上备注</span><br><span class="line">git remote add origin 仓库地址</span><br><span class="line">git push -u origin master</span><br><span class="line">就可以部署了</span><br></pre></td></tr></table></figure><p>如果git push弹出账号和密码的输入，就需要填写用户信息，以及github的token，因为最近的版本的只允许使用token禁用了密码，如果想免除每次输入token的问题</p><p>可以使用以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>之后一直回车</p><p>最后查看生成的id_rsa.pub文件内容，将其添加到GitHub中，形成私钥。</p><p>如果git push 失败那么，使用指令进行重置代理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global  --unset http.https://github.com.proxy </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Imx6ull数据手册生词</title>
      <link href="/2023/03/14/2023-3-14-Imx6ull%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E7%94%9F%E8%AF%8D/"/>
      <url>/2023/03/14/2023-3-14-Imx6ull%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E7%94%9F%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>生词</th><th>汉译</th></tr></thead><tbody><tr><td>prescaler</td><td>预分频器</td></tr><tr><td>programmable</td><td>可编程</td></tr><tr><td>route</td><td>线路</td></tr><tr><td>formula</td><td>公式</td></tr><tr><td>subroutine</td><td>子程序</td></tr><tr><td>reprogram</td><td>重新编程</td></tr><tr><td>parameter</td><td>参数</td></tr><tr><td>slave</td><td>从机</td></tr><tr><td>arbitration</td><td>仲裁</td></tr><tr><td>addressed</td><td>解决</td></tr><tr><td>multiplexing</td><td>多路复用</td></tr><tr><td>acknowledge signal</td><td>应答信号</td></tr><tr><td>master drive high</td><td>主驱动器高</td></tr><tr><td>pending</td><td>待定</td></tr><tr><td>idle</td><td>闲置</td></tr><tr><td>muxe</td><td>多路复用器</td></tr><tr><td>peripheral</td><td>外设</td></tr><tr><td>dedicated software</td><td>专用软件</td></tr><tr><td>daisy chain</td><td>菊花链式结构</td></tr><tr><td>external</td><td>外部</td></tr><tr><td>diagram</td><td>图</td></tr><tr><td>synchronize</td><td>同步</td></tr><tr><td>field</td><td>场</td></tr><tr><td>initialize the counter</td><td>初始化计数器</td></tr><tr><td>duplex</td><td>双工</td></tr><tr><td>synchronous</td><td>同步</td></tr><tr><td>polarity</td><td>极性</td></tr><tr><td>FIFO</td><td>先进先出</td></tr><tr><td>kernel</td><td>内核</td></tr><tr><td>relocaddr</td><td>搬迁地址</td></tr><tr><td>bracket</td><td>把。。。分类</td></tr><tr><td>framebuffer</td><td>帧缓存</td></tr><tr><td>alignment</td><td>队列</td></tr><tr><td>alloc</td><td>分配内存</td></tr><tr><td>miscellaneous</td><td>杂项</td></tr><tr><td>modularize</td><td>模块化</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6ull的IIC实验</title>
      <link href="/2023/03/13/2023-3-13-imx6ull%E7%9A%84IIC%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/03/13/2023-3-13-imx6ull%E7%9A%84IIC%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h2><p>IIC是半双工通信（同一时间单向通信），I2C 使用两条线在主控制器和从机之间进行数据通信。一条是 SCL(串行时钟线)，另外一条是 SDA(串行数据线)，这两条数据线需要接上拉电阻，总线空闲的时候 SCL 和 SDA 处于高电平。I2C 总线标准模式下速度可以达到 100Kb&#x2F;S，快速模式下可以达到 400Kb&#x2F;S。I2C 总线工作是按照一定的协议来运行的，接下来就看一下 I2C 协议。</p><p>主机就是负责整个系统的任务协调与分配，从机一般是通过接收主机的指令从而完成某些特定的任务，主机和从机之间通过总线连接，进行数据通讯。</p><ul><li>发布主要命令的称为主机</li><li>接受命令的称为从机</li></ul><p>IIC主设备功能：主要产生时钟，产生起始信号，停止信号。</p><p>IIC从设备功能：可编程的IIC地址检测，停止位检测。</p><p>**IIC的一个优点是它支持多主控(multimastering)**， 其中任何一个能够进行发送和接收的设备都可以成为主总线。一个主控能够控制信号的传输和时钟频率。当然，在任何时间点上只能有一个主控。</p><p>I2C是支持多从机应答，也就是一个 I2C 控制器下可以挂多个 I2C 从设备，这些不同的 I2C从设备有不同的器件地址，这样 I2C 主控制器就可以通过 I2C 设备的器件地址访问指定的 I2C设备了，</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-11%20145203.png"></p><p>I2C协议</p><p>起始信号：在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位。</p><p>终止信号：停止位就是停止 I2C 通信的标志位，和起始位的功能相反。在 SCL 位高电平的时候，SDA出现上升沿就表示为停止位。</p><p>数据传输：I2C 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，因此 SDA 上的数据变化只能在 SCL 低电平期间发生</p><p>应答信号：当 I2C 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 I2C 从机应答，也就是等到 I2C 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。</p><h2 id="IIC写数据"><a href="#IIC写数据" class="headerlink" title="IIC写数据"></a>IIC写数据</h2><p>写时序</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-11%20153434.png"></p><p>起始信号-&gt;器件地址（7位地址加一个读写位）-&gt;等待应答-&gt;要操作内存的地址-&gt;等待应答-&gt;写入数据-&gt;等待应答-&gt;停止读时序</p><p>主机向从机写数据时候；</p><p>1.主机产生起始信号；</p><p>2.然后紧跟着发送一个地址，地址一共有7位，紧跟着第8位是数据方向位，0表示主机发送数据，1表示主机接受数据（读）；</p><p>3.主机发送地址时，总线上的每个从机都将7位地址位与自己的地址比较，相同代表正在被主机寻址，根据R&#x2F;T位将自己确定为发送器或者接收器；</p><p>4.这时主机等待从机的应答信号（A）；</p><p>5.当主机收到应答信号时，发送要访问从机的那个地址，继续等待从机的应答信号；</p><p>6.当主机收到应答信号时，发送N个字节的数据，继续等待从机的N次应答信号；</p><p>7.主机产生停止信号，结束传输过程。</p><h2 id="IIC读数据"><a href="#IIC读数据" class="headerlink" title="IIC读数据"></a>IIC读数据</h2><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-11%20153441.png"></p><p>起始信号-&gt;器件地址(7+1位写（0）)-&gt;应答-&gt;读取地址-&gt;应答-&gt;起始信号-.&gt;器件地址（7位+读（1））-&gt;应答-&gt;读取数据-&gt;发送应答-&gt;停止信号</p><p>1.主机产生起始信号；</p><p>2.然后紧跟着发送一从机个地址，地址一共有7位，第8位为0，表明是向从机写命令；</p><p>3.主机等待从机的应答信号（ACK）；</p><p>4.这时主机收到从机的应答信号（A），发送要访问的地址，继续等待从机的应答信号；</p><p>5.当主机收到应答信号后，主机要改变通信模式（主机将由发送变为接受，从机将由接受变为发送）所以主机重新发送一个起始信号，之后紧接着发送一个从机地址，此时该地址第8位为1，表明将主机设置成接受模式开始读取数据；</p><p>6.这时候主机等待从机的应答信号，当主机收到应答信号时， 就可以接受1个字节数据，当接受完成后， 主机发送非应答信号时候，表示不在接受数据；</p><p>7.主机产生停止信号，结束传输过程。</p><h3 id="使用的寄存器"><a href="#使用的寄存器" class="headerlink" title="使用的寄存器"></a>使用的寄存器</h3><p>IIC的地址寄存器 I2Cx_IADR(x&#x3D;1<del>4)寄存器，(x&#x3D;1</del>4)寄存器，这是I2C 的地址寄存器，只有 ADR(bit7:1)位有效，</p><p>用来保存 I2C 从设备地址数据。</p><p>I2C Frequency Divider Register (I2C1_IFDR) ：IC(bit5:0)这个位，用来设置 I2C 的波特率，I2C 的时钟源可以选择 IPG_CLK_ROOT&#x3D;66MHz，通过设置 IC 位既可以得到想要的 I2C 波特率。</p><p>&#x3D;&#x3D;<strong>时钟源&#x3D;IC设置的分频值*波特率。</strong>&#x3D;&#x3D;</p><p>I2C Control Register (I2C1_I2CR) </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-11%20172654.png"></p><p>IEN(bit7)：I2C 使能位，为 1 的时候使能 I2C，为 0 的时候关闭 I2C。<br>IIEN(bit6)：I2C 中断使能位，为 1 的时候使能 I2C 中断，为 0 的时候关闭 I2C 中断。<br>MSTA(bit5)：主从模式选择位，设置 IIC 工作在主模式还是从模式，为 1 的时候工作在主<br>模式，为 0 的时候工作在从模式。<br>MTX(bit4)：传输方向选择位，用来设置是进行发送还是接收，为 0 的时候是接收，为 1 的<br>时候是发送。<br>TXAK(bit3)：传输应答位使能，为 0 的话发送 ACK 信号，为 1 的话发送 NO ACK 信号。<br>RSTA(bit2)：重复开始信号，为 1 的话产生一个重新开始信号。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-11%20173313.png"></p><p>ICF(bit7)：数据传输状态位，为 0 的时候表示数据正在传输，为 1 的时候表示数据传输完成。<br>IAAS(bit6)：当为 1 的时候表示 I2C 地址，也就是 I2Cx_IADR 寄存器中的地址是从设备地址。<br>IBB(bit5)：I2C 总线忙标志位，当为 0 的时候表示 I2C 总线空闲，为 1 的时候表示 I2C 总线忙。<br>IAL(bit4)：仲裁丢失位，为 1 的时候表示发生仲裁丢失。<br>SRW(bit2)：从机读写状态位，当 I2C 作为从机的时候使用，此位用来表明主机发送给从机的是读还是写命令。为 0 的时候表示主机要向从机写数据，为 1 的时候表示主机要从从机读取数据。<br>IIF(bit1)：I2C 中断挂起标志位，当为 1 的时候表示有中断挂起，此位需要软件清零。<br>RXAK(bit0)：应答信号标志位，为 0 的时候表示接收到 ACK 应答信号，为 1 的话表示检测到 NO ACK 信号。</p><p>I2C Data I&#x2F;O Register (I2C1_I2DR) ，这是 I2C 的数据寄存器，此寄存器只有低 8 位有效，当要发送数据的时候将要发送的数据写入到此寄存器，如果要接收数据的话直接读取此寄存器即可得到接收到的数据。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20112239.png"></p><h2 id="硬件IIC和软件IIC"><a href="#硬件IIC和软件IIC" class="headerlink" title="硬件IIC和软件IIC"></a>硬件IIC和软件IIC</h2><p>所谓硬件I2C对应芯片上的I2C外设，有相应I2C驱动电路，其所使用的I2C管脚也是专用的；软件I2C一般是用GPIO管脚，用软件控制管脚状态以模拟I2C通信波形。</p><p>硬件I2C的效率要远高于软件的，而软件I2C由于不受管脚限制，接口比较灵活。</p><p>至于如何区分它们：<br>可以看底层配置，比如IO口配置，如果配置了IO口的功能（IIC功能）那就是固件IIC，否则就是模拟。<br>可以看IIC写函数，看里面有木有调用现成的函数或者给某个寄存器赋值，如果有，则肯定是固件IIC功能，没有的话肯定是数据一个bit一个bit模拟发生送的，肯定用到了循环，则为模拟。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6ull的RTC 实时时钟实验</title>
      <link href="/2023/03/10/2023-3-20-imx6ull%E7%9A%84RTC-%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/03/10/2023-3-20-imx6ull%E7%9A%84RTC-%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="实时时钟实现原理"><a href="#实时时钟实现原理" class="headerlink" title="实时时钟实现原理"></a>实时时钟实现原理</h4><p>I.MX6U 系列的 RTC 是在 SNVS 里面，SNVS 直译过来就是安全的非易性存储，SNVS 里面主要是一些低功耗的外设，包括一个安全的实时计数器(RTC)、一个单调计数器(monotonic counter)和一些通用的寄存器。SNVS 有两部分：SNVS_HP 和 SNVS_LP，系统主电源断电以后 SNVS_HP 也会断电，但是在后备电源支持下，SNVS_LP 是不会断电的，而且 SNVS_LP是和芯片复位隔离开的，因此 SNVS_LP 相关的寄存器的值会一直保存着。</p><p>①、SNVS_LP：专用的always-powered-on电源域，系统主电源和备用电源都可以为其供电。<br>②、SNVS_HP：系统（芯片）电源。</p><p>SNVS_LP和SNVS_LP都有SRTC，为保证掉电后依旧可以执行，所以设置SNVS_LP中的SRTC来实现实时时钟。</p><p>在硬件方面，SRTC需要外界提供一个32.768KHz的时钟，寄存器 SNVS_LPSRTCMR 和 SNVS_LPSRTCLR 保存着秒数，直接读取这两个寄存器的值就知道过了多长时间了。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-10%20135947.png"></p><h4 id="使用的SNVS寄存器："><a href="#使用的SNVS寄存器：" class="headerlink" title="使用的SNVS寄存器："></a>使用的SNVS寄存器：</h4><p><strong>①</strong>SNVS_HPCOMR</p><p>NPSWA_EN(bit31)，这个位是非特权软件访问控制位，如果非特权软件要访问 SNVS 的话此位必须为 1</p><p><strong>②</strong>SNVS_LPCR</p><p>SRTC_ENV(bit0)，此位为 1 的话就使能 STC 计数器。</p><p><strong>③</strong>SNVS_SRTCMR</p><p>SNVS_SRTCMR 的 bit14:0 这 15 位是 SRTC 计数器的高 15 位。</p><p><strong>④</strong>SNVS_SRTCLR</p><p>SNVS_SRTCLR 的 bit31:bit15 这 17 位是 SRTC 计数器的低 17 位。</p><h4 id="使能SRTC的配置如下："><a href="#使能SRTC的配置如下：" class="headerlink" title="使能SRTC的配置如下："></a><strong>使能SRTC的配置如下：</strong></h4><p>（1）初始化SNVS_SRTC<br>     初始化SNVS_LP中的SRTC。<br>（2）设置RTC时间<br>     第一次使用RTC肯定要先设置时间。<br>（3）使能RTC<br>     配置好RTC并设置好初始时间以后就可以开启RTC了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补充知识点</title>
      <link href="/2023/03/07/2023-3-06-%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/03/07/2023-3-06-%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="嵌入式面向对象编程"><a href="#嵌入式面向对象编程" class="headerlink" title="嵌入式面向对象编程"></a>嵌入式面向对象编程</h3><p>面向对象，是编程界的一个概念。什么叫面向对象呢？编程有两种要素：程序（方法），数据（属性）。例如：一个LED，我们可以点亮或者熄灭它，这叫方法。LED什么状态？亮还是灭？这就是属性。我们通常这样编程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u8 ledsta = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ledset</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的编程有一个问题，假如我们有10个这样的LED，怎么写？这时我们可以引入面向对象编程，将每一个LED封装为一个对象。可以这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个结构体，将LED这个对象的属性跟方法封装。</span></span><br><span class="line"><span class="comment">这个结构体就是一个对象。</span></span><br><span class="line"><span class="comment">但是这个不是一个真实的存在，而是一个对象的抽象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u8 sta;</span><br><span class="line"><span class="type">void</span> (*setsta)(u8 sta);</span><br><span class="line">&#125;LedObj;</span><br><span class="line"><span class="comment">/* 声明一个LED对象，名称叫做LED1，并且实现它的方法drv_led1_setsta*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">drv_led1_setsta</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LedObj LED1=&#123;</span><br><span class="line"></span><br><span class="line">.sta = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">.setsta = drv_led1_setsta,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明一个LED对象，名称叫做LED2，并且实现它的方法drv_led2_setsta*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drv_led2_setsta</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LedObj LED2=&#123;</span><br><span class="line"></span><br><span class="line">.sta = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">.setsta = drv_led2_setsta,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 操作LED的函数，参数指定哪个led*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ledset</span><span class="params">(LedObj *led, u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">led-&gt;setsta(sta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，在C语言中，实现面向对象的手段就是结构体的使用。上面的代码，对于API来说，就很友好了。操作所有LED，使用同一个接口，只需告诉接口哪个LED。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u的RGBlCD显示</title>
      <link href="/2023/03/06/2023-3-06-imx6u%E7%9A%84RGBlCD%E6%98%BE%E7%A4%BA/"/>
      <url>/2023/03/06/2023-3-06-imx6u%E7%9A%84RGBlCD%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="像素格式"><a href="#像素格式" class="headerlink" title="像素格式"></a>像素格式</h3><p>一个像素点就相当于一个 RGB 小灯，通过控制 R、G、B 这三种颜色的亮度就可以显示出各种各样的色彩。那该如何控制 R、G、B 这三种颜色的显示亮度呢？一般一个 R、G、B 这三部分分别使用 8bit 的数据，那么一个像素点就是 8bit*3&#x3D;24bit，也就是说一个像素点3 个字节，这种像素格式称为 RGB888。如果再加入 8bit 的 Alpha(透明)通道的话一个像素点就是 32bit，也就是 4 个字节，这种像素格式称为 ARGB8888。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20140301.png"></p><p>一个像素点是 4 个字节，其中 bit31<del>bit24 是 Alpha 通道，bit23</del>bit16 是RED 通道，bit15<del>bit14 是 GREEN 通道，bit7</del>bit0 是 BLUE 通道。所以红色对应的值就是0X00FF0000，蓝色对应的值就是 0X000000FF，绿色对应的值为 0X0000FF00。通过调节 R、G、B的比例可以产生其它的颜色，比如0X00FFFF00就是黄色，0X00000000就是黑色，0X00FFFFFF就是白色。</p><p>R[7:0]、G[7:0]和B[7:0]这24根是数据线，DE、VSYNC、HSYNC 和 PCLK 这四根是控制信号线。RGB LCD 一般有两种驱动模式：DE 模式和 HV 模式，这两个模式的区别是 DE 模式需要用到 DE 信号线，而 HV 模式不需要用到 DE 信号线，在 DE模式下是可以不需要 HSYNC 信号线的，即使不接 HSYNC 信号线 LCD 也可以正常工作。</p><h3 id="lcd显示过程"><a href="#lcd显示过程" class="headerlink" title="lcd显示过程"></a><a href="https://www.cnblogs.com/fah936861121/articles/7116400.html">lcd显示过程</a></h3><h3 id="RGBLCD屏幕时序"><a href="#RGBLCD屏幕时序" class="headerlink" title="RGBLCD屏幕时序"></a>RGBLCD屏幕时序</h3><p>行显示时序图片：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20142928.png"></p><p>HSYNC：行同步信号，当此信号有效的话就表示开始显示新的一行数据，查阅所使用的LCD 数据手册可以知道此信号是低电平有效还是高电平有效，假设此时是低电平有效。<br>HSPW：有些地方也叫做 thp，是 HSYNC 信号宽度，也就是 HSYNC 信号持续时间。HSYNC信号不是一个脉冲，而是需要持续一段时间才是有效的，单位为 CLK。<br>HBP：有些地方叫做 thb，前面已经讲过了，术语叫做行同步信号后肩，单位是 CLK。<br>HOZVAL：有些地方叫做 thd，显示一行数据所需的时间，假如屏幕分辨率为 1024*600，那么 HOZVAL 就是 1024，单位为 CLK。<br>HFP：有些地方叫做 thf，术语叫做行同步信号前肩，单位是 CLK。当 HSYNC 信号发出以后，需要等待 HSPW+HBP 个 CLK 时间才会接收到真正有效的像素数据。当显示完一行数据以后需要等待 HFP 个 CLK 时间才能发出下一个 HSYNC 信号，所以显示一行所需要的时间就是：HSPW + HBP + HOZVAL + HFP。<br>一帧图像就是由很多个行组成的，</p><p>帧显示时序图片：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20143953.png"></p><p>VSYNC：帧同步信号，当此信号有效的话就表示开始显示新的一帧数据，查阅所使用的<br>LCD 数据手册可以知道此信号是低电平有效还是高电平有效，假设此时是低电平有效。<br>VSPW：有些地方也叫做 tvp，是 VSYNC 信号宽度，也就是 VSYNC 信号持续时间，单位为 1 行的时间。<br>VBP：有些地方叫做 tvb，前面已经讲过了，术语叫做帧同步信号后肩，单位为 1 行的时间。<br>LINE：有些地方叫做 tvd，显示一帧有效数据所需的时间，假如屏幕分辨率为 1024*600，那么 LINE 就是 600 行的时间。<br>VFP：有些地方叫做 tvf，前面已经讲过了，术语叫做帧同步信号前肩，单位为 1 行的时间。显示一帧所需要的时间就是：VSPW+VBP+LINE+VFP 个行时间</p><p><strong>最终的计算公式：</strong><br>T &#x3D; (VSPW+VBP+LINE+VFP) * (HSPW + HBP + HOZVAL + HFP)</p><p>4.3寸屏幕参数：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20212722.png"></p><p>显示一帧图像所要的时钟数为</p><p>&#x3D; (VSPW+VBP+LINE+VFP) * (HSPW + HBP + HOZVAL + HFP)</p><p>&#x3D;(480+3+32+13)*(48+88+800+40)&#x3D;515328</p><p>显示一帧图像需要515328个时钟数，那么显示60帧就是：515328 * 60 &#x3D; 30,919,680≈31M，所以像素时钟就是 31MHz。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20144933.png"></p><p>①、此部分是一个选择器，用于选择哪个 PLL 可以作为 LCDIF 时钟源，由寄存器CCM_CSCDR2 的位 LCDIF1_PRE_CLK_SEL(bit17:15)来决定，LCDIF1_PRE_CLK_SEL 选择设置如表</p><table><thead><tr><th align="center">值</th><th>时钟源</th></tr></thead><tbody><tr><td align="center">0</td><td>PLL2 作为 LCDIF 的时钟源。</td></tr><tr><td align="center">1</td><td>PLL3_PFD3 作为 LCDIF 的时钟源。</td></tr><tr><td align="center">2</td><td>PLL5 作为 LCDIF 的时钟源。</td></tr><tr><td align="center">3</td><td>PLL2_PFD0 作为 LCDIF 的时钟源。</td></tr><tr><td align="center">4</td><td>PLL2_PFD1 作为 LCDIF 的时钟源。</td></tr><tr><td align="center">5</td><td>PLL3_PFD1 作为 LCDIF 的时钟源。</td></tr></tbody></table><p>②、此部分是 LCDIF 时钟的预分频器，由寄存器 CCM_CSCDR2 的位 LCDIF1_PRED 来决定预分频值。可设置值为 0<del>7，分别对应 1</del>8 分频。<br>③、此部分进一步分频，由寄存器 CBCMR 的位 LCDIF1_PODF 来决定分频值。可设置值为 0<del>7，分别对应 1</del>8 分频。<br>④、此部分是一个选择器，选择 LCDIF 最终的根时钟，由寄存器 CSCDR2 的位LCDIF1_CLK_SEL 决定，LCDIF1_CLK_SEL 选择设置如表</p><table><thead><tr><th align="center">值</th><th align="left">时钟源</th></tr></thead><tbody><tr><td align="center">0</td><td align="left">前面复用器出来的时钟，也就是前面 PLL5 出来的时钟作<br/>为 LCDIF 的根时钟。</td></tr><tr><td align="center">1</td><td align="left">ipp_di0_clk 作为 LCDIF 的根时钟。</td></tr><tr><td align="center">2</td><td align="left">ipp_di1_clk 作为 LCDIF 的根时钟。</td></tr><tr><td align="center">3</td><td align="left">ldb_di0_clk 作为 LCDIF 的根时钟。</td></tr><tr><td align="center">4</td><td align="left">ldb_di1_clk 作为 LCDIF 的根时钟。</td></tr></tbody></table><p>定选择 PLL5 出来的那一路时钟作为 LCDIF 的根时钟，因此 LCDIF1_CLK_SEL 设置为 0。LCDIF 既然选择了 PLL5 作为时钟源，那么还需要初始化 PLL5，LCDIF 的时钟是由PLL5 和接口时钟图片②、③这两个分频值决定的，</p><p><strong>PLL5_CLK &#x3D; OSC24M * (loopDivider + (denominator &#x2F; numerator)) &#x2F; postDivider</strong></p><p>设置为24*（1+7&#x2F;8）&#x2F;1&#x3D;45</p><p>②和③进一步分频，设置②中为 1 分频，也就是寄存器 CCM_CSCDR2 的位 LCDIF1_PRED(bit14:12)为 0。设置③中为 5 分频，就是寄存器CCM_CBCMR 的位 LCDIF1_PODF(bit25:23)为 4。设置好以后最终进入到 LCDIF 的时钟频率就是：45&#x2F;1&#x2F;5 &#x3D;9MHz，这就是我们需要的像素时钟频率。</p><h3 id="显存"><a href="#显存" class="headerlink" title="显存"></a>显存</h3><p>如果采用 ARGB8888 格式的话一个像素需要 4 个字节的内存来存放像素数据，那么 1024<em>600 分辨率就需要 1024</em>600*4&#x3D;2457600B≈2.4MB 内存。但是 RGB LCD 内部是没有内存的，所以就需要在开发板上的 DDR3 中分出一段内存作为 RGB LCD 屏幕的显存，我们如果要在屏幕上显示什么图像的话直接操作这部分显存即可。</p><h3 id="eLCDIF-接口"><a href="#eLCDIF-接口" class="headerlink" title="eLCDIF 接口"></a>eLCDIF 接口</h3><p>eLCDIF 是 I.MX6U 自带的液晶屏幕接口，用于连接 RGB LCD 接口的屏幕，eLCDIF 接口特性如下：</p><p>①、支持 RGB LCD 的 DE 模式。<br>②、支持 VSYNC 模式以实现高速数据传输。<br>③、支持 ITU-R BT.656 格式的 4:2:2 的 YCbCr 数字视频，并且将其转换为模拟 TV 信号。<br>④、支持 8&#x2F;16&#x2F;18&#x2F;24&#x2F;32 位 LCD。</p><p>eLCDIF 支持三种接口：MPU 接口、VSYNC 接口和 DOTCLK 接口，这三种接口区别如下：</p><p>①MPU 接口用于在 I.MX6U 和 LCD 屏幕直接传输数据和命令，这个接口用于 6080&#x2F;8080 接口的 LCD 屏幕，关于 MPU 接口的详细信息以及时序参考《I.MX6ULL 参考手册》第 2150 页的“34.4.6MPU Interface”小节</p><p>⑤VSYNC 接口时序和 MPU 接口时序基本一样，只是多了 VSYNC 信号来作为帧同步，当LCDIF_CTRL 的位 VSYNC_MODE 为 1 的时候此接口使能。关于 VSYNC 接口的详细信息请参考《I.MX6ULL 参考手册》第 2152 页的“34.4.7 VSYNC Interface”小节。</p><p>③DOTCLK 接口就是用来连接 RGB LCD 接口屏幕的， 它包括 VSYNC、HSYNC、DOTCLK和 ENABLE(可选的)这四个信号，这样的接口通常被称为 RGB 接口。</p><h3 id="配置寄存器"><a href="#配置寄存器" class="headerlink" title="配置寄存器"></a>配置寄存器</h3><p><strong>配置eLCDIF接口的寄存器</strong>：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20154312.png"></p><p>SFTRST(bit31)：eLCDIF 软复位控制位，当此位为 1 的话就会强制复位 LCD。<br>CLKGATE(bit30)：正常运行模式下，此位必须为 0！如果此位为 1 的话时钟就不会进入到LCDIF。<br>BYPASS_COUNT(bit19)：如果要工作在 DOTCLK 模式的话就此位必须为 1。<br>VSYNC_MODE(bit18)：此位为 1 的话 LCDIF 工作在 VSYNC 接口模式。<br>DOTCLK_MODE(bit17)：此位为 1 的话 LCDIF 工作在 DOTCLK 接口模式。<br>INPUT_DATA_SWIZZLE(bit15:14)：输入数据字节交换设置，此位为 0 的话不交换字节也就是小端模式；为 1 的话交换所有字节，也就是大端模式；为 2 的话半字交换；为 3 的话在每个半字内进行字节交换。本章我们设置为 0，也就是不使用字节交换。<br>CSC_DATA_SWIZZLE(bit13:12) ： CSC 数 据 字 节 交 换 设 置 ， 交 换 方 式 和INPUT_DATA_SWIZZLE 一样，本章设置为 0，不使用字节交换。<br>LCD_DATABUS_WIDTH(bit11:10)：LCD 数据总线宽度，为 0 的话总线宽度为 16 位；为1 的话总线宽度为 8 位；为 2 的话总线宽度为 18 位；为 3 的话总线宽度为 24 位。本章我们使用 24 位总线宽度。WORD_LENGTH(bit9:8)：输入的数据格式，也就是像素数据宽度，为 0 的话每个像素 16位；为 1 的话每个像素 8 位；为 2 的话每个像素 18 位；为 3 的话每个像素 24 位。<br>MASTER(bit5)：为 1 的话设置 eLCDIF 工作在主模式。<br>DATA_FORMAT_16_BIT(bit3)：当此位为 1 并且 WORD_LENGTH 为 0 的时候像素格式为 ARGB555，当此位为 0 并且 WORD_LENGTH 为 0 的时候像素格式为 RGB565。<br>DATA_FORMAT_18_BIT(bit2)：只有当 WORD_LENGTH 为 2 的时候此位才有效，此位为 0 的话低 18 位有效，像素格式为 RGB666，高 14 位数据无效。当此位为 1 的话高 18 位有效，像素格式依旧是 RGB666，但是低 14 位数据无效。<br>DATA_FORMAT_24_BIT(bit1)：只有当 WORD_LENGTH 为 3 的时候此位才有效，为 0 的时候表示全部的 24 位数据都有效。为 1 的话实际输入的数据有效位只有 18 位，虽然输入的是24 位数据，但是每个颜色通道的高 2 位数据会被丢弃掉。<br>RUN(bit0)：eLCDIF 接口运行控制位，当此位为 1 的话 eLCDIF 接口就开始传输数据，也就是 eLCDIF 的使能位。</p><p>接 下 来 看 一 下 寄 存 器 <strong>LCDIF_CTRL1</strong> ， 此 寄 存 器 我 们 只 用 到 位BYTE_PACKING_FORMAT(bit19:16)，此位用来决定在 32 位的数据中哪些字节的数据有效，默认值为 0XF，也就是所有的字节有效，当为 0 的话表示所有的字节都无效。如果显示的数据是24 位(ARGB 格式，但是 A 通道不传输)的话就设置此位为 0X7。</p><p>接下来看一下寄存器 <strong>LCDIF_TRANSFER_COUNT</strong>，这个寄存器用来设置所连接的 RGB LCD 屏幕分辨率大小，寄存器LCDIF_TRANSFER_COUNT 分为两部分，高16位和低16位，高16位是V_COUNT，是 LCD 的垂直分辨率。低 16 位是 H_COUNT，是 LCD 的水平分辨率。如果 LCD 分辨率为480*272 的话，那么 V_COUNT 就是 272，H_COUNT 就是 480。</p><p>接下来看一下寄存器 <strong>LCDIF_VDCTRL0</strong>，这个寄存器是 VSYNC 和 DOTCLK 模式控制寄存器 0，</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20160914.png"></p><p>VSYNC_OEB(bit29)：VSYNC 信号方向控制位，为 0 的话 VSYNC 是输出，为 1 的话VSYNC 是输入。<br>ENABLE_PRESENT(bit28)：EBABLE 数据线使能位，也就是 DE 数据线。为 1 的话使能ENABLE 数据线，为 0 的话关闭 ENABLE 数据线。<br>VSYNC_POL(bit27)：VSYNC 数据线极性设置位，为 0 的话 VSYNC 低电平有效，为 1 的话 VSYNC 高电平有效，要根据所使用的 LCD 数据手册来设置。<br>HSYNC_POL(bit26)：HSYNC 数据线极性设置位，为 0 的话 HSYNC 低电平有效，为 1 的话 HSYNC 高电平有效，要根据所使用的 LCD 数据手册来设置。<br>DOTCLK_POL(bit25)：DOTCLK 数据线(像素时钟线 CLK) 极性设置位，为 0 的话下降沿锁存数据，上升沿捕获数据，为 1 的话相反，要根据所使用的 LCD 数据手册来设置。<br>ENABLE_POL(bit24)：EANBLE 数据线极性设置位，为 0 的话低电平有效，为 1 的话高电平有效。<br>VSYNC_PERIOD_UNIT(bit21)：VSYNC 信号周期单位，为 0 的话 VSYNC 周期单位为像素时钟。为 1 的话 VSYNC 周期单位是水平行，如果使用 DOTCLK 模式话就要设置为 1。<br>VSYNC_PULSE_WIDTH_UNIT(bit20) ： VSYNC 信 号 脉 冲 宽 度 单 位 ， 和VSYNC_PERIOD_UNUT 一样，如果使用 DOTCLK 模式的话要设置为 1。<br>VSYNC_PULSE_WIDTH(bit17:0)：VSPW 参数设置位。</p><p>看一下寄存器 <strong>LCDIF_VDCTRL1</strong>，这个寄存器是 VSYNC 和 DOTCLK 模式控制寄存器 1，此寄存器只有一个功能用来设置 VSYNC 总周期，就是：屏幕高度+VSPW+VBP+VFP。</p><p>接下来看一下寄存器 <strong>LCDIF_VDCTRL2</strong>，这个寄存器分为高 16 位和低 16 位两部分，高 16位是HSYNC_PULSE_WIDTH，用来设置 HSYNC 信号宽度，也就是 HSPW。低 16 位是HSYNC_PERIOD，设置 HSYNC 总周期，就是：屏幕宽度+HSPW+HBP+HFP。</p><p>看一下寄存器 <strong>LCDIF_VDCTRL3</strong>，HORIZONTAL_WAIT_CNT(bit27:16)：此位用于 DOTCLK 模式，用于设置 HSYNC 信号产生到有效数据产生之间的时间，也就是 HSPW+HBP。<br>VERTICAL_WAIR_CNT(bit15:0)：和 HORIZONTAL_WAIT_CNT 一样，只是此位用于VSYNC 信号，也就是 VSPW+VBP。</p><p>接下来看一下寄存器 <strong>LCDIF_VDCTRL4</strong>，寄存器 LCDIF_VDCTRL4 用到的重要位如下：<br>SYNC_SIGNALS_ON(bit18)：同步信号使能位，设置为 1 的话使能 VSYNC、HSYNC、DOTCLK 这些信号。<br>DOTCLK_H_VALID_DATA_CNT(bit15:0)：设置 LCD 的宽度，也就是水平像素数量。最后在看一下寄存器 LCDIF_CUR_BUF 和 LCDIF_NEXT_BUF，这两个寄存器分别为当前帧和下一帧缓冲区，也就是 LCD 显存。一般这两个寄存器保存同一个地址，也就是划分给 LCD的显存首地址。</p><h3 id="驱动屏幕的步骤"><a href="#驱动屏幕的步骤" class="headerlink" title="驱动屏幕的步骤"></a>驱动屏幕的步骤</h3><p>配置步骤如下：<br><strong>1、初始化 LCD 所使用的 IO</strong><br>首先肯定是初始化 LCD 所示使用的 IO，将其复用为 eLCDIF 接口 IO。<br><strong>2、设置 LCD 的像素时钟</strong><br>查阅所使用的 LCD 屏幕数据手册，或者自己计算出的时钟像素，然后设置 CCM 相应的寄存器。<br><strong>3、配置 eLCDIF 接口</strong><br>设置 LCDIF 的寄存器 CTRL、CTRL1、TRANSFER_COUNT、VDCTRL0~4、CUR_BUF 和NEXT_BUF。根据 LCD 的数据手册设置相应的参数。<br><strong>4、编写 API 函数</strong><br>驱动 LCD 屏幕的目的就是显示内容，所以需要编写一些基本的 API 函数，比如画点、画线、画圆函数，字符串显示函数等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot使用实验</title>
      <link href="/2023/03/01/2023-3-01-U-Boot%E4%BD%BF%E7%94%A8%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/03/01/2023-3-01-U-Boot%E4%BD%BF%E7%94%A8%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="U-Boot简介"><a href="#U-Boot简介" class="headerlink" title="U-Boot简介"></a>U-Boot简介</h3><h3 id="Linux启动简介以及Bootloader"><a href="#Linux启动简介以及Bootloader" class="headerlink" title="Linux启动简介以及Bootloader"></a>Linux启动简介以及Bootloader</h3><p>linux系统从软件角度看，可以分为以下四个层次。</p><ul><li>引导加载程序，包括固化固件的boot代码和Bootloader两个部分。大多数是没有固件的，Bootloader是上电后执行后的第一个程序。</li><li>Linux内核，特定于嵌入式板子的定制内核以及内核的启动参数，启动参数可以是内核默认的或者Bootloader传递的。</li><li>文件系统，博爱阔根文件系统和建立于flash内存上的文件系统，包含了Linux系统能过运行所需要的应用程序、库等。</li><li>用户应用程序，存储于文件系统中，又是在用户应用程序和内核层之间可能包含一个嵌入式图形用户界面，常用的GUI有：Qtopia和Mini GUI等。</li></ul><p>Bootloader存放参数如串口，IP地址等，正常启动Bootloader运行，它将kernel(内核）复制到内存中，并且在内存的固定地址设置好传递的内核参数，运行内核，内核启动后挂在根文件系统。</p><p>Bootloader启动要分两过程，第一个使用汇编，利用其完成CPU体系结构的初始化（硬件设备初始化，未加载第二过程准备RAM空间，复制Bootloader第二过程代码到RAM中，设置好栈，跳转到C的入口），并调第二过程代码，第二过程使用C语言来实现（初始化使用的硬件设备，检测系统内存映射，将内核映像和根文件系统映像从Flash读到RAM中，为内核设置启动参数，调用内核）。</p><p>调用内核前必须满足：</p><ol><li><p>CPU 寄存器的设置</p><ul><li><p>R0&#x3D;0</p></li><li><p>R1&#x3D;机器类型的ID</p></li><li><p>R2&#x3D;启动参数标记列表在RAM中的起始基地址</p></li></ul></li><li><p>CPU工作模式</p><ul><li><p>必须禁止中断</p></li><li><p>CPU必须为SVC 模式</p></li></ul></li><li><p>Cache和MMU的设置</p><ul><li><p>MMU必须关闭</p></li><li><p>指令Cache可开可关</p></li><li><p>数据Cache必须关</p></li></ul></li></ol><p>Uboot是通用Bootloader，可以引导多种架构的CPU，具有开源代码，支持多种嵌入式操作系统内核，支持多种处理器系列，有较高的可靠性和稳定性，高度灵活的功能设置，有丰富的设备驱动源码，有调试文档和技术支持，支持NFS挂载，支持目标板环境变量多种存储方式，上电自检。</p><h3 id="使用Uboot"><a href="#使用Uboot" class="headerlink" title="使用Uboot"></a>使用Uboot</h3><p>将Uboot压缩包在Ubuntu上解压后使用以下命令来编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- (加空格)</span><br><span class="line">mx6ull_14x14_ddr512_emmc_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</span><br></pre></td></tr></table></figure><p>这三条命令中 ARCH&#x3D;arm 设置目标为 arm 架构，CROSS_COMPILE 指定所使用的交叉编译器。第一条命令相当于“make distclean”，目的是清除工程，一般在第一次编译的时候最好清理一下工程。第二条指令相当于“make mx6ull_14x14_ddr512_emmc_defconfig”，用于配置 uboot，配置文件为 mx6ull_14x14_ddr512_emmc_defconfig。最后一条指令相当于 “make -j12”也就是使用 12 核来编译 uboot。</p><p>之后使用imxdownload将uboot.bin下载进入sd卡，之后将板子的uart1接上ttl转usb，之后打开MobaXterm。设置好参数后，复位linux板子，之后按下回车键，进入uboot命令行。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230302_164244.png"></p><h3 id="boot指令使用"><a href="#boot指令使用" class="headerlink" title="boot指令使用"></a>boot指令使用</h3><h4 id="信息查询命令"><a href="#信息查询命令" class="headerlink" title="信息查询命令"></a>信息查询命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bdinfo//用于查看板子信息</span><br><span class="line">printenv//用于输出环境变量</span><br><span class="line">version //用于查看uboot版本号</span><br></pre></td></tr></table></figure><h4 id="环境变量操作命令"><a href="#环境变量操作命令" class="headerlink" title="环境变量操作命令"></a>环境变量操作命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">saveenv //保存修改后的环境变量、</span><br><span class="line">setenv  //用于设置或者修改环境变量</span><br></pre></td></tr></table></figure><p>一般环境变量是存放在外部 flash 中的，uboot 启动的时候会将环境变量从 flash 读取到 DRAM 中。所以使用命令 setenv 修改的是 DRAM中的环境变量值，修改以后要使用 saveenv 命令将修改后的环境变量保存到 flash 中，否则的话uboot 下一次重启会继续使用以前的环境变量值。</p><p>也可以使用setenv来删除环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set author</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>上面命令中通过 setenv 给 author 赋空值，也就是什么都不写来删除环境变量 author。重启uboot 就会发现环境变量 author 没有了。</p><h4 id="内存操作命令"><a href="#内存操作命令" class="headerlink" title="内存操作命令"></a>内存操作命令</h4><p>md 命令用于显示内存值，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md[.b, .w, .l] address [# of objects]</span><br></pre></td></tr></table></figure><p>命令中的[.b .w .l]对应 byte、word 和 long，也就是分别以 1个字节、2 个字节、4 个字节来显示内存值。address 就是要查看的内存起始地址，[# of objects]表示要查看的数据长度。</p><p><strong>Uboot命令中的数字是十六进制的。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md.b 80000000 14 以 0X80000000 开始的 20 个字节的内存值</span><br></pre></td></tr></table></figure><p>nm 命令用于修改指定地址的内存值，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm [.b, .w, .l] address</span><br></pre></td></tr></table></figure><p>nm 命令同样可以以.b、.w 和.l 来指定操作格式，比如现在以.l格式修改 0x80000000 地址的数据为 0x12345678。输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm.l 80000000</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230302_203017.png"></p><p>80000000 表示现在要修改的内存地址，0500e031 表示地址0x80000000 现在的数据，？后面就可以输入要修改后的数据 0x12345678，输入完成以后按下回车，然后再输入‘q’即可退出</p><p>mm 命令也是修改指定地址内存值的，使用 mm 修改内存值的时候地址会自增。比如以.l 格式修改从地址 0x80000000 开始的连续 3 个内存块(3*4&#x3D;12个字节)的数据为 0X05050505。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230302_203845.png"></p><p>命令 mw 用于使用一个指定的数据填充一段内存，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mw [.b, .w, .l] address value [count]</span><br></pre></td></tr></table></figure><p>mw 命令同样可以以.b、.w 和.l 来指定操作格式，address 表示要填充的内存起始地址，value为要填充的数据，count 是填充的长度。比如使用.l 格式将以 0X80000000 为起始地址的 0x10 个内存块(0x10 * 4&#x3D;64 字节)填充为 0X0A0A0A0A</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mw.l 80000000 0A0A0A0A 10</span><br></pre></td></tr></table></figure><p>cp 是数据拷贝命令，用于将 DRAM 中的数据从一段内存拷贝到另一段内存中，或者把 Nor Flash 中的数据拷贝到 DRAM 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [.b, .w, .l] source target count</span><br></pre></td></tr></table></figure><p>cp 命令同样可以以.b、.w 和.l 来指定操作格式，source 为源地址，target 为目的地址，count为拷贝的长度。我们使用.l 格式将 0x80000000 处的地址拷贝到 0X80000100 处，长度为0x10 个内存块(0x10 * 4&#x3D;64 个字节)，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp.l 80000000 80000100 10</span><br></pre></td></tr></table></figure><p>cmp 是比较命令，用于比较两段内存的数据是否相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp [.b, .w, .l] addr1 addr2 count</span><br></pre></td></tr></table></figure><p>addr1 为第一段内存首地址，addr2 为第二段内存首地址，count 为要比较的长度。</p><h4 id="网络操作命令"><a href="#网络操作命令" class="headerlink" title="网络操作命令"></a>网络操作命令</h4><p>将开发板的enet2接口和wifi或者电脑连接，使用setenv和saveenv命令来设置网络的ip相关参数。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230303_130601.png"></p><p><strong>ping 命令</strong></p><p>开发板的网络能否使用，是否可以和服务器(Ubuntu 主机)进行通信，通过 ping 命令就可以验证，直接 ping 服务器的 IP 地址即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.1.115</span><br></pre></td></tr></table></figure><p><strong>dhcp 命令</strong></p><p>dhcp 用于从路由器获取 IP 地址，前提得开发板连接到路由器上的，如果开发板是和电脑直连的，那么 dhcp 命令就会失效。直接输入 dhcp 命令即可通过路由器获取到 IP 地址.</p><p><strong>nfs 命令</strong></p><p>nfs(Network File System)网络文件系统，通过 nfs 可以在计算机之间通过网络来分享资源，这样做的目的是为了方便调试 linux 镜像和设备树，也就是网络调试，通过网络调试是 Linux 开发中最常用的调试方法。在 Linux 内核调试阶段，如果用这个烧写软件的话将会非常浪费时间，而这个时候网络调试的优势就显现出来了，可以通过网络将编译好的 linux 镜像和设备树文件下载到 DRAM 中，然后就可以直接运行。</p><p>一般使用 uboot 中的 nfs 命令将 Ubuntu 中的文件下载到开发板的 DRAM 中，在使用之前需要开启 Ubuntu 主机的 NFS 服务，并且要新建一个 NFS 使用的目录，以后所有要通过NFS 访问的文件都需要放到这个 NFS 目录中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nfs [loadAddress] [[hostIPaddr:]bootfilename]</span><br></pre></td></tr></table></figure><p>loadAddress 是要保存的 DRAM 地址[[hostIPaddr:]bootfilename]是要下载的文件地址。</p><p>Ubuntu20.04具体参考以下方法：</p><p><a href="https://blog.csdn.net/weixin_56646002/article/details/127388021">(嵌入式Linux开发——解决uboot无法使用nfs服务从ubuntu中下载文件（TTT、cannot mount等错误）_</a></p><h4 id="EMMC-和-SD-卡操作命令"><a href="#EMMC-和-SD-卡操作命令" class="headerlink" title="EMMC 和 SD 卡操作命令"></a>EMMC 和 SD 卡操作命令</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230303_190432.png">                       </p><p>如果要在 uboot 中更新 SD对应的 uboot，可以使用如下所示命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 0 0//切换SD卡的0区</span><br><span class="line">mmc write 80800000 2 2E6//2E6这个数据根据写入的字节来转换为十六进制烧入第三个扇区</span><br></pre></td></tr></table></figure><p>如果要在 uboot 中更新 EMMC 对应的 uboot，可以使用如下所示命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 1 0 //切换到 EMMC 分区 0</span><br><span class="line">tftp 80800000 u-boot.imx //下载 u-boot.imx 到 DRAM</span><br><span class="line">mmc write 80800000 2 32E //烧写 u-boot.imx 到 EMMC 中的第三个扇区</span><br><span class="line">mmc partconf 1 1 0 0 //分区配置，EMMC 需要这一步！</span><br></pre></td></tr></table></figure><h4 id="FAT-格式文件系统操作命令"><a href="#FAT-格式文件系统操作命令" class="headerlink" title="FAT 格式文件系统操作命令"></a>FAT 格式文件系统操作命令</h4><p><strong>fatinfo 命令</strong></p><p>fatinfo 命令用于查询指定 MMC 设备分区的文件系统信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatinfo &lt;interface&gt; [&lt;dev[:part]&gt;]</span><br></pre></td></tr></table></figure><p>interface 表示接口，比如 mmc，dev 是查询的设备号，part 是要查询的分区。比如我们要查询 EMMC 分区 1 的文件系统信息，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatinfo mmc 1:1</span><br></pre></td></tr></table></figure><p><strong>fatls 命令</strong></p><p>fatls 命令用于查询 FAT 格式设备的目录和文件信息，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatls &lt;interface&gt; [&lt;dev[:part]&gt;] [directory]</span><br></pre></td></tr></table></figure><p>interface 是要查询的接口，比如 mmc，dev 是要查询的设备号，part 是要查询的分区，directory是要查询的目录。</p><p><strong>fstype 命令</strong></p><p>fstype 用于查看 MMC 设备某个分区的文件系统格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstype &lt;interface&gt; &lt;dev&gt;:&lt;part&gt;</span><br></pre></td></tr></table></figure><p><strong>fatload命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatload &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]]</span><br></pre></td></tr></table></figure><p>interface 为接口，比如 mmc，dev 是设备号，part 是分区，addr 是保存在 DRAM 中的起始地址，filename 是要读取的文件名字。bytes 表示读取多少字节的数据，如果 bytes 为 0 或者省略的话表示读取整个文件。pos 是要读的文件相对于文件首地址的偏移，如果为 0 或者省略的话表示从文件首地址开始读取。</p><p><strong>fatwrite命令</strong></p><p><u>uboot 默认没有使能 fatwrite 命令，需要修改板子配置头文件</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_FAT_WRITE /* 使能 fatwrite 命令 */</span><br></pre></td></tr></table></figure><p>fatwirte 命令用于将 DRAM 中的数据写入到 MMC 设备中，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatwrite &lt;interface&gt; &lt;dev[:part]&gt; &lt;addr&gt; &lt;filename&gt; &lt;bytes&gt;</span><br></pre></td></tr></table></figure><p>interface 为接口，比如 mmc，dev 是设备号，part 是分区，addr 是要写入的数据在 DRAM中的起始地址，filename 是写入的数据文件名字，bytes 表示要写入多少字节的数据。我们可以通过 fatwrite 命令在 uboot 中更新 linux 镜像文件和设备树。</p><h4 id="EXT-格式文件系统操作命令"><a href="#EXT-格式文件系统操作命令" class="headerlink" title="EXT 格式文件系统操作命令"></a>EXT 格式文件系统操作命令</h4><p>常用的就四个命令，分别为：ext2load、ext2ls、ext4load、ext4ls 和 ext4write，这些命令的含义和使用与 fatload、fatls 和 fatwrite一样，只是 ext2 和 ext4 都是针对 ext 文件系统的。</p><h4 id="Boot操作命令"><a href="#Boot操作命令" class="headerlink" title="Boot操作命令"></a>Boot操作命令</h4><p><strong>bootz命令</strong></p><p>要启动 Linux，需要先将 Linux 镜像文件拷贝到 DRAM 中，如果使用到设备树的话也需要将设备树拷贝到 DRAM 中。可以从 EMMC 或者 NAND 等存储设备中将 Linux 镜像和设备树文件拷贝到 DRAM，也可以通过 nfs 或者 tftp 将 Linux 镜像文件和设备树文件下载到 DRAM 中。</p><p>之后就可以使用bootz来启动zImage镜像文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootz [addr [initrd[:size]] [fdt]]</span><br></pre></td></tr></table></figure><p>命令 bootz 有三个参数，addr 是 Linux 镜像文件在 DRAM 中的位置，initrd 是 initrd 文件在DRAM 中的地址，如果不使用 initrd 的话使用‘-’代替即可，fdt 就是设备树文件在 DRAM 中的地址。</p><p><strong>bootm 命令</strong></p><p>bootm 和 bootz 功能类似，但是 bootm 用于启动 uImage 镜像文件。如果不使用设备树的话启动 Linux 内核的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootm addr</span><br></pre></td></tr></table></figure><p>addr 是 uImage 镜像在 DRAM 中的首地址。<br>如果要使用设备树，那么 bootm 命令和 bootz 一样，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootm [addr [initrd[:size]] [fdt]]</span><br></pre></td></tr></table></figure><p>其中 addr 是 uImage 在 DRAM 中的首地址，initrd 是 initrd 的地址，fdt 是设备树(.dtb)文件在 DRAM 中的首地址，如果 initrd 为空的话，同样是用“-”来替代。</p><p><strong>boot 命令</strong></p><p>boot 命令也是用来启动 Linux 系统的，只是 boot 会读取环境变量 bootcmd 来启动 Linux 系统，bootcmd 是一个很重要的环境变量！其名字分为“boot”和“cmd”，也就是“引导”和“命令”，说明这个环境变量保存着引导命令，其实就是启动的命令集合，具体的引导命令内容是可以修改的。比如我们要想使用 tftp 命令从网络启动 Linux 那么就可以设置 bootcmd 为“tftp 80800000 zImage; tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb; bootz 80800000 -83000000”，然后使用 saveenv 将 bootcmd 保存起来。然后直接输入 boot 命令即可从网络启动Linux 系统，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb; bootz 80800000 - 83000000&#x27;</span><br><span class="line">saveenv</span><br><span class="line">boot</span><br></pre></td></tr></table></figure><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><p><strong>reset命令</strong></p><p>输入reset即可实现复位重启。</p><p><strong>go 命令</strong></p><p>go 命令用于跳到指定的地址处执行应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go addr [arg ...]</span><br></pre></td></tr></table></figure><p><strong>run 命令</strong></p><p>run 命令用于运行环境变量中定义的命令，比如可以通过“run bootcmd”来运行 bootcmd 中的启动命令，但是 run 命令最大的作用在于运行我们自定义的环境变量。在后面调试 Linux 系统的时候常常要在网络启动和 EMMC&#x2F;NAND 启动之间来回切换，而 bootcmd 只能保存一种启动方式，如果要换另外一种启动方式的话就得重写 bootcmd，会很麻烦。这里我们就可以通过自定义环境变量来实现不同的启动方式，比如定义环境变量 mybootemmc 表示从 emmc 启动，定义 mybootnet 表示从网络启动，定义 mybootnand 表示从 NAND 启动。如果要切换启动方式的话只需要运行“run mybootxxx(xxx 为 emmc、net 或 nand)”即可。</p><p><strong>mtest 命令</strong></p><p>mtest 命令是一个简单的内存读写测试命令，可以用来测试自己开发板上的 DDR，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtest [start [end [pattern [iterations]]]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6ual的DDR3（内存芯片）的使用</title>
      <link href="/2023/02/28/2023-2-28-imx6ual%E7%9A%84DDR3%EF%BC%88%E5%86%85%E5%AD%98%E8%8A%AF%E7%89%87%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/28/2023-2-28-imx6ual%E7%9A%84DDR3%EF%BC%88%E5%86%85%E5%AD%98%E8%8A%AF%E7%89%87%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="何为位？位宽？字？字长？字节？"><a href="#何为位？位宽？字？字长？字节？" class="headerlink" title="何为位？位宽？字？字长？字节？"></a>何为位？位宽？字？字长？字节？</h3><p><strong>计算机在进行数据处理，一次存取、加工、传送的数据长度称为字(word)。</strong></p><p><strong>字长，是CPU一次能处理的二进制数的位数，*字长与之关联的是数据总线的位数</strong>，字长为32，则数据总线的宽度为32位。*比如CPU一次可以处理8个1（或者0），那么我们称这个CPU是8位的CPU，也就是说这个CPU的字长是8位。如果CPU一次可以处理16个二进制数，这个CPU的字长就是16位。<br><strong>位宽就是内存或显存一次能传输的数据量</strong>。(这里我对位宽的理解也仅限于此）简单地讲就是一次能传递的数据宽度。字长指的是计算能力，位宽指的是传输能力。</p><p><em>计算机三大总线：地址线，控制线，数据线。</em></p><p><strong>数据总线</strong><br>①是CPU与内存或其他器件之间的数据传送的通道。</p><p>②数据总线的宽度决定了CPU和外界的数据传送速度。</p><p>③每条传输线一次只能传输1位二进制数据。eg: 8根数据线一次可传送一个8位二进制数据(即一个字节)。</p><p>④数据总线是数据线数量之和。</p><p><strong>地址总线</strong><br>①CPU是通过地址总线来指定存储单元的。</p><p>②地址总线决定了cpu所能访问的最大内存空间的大小。eg: 10根地址线能访问的最大的内存为1024位二进制数据（1024个内存单元）(1B)</p><p>③地址总线是地址线数量之和。</p><p><strong>控制总线</strong><br>①CPU通过控制总线对外部器件进行控制。</p><p>②控制总线的宽度决定了CPU对外部器件的控制能力。</p><p>③控制总线是控制线数量之和。</p><h3 id="RAM和ROM"><a href="#RAM和ROM" class="headerlink" title="RAM和ROM"></a>RAM和ROM</h3><p>RAM：随机存储器，可以随时进行读写操作，速度很快，掉电以后数据会丢失。比如内存条、SRAM、SDRAM、DDR 等都是 RAM。RAM 一般用来保存程序数据、中间结果，掉电就会丢失数据。</p><p>ROM：只读存储器，容量大，但是掉电后数据不会丢失，适合用来存储资料，例如图片，音频，文件等。</p><p>SRAM：静态随机存储器，这里的“静态”说的就是只要 SRAM 上电，那么 SRAM 里面的数据就会一直保存着，直到 SRAM 掉电。</p><p>SDRAM 全称是 同步动态随机存储器，“同步”的意思是 SDRAM 工作需要时钟线，“动态”的意思是 SDRAM 中的数据需要不断的刷新来保证数据不会丢失，“随机”的意思就是可以读写任意地址的数据。SDRAM 分为 SDR SDRAM、DDR SDRAM、DDR2 SDRAM、DDR3 SDRAM、DDR4 SDRAM。</p><p>DDR 全称是 Double Data Rate SDRAM，也就是双倍速率 SDRAM，看名字就知道 DDR 的速率(数据传输速率)比 SDRAM 高 1 倍！这 1 倍的速度不是简简单单的将 CLK 提高 1 倍，SDRAM 在一个 CLK 周期传输一次数据，DDR 在一个 CLK 周期传输两次数据，也就是在上升沿和下降沿各传输一次数据，这个概念叫做预取(prefetch)，相当于 DDR 的预取为 2bit，因此DDR 的速度直接加倍！</p><p><a href="https://www.cnblogs.com/leaven/archive/2010/07/21/1782341.html#:~:text=1%E3%80%81%E5%B7%AE%E5%88%86%E6%97%B6%E9%92%9F%20%E5%B7%AE%E5%88%86%E6%97%B6%E9%92%9F%EF%BC%88%E5%8F%82%E8%A7%81%E4%B8%8A%E6%96%87%E2%80%9CDDR%20SDRAM%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE%E2%80%9D%EF%BC%89%E6%98%AFDDR%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BF%85%E8%A6%81%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%BD%86,CK%23%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%B9%B6%E4%B8%8D%E8%83%BD%E7%90%86%E8%A7%A3%E4%B8%BA%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%A7%A6%E5%8F%91%E6%97%B6%E9%92%9F%20%EF%BC%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%AE%B2%E8%BF%B0DDR%E5%8E%9F%E7%90%86%E6%97%B6%E7%AE%80%E5%8D%95%E5%9C%B0%E8%BF%99%E4%B9%88%E6%AF%94%E5%96%BB%EF%BC%89%EF%BC%8C%E8%80%8C%E6%98%AF%E8%B5%B7%E5%88%B0%20%E8%A7%A6%E5%8F%91%E6%97%B6%E9%92%9F%E6%A0%A1%E5%87%86%20%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82">DDR DQS （Double Data Rate SDRAM ） 原理及与SDRAM比较(cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u的串口通信</title>
      <link href="/2023/02/28/2023-2-28-imx6u%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/02/28/2023-2-28-imx6u%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>UART 通信格式</strong></p><p>串口全称叫做串行接口，通常也叫做 COM 接口，串行接口指的是数据一个一个的顺序传输，通信线路简单。使用两条线即可实现双向通信，一条用于发送，一条用于接收。串口通信距离远，但是速度相对会低，串口是一种很常用的工业接口。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230227_203724.png"></p><p>空闲位：数据线在空闲状态的时候为逻辑“1”状态，也就是高电平，表示没有数据线空闲，没有数据传输。<br>起始位：当要传输数据的时候先传输一个逻辑“0”，也就是将数据线拉低，表示开始数据传输。<br>数据位：数据位就是实际要传输的数据，数据位数可选择 5~8 位，我们一般都是按照字节传输数据的，一个字节 8 位，因此数据位通常是 8 位的。低位在前，先传输，高位最后传输。<br>奇偶校验位：这是对数据中“1”的位数进行奇偶校验用的，可以不使用奇偶校验功能。<br>停止位：数据传输完成标志位，停止位的位数可以选择 1 位、1.5 位或 2 位高电平，一般都选择 1 位停止位。<br>波特率：波特率就是 UART 数据传输的速率，也就是每秒传输的数据位数，一般选择 9600、19200、115200 等。</p><p>UART 一般的接口电平有 TTL 和 RS-232，一般开发板上都有 TXD 和 RXD 这样的引脚，这些引脚低电平表示逻辑 0，高电平表示逻辑 1，这个就是 TTL 电平。RS-232 采用差分线，-3<del>-15V 表示逻辑 1，+3</del>+15V 表示逻辑 0。</p><p>I.MX6U 一共有 8 个 UART，其主要特性如下：<br>①、兼容 TIA&#x2F;EIA-232F 标准，速度最高可到 5Mbit&#x2F;S。<br>②、支持串行 IR 接口，兼容 IrDA，最高可到 115.2Kbit&#x2F;s。<br>③、支持 9 位或者多节点模式(RS-485)。<br>④、1 或 2 位停止位。<br>⑤、可编程的奇偶校验(奇校验和偶校验)。<br>⑥、自动波特率检测(最高支持 115.2Kbit&#x2F;S)。</p><p>UCR1寄存器</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20122716.png"></p><p>ADBR(bit14)：自动波特率检测使能位，为 0 的时候关闭自动波特率检测，为 1 的时候使能自动波特率检测。<br>UARTEN(bit0)：UART 使能位，为 0 的时候关闭 UART，为 1 的时候使能 UART。</p><p>UCR2寄存器</p><p><img src="C:\Users\hanfeng\AppData\Roaming\Typora\typora-user-images\1678081179783.png" alt="1678081179783"></p><p>IRTS(bit14)：为 0 的时候使用 RTS 引脚功能，为 1 的时候忽略 RTS 引脚。<br>PREN(bit8)：奇偶校验使能位，为 0 的时候关闭奇偶校验，为 1 的时候使能奇偶校验。<br>PROE(bit7)：奇偶校验模式选择位，开启奇偶校验以后此位如果为 0 的话就使用偶校验，此位为 1 的话就使能奇校验。<br>STOP(bit6)：停止位数量，为 0 的话 1 位停止位，为 1 的话 2 位停止位。<br>WS(bit5)：数据位长度，为 0 的时候选择 7 位数据位，为 1 的时候选择 8 位数据位。<br>TXEN(bit2)：发送使能位，为 0 的时候关闭 UART 的发送功能，为 1 的时候打开 UART的发送功能。<br>RXEN(bit1)：接收使能位，为 0 的时候关闭 UART 的接收功能，为 1 的时候打开 UART的接收功能。<br>SRST(bit0)：软件复位，为 0 的是时候软件复位 UART，为 1 的时候表示复位完成。复位完成以后此位会自动置 1，表示复位完成。此位只能写 0，写 1 会被忽略掉。</p><p>UCR3寄存器</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/20230306134052.png"></p><p>UARTx_UCR3 中的位 RXDMUXSEL(bit2)，这个位应该始终为 1。</p><p>接下来看一下寄存器 UARTx_UFCR 、 UARTx_UBIR 和 UARTx_UBMR ，寄存器UARTx_UFCR 中我们要用到的是位 RFDIV(bit9:7)，用来设置参考时钟分频</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20134323.png"></p><p>波特率是</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20134333.png"></p><p>Ref Freq：经过分频以后进入 UART 的最终时钟频率。<br>UBMR：寄存器 UARTx_UBMR 中的值。<br>UBIR：寄存器 UARTx_UBIR 中的值。</p><h3 id="Uart1的配置步骤"><a href="#Uart1的配置步骤" class="headerlink" title="Uart1的配置步骤"></a>Uart1的配置步骤</h3><p>UART1 的配置步骤如下：<br>1、设置 UART1 的时钟源<br>设置 UART 的时钟源为 pll3_80m，设置寄存器 CCM_CSCDR1 的 UART_CLK_SEL 位为 0即可。<br>2、初始化 UART1<br>初始化 UART1 所使用 IO，设置 UART1 的寄存器 UART1_UCR1~UART1_UCR3，设置内容包括波特率，奇偶校验、停止位、数据位等等。<br>4、使能 UART1<br>UART1 初始化完成以后就可以使能 UART1 了，设置寄存器 UART1_UCR1 的位 UARTEN为 1。<br>5、编写 UART1 数据收发函数<br>编写两个函数用于 UART1 的数据收发操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u的EPIT定时器</title>
      <link href="/2023/02/27/2023-2-27-imx6u%E7%9A%84EPIT%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2023/02/27/2023-2-27-imx6u%E7%9A%84EPIT%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="EPIT"><a href="#EPIT" class="headerlink" title="EPIT"></a>EPIT</h3><p>EPIT的全称是：Enhanced Periodic Interrupt Timer，直译过来就是增强的周期中断定时器，它主要是完成周期性中断定时的。</p><p>EPIT 是一个 32 位定时器，在处理器几乎不用介入的情况下提供精准的定时中断，软件使能以后 EPIT 就会开始运行，EPIT 定时器有如下特点：</p><p>①、时钟源可选的 32 位向下计数器。<br>②、12 位的分频值。<br>③、当计数值和比较值相等的时候产生中断。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230227_193455.png"></p><p>①、这是个多路选择器，用来选择 EPIT 定时器的时钟源，EPIT 共有 3 个时钟源可选择，ipg_clk、ipg_clk_32k 和 ipg_clk_highfreq。<br>②、这是一个 12 位的分频器，负责对时钟源进行分频，12 位对应的值是 0<del>4095，对应着1</del>4096 分频。<br>③、经过分频的时钟进入到 EPIT 内部，在 EPIT 内部有三个重要的寄存器：计数寄存器(EPIT_CNR)、加载寄存器(EPIT_LR)和比较寄存器(EPIT_CMPR)，这三个寄存器都是 32 位的。EPIT 是一个向下计数器，也就是说给它一个初值，它就会从这个给定的初值开始递减，直到减为 0，计数寄存器里面保存的就是当前的计数值。如果 EPIT 工作在 set-and-forget 模式下，当计数寄存器里面的值减少到 0，EPIT 就会重新从加载寄存器读取数值到计数寄存器里面，重新开始向下计数。比较寄存器里面保存的数值用于和计数寄存器里面的计数值比较，如果相等的话就会产生一个比较事件。<br>④、比较器。<br>⑤、EPIT 可以设置引脚输出，如果设置了的话就会通过指定的引脚输出信号。<br>⑥、产生比较中断，也就是定时中断。</p><p>EPIT 定时器有两种工作模式：set-and-forget 和 free-running，这两个工作模式的区别如下：</p><p>set-and-forget 模式：EPITx_CR(x&#x3D;1，2)寄存器的 RLD 位置 1 的时候 EPIT 工作在此模式下，在此模式下 EPIT 的计数器从加载寄存器 EPITx_LR 中获取初始值，不能直接向计数器寄存器写入数据。不管什么时候，只要计数器计数到 0，那么就会从加载寄存器 EPITx_LR 中重新加载数据到计数器中，周而复始。<br>free-running 模式：EPITx_CR 寄存器的 RLD 位清零的时候 EPIT 工作在此模式下，当计数器计数到0以后会重新从0XFFFFFFFF开始计数，并不是从加载寄存器EPITx_LR中获取数据。</p><p>三个寄存器的具体配置查询手册。</p><h3 id="EPIT-的配置步骤如下："><a href="#EPIT-的配置步骤如下：" class="headerlink" title="EPIT 的配置步骤如下："></a><strong>EPIT 的配置步骤如下：</strong></h3><p><strong>1、设置 EPIT1 的时钟源</strong><br>设置寄存器 EPIT1_CR 寄存器的 CLKSRC(bit25:24)位，选择 EPIT1 的时钟源。<br><strong>2、设置分频值</strong><br>设置寄存器 EPIT1_CR 寄存器的 PRESCALAR(bit15:4)位，设置分频值。<br><strong>3、设置工作模式</strong><br>设置寄存器 EPIT1_CR 的 RLD(bit3)位，设置 EPTI1 的工作模式。<br><strong>4、设置计数器的初始值来源</strong><br>设置寄存器 EPIT1_CR 的 ENMOD(bit1)位，设置计数器的初始值来源。<br><strong>5、使能比较中断</strong><br>使用就设置寄存器 EPIT1_CR 的 OCIEN(bit2)位，使能比较中断。<br><strong>6、设置加载值和比较值</strong><br>设置寄存器 EPIT1_LR 中的加载值和寄存器 EPIT1_CMPR 中的比较值，通过这两个寄存器就可以决定定时器的中断周期。<br><strong>7、EPIT1 中断设置和中断服务函数编写</strong><br>使能 GIC 中对应的 EPIT1 中断，注册中断服务函数，如果需要的话还可以设置中断优先级。最后编写中断服务函数。<br><strong>8、使能 EPIT1 定时器</strong><br>配置好 EPIT1 以后就可以使能 EPIT1 了，通过寄存器 EPIT1_CR 的 EN(bit0)位来设置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u的GPIO中断</title>
      <link href="/2023/02/22/2023-2-16-imx6u%E7%9A%84GPIO%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/02/22/2023-2-16-imx6u%E7%9A%84GPIO%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>STM32 的中断系统主要有以下几个关键点：<br>①、中断向量表。<br>②、NVIC(内嵌向量中断控制器)。<br>③、中断使能。<br>④、中断服务函数</p><p>而在imx6ul中的NVIC中断管理机构叫做GIC。</p><p>中断服务程序的入口地址或存放中断服务程序的首地址成为中断向量，因此中断向量表是一系列中断服务程序入口地址组成的表。</p><h3 id="Cortex-A7中断系统简介"><a href="#Cortex-A7中断系统简介" class="headerlink" title="Cortex-A7中断系统简介"></a>Cortex-A7中断系统简介</h3><p>跟 STM32 一样，Cortex-A7 也有中断向量表，中断向量表也是在代码的最前面。CortexA7 内核有 8 个异常中断，这 8 个异常中断的中断向量表如表 ：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_211414.png"></p><p>①、复位中断(Rest)，CPU 复位以后就会进入复位中断，我们可以在复位中断服务函数里面做一些初始化工作，比如初始化 SP 指针、DDR 等等。<br>②、未定义指令中断(Undefined Instruction)，如果指令不能识别的话就会产生此中断。<br>③、软中断(Software Interrupt,SWI)，由 SWI 指令引起的中断，Linux 的系统调用会用 SWI指令来引起软中断，通过软中断来陷入到内核空间。<br>④、指令预取中止中断(Prefetch Abort)，预取指令的出错的时候会产生此中断。<br>⑤、数据访问中止中断(Data Abort)，访问数据出错的时候会产生此中断。<br>⑥、IRQ 中断(IRQ Interrupt)，外部中断，前面已经说了，芯片内部的外设中断都会引起此中断的发生。<br>⑦、FIQ 中断(FIQ Interrupt)，快速中断，如果需要快速处理中断的话就可以使用此中断。</p><p>中断向量表一般写在start.S的前面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">示例代码 17.1.1.1 Cortex-A 向量表模板</span><br><span class="line">1 .global _start /* 全局标号 */</span><br><span class="line">2 </span><br><span class="line">3 _start:</span><br><span class="line">4 ldr pc, =Reset_Handler /* 复位中断 */ </span><br><span class="line">5 ldr pc, =Undefined_Handler /* 未定义指令中断 */</span><br><span class="line">6 ldr pc, =SVC_Handler /* SVC(Supervisor)中断 */</span><br><span class="line">7 ldr pc, =PrefAbort_Handler /* 预取终止中断 */</span><br><span class="line">8 ldr pc, =DataAbort_Handler /* 数据终止中断 */</span><br><span class="line">9 ldr pc, =NotUsed_Handler /* 未使用中断 */</span><br><span class="line">10 ldr pc, =IRQ_Handler /* IRQ 中断 */</span><br><span class="line">11 ldr pc, =FIQ_Handler /* FIQ(快速中断)未定义中断 */</span><br><span class="line">12</span><br><span class="line">13 /* 复位中断 */ </span><br><span class="line">14 Reset_Handler:</span><br><span class="line">15 /* 复位中断具体处理过程 */</span><br><span class="line">16</span><br><span class="line">17 /* 未定义中断 */</span><br><span class="line">18 Undefined_Handler:</span><br><span class="line">19 ldr r0, =Undefined_Handler</span><br><span class="line">20 bx r0</span><br><span class="line">21</span><br><span class="line">22 /* SVC 中断 */</span><br><span class="line">23 SVC_Handler:</span><br><span class="line">24 ldr r0, =SVC_Handler</span><br><span class="line">25 bx r0</span><br><span class="line">26</span><br><span class="line">27 /* 预取终止中断 */</span><br><span class="line">28 PrefAbort_Handler:</span><br><span class="line">29 ldr r0, =PrefAbort_Handler </span><br><span class="line">30 bx r0</span><br><span class="line">31</span><br><span class="line">32 /* 数据终止中断 */</span><br><span class="line">33 DataAbort_Handler:</span><br><span class="line">34 ldr r0, =DataAbort_Handler</span><br><span class="line">35 bx r0</span><br><span class="line">36</span><br><span class="line">37 /* 未使用的中断 */</span><br><span class="line">38 NotUsed_Handler:</span><br><span class="line">39</span><br><span class="line">40 ldr r0, =NotUsed_Handler</span><br><span class="line">41 bx r0</span><br><span class="line">42</span><br><span class="line">43 /* IRQ 中断！重点！！！！！ */</span><br><span class="line">44 IRQ_Handler:</span><br><span class="line">45 /* 复位中断具体处理过程 */</span><br><span class="line">46 </span><br><span class="line">47 /* FIQ 中断 */</span><br><span class="line">48 FIQ_Handler:</span><br><span class="line">49 ldr r0, =FIQ_Handler </span><br><span class="line">50 bx r0 </span><br></pre></td></tr></table></figure><h4 id="GIC控制器"><a href="#GIC控制器" class="headerlink" title="GIC控制器"></a>GIC控制器</h4><p>ARM 针对 GIC V2 就开发出了 GIC400 这个中断控制器 IP 核。当 GIC 接收到外部中断信号以后就会报给 ARM 内核，但是ARM 内核只提供了四个信号给 GIC 来汇报中断情况：VFIQ、VIRQ、FIQ 和 IRQ。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_212349.png"></p><p><strong>VFIQ:虚拟快速 FIQ。</strong><br><strong>VIRQ:虚拟外部 IRQ。</strong><br><strong>FIQ:快速中断 IRQ。</strong><br><strong>IRQ:外部中断 IRQ。</strong>（GPIO中断属于IRQ外部中断。）</p><p>GIC 将众多的中断源分为分为三类：<br>①、SPI(Shared Peripheral Interrupt),共享中断，顾名思义，所有 Core 共享的中断，这个是最常见的，那些外部中断都属于 SPI 中断(注意！不是 SPI 总线那个中断) 。比如按键中断、串口中断等等，这些中断所有的 Core 都可以处理，不限定特定 Core。<br>②、PPI(Private Peripheral Interrupt)，私有中断，我们说了 GIC 是支持多核的，每个核肯定有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断。<br>③、SGI(Software-generated Interrupt)，软件中断，由软件触发引起的中断，通过向寄存器GICD_SGIR 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信。</p><p><strong>中断源有很多，为了区分这些不同的中断源肯定要给他们分配一个唯一 ID，这些 ID 就是中断 ID</strong>。每一个 CPU 最多支持 1020 个中断 ID，中断 ID 号为 ID0<del>ID1019。这 1020 个 ID 包含了 PPI、SPI 和 SGI。<br>ID0</del>ID15：这 16 个 ID 分配给 SGI。<br>ID16<del>ID31：这 16 个 ID 分配给 PPI。<br>ID32</del>ID1019：这 988 个 ID 分配给 SPI。具体看手册。</p><p><strong>GIC 架构分为了两个逻辑块：Distributor 和 CPU Interface，也就是分发器端和 CPU 接口端。</strong></p><p>Distributor(分发器端)：此逻辑块负责处理各个中断事件的分发问题，也就是中断事件应该发送到哪个 CPU Interface 上去。分发器收集所有的中断源，可以控制每个中断的优先级，它总是将优先级最高的中断事件发送到 CPU 接口端。分发器端要做的主要工作如下：<br>①、全局中断使能控制。<br>②、控制每一个中断的使能或者关闭。<br>③、设置每个中断的优先级。<br>④、设置每个中断的目标处理器列表。<br>⑤、设置每个外部中断的触发模式：电平触发或边沿触发。<br>⑥、设置每个中断属于组 0 还是组 1。</p><p>CPU Interface(CPU 接口端)：CPU 接口端听名字就知道是和 CPU Core 相连接的，因此在每个 CPU Core 都可以在 GIC 中找到一个与之对应的 CPU Interface。CPU 接口端就是分发器和 CPU Core 之间的桥梁，CPU 接口端主要工作如下：<br>①、使能或者关闭发送到 CPU Core 的中断请求信号。<br>②、应答中断。<br>③、通知中断处理完成。<br>④、设置优先级掩码，通过掩码来设置哪些中断不需要上报给 CPU Core。<br>⑤、定义抢占策略。<br>⑥、当多个中断到来的时候，选择优先级最高的中断通知给 CPU Core。</p><p><strong>CP15 协处理器</strong></p><p>CP15 协处理器一般用于存储系统管理，但是在中断中也会使用到，CP15 协处理器一共有16 个 32 位寄存器。</p><p>CP15 协处理器的访问通过如下另个指令完成：</p><p>MRC: 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。读CP5寄存器<br>MCR: 将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中。写CP15寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MCR&#123;cond&#125; p15, &lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;, &lt;opc2&gt;</span><br><span class="line">MRC p15, 0, r0, c0, c0, 0//CP15 中 C0 寄存器的值读取到 R0 寄存器</span><br></pre></td></tr></table></figure><p>cond:指令执行的条件码，如果忽略的话就表示无条件执行。<br>opc1：协处理器要执行的操作码。<br>Rt：ARM 源寄存器，要写入到 CP15 寄存器的数据就保存在此寄存器中。<br>CRn：CP15 协处理器的目标寄存器。<br>CRm：协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将<br>CRm 设置为 C0，否则结果不可预测。<br>opc2：可选的协处理器特定操作码，当不需要的时候要设置为 0。</p><p>CP15 协处理器有 16 个 32 位寄存器，c0~c15，在使用 MRC 或者 MCR 指令访问这 16 个<br>寄存器的时候，指令中的 CRn、opc1、CRm 和 opc2 通过不同的搭配，其得到的寄存器含义是<br>不同的。例如C1寄存器的搭配。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_220740.png"></p><h4 id="中断使能"><a href="#中断使能" class="headerlink" title="中断使能"></a>中断使能</h4><p>中断使能包括两部分，一个是 IRQ 或者 FIQ 总中断使能，另一个就是 ID0~ID1019 这 1020<br>个中断源的使能。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_221931.png"></p><p>GIC 寄存器 GICD_ISENABLERn 和 GICD_ ICENABLERn 用来完成外部中断的使能和禁止，对于 Cortex-A7 内核来说中断 ID 只使用了 512 个。一个 bit 控制一个中断 ID 的使能，那么就需要 512&#x2F;32&#x3D;16 个 GICD_ISENABLER 寄存器来完成中断的使能。同理，也需要 16 个GICD_ICENABLER 寄存器来完成中断的禁止。其中 GICD_ISENABLER0 的 bit[15:0]对应ID15<del>0 的 SGI 中断，GICD_ISENABLER0 的 bit[31:16]对应 ID31</del>16 的 PPI 中断。剩下的GICD_ISENABLER1~GICD_ISENABLER15 就是控制 SPI 中断的。</p><h4 id="中断优先级设置"><a href="#中断优先级设置" class="headerlink" title="中断优先级设置"></a>中断优先级设置</h4><p><strong>优先级数配置</strong></p><p>GIC 控制器最多可以支持 256 个优先级，数字越小，优先级越高！Cortex-A7 选择了 32 个优先级。在使用中断的时候需要初始化 GICC_PMR 寄存器，此寄存器用来决定使用几级优先级。I.MX6U 是 Cortex-A7内核，所以支持 32 个优先级，因此 GICC_PMR 要设置为 0b11111000。</p><p><strong>抢占优先级和子优先级位数设置</strong></p><p>优先级寄存器分为两部分：抢占优先级和子优先级。分配给每个部分的位数是可配置的。抢占优先级定义了一个中断是否可以抢占一个已经在执行的中断。当两个抢占优先级相同的中断同时发生时，子优先级决定哪个中断将首先执行。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_222553.png"></p><p><strong>优先级设置</strong></p><p>前面已经设置好了 I.MX6U 一共有 32 个抢占优先级，数字越小优先级越高。具体要使用某个中断的时候就可以设置其优先级为 0~31。某个中断 ID 的中断优先级设置由寄存器D_IPRIORITYR 来完成，前面说了 Cortex-A7 使用了 512 个中断 ID，每个中断 ID 配有一个优先级寄存器，所以一共有 512 个 D_IPRIORITYR 寄存器。如果优先级个数为 32 的话，使用寄存器 D_IPRIORITYR 的 bit7:4 来设置优先级，也就是说实际的优先级要左移 3 位。比如要设置ID40 中断的优先级为 5，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GICD_IPRIORITYR[40] = 5 &lt;&lt; 3;</span><br></pre></td></tr></table></figure><p>有关优先级设置的内容就讲解到这里，优先级设置主要有三部分：<br>①、设置寄存器 GICC_PMR，配置优先级个数，比如 I.MX6U 支持 32 级优先级。<br>②、设置抢占优先级和子优先级位数。<br>③、设置指定中断 ID 的优先级，也就是设置外设优先级。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u时钟配置</title>
      <link href="/2023/02/16/2023-2-16-imx6u%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/02/16/2023-2-16-imx6u%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="系统时钟来源"><a href="#系统时钟来源" class="headerlink" title="系统时钟来源"></a>系统时钟来源</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230215_214959.png"></p><p>开发板的系统时钟来源于两部分：32.768KHz 和24MHz 的晶振，其中 32.768KHz 晶振是 I.MX6U 的 RTC 时钟源，24MHz 晶振是 I.MX6U 内核和其它外设的时钟源。</p><p>I.MX6U 的外设有很多，不同的外设时钟源不同，这些外设的时钟源分了7组，这 7 组时钟源都是从 24MHz 晶振 PLL 而来的，因此也叫做 7 组 PLL.</p><h3 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h3><p>由下面的时钟切换图可知，IMX6U总共有7组PLL：</p><p>PLL1（996M）、PLL2（528M）、PLL3（480M）、PLL4、PLL5、PLL6、PLL7</p><p>其中PLL2、PLL3各自有4组PFD，这些PFD以PLL为基础，经过不同的分频系数可以产生不同频率的时钟，在参考手册的相关寄存器的地方，可以看到官方有推荐的配置参数。(《IMX6UL参考手册》</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/edr.png"></p><p>①、 ARM_PLL（PLL1），此路 PLL 是供 ARM 内核使用的，ARM 内核时钟就是由此 PLL生成的，此 PLL 通过编程的方式最高可倍频到 1.3GHz。<br>②、528_PLL(PLL2)，此路 PLL 也叫做 System_PLL，此路 PLL 是固定的 22 倍频，不可编程修改。因此，此路 PLL 时钟&#x3D;24MHz * 22 &#x3D; 528MHz，这也是为什么此 PLL 叫做 528_PLL 的原因。此 PLL 分出了 4 路 PFD，分别为：PLL2_PFD0<del>PLL2_PFD3，这 4 路 PFD 和 528_PLL共同作为其它很多外设的根时钟源。通常 528_PLL 和这 4 路 PFD 是 I.MX6U 内部系统总线的时钟源，比如内处理逻辑单元、DDR 接口、NAND&#x2F;NOR 接口等等。<br>③、USB1_PLL(PLL3)，此路 PLL 主要用于 USBPHY，此 PLL 也有四路 PFD，为：PLL3_PFD0</del>PLL3_PFD3，USB1_PLL 是固定的 20 倍频，因此 USB1_PLL&#x3D;24MHz *20&#x3D;480MHz。<br>USB1_PLL虽然主要用于USB1PHY，但是其和四路PFD同样也可以作为其他外设的根时钟源。<br>④、USB2_PLL(PLL7，没有写错！就是 PLL7，虽然序号标为 4，但是实际是 PLL7)，看名字就知道此路PLL是给USB2PHY 使用的。同样的，此路PLL固定为20倍频，因此也是480MHz。<br>⑤、ENET_PLL(PLL6),此路 PLL 固定为 20+5&#x2F;6 倍频，因此 ENET_PLL&#x3D;24MHz * (20+5&#x2F;6) &#x3D; 500MHz。此路 PLL 用于生成网络所需的时钟，可以在此 PLL 的基础上生成 25&#x2F;50&#x2F;100&#x2F;125MHz的网络时钟。<br>⑥、VIDEO_PLL(PLL5),此路 PLL 用于显示相关的外设，比如 LCD，此路 PLL 的倍频可以调整，PLL 的输出范围在 650MHz<del>1300MHz。此路 PLL 在最终输出的时候还可以进行分频，可选 1&#x2F;2&#x2F;4&#x2F;8&#x2F;16 分频。<br>⑦、AUDIO_PLL(PLL4),此路 PLL 用于音频相关的外设，此路 PLL 的倍频可以调整，PLL的输出范围同样也是 650MHz</del>1300MHz，此路 PLL 在最终输出的时候也可以进行分频，可选1&#x2F;2&#x2F;4 分频。</p><p>PLL：接收锁相环输出时钟和锁相环旁路时钟。 简单来说，锁相环就是用来将外部晶振进行倍频，以实现稳定且高频的时钟信号。</p><h4 id="内核时钟设置（PLL1）"><a href="#内核时钟设置（PLL1）" class="headerlink" title="内核时钟设置（PLL1）"></a>内核时钟设置（PLL1）</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_182344.png"></p><p>①、pll1_sw_clk 也就是 PLL1 的最终输出频率。<br>②、此处是一个选择器，选择 pll1_sw_clk 的时钟源，由寄存器 CCM_CCSR 的PLL1_SW_CLK_SEL 位决定 pll1_sw_clk 是选择 pll1_main_clk 还是 step_clk。正常情况下应该选择 pll1_main_clk，但是如果要对 pll1_main_clk(PLL1)的频率进行调整的话，比如我们要设置PLL1&#x3D;1056MHz，此时就要先将 pll1_sw_clk 切换到 step_clk 上。等 pll1_main_clk 调整完成以后再切换回来。<br>③、此处也是一个选择器，选择 step_clk 的时钟源，由寄存器 CCM_CCSR 的 STEP_SEL 位来决定 step_clk 是选择 osc_clk 还是 secondary_clk。一般选择 osc_clk，也就是 24MHz 的晶振。</p><p><strong>首先要使用CCM_CCSR寄存器来决定使用时钟源来进行配置。</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_174705.png"></p><p>①、 设置寄存器 CCSR 的 STEP_SEL 位，设置 step_clk 的时钟源为 24M 的晶振。<br>②、设置寄存器 CCSR 的 PLL1_SW_CLK_SEL 位，设置 pll1_sw_clk 的时钟源为<br>step_clk&#x3D;24MHz，通过这一步我们就将 I.MX6U 的主频先设置为 24MHz，直接来自于外部的<br>24M 晶振。<br>③、设置寄存器 CCM_ANALOG_PLL_ARMn，将 pll1_main_clk(PLL1)设置为 1056MHz。<br>④、设置寄存器 CCSR 的 PLL1_SW_CLK_SEL 位，重新将 pll1_sw_clk 的时钟源切换回<br>pll1_main_clk，切换回来以后的 pll1_sw_clk 就等于 1056MHz。<br>⑤、最后设置寄存器 CCM_CACRR 的 ARM_PODF 为 2 分频，I.MX6U 的内核主频就为<br>1056&#x2F;2&#x3D;528MHz。</p><h4 id="PFD-时钟设置"><a href="#PFD-时钟设置" class="headerlink" title="PFD 时钟设置"></a>PFD 时钟设置</h4><p>设置好主频以后我们还需要设置好其他的 PLL 和 PFD 时钟，PLL1 上一小节已经设置了，PLL2、PLL3 和 PLL7 固定为 528MHz、480MHz 和 480MHz，PLL4~PLL6 都是针对特殊外设的，用到的时候再设置。因此，接下来重点就是设置 PLL2 和 PLL3 的各自 4 路 PFD，这 8 路 PFD 频率如表  所示：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_183230.png"></p><p>设置PFD0~3需要按照寄存器的所在位进行置数。以下是寄存器CCM_ANALOG_PFD_528n的结构。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_191351.png"></p><p>频率计算公式</p><p><strong>PLL2_PFDX&#x3D;528*18&#x2F;PFDX_FRAC(X&#x3D;1~3)。</strong></p><p>*<em>PLL3_PFDX&#x3D;480</em>18&#x2F;PFDX_FRAC(X&#x3D;0~3)**。</p><p>例如设置PFD3的的频率为297MHz需要进行以下设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> reg = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">reg &amp;= ~(<span class="number">0X3F3F3F3F</span>);<span class="comment">//清楚以前设置</span></span><br><span class="line">x = <span class="number">32</span>;<span class="comment">//528*18/297</span></span><br><span class="line">reg |= (x&lt;&lt;<span class="number">24</span>);<span class="comment">//24是寄存器的位置</span></span><br></pre></td></tr></table></figure><h4 id="AHB、IPG-和-PERCLK-根时钟设置"><a href="#AHB、IPG-和-PERCLK-根时钟设置" class="headerlink" title="AHB、IPG 和 PERCLK 根时钟设置"></a>AHB、IPG 和 PERCLK 根时钟设置</h4><p>7 路 PLL 和 8 路 PFD 设置完成以后最后还需要设置 AHB_CLK_ROOT 和 IPG_CLK_ROOT的时钟，I.MX6U 外设根时钟可设置范围如图：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_192443.png"></p><p>AHB_CLK_ROOT 最高可以设置 132MHz，IPG_CLK_ROOT 和PERCLK_CLK_ROOT 最高可以设置66MHz。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_193126.png"></p><p>①、此选择器用来选择 pre_periph_clk 的时钟源，可以选择 PLL2、PLL2_PFD2、PLL2_PFD0和 PLL2_PFD2&#x2F;2。寄存器 CCM_CBCMR 的 PRE_PERIPH_CLK_SEL 位决定选择哪一个，默认选择 PLL2_PFD2，因此 pre_periph_clk&#x3D;PLL2_PFD2&#x3D;396MHz。<br>②、此选择器用来选择 periph_clk 的时钟源，由寄存器 CCM_CBCDR 的 PERIPH_CLK_SEL位与 PLL_bypass_en2 组成的或来选择。当 CCM_CBCDR 的 PERIPH_CLK_SEL 位为 0 的时候periph_clk&#x3D;pr_periph_clk&#x3D;396MHz。<br>③、通过 CBCDR 的 AHB_PODF 位来设置 AHB_CLK_ROOT 的分频值，可以设置 1<del>8 分频，如果想要 AHB_CLK_ROOT&#x3D;132MHz 的话就应该设置为 3 分频：396&#x2F;3&#x3D;132MHz。图 中虽然写的是默认 4 分频，但是 I.MX6U 的内部 boot rom 将其改为了 3 分频！<br>④、通过 CBCDR 的 IPG_PODF 位来设置 IPG_CLK_ROOT 的分频值，可以设置 1</del>4 分频，IPG_CLK_ROOT 时钟源是 AHB_CLK_ROOT，要想 IPG_CLK_ROOT&#x3D;66MHz 的话就应该设置2 分频：132&#x2F;2&#x3D;66MHz。</p><p><strong>设置 PERCLK_CLK_ROOT 时钟频率</strong></p><p>PERCLK_CLK_ROOT 来 源 有 两 种 ： OSC(24MHz) 和IPG_CLK_ROOT，由寄存器 CCM_CSCMR1 的 PERCLK_CLK_SEL 位来决定，如果为 0 的话，PERCLK_CLK_ROOT 的时钟源就是 IPG_CLK_ROOT&#x3D;66MHz 。可以通过寄存器CCM_CSCMR1 的 PERCLK_PODF 位来设置分频，如果要设置 PERCLK_CLK_ROOT 为 66MHz的话就要设置为 1 分频。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clk_enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">CCM-&gt;CCGR0 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR1 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR2 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR3 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR4 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR5 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR6 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 初始化系统时钟，设置系统时钟为792Mhz，并且设置PLL2和PLL3各个</span></span><br><span class="line"><span class="comment">   PFD时钟,所有的时钟频率均按照I.MX6U官方手册推荐的值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">imx6u_clkinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> reg = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 1、设置ARM内核时钟为792MHz */</span></span><br><span class="line"><span class="comment">/* 1.1、判断当前ARM内核是使用的那个时钟源启动的，正常情况下ARM内核是由pll1_sw_clk驱动的，而</span></span><br><span class="line"><span class="comment"> *  pll1_sw_clk有两个来源：pll1_main_clk和tep_clk。</span></span><br><span class="line"><span class="comment"> *  如果我们要让ARM内核跑到792M的话那必须选择pll1_main_clk作为pll1的时钟源。</span></span><br><span class="line"><span class="comment"> *  如果我们要修改pll1_main_clk时钟的话就必须先将pll1_sw_clk从pll1_main_clk切换到step_clk,</span></span><br><span class="line"><span class="comment"> *当修改完pll1_main_clk以后在将pll1_sw_clk切换回pll1_main_clk。而step_clk的时钟源可以选择</span></span><br><span class="line"><span class="comment"> * 板子上的24MHz晶振。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((((CCM-&gt;CCSR) &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x1</span> ) == <span class="number">0</span>) <span class="comment">/* 当前pll1_sw_clk使用的pll1_main_clk*/</span></span><br><span class="line">&#123;</span><br><span class="line">CCM-&gt;CCSR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">8</span>);<span class="comment">/* 配置step_clk时钟源为24MH OSC */</span></span><br><span class="line">CCM-&gt;CCSR |= (<span class="number">1</span> &lt;&lt; <span class="number">2</span>);<span class="comment">/* 配置pll1_sw_clk时钟源为step_clk */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1.2、设置pll1_main_clk为792MHz</span></span><br><span class="line"><span class="comment"> *      因为pll1_sw_clk进ARM内核的时候会被二分频！</span></span><br><span class="line"><span class="comment"> *      配置CCM_ANLOG-&gt;PLL_ARM寄存器</span></span><br><span class="line"><span class="comment"> *      bit13: 1 使能时钟输出</span></span><br><span class="line"><span class="comment"> *      bit[6:0]: 66, 由公式：Fout = Fin * div_select / 2.0，792=24*div_select/2.0,</span></span><br><span class="line"><span class="comment"> *              得出：div_select=    66 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CCM_ANALOG-&gt;PLL_ARM = (<span class="number">1</span> &lt;&lt; <span class="number">13</span>) | ((<span class="number">66</span> &lt;&lt; <span class="number">0</span>) &amp; <span class="number">0X7F</span>); <span class="comment">/* 配置pll1_main_clk=792MHz */</span></span><br><span class="line">CCM-&gt;CCSR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>);<span class="comment">/* 将pll_sw_clk时钟重新切换回pll1_main_clk */</span></span><br><span class="line">CCM-&gt;CACRR = <span class="number">0</span>;<span class="comment">/* ARM内核时钟为pll1_sw_clk/1=792/1=792Mhz */</span></span><br><span class="line"><span class="comment">/* 2、设置PLL2(SYS PLL)各个PFD */</span></span><br><span class="line">reg = CCM_ANALOG-&gt;PFD_528;</span><br><span class="line">reg &amp;= ~(<span class="number">0X3F3F3F3F</span>);<span class="comment">/* 清除原来的设置 */</span></span><br><span class="line">reg |= <span class="number">32</span>&lt;&lt;<span class="number">24</span>;<span class="comment">/* PLL2_PFD3=528*18/32=297Mhz */</span></span><br><span class="line">reg |= <span class="number">24</span>&lt;&lt;<span class="number">16</span>;<span class="comment">/* PLL2_PFD2=528*18/24=396Mhz(DDR使用的时钟，最大400Mhz) */</span></span><br><span class="line">reg |= <span class="number">16</span>&lt;&lt;<span class="number">8</span>;<span class="comment">/* PLL2_PFD1=528*18/16=594Mhz */</span></span><br><span class="line">reg |= <span class="number">27</span>&lt;&lt;<span class="number">0</span>;<span class="comment">/* PLL2_PFD0=528*18/27=352Mhz  */</span></span><br><span class="line">CCM_ANALOG-&gt;PFD_528=reg;<span class="comment">/* 设置PLL2_PFD0~3  */</span></span><br><span class="line"><span class="comment">/* 3、设置PLL3(USB1)各个PFD */</span></span><br><span class="line">reg = <span class="number">0</span>;<span class="comment">/* 清零   */</span></span><br><span class="line">reg = CCM_ANALOG-&gt;PFD_480;</span><br><span class="line">reg &amp;= ~(<span class="number">0X3F3F3F3F</span>);<span class="comment">/* 清除原来的设置 */</span></span><br><span class="line">reg |= <span class="number">19</span>&lt;&lt;<span class="number">24</span>;<span class="comment">/* PLL3_PFD3=480*18/19=454.74Mhz */</span></span><br><span class="line">reg |= <span class="number">17</span>&lt;&lt;<span class="number">16</span>;<span class="comment">/* PLL3_PFD2=480*18/17=508.24Mhz */</span></span><br><span class="line">reg |= <span class="number">16</span>&lt;&lt;<span class="number">8</span>;<span class="comment">/* PLL3_PFD1=480*18/16=540Mhz*/</span></span><br><span class="line">reg |= <span class="number">12</span>&lt;&lt;<span class="number">0</span>;<span class="comment">/* PLL3_PFD0=480*18/12=720Mhz */</span></span><br><span class="line">CCM_ANALOG-&gt;PFD_480=reg;<span class="comment">/* 设置PLL3_PFD0~3 */</span></span><br><span class="line"><span class="comment">/* 4、设置AHB时钟 最小6Mhz， 最大132Mhz (boot rom自动设置好了可以不用设置)*/</span></span><br><span class="line">CCM-&gt;CBCMR &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">18</span>); <span class="comment">/* 清除设置*/</span> </span><br><span class="line">CCM-&gt;CBCMR |= (<span class="number">1</span> &lt;&lt; <span class="number">18</span>);<span class="comment">/* pre_periph_clk=PLL2_PFD2=396MHz */</span></span><br><span class="line">CCM-&gt;CBCDR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">25</span>);<span class="comment">/* periph_clk=pre_periph_clk=396MHz */</span></span><br><span class="line"><span class="keyword">while</span>(CCM-&gt;CDHIPR &amp; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>));<span class="comment">/* 等待握手完成 */</span></span><br><span class="line"><span class="comment">/* 5、设置IPG_CLK_ROOT最小3Mhz，最大66Mhz (boot rom自动设置好了可以不用设置)*/</span></span><br><span class="line">CCM-&gt;CBCDR &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">8</span>);<span class="comment">/* CBCDR的IPG_PODF清零 */</span></span><br><span class="line">CCM-&gt;CBCDR |= <span class="number">1</span> &lt;&lt; <span class="number">8</span>;<span class="comment">/* IPG_PODF 2分频，IPG_CLK_ROOT=66MHz */</span></span><br><span class="line"><span class="comment">/* 6、设置PERCLK_CLK_ROOT时钟 */</span></span><br><span class="line">CCM-&gt;CSCMR1 &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">6</span>);<span class="comment">/* PERCLK_CLK_ROOT时钟源为IPG */</span></span><br><span class="line">CCM-&gt;CSCMR1 &amp;= ~(<span class="number">7</span> &lt;&lt; <span class="number">0</span>);<span class="comment">/* PERCLK_PODF位清零，即1分频 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPIO寄存器配置原理</title>
      <link href="/2023/02/14/2023-2-14-GPIO%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>/2023/02/14/2023-2-14-GPIO%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="i-MX6ULL也有多种点灯方式：（究其本质，最终都是要操作i-MX6ULL的寄存器）"><a href="#i-MX6ULL也有多种点灯方式：（究其本质，最终都是要操作i-MX6ULL的寄存器）" class="headerlink" title="i.MX6ULL也有多种点灯方式：（究其本质，最终都是要操作i.MX6ULL的寄存器）"></a>i.MX6ULL也有多种点灯方式：（究其本质，最终都是要操作i.MX6ULL的寄存器）</h3><ul><li><strong>裸机系统</strong>：汇编操作寄存器点灯、C语言操作寄存器点灯</li><li><strong>跑Linux系统</strong>：字符驱动LED点灯、设备树驱动LED点灯</li></ul><h3 id="IO与GPIO是两个概念，GPIO是属于IO的一部分。"><a href="#IO与GPIO是两个概念，GPIO是属于IO的一部分。" class="headerlink" title="IO与GPIO是两个概念，GPIO是属于IO的一部分。"></a>IO与GPIO是两个概念，GPIO是属于IO的一部分。</h3><p>IO: Input Output，用于CPU与外界进行信息交互。例如CPU 读内存数据需要 I&#x2F;O 系统，CPU 输出数据到屏幕显示出来也需要 I&#x2F;O 系统，信息在 I&#x2F;O 系统上传输有串行或并行。<br>GPIO: General-Purpose IO ports，即通用I&#x2F;O口，在微控制器芯片上一般都会提供一个“通用可编程I&#x2F;O接口”。接口至少有两个寄存器——数据寄存器与控制寄存器。数据寄存器的各位直接引到芯片外部，控制寄存器则是对数据寄存器中每一位进行独立的设置。</p><h3 id="imx6ul的GPIO硬件结构"><a href="#imx6ul的GPIO硬件结构" class="headerlink" title="imx6ul的GPIO硬件结构"></a>imx6ul的GPIO硬件结构</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230215_150827.png"></p><p>① PAD：它代表了i.MX6ULL芯片的一个GPIO引脚。</p><p>② IOMUX复用选择器：与STM32的引脚复用功能类似，i.MX6ULL芯片的每个IO通过IOMUXC中的MUX寄存器和PAD寄存器设置，可以支持多种功能(如GPIO、IIC、USART…)。</p><p>IOMUX由其左侧的IOMUXC提供寄存器给用户进行配置，它又分成MUX_Mode（IO 模式控制）以及Pad Settings（Pad 配置）两个部分：</p><ol><li><p>MUX_Mode配置：用来配置引脚的复用功能</p><p>2.Pad Settings 配置：配置引脚的属性，例如驱动能力，是否使用上下拉电阻，是否使用保持器，是否使用开漏模式以及使用施密特模式还是CMOS模式等</p></li></ol><p>③ Block外设功能控制块：例如具有PWM输出功能的引脚，它需要PWM外设的支持。</p><p>④ GPIO外设：GPIO模块是每个IO都具有的外设， 它是IO控制的基本功能， 如输出高低电平、 检测电平输入等。当需要使用引脚的GPIO功能时，就要配置GPIO外设中的各个寄存器(DR、GDIR、PSR…)。</p><p>⑤ 与其它引脚的连接：这里是另一个引脚PAD2，它与PAD1有一根信号线连接，表示部分引脚的输出可以作为另一个引脚的输入。</p><h4 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> DR;         <span class="comment">/**&lt; GPIO data register, offset: 0x0 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> GDIR;       <span class="comment">/**&lt; GPIO direction register, offset: 0x4 */</span></span><br><span class="line">  __I  <span class="type">uint32_t</span> PSR;        <span class="comment">/**&lt; GPIO pad status register, offset: 0x8 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ICR1;       <span class="comment">/**&lt; GPIO interrupt configuration register1, offset: 0xC */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ICR2;       <span class="comment">/**&lt; GPIO interrupt configuration register2, offset: 0x10 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> IMR;        <span class="comment">/**&lt; GPIO interrupt mask register, offset: 0x14 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ISR;        <span class="comment">/**&lt; GPIO interrupt status register, offset: 0x18 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> EDGE_SEL;   <span class="comment">/**&lt; GPIO edge select register, offset: 0x1C */</span></span><br><span class="line">&#125; GPIO_Type;</span><br></pre></td></tr></table></figure><p>DR（data register），即数据寄存器，它是32位的，一个GPIO组最大只有32个IO，因此DR寄存器中的每个位都对应一个 GPIO。当GPIO被配置为输出模式后，向指定的位写入数据那么相应的IO就会输出相应的高低电平，当 GPIO被配置为输入模式后，此寄存器就保存着对应IO的电平值，每个位对对应一个GPIO。</p><p><strong>GDIR（GPIO direction register）</strong>，即方向寄存器，也是32位的，用来设置某个GPIO的工作方向的，即输入&#x2F;输出。同样的，每个IO对应一个位，如果要设置GPIO为输入，就设置相应的位为0，如果要设置为输出，就设置为1</p><p><strong>PSR（Pad Status Register）</strong>，即状态寄存器，也是32位的。注意它是一个<strong>只读寄存器</strong>，每个IO对应一个位，读取相应的位即可获取对应的GPIO的状(高低电平值)，功能和输入状态下的DR寄存器一样。</p><p><strong>ICR1（interrupt configuration register1）和ICR2</strong>，都是中断控制寄存器， ICR1用于配置低16个GPIO，ICR2 用于配置高16 个GPIO。</p><p><strong>IMR（interrupt mask register）</strong>，即中断屏蔽寄存器，也是32位，每个IO对应一个位。IMR寄存器用来控制GPIO的中断禁止和使能，如果使能某个GPIO的中断，那么设置相应的位为1即可，反之，如果要禁止中断，那么就设置相应的位为0即可。</p><p><strong>ISR（interrupt status register）</strong>，即中断状态寄存器，也是32位，每个IO对应一个位。只要某个GPIO的中断发生，则ISR中相应的位就会被置1。所以通过读取ISR寄存器来判断是否发生了中断，类似于学习STM32用到的中断标志位。</p><p><strong>EDGE_SEL（edge select register）</strong>，即边沿选择寄存器，也是32位，每个IO对应一个位。</p><p>它用来设置边沿中断， 并会覆盖ICR1和ICR2的设置。</p><h4 id="时钟配置"><a href="#时钟配置" class="headerlink" title="时钟配置"></a>时钟配置</h4><p><strong>CCM（Clock Controller Module）时钟控制模块寄存器用来使能外设时钟。 CMM一共有CCM_CCGR0~CCM_CCGR6</strong>这 7 个寄存器，控制着I.MX6U的所有外设时钟开关。</p><p>以CCM_CCGR0为例，它是个32位寄存器，每2位控制一个外设的时钟，比如 bit31:30 控制着GPIO2 的外设时钟，两个位就有 4 种操作方式：</p><table><thead><tr><th>位设置</th><th>时钟控制</th></tr></thead><tbody><tr><td>00</td><td>所有模式下都关闭外设时钟</td></tr><tr><td>01</td><td>只有在运行模式下打开外设时钟，等待模式和停止模式下均关闭外设时钟</td></tr><tr><td>10</td><td>未使用(保留)</td></tr><tr><td>11</td><td>除了停止模式以外，其他所有模式下时钟都打开</td></tr></tbody></table><p><strong>配置总结</strong><br>使用i.MX6ULL的GPIO时，需要如下几步配置：</p><p>使能 GPIO 对应的时钟<br>配置MUX寄存器，设置IO的复用功能，使其复用为GPIO功能<br>配置PAD寄存器，设置 IO 的上下拉、速度等<br>配置GPIO的各种寄存器（DR、GDIR、…），设置输入&#x2F;输出、是否使用中断、默认输出电平等</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bsp工程管理</title>
      <link href="/2023/02/12/2023-2-12-bsp%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2023/02/12/2023-2-12-bsp%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="BSP管理"><a href="#BSP管理" class="headerlink" title="BSP管理"></a>BSP管理</h3><p><strong>所有完成同一个功能的代码提取出来放到一个单独的文件中，也就是对程序分功能管理。</strong></p><p>所谓bsp管理就是按照各个功能函数模块化放入各自文件夹进行保存管理，使用时到各自的路径中进行调用。</p><p>类似于stm32的工程管理格式来存储。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230212_222148.png"></p><p>首先以led实验为例子,其中 bsp 用来存放驱动文件；imx6ul 用来存放跟芯片有关的文件，比如  SDK库文件；obj 用来存放编译生成的.o 文件；project 存放 start.S 和 main.c 文件，cc.h、fsl_common.h、fsl_iomuxc.h 和 MCIMX6Y2.h 这四个文件拷贝到文件夹 imx6ul 中；将 start.S 和 main.c 这两个文件拷贝到文件夹 project 中。前面的实验中所有的驱动相关的函数都写到了 main.c 文件中，比如函数 clk_enable、led_init 和 delay，这三个函数可以分为三类：时钟驱动、LED 驱动和延时驱动。因此我们可以在 bsp 文件夹下创建三个子文件夹：clk、delay 和 led，分别用来存放时钟驱动文件、延时驱动文件和 LED 驱动文件，这样main.c 函数就会清爽很多，程序功能模块清晰。工程文件夹都创建好了，接下来就是编写代码了，其实就是将时钟驱动、LED 驱动和延时驱动相关的函数从 main.c 中提取出来做成一个独立的驱动文件 。</p><p>代码部分就是将各部分的驱动函数打包成各自的驱动文件，剩余的不变。最主要的是makefile的编写和之前有很大的区别。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1 CROSS_COMPILE ?= arm-linux-gnueabihf</span><br><span class="line">2 TARGET ?= bsp</span><br><span class="line">3 </span><br><span class="line">4 CC := <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">5 LD := <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">6 OBJCOPY := <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">7 OBJDUMP := <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line">8 </span><br><span class="line">9 INCDIRS := imx6ul \                       //包含整个工程的.h 头文件目录</span><br><span class="line">10 bsp/clk \</span><br><span class="line">11 bsp/led \</span><br><span class="line">12 bsp/delay </span><br><span class="line">13 </span><br><span class="line">14 SRCDIRS := project \//包含的是整个工程的所有.c 和.S 文件目录。</span><br><span class="line">15 bsp/clk \</span><br><span class="line">16 bsp/led \</span><br><span class="line">17 bsp/delay </span><br><span class="line">18 </span><br><span class="line">19 INCLUDE := <span class="variable">$(<span class="built_in">patsubst</span> %, -I %, <span class="variable">$(INCDIRS)</span>)</span>//使用patsubst函数给INCDIRS后面加上-I</span><br><span class="line">20</span><br><span class="line">21 SFILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(SRCDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.S)</span>)//使用foreach和dir挑出所有的.S 汇编文件即可</span><br><span class="line">22 CFILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(SRCDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)//挑出所有的.c文件</span><br><span class="line">等同CFILES = project/main.c bsp/clk/bsp_clk.c bsp/led/bsp_led.c bsp/delay/bsp_delay.c</span><br><span class="line">23</span><br><span class="line">24 SFILENDIR := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(SFILES)</span>)</span>//使用函数 notdir 将 SFILES 和 CFILES 中的路径去掉</span><br><span class="line">25 CFILENDIR := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(CFILES)</span>)</span></span><br><span class="line">等同 SFILENDIR = start.S</span><br><span class="line">CFILENDIR = main.c bsp_clk.c bsp_led.c bsp_delay.c</span><br><span class="line">26</span><br><span class="line">27 SOBJS := <span class="variable">$(<span class="built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)</span><br><span class="line">28 COBJS := <span class="variable">$(<span class="built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)</span><br><span class="line">29 OBJS := <span class="variable">$(SOBJS)</span> <span class="variable">$(COBJS)</span></span><br><span class="line">30</span><br><span class="line">31 VPATH := <span class="variable">$(SRCDIRS)</span>//VPATH 是指定搜索目录</span><br><span class="line">32</span><br><span class="line">33 .PHONY: clean</span><br><span class="line">34 </span><br><span class="line">35 <span class="variable">$(TARGET)</span>.bin : <span class="variable">$(OBJS)</span></span><br><span class="line">36 <span class="variable">$(LD)</span> -Timx6ul.lds -o <span class="variable">$(TARGET)</span>.elf <span class="variable">$^</span></span><br><span class="line">37 <span class="variable">$(OBJCOPY)</span> -O binary -S <span class="variable">$(TARGET)</span>.elf <span class="variable">$@</span></span><br><span class="line">38 <span class="variable">$(OBJDUMP)</span> -D -m arm <span class="variable">$(TARGET)</span>.elf &gt; <span class="variable">$(TARGET)</span>.dis</span><br><span class="line">39</span><br><span class="line">40 <span class="variable">$(SOBJS)</span> : obj/%.o : %.S</span><br><span class="line">41 <span class="variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">42</span><br><span class="line">43 <span class="variable">$(COBJS)</span> : obj/%.o : %.c</span><br><span class="line">44 <span class="variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">45 </span><br><span class="line">46 clean:</span><br><span class="line">47 rm -rf <span class="variable">$(TARGET)</span>.elf <span class="variable">$(TARGET)</span>.dis <span class="variable">$(TARGET)</span>.bin <span class="variable">$(COBJS)</span> <span class="variable">$(SOBJS)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言点亮led</title>
      <link href="/2023/02/05/2023-2-5-C%E8%AF%AD%E8%A8%80%E7%82%B9%E4%BA%AEled/"/>
      <url>/2023/02/05/2023-2-5-C%E8%AF%AD%E8%A8%80%E7%82%B9%E4%BA%AEled/</url>
      
        <content type="html"><![CDATA[<p>Cortex-A 处理器运行模型</p><p>Cortex-A7 处理器有 9 种处理模式。如下图：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230206_165721.png"></p><p>所有的处理器模式都共用一个 CPSR 物理寄存器，因此 CPSR 可以在任何模式下被访问。CPSR 是当前程序状态寄存器，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志等一些状态位以及一些控制位。所有的处理器模式都共用一个 CPSR 必然会导致冲突，为此，除了 User 和 Sys 这两个模式以外，其他 7 个模式每个都配备了一个专用的物理状态寄存器，叫做 SPSR(备份程序状态寄存器)，当特定的异常中断发生时，SPSR 寄存器用来保存当前程序状态寄存器(CPSR)的值，当异常退出以后可以用 SPSR 中保存的值来恢复 CPSR。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230206_170328.png"></p><p>N(bit31)：当两个补码表示的 有符号整数运算的时候，N&#x3D;1 表示运算对的结果为负数，N&#x3D;0表示结果为正数。<br>Z(bit30)：Z&#x3D;1 表示运算结果为零，Z&#x3D;0 表示运算结果不为零，对于 CMP 指令，Z&#x3D;1 表示进行比较的两个数大小相等。<br>C(bit29)：在加法指令中，当结果产生了进位，则 C&#x3D;1，表示无符号数运算发生上溢，其它情况下 C&#x3D;0。在减法指令中，当运算中发生借位，则 C&#x3D;0，表示无符号数运算发生下溢，其它情况下 C&#x3D;1。对于包含移位操作的非加&#x2F;减法运算指令，C 中包含最后一次溢出的位的数值，对于其它非加&#x2F;减运算指令，C 位的值通常不受影响。<br>V(bit28)：对于加&#x2F;减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时，V&#x3D;1 表示符号位溢出，通常其他位不影响 V 位。<br>Q(bit27)：仅 ARM v5TE_J 架构支持，表示饱和状态，Q&#x3D;1 表示累积饱和，Q&#x3D;0 表示累积不饱和。<br>IT<a href="bit26:25">1:0</a>：和 IT<a href="bit15:bit10">7:2</a>一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。<br>J(bit24)：仅 ARM_v5TE-J 架构支持，J&#x3D;1 表示处于 Jazelle 状态，此位通常和 T(bit5)位一起表示当前所使用的指令集。<br>GE<a href="bit19:16">3:0</a>：SIMD 指令有效，大于或等于。<br>IT<a href="bit15:10">7:2</a>：参考 IT[1:0]。<br>E(bit9)：大小端控制位，E&#x3D;1 表示大端模式，E&#x3D;0 表示小端模式。<br>A(bit8)：禁止异步中断位，A&#x3D;1 表示禁止异步中断。<br>I(bit7)：I&#x3D;1 禁止 IRQ，I&#x3D;0 使能 IRQ。<br>F(bit6)：F&#x3D;1 禁止 FIQ，F&#x3D;0 使能 FIQ。<br>T(bit5)：控制指令执行状态，表明本指令是 ARM 指令还是 Thumb 指令，通常和 J(bit24)一起表明指令类型，参考 J(bit24)位。<br>M[4:0]：处理器模式控制位</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230206_170546.png"></p><h3 id="点亮led"><a href="#点亮led" class="headerlink" title="点亮led"></a>点亮led</h3><p>在开始部分用汇编来初始化一下 C 语言环境，比如初始化 DDR、设置堆栈指针 SP 等等，当这些工作都做完以后就可以进入 C 语言环境，也就是运行 C 语言代码，一般都是进入 main 函数。所以我们有两部分文件要做：<br>①、汇编文件：汇编文件只是用来完成 C 语言环境搭建。<br>②、C 语言文件：C 语言文件就是完成我们的业务层代码的，其实就是我们实际例程要完成的功能。</p><p>start.s文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 .global _start /* 全局标号 */</span><br><span class="line">2 </span><br><span class="line">3 /*</span><br><span class="line">4 * 描述： _start 函数，程序从此函数开始执行，此函数主要功能是设置 C</span><br><span class="line">5 * 运行环境。</span><br><span class="line">6 */</span><br><span class="line">7 _start:</span><br><span class="line">8 </span><br><span class="line">9 /* 进入 SVC 模式 */</span><br><span class="line">10 mrs r0, cpsr</span><br><span class="line">11 bic r0, r0, #0x1f /* 将 r0 的低 5 位清零，也就是 cpsr 的 M0~M4 */</span><br><span class="line">12 orr r0, r0, #0x13 /* r0 或上 0x13,表示使用 SVC 模式 */</span><br><span class="line">13 msr cpsr, r0 /* 将 r0 的数据写入到 cpsr_c 中 */</span><br><span class="line">14</span><br><span class="line">15 ldr sp, =0X80200000 /* 设置栈指针 */</span><br><span class="line">16 b main /* 跳转到 main 函数 */</span><br></pre></td></tr></table></figure><p>第 1 行定义了一个全局标号_start。<br>第 7 行就是标号_start 开始的地方，相当于是一个_start 函数，这个_start 就是第一行代码。<br>第 10<del>13 行就是设置处理器进入 SVC 模式，在 6.2 小节的“Cortex-A 处理器运行模型”中，设置处理器运行在 SVC 模式下。处理器模式的设置是通过修改 CPSR(程序状态)寄存器来完成的，其中 M[4:0](CPSR 的 bit[4:0])就是设置处理器运行模式的，如果要将处理器设置为 SVC 模式，那么 M[4:0]就要等于 0X13。11</del>13 行代码就是先使用指令 MRS 将 CPSR寄存器的值读取到 R0 中，然后修改 R0 中的值，设置 R0 的 bit[4:0]为 0X13，然后再使用指令MSR 将修改后的 R0 重新写入到 CPSR 中。<br>第 15 行通过 ldr 指令设置 SVC 模式下的 SP 指针&#x3D;0X80200000，因为 I.MX6U-ALPHA 开发板上的 DDR3 地址范围 是 0X80000000<del>0XA0000000(512MB) 或 者0X80000000</del>0X90000000(256MB)，不管是 512MB 版本还是 256MB 版本的，其 DDR3 起始地址都是 0X80000000。由于 Cortex-A7 的堆栈是向下增长的，所以将 SP 指针设置为 0X80200000，因此 SVC 模式的栈大小 0X80200000-0X80000000&#x3D;0X200000&#x3D;2MB，2MB 的栈空间已经很大了，如果做裸机开发的话绰绰有余。<br>第 16 行就是跳转到 main 函数，main 函数就是 C 语言代码了。<br>至此汇编部分程序执行完成，就几行代码，用来设置处理器运行到 SVC 模式下、然后初始化 SP 指针、最终跳转到 C 文件的 main 函数中。</p><p>编写led.h文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * CCM 相关寄存器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR0 *((volatile unsigned int *)0X020C4068)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR1 *((volatile unsigned int *)0X020C406C)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR2 *((volatile unsigned int *)0X020C4070)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR3 *((volatile unsigned int *)0X020C4074)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR4 *((volatile unsigned int *)0X020C4078)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR5 *((volatile unsigned int *)0X020C407C)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR6 *((volatile unsigned int *)0X020C4080)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * IOMUX 相关寄存器地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SW_MUX_GPIO1_IO03 *((volatile unsigned int *)0X020E0068)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SW_PAD_GPIO1_IO03 *((volatile unsigned int *)0X020E02F4)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * GPIO1 相关寄存器地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_DR *((volatile unsigned int *)0X0209C000)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_GDIR *((volatile unsigned int *)0X0209C004)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_PSR *((volatile unsigned int *)0X0209C008)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_ICR1 *((volatile unsigned int *)0X0209C00C)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_ICR2 *((volatile unsigned int *)0X0209C010)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_IMR *((volatile unsigned int *)0X0209C014)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_ISR *((volatile unsigned int *)0X0209C018)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_EDGE_SEL *((volatile unsigned int *)0X0209C01C)</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>编写led.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  @description : 使能 I.MX6U 所有外设时钟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">clk_enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> CCM_CCGR0 = <span class="number">0xffffffff</span>;</span><br><span class="line"> CCM_CCGR1 = <span class="number">0xffffffff</span>;</span><br><span class="line"> CCM_CCGR2 = <span class="number">0xffffffff</span>;</span><br><span class="line">CCM_CCGR3 = <span class="number">0xffffffff</span>;</span><br><span class="line">CCM_CCGR4 = <span class="number">0xffffffff</span>;</span><br><span class="line">CCM_CCGR5 = <span class="number">0xffffffff</span>;</span><br><span class="line">CCM_CCGR6 = <span class="number">0xffffffff</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  @description : 初始化 LED 对应的 GPIO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">/* 1、初始化 IO 复用, 复用为 GPIO1_IO03 */</span></span><br><span class="line"> SW_MUX_GPIO1_IO03 = <span class="number">0x5</span>;  </span><br><span class="line"> <span class="comment">/* 2、配置 GPIO1_IO03 的 IO 属性 </span></span><br><span class="line"><span class="comment">bit 16:0 HYS 关闭</span></span><br><span class="line"><span class="comment">bit [15:14]: 00 默认下拉</span></span><br><span class="line"><span class="comment"> bit [13]: 0 kepper 功能</span></span><br><span class="line"><span class="comment"> bit [12]: 1 pull/keeper 使能</span></span><br><span class="line"><span class="comment"> bit [11]: 0 关闭开路输出</span></span><br><span class="line"><span class="comment"> bit [7:6]: 10 速度 100Mhz</span></span><br><span class="line"><span class="comment"> bit [5:3]: 110 R0/6 驱动能力</span></span><br><span class="line"><span class="comment"> bit [0]: 0 低转换率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SW_PAD_GPIO1_IO03 = <span class="number">0X10B0</span>; </span><br><span class="line"> <span class="comment">/* 3、初始化 GPIO, GPIO1_IO03 设置为输出 */</span></span><br><span class="line">GPIO1_GDIR = <span class="number">0X0000008</span>;</span><br><span class="line"> <span class="comment">/* 4、设置 GPIO1_IO03 输出低电平，打开 LED0 */</span></span><br><span class="line">GPIO1_DR = <span class="number">0X0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   打开 LED 灯</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">led_on</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将 GPIO1_DR 的 bit3 清零 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> GPIO1_DR &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : 关闭 LED 灯</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">led_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * 将 GPIO1_DR 的 bit3 置 1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> GPIO1_DR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * @description : 短时间延时函数</span></span><br><span class="line"><span class="comment">   * @param - n : 要延时循环次数(空操作循环次数，模式延时)</span></span><br><span class="line"><span class="comment">   * @return : 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_short</span><span class="params">(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span>(n--)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : 延时函数,在 396Mhz 的主频下延时时间大约为 1ms</span></span><br><span class="line"><span class="comment"> * @param - n : 要延时的 ms 数</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"> delay_short(<span class="number">0x7ff</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> clk_enable(); <span class="comment">/* 使能所有的时钟 */</span></span><br><span class="line"> led_init(); <span class="comment">/* 初始化 led */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">/* 死循环 */</span></span><br><span class="line">&#123; </span><br><span class="line"> led_off(); <span class="comment">/* 关闭 LED */</span></span><br><span class="line"> delay(<span class="number">500</span>); <span class="comment">/* 延时大约 500ms */</span></span><br><span class="line">led_on(); <span class="comment">/* 打开 LED */</span></span><br><span class="line"> delay(<span class="number">500</span>); <span class="comment">/* 延时大约 500ms */</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就编写Makefile文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">objects: start.o led.o</span></span><br><span class="line"><span class="section">ledc.bin:<span class="variable">$(objects)</span></span></span><br><span class="line">arm-linux-gnuebihf-ld -Ttext 0X8780000 -o ledc.elf start.o led.o</span><br><span class="line">arm-linux-gnuebihf-objcopy -O binary -S ledc.edf ledc.bin</span><br><span class="line">arm-linux-gnueabihf-objdump -D -m arm ledc.elf &gt; ledc.dis</span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.s</span></span><br><span class="line">arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">%.o:%.S</span></span><br><span class="line">arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm-rf *.o ledc.bin ledc.elf ledc.dis</span><br></pre></td></tr></table></figure><p>第一行定义变量，第二行默认目标目的是生成start.o 和led.o，之后是使用arm-linux-gnueabihf-ld进行链接，链接地址是0X87800000,之后是编译为ledc.bin文件，在之后是反汇编，第七行是针对不同文件生成对应的.o文件，用到了自动变量$@和$&lt;,其中“$&lt;”的意思是依赖目标集合的第一个文件</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230206_230300.png"></p><h4 id="链接脚本编写格式"><a href="#链接脚本编写格式" class="headerlink" title="链接脚本编写格式"></a>链接脚本编写格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 SECTIONS&#123;</span><br><span class="line">2 . = 0X10000000;</span><br><span class="line">3 .text : &#123;*(.text)&#125;</span><br><span class="line">4 . = 0X30000000;</span><br><span class="line">5 .data ALIGN(4) : &#123; *(.data) &#125; </span><br><span class="line">6 .bss ALIGN(4) : &#123; *(.bss) &#125; </span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure><p>第 1 行我们先写了一个关键字“SECTIONS”，后面跟了一个大括号，这个大括号和第 7 行的大括号是一对，这是必须的。看起来就跟 C 语言里面的函数一样。<br>第 2 行对一个特殊符号“.”进行赋值，“.”在链接脚本里面叫做定位计数器，默认的定位计数器为 0。我们要求代码链接到以 0X10000000 为起始地址的地方，因此这一行给“.”赋值0X10000000，表示以 0X10000000 开始，后面的文件或者段都会以 0X10000000 为起始地址开始链接。<br>第 3 行的“.text”是段名，后面的冒号是语法要求，冒号后面的大括号里面可以填上要链接到“.text”这个段里面的所有文件，“*(.text)”中的“*”是通配符，表示所有输入文件的.text段都放到“.text”中。<br>第 4 行，我们的要求是数据放到 0X30000000 开始的地方，所以我们需要重新设置定位计数器“.”，将其改为 0X30000000。如果不重新设置的话会怎么样？假设“.text”段大小为 0X10000，那么接下来的.data 段开始地址就是 0X10000000+0X10000&#x3D;0X10010000，这明显不符合我们的要求。所以我们必须调整定位计数器为 0X30000000。<br>第 5 行跟第 3 行一样，定义了一个名为“.data”的段，然后所有文件的“.data”段都放到这里面。但是这一行多了一个“ALIGN(4)”，这是什么意思呢？这是用来对“.data”这个段的起始地址做字节对齐的，ALIGN(4)表示 4 字节对齐。也就是说段“.data”的起始地址要能被 4 整除，一般常见的都是 ALIGN(4)或者 ALIGN(8)，也就是 4 字节或者 8 字节对齐。<br>第 6 行定义了一个“.bss”段，所有文件中的“.bss”数据都会被放到这个里面，“.bss”数据就是那些定义了但是没有被初始化的变量。上面就是链接脚本最基本的语法格式，我们接下来就按照这个基本的语法格式来编写我们本试验的链接脚本，我们本试验的链接脚本要求如下：<br>①、链接起始地址为 0X87800000。<br>②、start.o 要被链接到最开始的地方，因为 start.o 里面包含这第一个要执行的命令。</p><h5 id="imx6ul-lds-链接脚本代码"><a href="#imx6ul-lds-链接脚本代码" class="headerlink" title="imx6ul.lds 链接脚本代码"></a>imx6ul.lds 链接脚本代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 SECTIONS&#123;</span><br><span class="line">2 . = 0X87800000;</span><br><span class="line">3 .text :</span><br><span class="line">4 &#123;</span><br><span class="line">5 start.o </span><br><span class="line">6led.o </span><br><span class="line">7 *(.text)</span><br><span class="line">8 &#125;</span><br><span class="line">9 .rodata ALIGN(4) : &#123;*(.rodata*)&#125; </span><br><span class="line">10 .data ALIGN(4) : &#123; *(.data) &#125; </span><br><span class="line">11 __bss_start = .; </span><br><span class="line">12 .bss ALIGN(4) : &#123; *(.bss) *(COMMON) &#125; </span><br><span class="line">13 __bss_end = .;</span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><p>第 11、13 这两行其实就是对这两个符号进行赋值，其值为定位符“.”，这两个符号用来保存.bss 段的起始地址和结束地址,前面说了.bss 段是定义了但是没有被初始化的变量，我们需要手动对.bss 段的变量清零的，因此我们需要知道.bss 段的起始和结束地址，这样我们直接对这段内存赋 0 即可完成清零。通过第 11、13 行代码，.bss 段的起始地址和结束地址就保存在了“__bss_start”和“__bss_end”中，我们就可以直接在汇编或者 C 文件里面使用这两个符号。</p><h5 id="修改-Makefile"><a href="#修改-Makefile" class="headerlink" title="修改 Makefile"></a>修改 Makefile</h5><p>已经编写好了链接脚本文件：imx6ul.lds，将 Makefile 中的如下一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf $^</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld -Timx6ul.lds -o ledc.elf $^</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编点亮led</title>
      <link href="/2023/02/05/2023-2-5-%E6%B1%87%E7%BC%96%E7%82%B9%E4%BA%AEled/"/>
      <url>/2023/02/05/2023-2-5-%E6%B1%87%E7%BC%96%E7%82%B9%E4%BA%AEled/</url>
      
        <content type="html"><![CDATA[<p>I.MX6ULL的IO分为SNVS域值和通用的。</p><p>点亮led的GPIO需要以下设置：</p><p>①、使能 GPIO 对应的时钟。<br>②、设置寄存器 IOMUXC_SW_MUX_CTL_PAD_XX_XX，设置 IO 的复用功能，使其复用<br>为 GPIO 功能。<br>③、设置寄存器 IOMUXC_SW_PAD_CTL_PAD_XX_XX，设置 IO 的上下拉、速度等等。<br>④、第②步已经将 IO 复用为了 GPIO 功能，所以需要配置 GPIO，设置输入&#x2F;输出、是否使<br>用中断、默认输出电平等。</p><p>1.首先是定义全局标号_start,代码是从这开始续写。</p><p>2.像stm32一样使能时钟，首先是查询手册查找每一个CCGR的地址并将其进行置1，为点亮led，使GPIO进行复用。查询手册寻找SW_MUX_GPIO_IO103_BASE的地址，并且查看手册MUX_MODE将其设置为GPIO的输出。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230205_220552.png"></p><p>会是ALT5模式置0101来调为GPIO输出，GPIO1_IO00有两个书签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00<span class="comment">//配置复用模式</span></span><br><span class="line">IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO00<span class="comment">//配置电气属性</span></span><br></pre></td></tr></table></figure><p>3.查询IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03的地址根据手册配置电气属性。</p><p>4.之后配置GPIO为输出模式</p><p>5.GPIO1_IO03 已经配置好了，只需要向 GPIO1_DR 寄存器的 bit3 写入 0 即可控制 GPIO1_IO03 输出低电平，打开 LED，向 bit3 写入 1 可控制 GPIO1_IO03 输出高电平，关闭 LED。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">2 .global _start /* 全局标号 */</span><br><span class="line">3 </span><br><span class="line">4 /*</span><br><span class="line">5 * 描述： _start 函数，程序从此函数开始执行此函数完成时钟使能、</span><br><span class="line">6 * GPIO 初始化、最终控制 GPIO 输出低电平来点亮 LED 灯。</span><br><span class="line">7 */</span><br><span class="line">8 _start:</span><br><span class="line">9 /* 例程代码 */</span><br><span class="line">10 /* 1、使能所有时钟 */</span><br><span class="line">11 ldr r0, =0X020C4068 /* 寄存器 CCGR0 */</span><br><span class="line">12 ldr r1, =0XFFFFFFFF </span><br><span class="line">13 str r1, [r0] </span><br><span class="line">14 </span><br><span class="line">15 ldr r0, =0X020C406C /* 寄存器 CCGR1 */</span><br><span class="line">16 str r1, [r0]</span><br><span class="line">17</span><br><span class="line">18 ldr r0, =0X020C4070 /* 寄存器 CCGR2 */</span><br><span class="line">19 str r1, [r0]</span><br><span class="line">20 </span><br><span class="line">21 ldr r0, =0X020C4074 /* 寄存器 CCGR3 */</span><br><span class="line">22 str r1, [r0]</span><br><span class="line">23 </span><br><span class="line">24 ldr r0, =0X020C4078 /* 寄存器 CCGR4 */</span><br><span class="line">25 str r1, [r0]</span><br><span class="line">26 </span><br><span class="line">27 ldr r0, =0X020C407C /* 寄存器 CCGR5 */</span><br><span class="line">28 str r1, [r0]</span><br><span class="line">29 </span><br><span class="line">30 ldr r0, =0X020C4080 /* 寄存器 CCGR6 */</span><br><span class="line">31 str r1, [r0]</span><br><span class="line">32 </span><br><span class="line">33</span><br><span class="line">34 /* 2、设置 GPIO1_IO03 复用为 GPIO1_IO03 */</span><br><span class="line">35 ldr r0, =0X020E0068 /* 将寄存器 SW_MUX_GPIO1_IO03_BASE 加载到 r0 中 */</span><br><span class="line">36 ldr r1, =0X5 /* 设置寄存器 SW_MUX_GPIO1_IO03_BASE 的 MUX_MODE 为 5 */</span><br><span class="line">37 str r1,[r0]</span><br><span class="line">38</span><br><span class="line">39 /* 3、配置 GPIO1_IO03 的 IO 属性 </span><br><span class="line">40 *bit 16:0 HYS 关闭</span><br><span class="line">41 *bit [15:14]: 00 默认下拉</span><br><span class="line">42 *bit [13]: 0 kepper 功能</span><br><span class="line">43 *bit [12]: 1 pull/keeper 使能</span><br><span class="line">44 *bit [11]: 0 关闭开路输出</span><br><span class="line">45 *bit [7:6]: 10 速度 100Mhz</span><br><span class="line">46 *bit [5:3]: 110 R0/6 驱动能力</span><br><span class="line">47 *bit [0]: 0 低转换率</span><br><span class="line">48 */</span><br><span class="line">49 ldr r0, =0X020E02F4 /*寄存器 SW_PAD_GPIO1_IO03_BASE */</span><br><span class="line">50 ldr r1, =0X10B0/*把IO属性按照位来转换成16进制之后置位*/</span><br><span class="line">51 str r1,[r0]</span><br><span class="line">52</span><br><span class="line">53 /* 4、设置 GPIO1_IO03 为输出 */</span><br><span class="line">54 ldr r0, =0X0209C004 /*寄存器 GPIO1_GDIR */</span><br><span class="line">55 ldr r1, =0X0000008 </span><br><span class="line">56 str r1,[r0]</span><br><span class="line">57</span><br><span class="line">58 /* 5、打开 LED0</span><br><span class="line">59 * 设置 GPIO1_IO03 输出低电平</span><br><span class="line">60 */</span><br><span class="line">61 ldr r0, =0X0209C000 /*寄存器 GPIO1_DR */</span><br><span class="line">62 ldr r1, =0 </span><br><span class="line">63 str r1,[r0]</span><br><span class="line">64</span><br><span class="line">65 /*</span><br><span class="line">66 * 描述： loop 死循环</span><br><span class="line">67 */</span><br><span class="line">68 loop:</span><br><span class="line">69 b loop</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arm汇编</title>
      <link href="/2023/02/04/2023-2-4-arm%E6%B1%87%E7%BC%96/"/>
      <url>/2023/02/04/2023-2-4-arm%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="GNU-汇编语法"><a href="#GNU-汇编语法" class="headerlink" title="GNU 汇编语法"></a>GNU 汇编语法</h1><p>GNU汇编语法适用于所有架构，每条语句有三个可选部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label：instruction @ comment</span><br></pre></td></tr></table></figure><p>label 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。<br>instruction 即指令，也就是汇编指令或伪指令。<br>@符号，表示后面的是注释。<br>comment 就是注释内容。</p><p><strong>注意！ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。</strong></p><p>用户可以使用.section 伪操作来定义一个段，汇编系统预定义了一些段名：<br>.text 表示代码段。<br>.data 初始化的数据段。<br>.bss 未初始化的数据段。<br>.rodata 只读数据段。</p><p>常见的伪操作有：<br>.byte 定义单字节数据，比如.byte 0x12。<br>.short 定义双字节数据，比如.short 0x1234。<br>.long 定义一个 4 字节数据，比如.long 0x12345678。<br>.equ 赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示 num&#x3D;0x12。<br>.align 数据字节对齐，比如：.align 4 表示 4 字节对齐。<br>.end 表示源文件结束。<br>.global 定义一个全局符号，格式为：.global symbol，比如：.global _start。</p><h3 id="内部传输指令"><a href="#内部传输指令" class="headerlink" title="内部传输指令"></a>内部传输指令</h3><p><strong>MOV指令</strong></p><p>MOV 指令用于将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0，R1 @将寄存器 R1 中的数据传递给 R0，即 R0=R1</span><br><span class="line">MOV R0, #0X12 @将立即数 0X12 传递给 R0 寄存器，即 R0=0X12</span><br></pre></td></tr></table></figure><p><strong>MRS指令</strong></p><p>MRS 指令用于将特殊寄存器(如 CPSR 和 SPSR)中的数据传递给通用寄存器，要读取特殊寄存器的数据只能使MRS </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRS R0, CPSR @将特殊寄存器 CPSR 里面的数据传递给 R0，即 R0=CPSR</span><br></pre></td></tr></table></figure><p><strong>MSR指令</strong></p><p>MSR 指令用来将普通寄存器的数据传递给特殊寄存器，写特殊寄存器只能使用MSR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSR CPSR, R0 @将 R0 中的数据复制到 CPSR 中，即 CPSR=R0</span><br></pre></td></tr></table></figure><p><strong>存储器访问指令</strong></p><p>ARM 不能直接访问存储器，一般先将要配置的值写入到 Rx(x&#x3D;0~12)寄存器中，然后借助存储器访问指令将 Rx 中的数据写入到 I.MX6UL 寄存器中。常用的存储器访问指令有两种：LDR 和STR。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/capture_20230204195445731.bmp"></p><p>LDR 主要用于从存储加载数据到寄存器 Rx 中，LDR 也可以将一个立即数加载到寄存器 Rx中，LDR 加载立即数的时候要使用“&#x3D;”，而不是“#”。在嵌入式开发中，LDR 最常用的就是读取 CPU 的寄存器值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</span><br><span class="line">2 LDR R1, [R0] @读取地址 0X0209C004 中的数据到 R1 寄存器中</span><br></pre></td></tr></table></figure><p>STR 就是将数据写入到存储器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</span><br><span class="line">2 LDR R1, =0X20000002 @R1 保存要写入到寄存器的值，即 R1=0X20000002</span><br><span class="line">3 STR R1, [R0] @将 R1 中的值写入到 R0 中所保存的地址中</span><br></pre></td></tr></table></figure><p>LDR 和 STR 都是按照字进行读取和写入的（操作的 32 位数据），如果要按照字节、半字进行操作的话可以在指令“LDR”后面加上 B 或 H，比如按字节操作的指令就是 LDRB 和STRB，按半字操作的指令就是 LDRH 和 STRH。</p><p><strong>压栈和出栈命令</strong></p><p>我们通常会在 A 函数中调用 B 函数，当 B 函数执行完以后再回到 A 函数继续执行。要想再跳回 A 函数以后代码能够接着正常运行，那就必须在跳到 B 函数之前将当前处理器状态保存起来(就是保存 R0<del>R15 这些寄存器值)，当 B 函数执行完成以后再用前面保存的寄存器值恢复R0</del>R15 即可。保存 R0<del>R15 寄存器的操作就叫做<u>现场保护</u>，恢复 R0</del>R15 寄存器的操作就叫做<u>恢复现场</u>。<strong>在进行现场保护的时候需要进行压栈(入栈)操作，恢复现场就要进行出栈操作。</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230204_200747.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUSH &#123;R0~R3, R12&#125; @将 R0~R3 和 R12 压栈</span><br><span class="line">PUSH &#123;LR&#125; @将 LR 进行压栈</span><br><span class="line">POP &#123;LR&#125; @先恢复 LR</span><br><span class="line">POP &#123;R0~R3,R12&#125; @在恢复 R0~R3,R12</span><br></pre></td></tr></table></figure><p>PUSH 和 POP 的另外一种写法是“STMFD SP！”和“LDMFD SP!”.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 STMFD SP!,&#123;R0~R3, R12&#125; @R0~R3,R12 入栈</span><br><span class="line">2 STMFD SP!,&#123;LR&#125; @LR 入栈</span><br><span class="line">4 LDMFD SP!, &#123;LR&#125; @先恢复 LR</span><br><span class="line">5 LDMFD SP!, &#123;R0~R3, R12&#125; @再恢复 R0~R3, R12</span><br></pre></td></tr></table></figure><p>SP 指向最后一个入栈的数值，堆栈是由高地址向下增长的，也就是前面说的向下增长的堆栈。</p><p><strong>跳转指令</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230204_202454.png"></p><p><strong>B指令</strong></p><p>B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指令，ARM 处理器就会立即跳转到指定的目标地址。如果要调用的函数不会再返回到原来的执行处，那就可以用 B 指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 _start:</span><br><span class="line">2</span><br><span class="line">3 ldr sp,=0X80200000 @设置栈指针</span><br><span class="line">4 b main @跳转到 main 函数</span><br></pre></td></tr></table></figure><p>上述代码就是典型的在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行，只是初始化了 SP 指针，有些处理器还需要做其他的初始化，</p><p><strong>BL指令</strong></p><p>BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。比如 Cortex-A 处理器的 irq 中断服务函数都是汇编写的，主要用汇编来实现现场的保护和恢复、获取中断号等。但是具体的中断处理过程都是 C 函数，所以就会存在汇编中调用 C 函数的问题。而且当 C 语言版本的中断处理函数执行完成以后是需要返回到irq 汇编中断服务函数，因为还要处理其他的工作，一般是恢复现场。这个时候就不能直接使用B 指令了，因为 B 指令一旦跳转就再也不会回来了，这个时候要使用 BL 指令，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 push &#123;r0, r1&#125; @保存 r0,r1</span><br><span class="line">2 cps #0x13 @进入 SVC 模式，允许其他中断再次进去</span><br><span class="line">3</span><br><span class="line">5 bl system_irqhandler @加载 C 语言中断处理函数到 r2 寄存器中</span><br><span class="line">6</span><br><span class="line">7 cps #0x12 @进入 IRQ 模式</span><br><span class="line">8 pop &#123;r0, r1&#125; </span><br><span class="line">9 str r0, [r1, #0X10] @中断执行完成，写 EOIR</span><br></pre></td></tr></table></figure><p><strong>算数指令</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230204_223246.png"></p><p><strong>逻辑运算指令</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230204_223427.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2023/01/20/2023-1-20-%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/01/20/2023-1-20-%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>线程是参与系统调度的最小单位。它被包含在进程之中，是进程中的实际运行单位。一个线程指的是进程中一个单一顺序的控制流（或者说是执行路线、执行流），一个进程中可以创建多个线程，多个线程实现并发运行，每个线程执行不同的任务。</strong></p><p>任何一个进程都包含一个主线程，只有主线程的进程称为单线程进程.</p><p>那自然就存在多线程进程，所谓多线程指的是除了主线程以外，还包含其它的线程，其它线程通常由主线程来创建（调用pthread_create 创建一个新的线程），那么创建的新线程就是主线程的子线程。</p><p>主线程的重要性体现在两方面：<br>⚫ 其它新的线程（也就是子线程）是由主线程创建的；<br>⚫ 主线程通常会在最后结束运行，执行各种清理工作，譬如回收各个子线程。</p><p>线程是程序最基本的运行单位，而进程不能运行，真正运行的是进程中的线程。同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack，我们称为线程栈），自己的寄存器环境（register context）、自己的线程本地存储（thread-local storage）。</p><p><strong>多进程编程的劣势：</strong><br>⚫ 进程间切换开销大。多个进程同时运行（指宏观上同时运行，无特别说明，均指宏观上），微观上依然是轮流切换运行，进程间切换开销远大于同一进程的多个线程间切换的开销，通常对于一些中小型应用程序来说不划算。<br>⚫ 进程间通信较为麻烦。每个进程都在各自的地址空间中、相互独立、隔离，处在于不同的地址空间中，因此相互通信较为麻烦，在上一章节给大家有所介绍。<br>解决方案便是使用多线程编程，多线程能够弥补上面的问题：<br>⚫ 同一进程的多个线程间切换开销比较小。<br>⚫ 同一进程的多个线程间通信容易。它们共享了进程的地址空间，所以它们都是在同一个地址空间中，通信容易。<br>⚫ 线程创建的速度远大于进程创建的速度。<br>⚫ 多线程在多核处理器上更有优势！</p><blockquote><p>并行：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。<br>并发：当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。</p></blockquote><p>内核实现了调度算法，用于控制系统中所有线程的调度，简单点来说，系统中所有参与调度的线程会加入到系统的调度队列中，它们由内核控制，每一个线程执行一段时间后，由系统调度切换执行调度队列中下一个线程，依次进行。</p><p>就像每个进程都有一个进程 ID 一样，每个线程也有其对应的标识，称为线程 ID。进程 ID 在整个系统中是唯一的。一个线程可通过库函数 pthread_self()来获取自己的线程 ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure><p>如果两个线程 ID t1 和 t2 相等，则 pthread_equal()返回一个非零值；否则返回 0。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>主线程可以使用库函数 pthread_create()负责创建一个新的线程，创建出来的新线程被称为主线程的子线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><p>thread：pthread_t 类型指针，当 pthread_create()成功返回时，新创建的线程的线程 ID 会保存在参数 thread所指向的内存中，后续的线程相关函数会使用该标识来引用此线程。<br>attr：pthread_attr_t 类型指针，指向 pthread_attr_t 类型的缓冲区，pthread_attr_t 数据类型定义了线程的各种属性，如果将参数 attr 设置为 NULL，那么表示将线程的所有属性设置为默认值，以此创建新线程。<br>start_routine：参数 start_routine 是一个函数指针，指向一个函数，新创建的线程从 start_routine()函数开始运行，该函数返回值类型为void *，并且该函数的参数只有一个void *，其实这个参数就是pthread_create()函数的第四个参数 arg。如果需要向 start_routine()传递的参数有一个以上，那么需要把这些参数放到一个结构体中，然后把这个结构体对象的地址作为 arg 参数传入。<br>arg：传递给 start_routine()函数的参数。一般情况下，需要将 arg 指向一个全局或堆变量，意思就是说在线程的生命周期中，该 arg 指向的对象必须存在，否则如果线程中访问了该对象将会出现错误。当然也可将参数 arg 设置为 NULL，表示不需要传入参数给 start_routine()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">new_thread_start</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程: 进程 ID&lt;%d&gt; 线程 ID&lt;%lu&gt;\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"> <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pthread_t</span> tid;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;主线程: 进程 ID&lt;%d&gt; 线程 ID&lt;%lu&gt;\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>在新线程的启动函数（线程 start 函数）new_thread_start()通过 return 返回之<br>后，意味着该线程已经终止了，除了在线程 start 函数中执行 return 语句终止线程外，终止线程的方式还有<br>多种，可以通过如下方式终止线程的运行：<br>⚫ 线程的 start 函数执行 return 语句并返回指定值，返回值就是线程的退出码；<br>⚫ 线程调用 pthread_exit()函数；<br>⚫ 调用 pthread_cancel()取消线程</p><p>如果进程中的任意线程调用 exit()、_exit()或者_Exit()，那么将会导致整个进程终止，这里需要注意！</p><p>pthread_exit()函数将终止调用它的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><p>参数 retval 的数据类型为 void *，指定了线程的返回值、也就是线程的退出码，该返回值可由另一个线程通过调用 pthread_join()来获取；同理，如果线程是在 start 函数中执行 return 语句终止，那么 return 的返回值也是可以通过 pthread_join()来获取的。<br>参数 retval 所指向的内容不应分配于线程栈中，因为线程终止后，将无法确定线程栈的内容是否有效；出于同样的理由，也不应在线程栈中分配线程 start 函数的返回值。<br>调用 pthread_exit()相当于在线程的 start 函数中执行 return 语句，不同之处在于，可在线程 start 函数所调用的任意函数中调用 pthread_exit()来终止线程。如果主线程调用了 pthread_exit()，那么主线程也会终止，但其它线程依然正常运行，直到进程中的所有线程终止才会使得进程终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">new_thread_start</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程 start\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程 end\n&quot;</span>);</span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pthread_t</span> tid;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;主线程 end\n&quot;</span>);</span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取消线程"><a href="#取消线程" class="headerlink" title="取消线程"></a>取消线程</h3><p>进程中的多个线程会并发执行，每个线程各司其职，直到线程的任务完成之后，该线程中会调用 pthread_exit()退出，或在线程 start 函数执行 return 语句退出。</p><p>在程序设计需求当中，需要向一个线程发送一个请求，要求它立刻退出，我们把这种操作称为取消线程，也就是向指定的线程发送一个请求，要求其立刻终止、退出。譬如，一组线程正在执行一个运算，一旦某个线程检测到错误发生，需要其它线程退出，取消线程这项功能就派上用场了。</p><p>通过调用 pthread_cancel()库函数向一个指定的线程发送取消请求，其函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> ** retval)</span>;</span><br></pre></td></tr></table></figure><p>  thread 参数用于指定接收哪个线程的返回值；retval 参数表示接收到的返回值，如果 thread 线程没有返回值，又或者我们不需要接收 thread 线程的返回值，可以将 retval 参数置为 NULL。</p><p>pthread_join() 函数会一直阻塞调用它的线程，直至目标线程执行结束（接收到目标线程的返回值），阻塞状态才会解除。如果 pthread_join() 函数成功等到了目标线程执行结束（成功获取到目标线程的返回值），返回值为数字 0；反之如果执行失败，函数会根据失败原因返回相应的非零值，每个非零值都对应着不同的宏  。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">new_thread_start</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程--running\n&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> ( ; ; )</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pthread_t</span> tid;</span><br><span class="line"> <span class="type">void</span> *tret;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 创建新线程 */</span></span><br><span class="line"> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="comment">/* 向新线程发送取消请求 */</span></span><br><span class="line"> ret = pthread_cancel(tid);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_cancel error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 等待新线程终止 */</span></span><br><span class="line"> ret = pthread_join(tid, &amp;tret);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程终止, code=%ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消状态以及类型</p><p>当然，线程可以选择不被取消或者控制如何被取消，通过 pthread_setcancelstate()和 pthread_setcanceltype()来设置线程的取消性状态和类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure><p>使用这些函数需要包含头文件，pthread_setcancelstate()函数会将调用线程的取消性状态设置为参数 state 中给定的值，并将线程之前的取消性状态保存在参数 oldstate 指向的缓冲区中，如果对之前的状态不感兴趣，Linux 允许将参数 oldstate 设置为 NULL；pthread_setcancelstate()调用成功将返回 0，失败返回非 0 值的错误码。<br>pthread_setcancelstate()函数执行的设置取消性状态和获取旧状态操作，这两步是一个原子操作。<br>参数 state 必须是以下值之一：<br>⚫ PTHREAD_CANCEL_ENABLE：线程可以取消，这是新创建的线程取消性状态的默认值，所以<br>新建线程以及主线程默认都是可以取消的。<br>⚫ PTHREAD_CANCEL_DISABLE：线程不可被取消，如果此类线程接收到取消请求，则会将请求<br>挂起，直至线程的取消性状态变为 PTHREAD_CANCEL_ENABLE。</p><p><strong>pthread_setcanceltype()函数</strong><br>如果线程的取消性状态为 PTHREAD_CANCEL_ENABLE，那么对取消请求的处理则取决于线程的取消性类型，该类型可以通过调用 pthread_setcanceltype()函数来设置，它的参数 type 指定了需要设置的类型，而线程之前的取消性类型则会保存在参数 oldtype 所指向的缓冲区中，如果对之前的类型不敢兴趣，Linux下允许将参数 oldtype 设置为 NULL。同样 pthread_setcanceltype()函数调用成功将返回 0，失败返回非 0 值的错误码。<br>pthread_setcanceltype()函数执行的设置取消性类型和获取旧类型操作，这两步是一个原子操作。<br>参数 type 必须是以下值之一：<br>⚫ PTHREAD_CANCEL_DEFERRED：取消请求到来时，线程还是继续运行，取消请求被挂起，直到线程到达某个取消点（cancellation point，将在 11.6.3 小节介绍）为止，这是所有新建线程包括主线程默认的取消性类型。<br>⚫ PTHREAD_CANCEL_ASYNCHRONOUS：可能会在任何时间点（也许是立即取消，但不一定）<br>取消线程，当某个线程调用 fork()创建子进程时，子进程会继承调用线程的取消性状态和取消性类型，而当某线程<br>调 用 exec 函 数 时 ， 会 将 新 程 序 主 线 程 的 取 消 性 状 态 和 类 型 重 置 为 默 认 值 ， 也 就 是<br>PTHREAD_CANCEL_ENABLE 和 PTHREAD_CANCEL_DEFERRED。</p><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>默认情况下，当线程终止时，其它线程可以通过调用 pthread_join()获取其返回状态、回收线程资源，有时，程序员并不关系线程的返回状态，只是希望系统在线程终止时能够自动回收线程资源并将其移除。在这种情况下，可以调用 pthread_detach()将指定线程进行分离，也就是分离线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>使用该函数需要包含头文件，参数 thread 指定需要分离的线程，函数 pthread_detach()调用成功将返回 0；失败将返回一个错误码。一个线程既可以将另一个线程分离，同时也可以将自己分离，譬如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(pthread_self());</span><br></pre></td></tr></table></figure><p>一旦线程处于分离状态，就不能再使用 pthread_join()来获取其终止状态，此过程是不可逆的，一旦处于分离状态之后便不能再恢复到之前的状态。处于分离状态的线程，当其终止后，能够自动回收线程资源。</p><h3 id="注册线程清理处理函数"><a href="#注册线程清理处理函数" class="headerlink" title="注册线程清理处理函数"></a>注册线程清理处理函数</h3><p>使用 atexit()函数注册进程终止处理函数，当进程调用 exit()退出时就会执行进程终止处理函数；其实，当线程退出时也可以这样做，当线程终止退出时，去执行这样的处理函数，我们把这个称为线程清理函数（thread cleanup handler）。与进程不同，一个线程可以注册多个清理函数，这些清理函数记录在栈中，每个线程都可以拥有一个清理函数栈，栈是一种先进后出的数据结构，也就是说它们的执行顺序与注册（添加）顺序相反，当执行完所<br>有清理函数后，线程终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;<span class="comment">//添加清理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;<span class="comment">//移除清理函数</span></span><br></pre></td></tr></table></figure><p>当线程执行以下动作时，清理函数栈中的清理函数才会被执行：<br>⚫ 线程调用 pthread_exit()退出时；<br>⚫ 线程响应取消请求时；<br>⚫ 用非 0 参数调用 pthread_cleanup_pop()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;cleanup: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">new_thread_start</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程--start run\n&quot;</span>);</span><br><span class="line"> pthread_cleanup_push(cleanup, <span class="string">&quot;第 1 次调用&quot;</span>);</span><br><span class="line"> pthread_cleanup_push(cleanup, <span class="string">&quot;第 2 次调用&quot;</span>);</span><br><span class="line"> pthread_cleanup_push(cleanup, <span class="string">&quot;第 3 次调用&quot;</span>);</span><br><span class="line"> sleep(<span class="number">2</span>);</span><br><span class="line"> pthread_exit((<span class="type">void</span> *)<span class="number">0</span>); <span class="comment">//线程终止</span></span><br><span class="line"> <span class="comment">/* 为了与 pthread_cleanup_push 配对,不添加程序编译会通不过 */</span></span><br><span class="line"> pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line"> pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">     pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pthread_t</span> tid;</span><br><span class="line"> <span class="type">void</span> *tret;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 创建新线程 */</span></span><br><span class="line"> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 等待新线程终止 */</span></span><br><span class="line"> ret = pthread_join(tid, &amp;tret);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程终止, code=%ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程栈属性"><a href="#线程栈属性" class="headerlink" title="线程栈属性"></a>线程栈属性</h2><p>每个线程都有自己的栈空间，pthread_attr_t 数据结构中定义了栈的起始地址以及栈大小，调用函数pthread_attr_getstack()可以获取这些信息，函数 pthread_attr_setstack()对栈起始地址和栈大小进行设置，其函<br>数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstack</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr, <span class="type">size_t</span> *stacksize)</span>;</span><br></pre></td></tr></table></figure><p>使用这些函数需要包含头文件，函数 pthread_attr_getstack()，参数和返回值含义如下：<br>attr：参数 attr 指向线程属性对象。<br>stackaddr：调用 pthread_attr_getstack()可获取栈起始地址，并将起始地址信息保存在*stackaddr 中；<br>stacksize：调用 pthread_attr_getstack()可获取栈大小，并将栈大小信息保存在参数 stacksize 所指向的内存中；<br>返回值：成功返回 0，失败将返回一个非 0 值的错误码。<br>函数 pthread_attr_setstack()，参数和返回值含义如下：<br>attr：参数 attr 指向线程属性对象。<br>stackaddr：设置栈起始地址为指定值。<br>stacksize：设置栈大小为指定值；<br>返回值：成功返回 0，失败将返回一个非 0 值的错误码。</p><p>如果想单独获取或设置栈大小、栈起始地址，可以使用下面这些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstackaddr</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstackaddr</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">new_thread_start</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pthread_attr_t</span> attr;</span><br><span class="line"> <span class="type">size_t</span> stacksize;</span><br><span class="line"> <span class="type">pthread_t</span> tid;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 对 attr 对象进行初始化 */</span></span><br><span class="line"> pthread_attr_init(&amp;attr);</span><br><span class="line"> <span class="comment">/* 设置栈大小为 4K */</span></span><br><span class="line"> pthread_attr_setstacksize(&amp;attr, <span class="number">4096</span>);</span><br><span class="line"> <span class="comment">/* 创建新线程 */</span></span><br><span class="line"> ret = pthread_create(&amp;tid, &amp;attr, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 等待新线程终止 */</span></span><br><span class="line"> ret = pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 销毁 attr 对象 */</span></span><br><span class="line"> pthread_attr_destroy(&amp;attr);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C issue2</title>
      <link href="/2023/01/13/2022-11-25-C-issue2/"/>
      <url>/2023/01/13/2022-11-25-C-issue2/</url>
      
        <content type="html"><![CDATA[<h3 id="堆栈空间"><a href="#堆栈空间" class="headerlink" title="堆栈空间"></a>堆栈空间</h3><p>C源代码进过预处理、编译、汇编和链接4步生成一个可执行程序。程序在没有运行之前，也就是说程序没有被加载到内存前，可执行程序内部已经分好3段信息，分别是代码区(text)、数据区(data)和未初始化数据区(bss)三个部分。（部分人直接把data和bss合起来叫做全局区或静态区）。<br>运行可执行程序，系统把程序加载到内存，除了根据可执行程序的信息分出代码区、初始化数据区和未初始化数据区之外，还额外增加了栈区和堆区。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20093154.png"></p><p>linux下的内存分配：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20093433.png"></p><h3 id="结构体和结构体指针的内存申请"><a href="#结构体和结构体指针的内存申请" class="headerlink" title="结构体和结构体指针的内存申请"></a>结构体和结构体指针的内存申请</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span><span class="comment">//包含malloc函数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>//<span class="title">typedef</span>可以将<span class="keyword">struct</span> <span class="title">student</span>结构体类型用<span class="title">std</span>替代</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> subject[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;<span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span> student1;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;student1,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">std</span>));<span class="comment">//初始化从student1开始的地址到后面sizeof（std）也就是结构体的字节个空间，这些空间都初始化为0也就是空。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,student1.name);<span class="comment">//如果不用memset初始化内存，用scanf语句输入了student1.name的信息再用printf输出是看不出来的，如果不输入直接输出的话就会乱码（原因也是系统内存没有初始化谁也不知道里面本来存的是什么）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,student1.name);</span><br><span class="line">    <span class="comment">//结构体是直接由栈自动分配指针的所以不需要我们来手动分配和释放内存，而接下来是用结构体指针来申请内存</span></span><br><span class="line">    <span class="built_in">std</span>* student2 = (<span class="built_in">std</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">std</span>));</span><br><span class="line">    <span class="keyword">if</span>(student2 == <span class="literal">NULL</span>)<span class="comment">//如果申请内存失败，malloc会返回一个NULl</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc use failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//申请内存失败，错误退出</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">memset</span> (student2,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">std</span>));<span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,student2-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:%s\n&quot;</span>,student2-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>(student2);<span class="comment">//释放指针指向的堆的内存但是不释放指针本身的内存，指针本身存放在栈区，再程序运行结束后才能自动释放</span></span><br><span class="line">    student2 = <span class="literal">NULL</span>;<span class="comment">//这里就是将指针指向空指针，避免被错误调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件中读取结构体"><a href="#文件中读取结构体" class="headerlink" title="文件中读取结构体"></a>文件中读取结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体, 存储一个字符串和年龄 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要写入文件的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开要写入的文件</span></span><br><span class="line">    FILE *p = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开失败直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将结构体写出到文件中</span></span><br><span class="line">    fwrite(&amp;s1, <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p);</span><br><span class="line">    <span class="comment">// 读取文件中的结构体</span></span><br><span class="line">    <span class="comment">// 存储读取到的结构体数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    FILE *p2 = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果打开失败, 退出</span></span><br><span class="line">    <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从文件中读取结构体信息</span></span><br><span class="line">    fread(&amp;s2, <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p2);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p2);</span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;student : name=%s, age=%d\n&quot;</span>, s2.name, s2.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体, 存储一个字符串和年龄 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要写入文件的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span>[2] =</span> &#123;&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>&#125;, &#123;<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开要写入的文件</span></span><br><span class="line">    FILE *p = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开失败直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结构体写出到文件中</span></span><br><span class="line">    fwrite(s1, <span class="number">2</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p);</span><br><span class="line">    <span class="comment">// 读取文件中的结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储读取到的结构体数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span>[2] =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    FILE *p2 = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果打开失败, 退出</span></span><br><span class="line">    <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取结构体信息</span></span><br><span class="line">    fread(s2, <span class="number">2</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p2);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student : name=%s, age=%d\n&quot;</span>, s2[i].name, s2[i].age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/ybny0421/article/details/123263594?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167220768816800184180646%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167220768816800184180646&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-3-123263594-null-null.142">数据结构对于文件的增删查改</a></p><h3 id="做了一个小系统遇到的问题"><a href="#做了一个小系统遇到的问题" class="headerlink" title="做了一个小系统遇到的问题"></a>做了一个小系统遇到的问题</h3><p><a href="https://gitee.com/hanfengdyh/code/blob/master/%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.c">图书馆管理系统.c (gitee.com)</a></p><p>首先关于清屏linux有三种方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x1b[Hx1b[2J&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;033c&quot;</span>);</span><br></pre></td></tr></table></figure><p>虽然都是清屏但是略有区别，首先是system(“clear”)好处可以替代windows中的system(“clr”)不知道是什么问题调用写的次数多了，会有不执行的情况.之后是printf(“033c”)会清楚掉之前对于终端命令行打印颜色的命令，所以它应该是重置整个终端。</p><p>之后的一些问题基本都是结构体的问题都写在了前面。</p><h3 id="stdout与stdin，stderr的区别"><a href="#stdout与stdin，stderr的区别" class="headerlink" title="stdout与stdin，stderr的区别"></a>stdout与stdin，stderr的区别</h3><p>当一个用户进程被创建的时候，系统会自动为该进程创建三个数据流， 一个程序要运行，需要有输入、输出，如果出错，还要能表现出自身的错误。这是就要从某个地方读入数据、将数据输出到某个地方，这就够成了数据流。</p><p>因此，一个进程初期所拥有的这么三个数据流，就分别是标准输出、标准输入和标准错误，分别用stdout, stdin, stderr来表示。。这3个文件分别为标准输入（stdin）、标准输出（stdout）、标准错误（stderr）。<br>输出重定向是指把命令（或可执行程序）的标准输出或标准错误输出重新定向到指定文件中。这样，该命令的输出就不显示在屏幕上，而是写入到指定文件中。<br>使用 “ &gt; ”符号，将标准输出重定向到文件中。形式为：命令&gt;文件名<br>使用“ &gt;&gt; ”符号，将标准输出结果追加到指定文件后面。形式为：命令&gt;&gt;文件名<br>使用“ 2&gt; ”符号，将标准错误输出重定向到文件中。形式为：命令 2&gt; 文件名<br>使用“ 2&gt;&gt; ”符号，将标准错误输出追加到指定文件后面。形式为：命令 2&gt;&gt;文件名<br>使用“ 2&gt;&amp;1 ”符号或“ &amp;&gt; ”符号，将把标准错误输出stderr重定向到标准输出stdout</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">return0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果World!Hello</span></span><br></pre></td></tr></table></figure><p>原理：在默认情况下，stdout是行缓冲的，他的输出会放在一个buffer里面，只有到换行的时候，才会输出到屏幕。</p><p>而stderr是无缓冲的，会直接输出，举例来说就是printf(stdout, “xxxx”) 和 printf(stdout, “xxxx\n”)，前者会憋住，直到遇到新行才会一起输出。而printf(stderr, “xxxxx”)，不管有么有\n，都输出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/2023/01/07/2023-1-7-%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/01/07/2023-1-7-%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>argc 和 argv 传参是如何实现的呢？</p><p>当在终端执行程序时，命令行参数（command-line argument）由 shell 进程逐一进行解析，shell 进程会将这些参数传递给加载器，加载器加载应用程序时会将其传递给应用程序引导代码，当引导程序调用 main()函数时，在由它最终传递给 main()函数，如此一来，在我们的应用程序当中便可以获取到命令行参数了。</p><p><strong>注册进程终止处理函数atexit()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><p>function：函数指针，指向注册的函数，此函数无需传入参数、无返回值。<br>返回值：成功返回 0；失败返回非 0。</p><p><strong>进程是操作系统对一个正在运行的程序的一种抽象。</strong></p><p><strong><u>进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后它就称为了一个进程，当程序运行结束后也就意味着进程终止，这就是进程的一个生命周期。</u></strong>*</p><p>在应用程序中，可通过系统调用 getpid()来获取本进程的进程号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//获取进程号</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//获取父进程进程号</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid = getpid();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;本进程的 PID 为: %d\n&quot;</span>, pid);</span><br><span class="line">    pid = getppid(); <span class="comment">//获取父进程 pid</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;父进程的 PID 为: %d\n&quot;</span>, pid);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>每一个进程都有一组与其相关的环境变量，这些环境变量以字符串形式存储在一个字符串数组列表中，把这个数组称为环境列表。其中每个字符串都是以“名称&#x3D;值（name&#x3D;value）”形式定义，所以环境变量是“名称-值”的成对集合，譬如在 shell 终端下可以使用 env 命令查看到 shell 进程的所有环境变量。</p><p>事实上，进程的环境变量是从其父进程中继承过来的，譬如在 shell 终端下执行一个应用程序，那么该进程的环境变量就是从其父进程（shell 进程）中继承过来的。新的进程在创建之前，会继承其父进程的环境变量副本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ; <span class="comment">// 申明外部全局变量 environ</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 打印进程的环境变量 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; <span class="literal">NULL</span> != environ[i]; i++)</span><br><span class="line"><span class="built_in">puts</span>(environ[i]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取指定环境变量getenv()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>name：指定获取的环境变量名称。<br>返回值：如果存放该环境变量，则返回该环境变量的值对应字符串的指针；如果不存在该环境变量返回NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *str_val = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> &gt; argc) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: 请传入环境变量名称\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 获取环境变量 */</span></span><br><span class="line"> str_val = getenv(argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">NULL</span> == str_val) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: 不存在[%s]环境变量\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 打印环境变量的值 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;环境变量的值: %s\n&quot;</span>, str_val);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加删除修改环境变量</strong></p><p><strong>putenv函数</strong>用于向进程的环境变量数组中添加一个新的环境变量，或者修改一个已经存在的环境变量的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br></pre></td></tr></table></figure><p>string：参数 string 是一个字符串指针，指向 name&#x3D;value 形式的字符串。<br>返回值：成功返回 0；失败将返回非 0 值，并设置 errno。</p><p>该函数调用成功之后，参数 string 所指向的字符串就成为了进程环境变量的一部分了，换言之，putenv()函数将设定 environ 变量（字符串数组）中的某个元素（字符串指针）指向该 string 字符串，而不是指向它的复制副本，这里需要注意！因此，不能随意修改参数 string 所指向的内容，这将影响进程的环境变量，出于这种原因，参数 string 不应为自动变量（即在栈中分配的字符数组）</p><p><strong>setenv()函数</strong>可以替代 putenv()函数，用于向进程的环境变量列表中添加一个新的环境变量或修改现有环境变量对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>;</span><br></pre></td></tr></table></figure><p>name：需要添加或修改的环境变量名称。<br>value：环境变量的值。<br>overwrite：若参数 name 标识的环境变量已经存在，在参数 overwrite 为 0 的情况下，setenv()函数将不改变现有环境变量的值，也就是说本次调用没有产生任何影响；如果参数 overwrite 的值为非 0，若参数 name标识的环境变量已经存在，则覆盖，不存在则表示添加新的环境变量。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。<br>setenv()函数为形如 name&#x3D;value 的字符串分配一块内存缓冲区，并将参数 name 和参数 value 所指向的字符串复制到此缓冲区中，以此来创建一个新的环境变量，所以，由此可知，setenv()与 putenv()函数有两个区别：</p><p>⚫ putenv()函数并不会为 name&#x3D;value 字符串分配内存；<br>⚫ setenv()可通过参数overwrite控制是否需要修改现有变量的值而仅以添加变量为目的，显然putenv()并不能进行控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">3</span> &gt; argc) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: 传入 name value\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/* 添加环境变量 */</span></span><br><span class="line"> <span class="keyword">if</span> (setenv(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="number">0</span>)) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;setenv error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unsetenv()函数<br>unsetenv()函数可以从环境变量表中移除参数 name 标识的环境变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p><strong>清空环境变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clearenv</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>clearenv()函数内部的做法其实就是将environ赋值为NULL。在某些情况下，使用setenv()函数和clearenv()函数可能会导致程序内存泄漏，前面提到过，setenv()函数会为环境变量分配一块内存缓冲区，随之称为进程的一部分；而调用 clearenv()函数时没有释放该缓冲区（clearenv()调用并不知晓该缓冲区的存在，故而也无法将其释放），反复调用者两个函数的程序，会不断产生内存泄漏。</p><h3 id="进程的内存布局"><a href="#进程的内存布局" class="headerlink" title="进程的内存布局"></a>进程的内存布局</h3><p>⚫ 正文段。也可称为代码段，这是 CPU 执行的机器语言指令部分，文本段具有只读属性，以防止程序由于意外而修改其指令；正文段是可以共享的，即使在多个进程间也可同时运行同一段程序。<br>⚫ 初始化数据段。通常将此段称为数据段，包含了显式初始化的全局变量和静态变量，当程序加载到内存中时，从可执行文件中读取这些变量的值。<br>⚫ 未初始化数据段。包含了未进行显式初始化的全局变量和静态变量，通常将此段称为 bss 段，这一名词来源于早期汇编程序中的一个操作符，意思是“由符号开始的块”（block started by symbol），在程序开始执行之前，系统会将本段内所有内存初始化为 0，可执行文件并没有为 bss 段变量分配存储空间，在可执行文件中只需记录 bss 段的位置及其所需大小，直到程序运行时，由加载器来分配这一段内存空间。<br>⚫ 栈。函数内的局部变量以及每次函数调用时所需保存的信息都放在此段中，每次调用函数时，函数传递的实参以及函数返回值等也都存放在栈中。栈是一个动态增长和收缩的段，由栈帧组成，系统会为每个当前调用的函数分配一个栈帧，栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。<br>⚫ 堆。可在运行时动态进行内存分配的一块区域，譬如使用 malloc()分配的内存空间，就是从系统堆内存中申请分配的。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230110_200011.png"></p><h3 id="进程的虚拟地址空间"><a href="#进程的虚拟地址空间" class="headerlink" title="进程的虚拟地址空间"></a>进程的虚拟地址空间</h3><p>在 Linux 系统中，采用了<strong>虚拟内存</strong>管理技术，虚拟地址会通过硬件 MMU（内存管理单元）映射到实际的物理地址空间中，建立虚拟地址到物理地址的映射关系后，对虚拟地址的读写操作实际上就是对物理地址的读写操作，MMU 会将物理地址“翻译”为对应的物理地址。</p><p>使得进程的虚拟地址空间和物理地址空间隔离开来，这样做带来了很多的优点：<br>⚫ 进程与进程、进程与内核相互隔离。一个进程不能读取或修改另一个进程或内核的内存数据，这是因为每一个进程的虚拟地址空间映射到了不同的物理地址空间。提高了系统的安全性与稳定性。<br>⚫ 在某些应用场合下，两个或者更多进程能够共享内存。因为每个进程都有自己的映射表，可以让不同进程的虚拟地址空间映射到相同的物理地址空间中。通常，共享内存可用于实现进程间通信。<br>⚫ 便于实现内存保护机制。譬如在多个进程共享内存时，允许每个进程对内存采取不同的保护措施，例如，一个进程可能以只读方式访问内存，而另一进程则能够以可读可写的方式访问。<br>⚫ 编译应用程序时，无需关心链接地址。前面提到了，当程序运行时，要求链接地址与运行地址一致，在引入了虚拟地址机制后，便无需关心这个问题。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是一个抽象概念，每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20103613.png"></p><h3 id="fork创建子进程"><a href="#fork创建子进程" class="headerlink" title="fork创建子进程"></a>fork创建子进程</h3><p>一个现有的进程可以调用 fork()函数创建一个新的进程，调用 fork()函数的进程称为父进程，由 fork()函数创建出来的进程被称为子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>在诸多的应用中，创建多个进程是任务分解时行之有效的方法，譬如，某一网络服务器进程可在监听客户端请求的同时，为处理每一个请求事件而创建一个新的子进程，与此同时，服务器进程会继续监听更多的客户端连接请求。在一个大型的应用程序任务中，创建子进程通常会简化应用程序的设计，同时提高了系统的并发性。</p><p><u>在程序代码中，可通过返回值来区分是子进程还是父进程。</u>fork()调用成功后，将会在父进程中返回子进程的 PID，而在子进程中返回值是 0；如果调用失败，父进程返回值-1，不创建子进程，并设置 errno。</p><p>ork()调用成功后，子进程和父进程会继续执行 fork()调用之后的指令，子进程、父进程各自在自己的进程空间中运行。事实上，子进程是父进程的一个副本，譬如子进程拷贝了父进程的数据段、堆、栈以及继承了父进程打开的文件描述符，父进程与子进程并不共享这些存储空间，这是子进程对父进程相应部分存储空间的完全复制，执行 fork()之后，每个进程均可修改各自的栈数据以及堆段中的变量，而并不影响另一个进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"> <span class="keyword">switch</span> (pid) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">-1</span>:perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;这是子进程打印信息&lt;pid: %d, 父进程 pid: %d&gt;\n&quot;</span>,getpid(), getppid());</span><br><span class="line"> _exit(<span class="number">0</span>); <span class="comment">//子进程使用_exit()退出</span></span><br><span class="line"> <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;这是父进程打印信息&lt;pid: %d, 子进程 pid: %d&gt;\n&quot;</span>,getpid(), pid);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>子进程被创建出来之后，便是一个独立的进程，拥有自己独立的进程空间，系统内唯一的进程号，拥有自己独立的 PCB（进程控制块），子进程会被内核同等调度执行，参与到系统的进程调度中。</u></p><h3 id="父子进程间的文件共享"><a href="#父子进程间的文件共享" class="headerlink" title="父子进程间的文件共享"></a>父子进程间的文件共享</h3><p><strong>调用 fork()函数之后，子进程会获得父进程所有文件描述符的副本，这些副本的创建方式类似于 dup()，这也意味着父、子进程对应的文件描述符均指向相同的文件表。</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230114_190912.png"></p><p>子进程拷贝了父进程的文件描述符表，使得父、子进程中对应的文件描述符指向了相同的文件表，也意味着父、子进程中对应的文件描述符指向了磁盘中相同的文件，因而这些文件在父、子进程间实现了共享.</p><p>fork()函数有以下两种用法：<br>⚫ 父进程希望子进程复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的，父进程等待客户端的服务请求，当接收到客户端发送的请求事件后，调用 fork()创建一个子进程，使子进程去处理此请求、而父进程可以继续等待下一个服务请求。<br>⚫ 一个进程要执行不同的程序。譬如在程序 app1 中调用 fork()函数创建了子进程，此时子进程是要去执行另一个程序 app2，也就是子进程需要执行的代码是 app2 程序对应的代码，子进程将从 app2程序的 main 函数开始运行。这种情况，通常在子进程从 fork()函数返回之后立即调用 exec 族函数来实现。</p><h3 id="fork-之后的竞争条件"><a href="#fork-之后的竞争条件" class="headerlink" title="fork()之后的竞争条件"></a>fork()之后的竞争条件</h3><p>调用 fork 之后，无法确定父、子两个进程谁将率先访问 CPU，也就是说无法确认谁先被系统调用运行（在多核处理器中，它们可能会同时各自访问一个 CPU），这将导致谁先运行、谁后运行这个顺序是不确定的。</p><p>为确保使子进程优先于父进程或者父进程优先于子进程，可以用信号阻塞来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收到信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">sigset_t</span> wait_mask;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;wait_mask);</span><br><span class="line">    </span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sigaction(SIGUSR1, &amp;sig, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">switch</span>(fork())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程开始执行\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程打印信息\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;~~~~~~~~~~~~~~~\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">2</span>);</span><br><span class="line">            kill(getppid(), SIGUSR1);</span><br><span class="line">            _exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(sigsuspend(&amp;wait_mask) != <span class="number">-1</span>)<span class="comment">//挂起阻塞</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程执行\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程打印信息\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程先运行打印相应信息，之后再执行父进程打印信息，在父进程分支中，直接调用了 sigsuspend()使父进程进入挂起状态，由子进程通过 kill 命令发送信号唤醒。</p><h3 id="进程的诞生与终止"><a href="#进程的诞生与终止" class="headerlink" title="进程的诞生与终止"></a>进程的诞生与终止</h3><p><u>init 进程的 PID 总是为 1，它是所有子进程的父进程，一切从 1 开始、一切从 init 进程开始！</u></p><p>进程有两种终止方式：异常终止和正常终止。</p><p>一般使用 exit()库函数而非_exit()系统调用，原因在于 exit()最终也会通过_exit()终止进程，但在此之前，它将会完成一些其它的工作，exit()函数会执行的动作如下：<br>⚫ 如果程序中注册了进程终止处理函数，那么会调用终止处理函数。<br>⚫ 刷新 stdio 流缓冲区。关于 stdio 流缓冲区的问题，稍后编写一个简单地测试程序进行说明；<br>⚫ 执行_exit()系统调用。</p><p>一般推荐的是子进程使用_exit()退出、而父进程则使用 exit()退出。其原因就在于调用 exit()函数终止进程时会刷新进程的 stdio 缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);<span class="comment">//有换行符打印1次没有打印两次</span></span><br><span class="line"> <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"> perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="comment">/* 子进程 */</span></span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="comment">/* 父进程 */</span></span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有换行符通过 fork()创建子进程时会复制这些缓冲区。标准输出设备默认使用的是行缓冲，当检测到换行符\n 时会立即显示函数 printf()输出的字符串；无换行符所以会立即读走缓冲区中的数据并显示，读走之后此时缓冲区就空了，子进程虽然拷贝了父进程的缓冲区，但是空的，虽然父、子进程使用 exit()退出时会刷新各自的缓冲区，但对于空缓冲区自然无数据可读。</p><p>可以采用以下任一方法来避免重复的输出结果：<br>⚫ 对于行缓冲设备，可以加上对应换行符，譬如 printf 打印输出字符串时在字符串后面添加\n 换行符，对于 puts()函数来说，本身会自动添加换行符；<br>⚫ 在调用 fork()之前，使用函数 fflush()来刷新 stdio 缓冲区，当然，作为另一种选择，也可以使用setvbuf()和 setbuf()来关闭 stdio 流的缓冲功能；<br>⚫ 子进程调用_ exit()退出进程不是使用exit()，调用_exit()在退出时便不会刷新 stdio 缓冲区。</p><h3 id="监视子进程"><a href="#监视子进程" class="headerlink" title="监视子进程"></a>监视子进程</h3><p>父进程需要知道子进程于何时被终止，并且需要知道子进程的终止状态信息，是正常终止、还是异常终止亦或者被信号终止等，意味着父进程会对子进程进行监视。</p><p><strong>wait()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure><p>status：参数 status 用于存放子进程终止时的状态信息，参数 status 可以为 NULL，表示不接收子进程终止时的状态信息。<br>返回值：若成功则返回终止的子进程对应的进程号；失败则返回-1。<br>系统调用 wait()将执行如下动作：</p><p>⚫ 调用 wait()函数，如果其所有子进程都还在运行，则 wait()会一直阻塞等待，直到某一个子进程终止；                                                                                                                                                                                    ⚫ 如果进程调用 wait()，但是该进程并没有子进程，也就意味着该进程并没有需要等待的子进程，那么 wait()将返回错误，也就是返回-1、并且会将 errno 设置为 ECHILD。<br>⚫ 如果进程调用 wait()之前，它的子进程当中已经有一个或多个子进程已经终止了，那么调用 wait()也不会塞。wait()函数的作用除了获取子进程的终止状态信息之外，更重要的一点，就是回收子进程的一些资源，俗称为子进程“收尸”，所以在调用 wait()函数之前，已经有子进程终止了，意味着正等待着父进程为其“收尸”，所以调用 wait()将不会阻塞，而是会立即替该子进程“收尸”、处理它的“后事”，然后返回到正常的程序流程中，一次 wait()调用只能处理一次。</p><p>参数 status 不为 NULL 的情况下，则 wait()会将子进程的终止时的状态信息存储在它指向的 int 变量中，可以通过以下宏来检查 status 参数：<br>⚫ WIFEXITED(status)：如果子进程正常终止，则返回 true；<br>⚫ WEXITSTATUS(status)：返回子进程退出状态，是一个数值，其实就是子进程调用_ exit()或 exit()时指定的退出状态；wait()获取得到的 status 参数并不是调用_exit()或 exit()时指定的状态，可通过WEXITSTATUS 宏转换；<br>⚫ WIFSIGNALED(status)：如果子进程被信号终止，则返回 true；<br>⚫ WTERMSIG(status)：返回导致子进程终止的信号编号。如果子进程是被信号所终止，则可以通过此宏获取终止子进程的信号；<br>⚫ WCOREDUMP(status)：如果子进程终止时产生了核心转储文件，则返回 true；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 循环创建 3 个子进程 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"> perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="comment">/* 子进程 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子进程&lt;%d&gt;被创建\n&quot;</span>, getpid());</span><br><span class="line"> sleep(i);</span><br><span class="line"> _exit(i);</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="comment">/* 父进程 */</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;~~~~~~~~~~~~~~\n&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line"> ret = wait(&amp;status);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ECHILD == errno) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;没有需要等待回收的子进程\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;回收子进程&lt;%d&gt;, 终止状态&lt;%d&gt;\n&quot;</span>, ret,WEXITSTATUS(status));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 for 循环创建了 3 个子进程，父进程中循环调用 wait()函数等待回收子进程，并将本次回收的子进程进程号以及终止状态打印出来。</p><p><strong>waitpid()函数</strong></p><p>使用 wait()系统调用存在着一些限制，这些限制包括如下：<br>⚫ 如果父进程创建了多个子进程，使用 wait()将无法等待某个特定的子进程的完成，只能按照顺序等待下一个子进程的终止，一个一个来、谁先终止就先处理谁；<br>⚫ 如果子进程没有终止，正在运行，那么 wait()总是保持阻塞，有时我们希望执行非阻塞等待，是否有子进程终止，通过判断即可得知；<br>⚫ 使用 wait()只能发现那些被终止的子进程，对于子进程因某个信号（譬如 SIGSTOP 信号）而停止（注意，这里停止指的暂停运行），或是已停止的子进程收到 SIGCONT 信号后恢复执行的情况就无能为力了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p>pid：参数 pid 用于表示需要等待的某个具体子进程，关于参数 pid 的取值范围如下：<br>⚫ 如果 pid 大于 0，表示等待进程号为 pid 的子进程；<br>⚫ 如果 pid 等于 0，则等待与调用进程（父进程）同一个进程组的所有子进程；<br>⚫ 如果 pid 小于-1，则会等待进程组标识符与 pid 绝对值相等的所有子进程；<br>⚫ 如果 pid 等于-1，则等待任意子进程。wait(&amp;status)与 waitpid(-1, &amp;status, 0)等价。<br>status：与 wait()函数的 status 参数意义相同。<br>参数 options 是一个位掩码，可以包括 0 个或多个如下标志：<br>⚫ WNOHANG：如果子进程没有发生状态改变（终止、暂停），则立即返回，也就是执行非阻塞等<br>待，可以实现轮训 poll，通过返回值可以判断是否有子进程发生状态改变，若返回值等于 0 表示没<br>有发生改变。<br>⚫ WUNTRACED：除了返回终止的子进程的状态信息外，还返回因信号而停止（暂停运行）的子进<br>程状态信息；<br>⚫ WCONTINUED：返回那些因收到 SIGCONT 信号而恢复运行的子进程的状态信息。</p><p>返回值：返回值与 wait()函数的返回值意义基本相同，在参数 options 包含了 WNOHANG 标志的情况<br>下，返回值会出现 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//waitpid()阻塞方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> status;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 循环创建 3 个子进程 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"> perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="comment">/* 子进程 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;子进程&lt;%d&gt;被创建\n&quot;</span>, getpid());</span><br><span class="line"> sleep(i);</span><br><span class="line"> _exit(i);</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="comment">/* 父进程 */</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;~~~~~~~~~~~~~~\n&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) </span><br><span class="line"> &#123;</span><br><span class="line"> ret = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ECHILD == errno) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;没有需要等待回收的子进程\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;回收子进程&lt;%d&gt;, 终止状态&lt;%d&gt;\n&quot;</span>, ret,WEXITSTATUS(status));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//轮训方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> status;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 循环创建 3 个子进程 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">switch</span> (fork()) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"> perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="comment">/* 子进程 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子进程&lt;%d&gt;被创建\n&quot;</span>, getpid());</span><br><span class="line"> sleep(i);</span><br><span class="line"> _exit(i);</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="comment">/* 父进程 */</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;~~~~~~~~~~~~~~\n&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) </span><br><span class="line"> &#123;</span><br><span class="line"> ret = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; ret) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (ECHILD == errno)</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;回收子进程&lt;%d&gt;, 终止状态&lt;%d&gt;\n&quot;</span>, ret,WEXITSTATUS(status));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>僵尸进程和孤儿进程</p><p>父进程先于子进程结束，也就是意味着，此时子进程变成了一个“孤儿”，我们把这种进程就称为孤儿进程。在 Linux 系统当中，所有的孤儿进程都自动成为 init 进程（进程号为 1）的子进程，换言之，某一子进程的父进程结束后，该子进程调用 getppid()将返回 1，init 进程变成了孤儿进程的“养父”。</p><p>进程结束之后，通常需要其父进程为其“收尸”，回收子进程占用的一些内存资源，父进程通过调用wait()（或其变体 waitpid()、waitid()等）函数回收子进程资源，归还给系统。如果子进程先于父进程结束，此时父进程还未来得及给子进程“收尸”，那么此时子进程就变成了一个僵尸进程。</p><p>SIGCHLD 信号在第八章中给大家介绍过，当发生以下两种情况时，父进程会收到该信号：<br>⚫ 当父进程的某个子进程终止时，父进程会收到 SIGCHLD 信号；<br>⚫ 当父进程的某个子进程因收到信号而停止（暂停运行）或恢复时，内核也可能向父进程发送该信号。<br>子进程的终止属于异步事件，父进程事先是无法预知的，如果父进程有自己需要做的事情，它不能一直wait()阻塞等待子进程终止（或轮训），这样父进程将啥事也做不了，那么有什么办法来解决这样的尴尬情况，当然有办法，那就是通过 SIGCHLD 信号。<br>那既然子进程状态改变时（终止、暂停或恢复），父进程会收到 SIGCHLD 信号，SIGCHLD 信号的系统默认处理方式是将其忽略，所以我们要捕获它、绑定信号处理函数，在信号处理函数中调用 wait()收回子进程，回收完毕之后再回到父进程自己的工作流程中。<br>当调用信号处理函数时，会暂时将引发调用的信号添加到进程的信号掩码中（除非 sigaction()指定SA_NODEFER 标志），这样一来，当 SIGCHLD 信号处理函数正在为一个终止的子进程“收尸”时，如果相继有两个子进程终止，即使产生了两次 SIGCHLD 信号，父进程也只能捕获到一次 SIGCHLD 信号，结果是，父进程的 SIGCHLD 信号处理函数每次只调用一次 wait()，那么就会导致有些僵尸进程成为“漏网之鱼”。<br>解决方案就是：在 SIGCHLD 信号处理函数中循环以非阻塞方式来调用 waitpid()，直至再无其它终止的<br>子进程需要处理为止，所以，通常 SIGCHLD 信号处理函数内部代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>上述代码一直循环下去，直至 waitpid()返回 0，表明再无僵尸进程存在；或者返回-1，表明有错误发生。<br>应在创建任何子进程之前，为 SIGCHLD 信号绑定处理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wait_child</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 替子进程收尸 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;父进程回收子进程\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/* 为 SIGCHLD 信号绑定处理函数 */</span></span><br><span class="line">sigemptyset(sig.sa_mask);</span><br><span class="line">sig.sa_handler = wait_child;</span><br><span class="line">sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGCHLD, &amp;sig, <span class="literal">NULL</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建子进程 */</span></span><br><span class="line"><span class="keyword">switch</span> (fork()) </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">/* 子进程 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子进程&lt;%d&gt;被创建\n&quot;</span>, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子进程结束\n&quot;</span>);</span><br><span class="line">_exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* 父进程 */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行新程序"><a href="#执行新程序" class="headerlink" title="执行新程序"></a>执行新程序</h3><p>系统调用 execve()可以将新程序加载到某一进程的内存空间，通过调用 execve()函数将一个外部的可执行文件加载到进程的内存空间运行，使用新的程序替换旧的程序，而进程的栈、数据、以及堆数据会被新程序的相应部件所替换，然后从新程序的 main()函数开始执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p>filename：参数 filename 指向需要载入当前进程空间的新程序的路径名，既可以是绝对路径、也可以是相对路径。<br>argv：参数 argv 则指定了传递给新程序的命令行参数。是一个字符串数组，该数组对应于 main(int argc, char *argv[])函数的第二个参数 argv，且格式也与之相同，是由字符串指针所组成的数组，以 NULL 结束。argv[0]对应的便是新程序自身路径名。<br>envp：参数 envp 也是一个字符串指针数组，指定了新程序的环境变量列表，参数 envp 其实对应于新程序的 environ 数组，同样也是以 NULL 结束，所指向的字符串格式为 name&#x3D;value。<br>返回值：execve 调用成功将不会返回；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个简单地程序，在测试程序 testApp 当中通过 execve()函数运行另一个新程序 newApp。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> *arg_arr[<span class="number">5</span>];</span><br><span class="line"> <span class="type">char</span> *env_arr[<span class="number">5</span>] = &#123;<span class="string">&quot;NAME=app&quot;</span>, <span class="string">&quot;AGE=25&quot;</span>,</span><br><span class="line"> <span class="string">&quot;SEX=man&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> arg_arr[<span class="number">0</span>] = argv[<span class="number">1</span>];</span><br><span class="line"> arg_arr[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"> arg_arr[<span class="number">2</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"> arg_arr[<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line"> execve(argv[<span class="number">1</span>], arg_arr, env_arr);</span><br><span class="line"> perror(<span class="string">&quot;execve error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将上述程序编译成一个可执行文件 testApp。</span></span><br><span class="line"><span class="comment">//接着编写新程序，在新程序当中打印出环境变量和传参，如下所示：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> **ep = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">int</span> j;</span><br><span class="line"> <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, j, argv[j]);</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;env:&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (ep = environ; *ep != <span class="literal">NULL</span>; ep++)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot; %s\n&quot;</span>, *ep);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exec 族函数包括多个不同的函数，这些函数命名都以 exec 为前缀。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p><strong>system()函数</strong></p><p><u><strong>使用 system()函数可以很方便地在我们的程序当中执行任意 shell 命令。</strong></u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure><p>system()函数其内部的是通过调用 fork()、execl()以及 waitpid()这三个函数来实现它的功能，首先 system()会调用 fork()创建一个子进程来运行 shell（可以把这个子进程成为 shell 进程），并通过 shell 执行参数command 所指定的命令。</p><p>system()的返回值如下：<br>⚫ 当参数 command 为 NULL，如果 shell 可用则返回一个非 0 值，若不可用则返回 0；针对一些非UNIX 系统，该系统上可能是没有 shell 的，这样就会导致 shell 不可能；如果 command 参数不为NULL，则返回值从以下的各种情况所决定。<br>⚫ 如果无法创建子进程或无法获取子进程的终止状态，那么 system()返回-1；<br>⚫ 如果子进程不能执行 shell，则 system()的返回值就好像是子进程通过调用_exit(127)终止了；<br>⚫ 如果所有的系统调用都成功，system()函数会返回执行 command 的 shell 进程的终止状态。</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>Linux 系统下进程通常存在 6 种不同的状态：</p><p>⚫ 就绪态（Ready）：指该进程满足被 CPU 调度的所有条件但此时并没有被调度执行，只要得到 CPU就能够直接运行；意味着该进程已经准备好被 CPU 执行，当一个进程的时间片到达，操作系统调度程序会从就绪态链表中调度一个进程；<br>⚫ 运行态：指该进程当前正在被 CPU 调度运行，处于就绪态的进程得到 CPU 调度就会进入运行态；<br>⚫ 僵尸态：僵尸态进程其实指的就是僵尸进程，指该进程已经结束、但其父进程还未给它“收尸”；<br>⚫ 可中断睡眠状态：可中断睡眠也称为浅度睡眠，表示睡的不够“死”，还可以被唤醒，一般来说可以通过信号来唤醒；<br>⚫ 不可中断睡眠状态：不可中断睡眠称为深度睡眠，深度睡眠无法被信号唤醒，只能等待相应的条件成立才能结束睡眠状态。把浅度睡眠和深度睡眠统称为等待态（或者叫阻塞态），表示进程处于一种等待状态，等待某种条件成立之后便会进入到就绪态；所以，处于等待态的进程是无法参与进程系统调度的。<br>⚫ 暂停态：暂停并不是进程的终止，表示进程暂停运行，一般可通过信号将进程暂停，譬如 SIGSTOP信号；处于暂停态的进程是可以恢复进入到就绪态的，譬如收到 SIGCONT 信号。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230118_205012.png" alt="进程各状态转换"></p><p>关于进程组需要注意以下以下内容：<br>⚫ 每个进程必定属于某一个进程组、且只能属于一个进程组；<br>⚫ 每一个进程组有一个组长进程，组长进程的 ID 就等于进程组 ID；<br>⚫ 在组长进程的 ID 前面加上一个负号即是操作进程组；<br>⚫ 组长进程不能再创建新的进程组；<br>⚫ 只要进程组中还存在一个进程，则该进程组就存在，这与其组长进程是否终止无关；<br>⚫ 一个进程组可以包含一个或多个进程，进程组的生命周期从被创建开始，到其内所有进程终止或离开该进程组；<br>⚫ 默认情况下，新创建的进程会继承父进程的进程组 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;<span class="comment">//获取进程组ID</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//获取进程组ID</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid = getpid();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;进程组 ID&lt;%d&gt;---getpgrp()\n&quot;</span>, getpgrp());</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;进程组 ID&lt;%d&gt;---getpgid(0)\n&quot;</span>, getpgid(<span class="number">0</span>));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;进程组 ID&lt;%d&gt;---getpgid(%d)\n&quot;</span>, getpgid(pid), pid);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//加入一个现有进程或者是创建一个新进程</span></span><br></pre></td></tr></table></figure><p>setpgid()函数将参数 pid 指定的进程的进程组 ID 设置为参数 gpid。如果这两个参数相等（pid&#x3D;&#x3D;gpid），则由 pid 指定的进程变成为进程组的组长进程，创建了一个新的进程；如果参数 pid 等于 0，则使用调用者的进程 ID；另外，如果参数 gpid 等于 0，则创建一个新的进程组，由参数 pid 指定的进程作为进程组组长进程。<br>setpgrp()函数等价于 setpgid(0, 0)。<br>一个进程只能为它自己或它的子进程设置进程组 ID，在它的子进程调用 exec 函数后，它就不能更改该子进程的进程组 ID 了。</p><p>守护进程（Daemon）也称为精灵进程，是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些事情的发生，主要表现为以下两个特点：<br>⚫ 长期运行。守护进程是一种生存期很长的一种进程，它们一般在系统启动时开始运行，除非强行终止，否则直到系统关机都会保持运行。与守护进程相比，普通进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，但守护进程不受用户登录注销的影响，它们将会一直运行着、直到系统关机。<br>⚫ 与控制终端脱离。在 Linux 中，系统与用户交互的界面称为终端，每一个从终端开始运行的进程都会依附于这个终端，这是上一小节给大家介绍的控制终端，也就是会话的控制终端。当控制终端被关闭的时候，该会话就会退出，由控制终端运行的所有进程都会被终止，这使得普通进程都是和运行该进程的终端相绑定的；但守护进程能突破这种限制，它脱离终端并且在后台运行，脱离终端的目的是为了避免进程在运行的过程中的信息在终端显示并且进程也不会被任何终端所产生的信息所打断。</p><p>守护进程 Daemon，通常简称为 d，一般进程名后面带有 d 就表示它是一个守护进程。守护进程与终端无任何关联，用户的登录与注销与守护进程无关、不受其影响，守护进程自成进程组、自成会话，即pid&#x3D;gid&#x3D;sid。通过命令”ps -ajx”查看系统所有的进程。</p><h4 id="编写守护进程的步骤"><a href="#编写守护进程的步骤" class="headerlink" title="编写守护进程的步骤"></a>编写守护进程的步骤</h4><p><strong>1) 创建子进程、终止父进程</strong><br>父进程调用 fork()创建子进程，然后父进程使用 exit()退出，这样做实现了下面几点。第一，如果该守护进程是作为一条简单地 shell 命令启动，那么父进程终止会让 shell 认为这条命令已经执行完毕。第二，虽然子进程继承了父进程的进程组ID，但它有自己独立的进程ID，这保证了子进程不是一个进程组的组长进程，这是下面将要调用 setsid 函数的先决条件！<br><strong>2) 子进程调用 setsid 创建会话</strong><br>这步是关键，在子进程中调用上一小节给大家介绍的 setsid()函数创建新的会话，由于之前子进程并不是进程组的组长进程，所以调用 setsid()会使得子进程创建一个新的会话，子进程成为新会话的首领进程，同样也创建了新的进程组、子进程成为组长进程，此时创建的会话将没有控制终端。所以这里调用 setsid 有三个作用：让子进程摆脱原会话的控制、让子进程摆脱原进程组的控制和让子进程摆脱原控制终端的控制。在调用 fork 函数时，子进程继承了父进程的会话、进程组、控制终端等，虽然父进程退出了，但原先的会话期、进程组、控制终端等并没有改变，因此，那还不是真正意义上使两者独立开来。setsid 函数能够使子进程完全独立出来，从而脱离所有其他进程的控制。<br><strong>3) 将工作目录更改为根目录</strong><br>子进程是继承了父进程的当前工作目录，由于在进程运行中，当前目录所在的文件系统是不能卸载的，这对以后使用会造成很多的麻烦。因此通常的做法是让“&#x2F;”作为守护进程的当前目录，当然也可以指定其它目录来作为守护进程的工作目录。<br><strong>4) 重设文件权限掩码 umask</strong><br>文件权限掩码 umask 用于对新建文件的权限位进行屏蔽。由于使用 fork 函数新建的子进程继承了父进程的文件权限掩码，这就给子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为 0，确保子进程有最大操作权限、这样可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是 umask，通常的使用方法为 umask(0)。<br><strong>5) 关闭不再需要的文件描述符</strong><br>子进程继承了父进程的所有文件描述符，这些被打开的文件可能永远不会被守护进程（此时守护进程指的就是子进程，父进程退出、子进程成为守护进程）读或写，但它们一样消耗系统资源，可能导致所在的文件系统无法卸载，所以必须关闭这些文件，这使得守护进程不再持有从其父进程继承过来的任何文件描述符。<br><strong>6) 将文件描述符号为 0、1、2 定位到&#x2F;dev&#x2F;null</strong><br>将守护进程的标准输入、标准输出以及标准错误重定向到&#x2F;dev&#x2F;null，这使得守护进程的输出无处显示、也无处从交互式用户那里接收输入。<br><strong>7) 其它：忽略 SIGCHLD 信号</strong><br>处理 SIGCHLD 信号不是必须的，但对于某些进程，特别是并发服务器进程往往是特别重要的，服务器进程在接收到客户端请求时会创建子进程去处理该请求，如果子进程结束之后，父进程没有去 wait 回收子进程，则子进程将成为僵尸进程；如果父进程 wait 等待子进程退出，将又会增加父进程的负担、也就是增加服务器的负担，影响服务器进程的并发性能，在 Linux 下，可以将 SIGCHLD 信号的处理方式设置为SIG_IGN，也就是忽略该信号，可让内核将僵尸进程转交给 init 进程去处理，这样既不会产生僵尸进程、又省去了服务器进程回收子进程所占用的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建子进程 */</span></span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; pid) &#123;</span><br><span class="line"> perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt; pid)<span class="comment">//父进程</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//直接退出</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/* 1.创建新的会话、脱离控制终端 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; setsid()) &#123;</span><br><span class="line"> perror(<span class="string">&quot;setsid error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 2.设置当前工作目录为根目录 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; chdir(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 3.重设文件权限掩码 umask */</span></span><br><span class="line"> umask(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">/* 4.关闭所有文件描述符 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sysconf(_SC_OPEN_MAX); i++)</span><br><span class="line"> close(i);</span><br><span class="line"> <span class="comment">/* 5.将文件描述符号为 0、1、2 定位到/dev/null */</span></span><br><span class="line"> open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"> dup(<span class="number">0</span>);</span><br><span class="line"> dup(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">/* 6.忽略 SIGCHLD 信号 */</span></span><br><span class="line"> signal(SIGCHLD, SIG_IGN);</span><br><span class="line"> <span class="comment">/* 正式进入到守护进程 */</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;守护进程运行中......&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>但对于有些程序设计来说，不允许出现这种情况，程序只能被执行一次，只要该程序没有结束，就无法再次运行，我们把这种情况称为单例模式运行。</p><p>首先这是一个非常简单且容易想到的方法：用一个文件的存在与否来做标志，在程序运行正式代码之前，先判断一个特定的文件是否存在，如果存在则表明进程已经运行，此时应该立马退出；如果不存在则表明进程没有运行，然后创建该文件，当程序结束时再删除该文件即可！</p><p>有很大的问题，主要包括如下三个方面：<br>⚫ 程序中使用_exit()退出，那么将无法执行 delete_file()函数，意味着无法删除这个特定的文件；<br>⚫ 程序异常退出。程序异常同样无法执行到进程终止处理函数 delete_file()，同样将导致无法删除这个特定的文件；<br>⚫ 计算机掉电关机。这种情况就更加直接了，计算机可能在程序运行到任意位置时发生掉电关机的情况，这是无法预料的；如果文件没有删除就发生了这种情况，计算机重启之后文件依然存在，导致程序无法执行。</p><p>由此使用文件锁</p><p>同样也需要通过一个特定的文件来实现，当程序启动之后，首先打开该文件，调用 open 时一般使用O_WRONLY | O_CREAT 标志，当文件不存在则创建该文件，然后尝试去获取文件锁，若是成功，则将程序的进程号（PID）写入到该文件中，写入后不要关闭文件或解锁（释放文件锁），保证进程一直持有该文件锁；若是程序获取锁失败，代表程序已经被运行、则退出本次启动。Tips：当程序退出或文件关闭之后，文件锁会自动解锁！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FILE <span class="string">&quot;./testApp.pid&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> str[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="comment">/* 打开 lock 文件，如果文件不存在则创建 */</span></span><br><span class="line"> fd = open(LOCK_FILE, O_WRONLY | O_CREAT, <span class="number">0666</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 以非阻塞方式获取文件锁 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == flock(fd, LOCK_EX | LOCK_NB)) &#123;</span><br><span class="line"> <span class="built_in">fputs</span>(<span class="string">&quot;不能重复执行该程序!\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;程序运行中...&quot;</span>);</span><br><span class="line"> ftruncate(fd, <span class="number">0</span>); <span class="comment">//将文件长度截断为 0</span></span><br><span class="line"> <span class="built_in">sprintf</span>(str, <span class="string">&quot;%d\n&quot;</span>, getpid());</span><br><span class="line">write(fd, str, <span class="built_in">strlen</span>(str));<span class="comment">//写入 pid</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; )</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序启动首先打开一个特定的文件，这里只是举例，以当前目录下的 testApp.pid 文件作为特定文件，以 O_WRONLY | O_CREAT 方式打开，如果文件不存在则创建该文件；打开文件之后使用 flock 尝试获取文件锁，调用 flock()时指定了互斥锁标志 LOCK_NB，意味着同时只能有一个进程拥有该锁，如果获取锁失败，表示该程序已经启动了，无需再次执行，然后退出；如果获取锁成功，将进程的 PID 写入到该文件中，当程序退出时，会自动解锁、关闭文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C错题</title>
      <link href="/2022/12/17/2022-12-17-C%E9%94%99%E9%A2%98/"/>
      <url>/2022/12/17/2022-12-17-C%E9%94%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">sizeof</span>(i++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出等于1</p><p><strong>根据C99规范， sizeof是一个编译时刻就起效果的运算符，在其内的任何运算都没有意义，sizeof(i++); 在编译的时候被翻译成 sizeof((i++的数据类型)) 也就是 sizeof(int); 不会执行i++了 。</strong></p><p>sizeof是操作符</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>下面说法中正确的是（） </p><ul><li><pre><code>若全局变量仅在单个C 文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;<br>设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑变量生命周期问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  静态全局变量使用过多，可那会导致动态存储区(堆栈)溢出</span><br></pre></td></tr></table></figure></li></ul><p>Static 函数在非类中有三个作用： </p><p>  1、用来隐藏，利用这一特性，可以在不同的文件中定义同名变量和同名函数，而不用担心命名冲突，对应A选项； </p><p>  2、默认初始化为0； </p><p>  3、保持局部变量的持久 。所以A选项是对的。B选项毫无关系，C选项中动态全局变量、静态全局变量、静态局部变量生命期都为函数运行期间。 其中静态局部变量的生存周期虽然为整个源程序，但是其作用域任然与局部变量相同，当退出该函数时，该变量还继续存在，但是不能使用它。所以C选项是错的。  D选项中，静态全局变量存储在全局（静态）存储区。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`int` `a = ``248``, b = ``4``;``int` `const` `c = ``21``;``const` `int` `*d = &amp;a; ``int` `*``const` `e = &amp;b;``int` `const` `* ``const` `f = &amp;a; `</span><br></pre></td></tr></table></figure><p>  请问下列表达式哪些会被编译器禁止? </p><ul><li><pre><code>*c=32<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  *d=43</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>e=&amp;a<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  f=0x321f</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;<br>d&#x3D;&amp;b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  *e=34</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221217_210448.png"></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>假设函数原型和变量说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span>(*p)[<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>&#125;，</span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>&#125;，&#123;<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>&#125;，&#123;<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>，<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>下面调用非法的是（b）<br>f3(&amp;a);<br>f3(b[1]);<br>f3(&amp;b[1]);<br>f3(b);</p><p>void f3(<strong>int(*p)[4]</strong>);    其参数是<strong>数组指针</strong> ，指向数组p的指针。</p><ul><li>​    选项A：f3(<strong>&amp;a</strong>);  参数为一个地址，符合指针定义。   </li><li>​    选项B：f3(<strong>b[1]</strong>); 参数为一个数组的具体元素，不符合指针定义。<strong>所以B是非法的调用。</strong>   </li><li>​    选项C：f3(<strong>&amp;b[1]</strong>); 参数为一个数组元素的地址，符合指针定义。   </li><li>​    选项D：f3(<strong>b</strong>);  参数为数组名，表示该数组的首地址，符合指针定义。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号</title>
      <link href="/2022/12/17/2022-12-17-%E4%BF%A1%E5%8F%B7/"/>
      <url>/2022/12/17/2022-12-17-%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>信号是事件发生时对进程的通知机制，也可以把它称为软件中断。信号与硬件中断的相似之处在于能够打断程序当前执行的正常流程，其实是在软件层次上对中断机制的一种模拟。大多数情况下，是无法预测信号达到的准确时间，所以，信号提供了一种处理异步事件的方法。</p><p><strong>产生信号的方式：</strong></p><p>⚫ 硬件发生异常，即硬件检测到错误条件并通知内核，随即再由内核发送相应的信号给相关进程。硬件检测到异常的例子包括执行一条异常的机器语言指令，诸如，除数为 0、数组访问越界导致引用了无法访问的内存区域等，这些异常情况都会被硬件检测到，并通知内核、然后内核为该异常情况发生时正在运行的进程发送适当的信号以通知进程。<br>⚫ 用于在终端下输入了能够产生信号的特殊字符。譬如在终端上按下 CTRL + C 组合按键可以产生中断信号（SIGINT），通过这个方法可以终止在前台运行的进程；按下 CTRL + Z 组合按键可以产生暂停信（SIGCONT），通过这个方法可以暂停当前前台运行的进程。<br>⚫ 进程调用 kill()系统调用可将任意信号发送给另一个进程或进程组。当然对此是有所限制的，接收信号的进程和发送信号的进程的所有者必须相同，亦或者发送信号的进程的所有者是 root 超级用户。<br>⚫ 用户可以通过 kill 命令将信号发送给其它进程。kill 命令想必大家都会使用，通常我们会通过 kill命令来“杀死”（终止）一个进程，譬如在终端下执行”kill -9 xxx”来杀死 PID 为 xxx 的进程。kill命令其内部的实现原理便是通过 kill()系统调用来完成的。<br>⚫ 发生了软件事件，即当检测到某种软件条件已经发生。这里指的不是硬件产生的条件（如除数为 0、引用无法访问的内存区域等），而是软件的触发条件、触发了某种软件条件（进程所设置的定时器已经超时、进程执行的 CPU 时间超限、进程的某个子进程退出等等情况）</p><p><strong><u>通常进程会视具体信号执行以下操作之一：</u></strong><br>⚫ 忽略信号。也就是说，当信号到达进程后，该进程并不会去理会它、直接忽略，就好像是没有出该信号，信号对该进程不会产生任何影响。事实上，大多数信号都可以使用这种方式进行处理，但有两种信号却决不能被忽略，它们是 SIGKILL 和 SIGSTOP，这两种信号不能被忽略的原因是：它们向内核和超级用户提供了使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号，则进程的运行行为是未定义的。<br>⚫ 捕获信号。当信号到达进程后，执行预先绑定好的信号处理函数。为了做到这一点，要通知内核在某种信号发生时，执行用户自定义的处理函数，该处理函数中将会对该信号事件作出相应的处理，Linux 系统提供了 signal()系统调用可用于注册信号的处理函数，将会在后面向大家介绍。<br>⚫ 执行系统默认操作。进程不对该信号事件作出处理，而是交由系统进行处理，每一种信号都会有其对应的系统默认的处理方式，8中对此有进行介绍。需要注意的是，对大多数信号来说，系统默认的处理方式就是终止该进程。</p><p>实时信号与非实时信号其实是从时间关系上进行的分类，与可靠信号与不可靠信号是相互对应的，非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。实时信号保证了发送的多个信号都能被接收，实时信号是 POSIX 标准的一部分，可用于应用进程。</p><p>Linux 下对标准信号（不可靠信号、非实时信号）的编号为 1~31。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221217_122938.png"></p><h3 id="进程对信号的处理"><a href="#进程对信号的处理" class="headerlink" title="进程对信号的处理"></a>进程对信号的处理</h3><p><strong>signal函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sig_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sig_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sig_t</span> handler)</span>;</span><br></pre></td></tr></table></figure><p>signum：此参数指定需要进行设置的信号，可使用信号名（宏）或信号的数字编号，建议使用信号名。<br>handler：sig_t 类型的函数指针，指向信号对应的信号处理函数，当进程接收到信号后会自动执行该处理函数；参数 handler 既可以设置为用户自定义的函数，也就是捕获信号时需要执行的处理函数，也可以设置为 SIG_IGN 或 SIG_DFL，SIG_IGN 表示此进程需要忽略该信号，SIG_DFL 则表示设置为系统默认操作。<br>sig_t 函数指针的 int 类型参数指的是，当前触发该函数的信号，可将多个信号绑定到同一个信号处理函数上，此时就可通过此参数来判断当前触发的是哪个信号。</p><p>返回值：此函数的返回值也是一个 sig_t 类型的函数指针，成功情况下的返回值则是指向在此之前的信号处理函数；如果出错则返回 SIG_ERR，并会设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">sig_t</span> ret = <span class="literal">NULL</span>;</span><br><span class="line"> ret = signal(SIGINT, (<span class="type">sig_t</span>)sig_handler);</span><br><span class="line"> <span class="keyword">if</span> (SIG_ERR == ret) </span><br><span class="line"> &#123;</span><br><span class="line">perror(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 死循环 */</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123; &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sigaction()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><p>signum：需要设置的信号，除了 SIGKILL 信号和 SIGSTOP 信号之外的任何信号。<br>act：act 参数是一个 struct sigaction 类型指针，指向一个 struct sigaction 数据结构，该数据结构描述了信<br>号的处理方式，稍后介绍该数据结构；如果参数 act 不为 NULL，则表示需要为信号设置新的处理方式；如<br>果参数 act 为 NULL，则表示无需改变信号当前的处理方式。<br>oldact：oldact 参数也是一个 struct sigaction 类型指针，指向一个 struct sigaction 数据结构。如果参数<br>oldact 不为 NULL，则会将信号之前的处理方式等信息通过参数 oldact 返回出来；如果无意获取此类信息，<br>那么可将该参数设置为 NULL。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line"> <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line"> <span class="type">sigset_t</span> sa_mask;</span><br><span class="line"> <span class="type">int</span> sa_flags;</span><br><span class="line"> <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> ret = sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 死循环 */</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123; &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向进程发信号"><a href="#向进程发信号" class="headerlink" title="向进程发信号"></a>向进程发信号</h3><p><strong>kill</strong>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>pid：参数 pid 为正数的情况下，用于指定接收此信号的进程 pid；除此之外，参数 pid 也可设置为 0 或-1 以及小于-1 等不同值，稍后给说明。<br>sig：参数 sig 指定需要发送的信号，也可设置为 0，如果参数 sig 设置为 0 则表示不发送信号，但任执行错误检查，这通常可用于检查参数 pid 指定的进程是否存在。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。<br>参数 pid 不同取值含义：<br>⚫ 如果 pid 为正，则信号 sig 将发送到 pid 指定的进程。<br>⚫ 如果 pid 等于 0，则将 sig 发送到当前进程的进程组中的每个进程。<br>⚫ 如果 pid 等于-1，则将 sig 发送到当前进程有权发送信号的每个进程，但进程 1（init）除外。<br>⚫ 如果 pid 小于-1，则将 sig 发送到 ID 为-pid 的进程组中的每个进程。<br>进程中将信号发送给另一个进程是需要权限的，并不是可以随便给任何一个进程发送信号，超级用户root 进程可以将信号发送给任何进程，但对于非超级用户（普通用户）进程来说，其基本规则是发送者进程的实际用户 ID 或有效用户 ID 必须等于接收者进程的实际用户 ID 或有效用户 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> pid;</span><br><span class="line"> <span class="comment">/* 判断传参个数 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 将传入的字符串转为整形数字 */</span></span><br><span class="line"> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\n&quot;</span>, pid);</span><br><span class="line"> <span class="comment">/* 向 pid 指定的进程发送信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == kill(pid, SIGINT)) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;kill error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>raise()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>sig：需要发送的信号。<br>返回值：成功返回 0；失败将返回非零值。<br>raise()其实等价于：kill(getpid(), sig);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> ret = sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">/* 向自身发送 SIGINT 信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> != raise(SIGINT)) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;raise error\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">3</span>); <span class="comment">// 每隔 3 秒发送一次</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>alarm()和 pause()函数</p><p>使用 alarm()函数可以设置一个定时器（闹钟），当定时器定时时间到时，内核会向进程发送 SIGALRM信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p>seconds：设置定时时间，以秒为单位；如果参数 seconds 等于 0，则表示取消之前设置的 alarm 闹钟。<br>返回值：如果在调用 alarm()时，之前已经为该进程设置了 alarm 闹钟还没有超时，则该闹钟的剩余值作为本次 alarm()函数调用的返回值，之前设置的闹钟则被新的替代；否则返回 0。参数 seconds 的值是产生 SIGALRM 信号需要经过的时钟秒数，当这一刻到达时，由内核产生该信号，每个进程只能设置一个 alarm 闹钟；虽然 SIGALRM 信号的系统默认操作是终止进程，但是如果程序当中设置了 alarm 闹钟，但大多数使用闹钟的进程都会捕获此信号。<br>需要注意的是 alarm 闹钟并不能循环触发，只能触发一次，若想要实现循环触发，可以在 SIGALRM 信号处理函数中再次调用 alarm()函数设置定时器。</p><p>pause()系统调用可以使得进程暂停运行、进入休眠状态，直到进程捕获到一个信号为止，只有执行了信<br>号处理函数并从其返回时，pause()才返回，在这种情况下，pause()返回-1，并且将 errno 设置为 EINTR。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Alarm timeout&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> second;</span><br><span class="line"> <span class="comment">/* 检验传参个数 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 为 SIGALRM 信号绑定处理函数 */</span></span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGALRM, &amp;sig, <span class="literal">NULL</span>)) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 启动 alarm 定时器 */</span></span><br><span class="line"> second = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;定时时长: %d 秒\n&quot;</span>, second);</span><br><span class="line"> alarm(second);</span><br><span class="line"> <span class="comment">/* 进入休眠状态 */</span></span><br><span class="line"> pause();</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;休眠结束&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>有一个能表示多个信号（一组信号）的数据类型—信号集（signalset），很多系统调用都使用到了信号集这种数据类型来作为参数传递，譬如 sigaction()函数、sigprocmask()函数、sigpending()函数等。</p><p>信号集其实就是 sigset_t 类型数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __val[_SIGSET_NWORDS];</span><br><span class="line">&#125; <span class="type">sigset_t</span>;</span><br></pre></td></tr></table></figure><p>使用这个结构体可以表示一组信号，将多个信号添加到该数据结构中，当然 Linux 系统了用于操作sigset_t 信号集的 API，譬如 sigemptyset()、sigfillset()、sigaddset()、sigdelset()、sigismember()。</p><h4 id="信号集处理"><a href="#信号集处理" class="headerlink" title="信号集处理"></a>信号集处理</h4><p><strong>初始化sigemptyset()和 sigfillset()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>set：指向需要进行初始化的信号集变量。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigfillset(&amp;sig_set);</span><br></pre></td></tr></table></figure><p><strong>添加和删除信号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;<span class="comment">//set指向信号集，signum需要添加和删除的信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;<span class="comment">//成功返回 0；失败将返回-1，并设置 errno。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line">sigaddset(&amp;sig_set, SIGINT);<span class="comment">//信号集添加信号</span></span><br><span class="line"></span><br><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigfillset(&amp;sig_set);</span><br><span class="line">sigdelset(&amp;sig_set, SIGINT);<span class="comment">//信号集移除信号</span></span><br></pre></td></tr></table></figure><p><strong>测试信号是否在信号集</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">//set：指定信号集。</span></span><br><span class="line"><span class="comment">//signum：需要进行测试的信号。</span></span><br><span class="line"><span class="comment">//返回值：如果信号 signum 在信号集 set 中，则返回 1；如果不在信号集 set 中，则返回 0；失败则返回1，并设置 errno。</span></span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line"><span class="keyword">if</span>(sigismember(&amp;sig_set, SIGINT) == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;信号集中包含SIGINT信号&quot;</span>);</span><br></pre></td></tr></table></figure><p>在 Linux 下，每个信号都有一串与之相对应的字符串描述信息，用于对该信号进行相应的描述。这些字符串位于 sys_siglist 数组中，sys_siglist 数组是一个 char *类型的数组，数组中的每一个元素存放的是一个字符串指针，指向一个信号描述信息。譬如，可以使用 sys_siglist[SIGINT]来获取对 SIGINT 信号的描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 描述信息: %s\n&quot;</span>, sys_siglist[SIGINT]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 描述信息: %s\n&quot;</span>, sys_siglist[SIGQUIT]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;SIGBUS 描述信息: %s\n&quot;</span>, sys_siglist[SIGBUS]);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>psignal()可以在标准错误（stderr）上输出信号描述信息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">psignal</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>信号掩码（阻塞信号传递）</p><p>内核为每一个进程维护了一个信号掩码（其实就是一个信号集），即一组信号。当进程接收到一个属于信号掩码中定义的信号时，该信号将会被阻塞、无法传递给进程进行处理，那么内核会将其阻塞，直到该信号从信号掩码中移除，内核才会把该信号传递给进程从而得到处理。</p><p>信号掩码中添加信号的方法：</p><p>①程序调用signal()或者sigaction函数为某一个信号设置处理方式时，进程会自动将该信号添加到信号掩码中，这样保证了处理一个给定信号时候，再次碰到该信号，会将请其阻塞。</p><p>②使用sigaction()函数为信号设置处理方式时，可以额外指定一组信号，当调用信号处理函数时将该组信号自动添加到信号掩码中，但信号处理函数结束返回后，再将这组信号从信号掩码中移除</p><p>③还可以使用sigprocmask()系统调用，随时可以显式地向信号掩码中添加&#x2F;移除信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure><p>how：参数 how 指定了调用函数时的一些行为。<br>set：将参数 set 指向的信号集内的所有信号添加到信号掩码中或者从信号掩码中移除；如果参数 set 为NULL，则表示无需对当前信号掩码作出改动。<br>oldset：如果参数 oldset 不为 NULL，在向信号掩码中添加新的信号之前，获取到进程当前的信号掩码，存放在 oldset 所指定的信号集中；如果为 NULL 则表示不获取当前的信号掩码。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。<br>参数 how 可以设置为以下宏：<br>⚫ <strong>SIG_BLOCK</strong>：将参数 set 所指向的信号集内的所有信号添加到进程的信号掩码中。换言之，将信号掩码设置为当前值与 set 的并集。<br>⚫ <strong>SIG_UNBLOCK</strong>：将参数 set 指向的信号集内的所有信号从进程信号掩码中移除。<br>⚫ <strong>SIG_SETMASK</strong>：进程信号掩码直接设置为参数 set 指向的信号集。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行信号处理函数\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">sigset_t</span> sig_set;</span><br><span class="line"> <span class="comment">/* 注册信号处理函数 */</span></span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 信号集初始化 */</span></span><br><span class="line"> sigemptyset(&amp;sig_set);</span><br><span class="line"> sigaddset(&amp;sig_set, SIGINT);</span><br><span class="line"> <span class="comment">/* 向信号掩码中添加信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_BLOCK, &amp;sig_set, <span class="literal">NULL</span>))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 向自己发送信号 */</span></span><br><span class="line"> raise(SIGINT);</span><br><span class="line"> <span class="comment">/* 休眠 2 秒 */</span></span><br><span class="line"> sleep(<span class="number">2</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;休眠结束\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 从信号掩码中移除添加的信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_UNBLOCK, &amp;sig_set, <span class="literal">NULL</span>))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞等待信号"><a href="#阻塞等待信号" class="headerlink" title="阻塞等待信号"></a>阻塞等待信号</h3><p>如果希望对一个信号解除阻塞后，然后调用 pause()以等待之前被阻塞的信号的传递，这将如何？譬如有如下代码段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> new_set, old_set;</span><br><span class="line"> <span class="comment">/* 信号集初始化 */</span></span><br><span class="line"> sigemptyset(&amp;new_set);</span><br><span class="line"> sigaddset(&amp;new_set, SIGINT);</span><br><span class="line"> <span class="comment">/* 向信号掩码中添加信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_BLOCK, &amp;new_set, &amp;old_set))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 受保护的关键代码段 */</span></span><br><span class="line"> ......</span><br><span class="line"> <span class="comment">/**********************/</span></span><br><span class="line"> <span class="comment">/* 恢复信号掩码 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_SETMASK, &amp;old_set, <span class="literal">NULL</span>))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> pause();<span class="comment">/* 等待信号唤醒 */</span></span><br></pre></td></tr></table></figure><p>执行受保护的关键代码时不希望被 SIGINT 信号打断，所以在执行关键代码之前将 SIGINT 信号添加到进程的信号掩码中，执行完毕之后再恢复之前的信号掩码。最后调用了 pause()阻塞等待被信号唤醒，如果此时发生了信号则会被唤醒、从 pause 返回继续执行；考虑到这样一种情况，如果信号的传递恰好发生在第二次调用sigprocmask()之后、pause()之前，如果确实发生了这种情况，就会产生一个问题，信号传递过来就会导致执行信号的处理函数，而从处理函数返回后又回到主程序继续执行，从而进入到 pause()被阻塞，知道下一次信号发生时才会被唤醒，这有违代码的本意。</p><p>要避免这个问题，需要将恢复信号掩码和 pause()挂起进程这两个动作封装成一个原子操作，这正是 sigsuspend()系统调用的目的所在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure><p>mask：参数 mask 指向一个信号集。<br>返回值：sigsuspend()始终返回-1，并设置 errno 来指示错误（通常为 EINTR），表示被信号所中断，如果调用失败，将 errno 设置为 EFAULT。</p><p>sigsuspend()函数会将参数 mask 所指向的信号集来替换进程的信号掩码，也就是将进程的信号掩码设置为参数 mask 所指向的信号集，然后挂起进程，直到捕获到信号被唤醒（如果捕获的信号是 mask 信号集中的成员，将不会唤醒、继续挂起）、并从信号处理函数返回，一旦从信号处理函数返回，sigsuspend()会将进程的信号掩码恢复成调用前的值。</p><p>调用 sigsuspend()函数相当于以不可中断（原子操作）的方式执行以下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;old_mask);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;old_mask, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="实时信号"><a href="#实时信号" class="headerlink" title="实时信号"></a>实时信号</h3><p>确定进程中处于等待状态的是哪些信号，用sigpending()函数获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p>set：处于等待状态的信号会存放在参数 set 所指向的信号集中。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p><u>判断 SIGINT 信号当前是否处于等待状态</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义信号集 */</span></span><br><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line"><span class="comment">/* 将信号集初始化为空 */</span></span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line"><span class="comment">/* 获取当前处于等待状态的信号 */</span></span><br><span class="line">sigpending(&amp;sig_set);</span><br><span class="line"><span class="comment">/* 判断 SIGINT 信号是否处于等待状态 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == sigismember(&amp;sig_set, SIGINT))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;SIGINT 信号处于等待状态&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!sigismember(&amp;sig_set, SIGINT))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;SIGINT 信号未处于等待状态&quot;</span>);</span><br></pre></td></tr></table></figure><p>等待信号集只是一个掩码，仅表明一个信号是否发生，而不能表示其发生的次数。换言之，如果一个同一个信号在阻塞状态下产生了多次，那么会将该信号记录在等待信号集中，并在之后仅传递一次（仅当做发生了一次），这是标准信号的缺点之一。</p><p>实时信号较之于标准信号，其优势如下：<br>⚫ 实时信号的信号范围有所扩大，可应用于应用程序自定义的目的，而标准信号仅提供了两个信号可用于应用程序自定义使用：SIGUSR1 和 SIGUSR2。<br>⚫ 内核对于实时信号所采取的是队列化管理。如果将某一实时信号多次发送给另一个进程，那么将会多次传递此信号。相反，对于某一标准信号正在等待某一进程，而此时即使再次向该进程发送此信号，信号也只会传递一次。<br>⚫ 当发送一个实时信号时，可为信号指定伴随数据（一整形数据或者指针值），供接收信号的进程在它的信号处理函数中获取。<br>⚫ 不同实时信号的传递顺序得到保障。如果有多个不同的实时信号处于等待状态，那么将率先传递具有最小编号的信号。换言之，信号的编号越小，其优先级越高，如果是同一类型的多个信号在排队，那么信号（以及伴随数据）的传递顺序与信号发送来时的顺序保持一致。</p><p>应用程序当中使用实时信号，需要有以下的两点要求：<br>⚫ 发送进程使用 sigqueue()系统调用向另一个进程发送实时信号以及伴随数据。<br>⚫ 接收实时信号的进程要为该信号建立一个信号处理函数，使用sigaction函数为信号建立处理函数，并加入 SA_SIGINFO，这样信号处理函数才能够接收到实时信号以及伴随数据，也就是要使用sa_sigaction 指针指向的处理函数，而不是 sa_handler，当然允许应用程序使用 sa_handler，但这样就不能获取到实时信号的伴随数据了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br></pre></td></tr></table></figure><p>pid：指定接收信号的进程对应的 pid，将信号发送给该进程。<br>sig：指定需要发送的信号。与 kill()函数一样，也可将参数 sig 设置为 0，用于检查参数 pid 所指定的进程是否存在。<br>value：参数 value 指定了信号的伴随数据，union sigval 数据类型。</p><p>返回值：成功将返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">sigval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> sival_int;</span><br><span class="line"><span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125; <span class="type">sigval_t</span>;</span><br></pre></td></tr></table></figure><p><strong>异常退出函数abort()</strong></p><p>使用 abort()终止进程运行，会生成核心转储文件，可用于判断程序调用 abort()时的程序状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><u>函数 abort()通常产生 SIGABRT 信号来终止调用该函数的进程，SIGABRT 信号的系统默认操作是终止进程运行、并生成核心转储文件；当调用 abort()函数之后，内核会向进程发送 SIGABRT 信号。</u></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统信息与系统资源</title>
      <link href="/2022/12/13/2022-12-13-Linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/"/>
      <url>/2022/12/13/2022-12-13-Linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="系统信息与系统资源"><a href="#系统信息与系统资源" class="headerlink" title="系统信息与系统资源"></a>系统信息与系统资源</h2><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><h4 id="系统标识uname"><a href="#系统标识uname" class="headerlink" title="系统标识uname"></a>系统标识uname</h4><p>系统调用uname()用于获取有关当前操作系统内核的名称和信息，原型可以通过man 2 uname查看</p><p>函数参数和返回值含义如下：<br>buf：struct utsname 结构体类型指针，指向一个 struct utsname 结构体类型对象。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>uname()函数用法非常简单，先定义一个 struct utsname 结构体变量，调用 uname()函数时传入变量的地<br>址即可，struct utsname 结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></span><br><span class="line"> <span class="type">char</span> sysname[]; <span class="comment">/* 当前操作系统的名称 */</span></span><br><span class="line"> <span class="type">char</span> nodename[]; <span class="comment">/* 网络上的名称（主机名） */</span></span><br><span class="line"> <span class="type">char</span> release[]; <span class="comment">/* 操作系统内核版本 */</span></span><br><span class="line"> <span class="type">char</span> version[]; <span class="comment">/* 操作系统发行版本 */</span></span><br><span class="line"> <span class="type">char</span> machine[]; <span class="comment">/* 硬件架构类型 */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> _GNU_SOURCE</span></span><br><span class="line"> <span class="type">char</span> domainname[];<span class="comment">/* 当前域名 */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="sysinfo函数"><a href="#sysinfo函数" class="headerlink" title="sysinfo函数"></a>sysinfo函数</h4><p>sysinfo 系统调用可用于获取一些系统统计信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *info)</span>;</span><br></pre></td></tr></table></figure><p>info：struct sysinfo 结构体类型指针，指向一个 struct sysinfo 结构体类型对象。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> &#123;</span></span><br><span class="line"> <span class="type">long</span> uptime; <span class="comment">/* 自系统启动之后所经过的时间（以秒为单位） */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> loads[<span class="number">3</span>]; <span class="comment">/* 1, 5, and 15 minute load averages */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> totalram; <span class="comment">/* 总的可用内存大小 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> freeram; <span class="comment">/* 还未被使用的内存大小 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> sharedram; <span class="comment">/* Amount of shared memory */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> bufferram; <span class="comment">/* Memory used by buffers */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> totalswap; <span class="comment">/* Total swap space size */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> freeswap; <span class="comment">/* swap space still available */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> procs; <span class="comment">/* 系统当前进程数量 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> totalhigh; <span class="comment">/* Total high memory size */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> freehigh; <span class="comment">/* Available high memory size */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> mem_unit; <span class="comment">/* 内存单元大小（以字节为单位） */</span></span><br><span class="line"> <span class="type">char</span> _f[<span class="number">20</span><span class="number">-2</span>*<span class="keyword">sizeof</span>(<span class="type">long</span>)-<span class="keyword">sizeof</span>(<span class="type">int</span>)]; <span class="comment">/* Padding to 64 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="gethostname函数"><a href="#gethostname函数" class="headerlink" title="gethostname函数"></a>gethostname函数</h4><p>此函数可用于单独获取 Linux 系统主机名，与 struct utsname 数据结构体中的 nodename 变量一样，原型通过命令man 2 gethostname查看。</p><p>name：指向用于存放主机名字符串的缓冲区。<br>len：缓冲区长度。<br>返回值：成功返回 0,；失败将返回-1，并会设置 errno。</p><h4 id="sysconf函数"><a href="#sysconf函数" class="headerlink" title="sysconf函数"></a>sysconf函数</h4><p>sysconf()函数是一个库函数，可在运行时获取系统的一些配置信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sysconf</span><span class="params">(<span class="type">int</span> name)</span>;</span><br></pre></td></tr></table></figure><p>⚫ _SC_ARG_MAX：exec 族函数的参数的最大长度，exec 族函数后面会介绍，这里先不管！<br>⚫ _SC_CHILD_MAX：每个用户的最大并发进程数，也就是同一个用户可以同时运行的最大进程数。<br>⚫ _SC_HOST_NAME_MAX：主机名的最大长度。<br>⚫ _SC_LOGIN_NAME_MAX：登录名的最大长度。<br>⚫ _SC_CLK_TCK：每秒时钟滴答数，也就是系统节拍率。<br>⚫ _SC_OPEN_MAX：一个进程可以打开的最大文件数。<br>⚫ _SC_PAGESIZE：系统页大小（page size）。<br>⚫ _SC_TTY_NAME_MAX：终端设备名称的最大长度。</p><p>更多请用man指令查询。</p><h3 id="时间、日期"><a href="#时间、日期" class="headerlink" title="时间、日期"></a>时间、日期</h3><h4 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h4><p>系统调用time()用于获取当前时间，以秒为单位，返回值是自 1970-01-01 00:00:00 +0000 (UTC)以来的秒数，原型可通过man2 time查看</p><p>tloc：如果 tloc 参数不是 NULL，则返回值也存储在 tloc 指向的内存中。</p><p>返回值：成功则返回自 1970-01-01 00:00:00 +0000 (UTC)以来的时间值（以秒为单位）；失败则返回-1，<br>并会设置 errno。</p><p>time 函数获取得到的是一个时间段，也就是从 1970-01-01 00:00:00 +0000 (UTC)到现在这段时间所经过的秒数，把这个称之为日历时间或 time_t 时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">time_t</span> t;</span><br><span class="line"> t = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == t) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;时间值: %ld\n&quot;</span>, t);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gettimeofday函数"><a href="#gettimeofday函数" class="headerlink" title="gettimeofday函数"></a>gettimeofday函数</h4><p>gettimeofday()函数提供微秒级时间精度。原型可通过man 2 gettimeofday查看</p><p>tv：参数 tv 是一个 struct timeval 结构体指针变量，struct timeval 结构体在前面章节内容中已经给大家介绍过，具体参考示例代码 5.6.3。<br>tz：参数 tz 是个历史产物，早期实现用其来获取系统的时区信息，目前已遭废弃，在调用 gettimeofday()函数时应将参数 tz 设置为 NULL。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tval</span>;</span></span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> ret = gettimeofday(&amp;tval, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;gettimeofday error&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;时间值: %ld 秒+%ld 微秒\n&quot;</span>, tval.tv_sec, tval.tv_usec);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间转换函数"><a href="#时间转换函数" class="headerlink" title="时间转换函数"></a>时间转换函数</h4><p><strong>ctime函数</strong></p><p>ctime可以将日历时间转换为可打印输出的字符串形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="type">char</span> *buf)</span>;</span><br></pre></td></tr></table></figure><p>timep：time_t 时间变量指针。<br>返回值：成功将返回一个 char *类型指针，指向转换后得到的字符串；失败将返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> tm_str[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">time_t</span> tm;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> tm = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == tm) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将时间转换为字符串形式 */</span></span><br><span class="line"> ctime_r(&amp;tm, tm_str);</span><br><span class="line"><span class="comment">/* 打印输出 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;当前时间: %s&quot;</span>, tm_str);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>localtime函数</strong></p><p>localtime()函数可以把 time()或 gettimeofday()得到的秒数（time_t 时间或日历时间）变成一个 struct tm<br>结构体所表示的时间，该时间对应的是本地时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br></pre></td></tr></table></figure><p>timep：需要进行转换的 time_t 时间变量对应的指针，可通过 time()或 gettimeofday()获取得到。<br>result：是一个 struct tm 结构体类型指针，稍后给大家介绍 struct tm 结构体，参数 result 是可重入函数<br>localtime_r()需要额外提供的参数。<br>返回值：对于不可重入版本 localtime()来说，成功则返回一个有效的 struct tm 结构体指针，而对于可重入版本 localtime_r()来说，成功执行情况下，返回值将会等于参数result；失败则返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> tm_sec; <span class="comment">/* 秒(0-60) */</span></span><br><span class="line"> <span class="type">int</span> tm_min; <span class="comment">/* 分(0-59) */</span></span><br><span class="line"> <span class="type">int</span> tm_hour; <span class="comment">/* 时(0-23) */</span></span><br><span class="line"> <span class="type">int</span> tm_mday; <span class="comment">/* 日(1-31) */</span></span><br><span class="line"> <span class="type">int</span> tm_mon; <span class="comment">/* 月(0-11) */</span></span><br><span class="line"> <span class="type">int</span> tm_year; <span class="comment">/* 年(这个值表示的是自 1900 年到现在经过的年数) */</span></span><br><span class="line"> <span class="type">int</span> tm_wday; <span class="comment">/* 星期(0-6, 星期日 Sunday = 0、星期一=1…) */</span></span><br><span class="line"> <span class="type">int</span> tm_yday; <span class="comment">/* 一年里的第几天(0-365, 1 Jan = 0) */</span></span><br><span class="line"> <span class="type">int</span> tm_isdst; <span class="comment">/* 夏令时 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">t</span>;</span></span><br><span class="line"> <span class="type">time_t</span> sec;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> sec = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sec) &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 转换得到本地时间 */</span></span><br><span class="line"> localtime_r(&amp;sec, &amp;t);</span><br><span class="line"> <span class="comment">/* 打印输出 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;当前时间: %d 年%d 月%d 日 %d:%d:%d\n&quot;</span>,</span><br><span class="line"> t.tm_year + <span class="number">1900</span>, t.tm_mon, t.tm_mday,</span><br><span class="line"> t.tm_hour, t.tm_min, t.tm_sec);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gmtime()函数</strong>把time_t时间变为struct tm结构体所表示的时间，得到的是UTC国际标准时间，不是本地时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">local_t</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">utc_t</span>;</span></span><br><span class="line"> <span class="type">time_t</span> sec;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> sec = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sec) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 转换得到本地时间 */</span></span><br><span class="line"> localtime_r(&amp;sec, &amp;<span class="type">local_t</span>);</span><br><span class="line"> <span class="comment">/* 转换得到国际标准时间 */</span></span><br><span class="line"> gmtime_r(&amp;sec, &amp;<span class="type">utc_t</span>);</span><br><span class="line"> <span class="comment">/* 打印输出 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;本地时间: %d 年%d 月%d 日 %d:%d:%d\n&quot;</span>,</span><br><span class="line"> <span class="type">local_t</span>.tm_year + <span class="number">1900</span>, <span class="type">local_t</span>.tm_mon, <span class="type">local_t</span>.tm_mday,</span><br><span class="line"> <span class="type">local_t</span>.tm_hour, <span class="type">local_t</span>.tm_min, <span class="type">local_t</span>.tm_sec);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;UTC 时间: %d 年%d 月%d 日 %d:%d:%d\n&quot;</span>,</span><br><span class="line"> <span class="type">utc_t</span>.tm_year + <span class="number">1900</span>, <span class="type">utc_t</span>.tm_mon, <span class="type">utc_t</span>.tm_mday,</span><br><span class="line"> <span class="type">utc_t</span>.tm_hour, <span class="type">utc_t</span>.tm_min, <span class="type">utc_t</span>.tm_sec);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mktime函数</strong>可以将使用 struct tm 结构体表示的分解时间转换为 time_t时间（日历时间）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure><p>tm：需要进行转换的 struct tm 结构体变量对应的指针。<br>返回值：成功返回转换得到 time_t 时间值；失败返回-1。</p><p><strong>asctime函数</strong>与 ctime()函数的作用一样，也可将时间转换为可打印输出的字符串形式，与 ctime()函数<br>的区别在于，ctime()是将 time_t 时间转换为固定格式字符串、而 asctime()则是将 struct tm 表示的分解时间转换为固定格式的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime_r</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm, <span class="type">char</span> *buf)</span>;</span><br></pre></td></tr></table></figure><p>tm：需要进行转换的 struct tm 表示的时间。<br>buf：可重入版本函数 asctime_r 需要额外提供的参数 buf，指向一个缓冲区，用于存放转换得到的字符串。<br>返回值：转换失败将返回 NULL；成功将返回一个 char *类型指针，指向转换后得到的时间字符串，对asctime_r 函数来说，返回值就等于参数 buf。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">local_t</span>;</span></span><br><span class="line"> <span class="type">char</span> tm_str[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">time_t</span> sec;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> sec = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (sec == <span class="number">-1</span>) </span><br><span class="line"> &#123;</span><br><span class="line">perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> localtime_r(&amp;sec, &amp;<span class="type">local_t</span>);</span><br><span class="line"> asctime_r(&amp;<span class="type">local_t</span>, tm_str);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;本地时间: %s&quot;</span>, tm_str);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>strftime 函数</strong>可以自定义时间显示格式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> max, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure><p>s：指向一个缓存区的指针，该缓冲区用于存放生成的字符串。<br>max：字符串的最大字节数。<br>format：这是一个用字符串表示的字段，包含了普通字符和特殊格式说明符，可以是这两种字符的任意<br>组合。特殊格式说明符将会被替换为 struct tm 结构体对象所指时间的相应值。</p><p>特殊格式可用命令man strftime查询。</p><p><strong>设置时间 settimeofday</strong></p><p>使用 settimeofday()函数可以设置时间，也就是设置系统的本地时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">settimeofday</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timeval *tv, <span class="type">const</span> <span class="keyword">struct</span> timezone *tz)</span>;</span><br></pre></td></tr></table></figure><p>tv：参数 tv 是一个 struct timeval 结构体指针变量，struct timeval 结构体在前面章节内容中已经给大家介绍了，需要设置的时间便通过参数 tv 指向的 struct timeval 结构体变量传递进去。<br>tz：参数 tz 是个历史产物，早期实现用其来设置系统的时区信息，目前已遭废弃，在调用 settimeofday()函数时应将参数 tz 设置为 NULL。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>使用 settimeofday 设置系统时间时内核会进行权限检查，只有超级用户（root）才可以设置系统时间，普通用户将无操作权限。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221211_135113.png"></p><h3 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h3><p>进程时间指的是进程从创建后（也就是程序运行后）到目前为止这段时间内使用 CPU 资源的时间总数，出于记录的目的，内核把 CPU 时间（进程时间）分为以下两个部分：<br>⚫ 用户 CPU 时间：进程在用户空间（用户态）下运行所花费的 CPU 时间。有时也成为虚拟时间（virtual time）。<br>⚫ 系统 CPU 时间：进程在内核空间（内核态）下运行所花费的 CPU 时间。这是内核执行系统调用或代表进程执行的其它任务（譬如，服务页错误）所花费的时间。<br>一般来说，进程时间指的是用户 CPU 时间和系统 CPU 时间的总和，也就是总的 CPU 时间。</p><h4 id="times函数"><a href="#times函数" class="headerlink" title="times函数"></a>times函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">times</span><span class="params">(<span class="keyword">struct</span> tms *buf)</span>;</span><br></pre></td></tr></table></figure><p>buf：times()会将当前进程时间信息存在一个 struct tms 结构体数据中</p><p>返回值：返回值类型为 clock_t（实质是 long 类型），调用成功情况下，将返回从过去任意的一个时间点（譬如系统启动时间）所经过的时钟滴答数（其实就是系统节拍数），将(节拍数 &#x2F; 节拍率)便可得到秒数，返回值可能会超过 clock_t 所能表示的范围（溢出）；调用失败返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">clock_t</span> tms_utime; <span class="comment">/* user time, 进程的用户 CPU 时间, tms_utime 个系统节拍数 */</span></span><br><span class="line"> <span class="type">clock_t</span> tms_stime; <span class="comment">/* system time, 进程的系统 CPU 时间, tms_stime 个系统节拍数 */</span></span><br><span class="line"> <span class="type">clock_t</span> tms_cutime; <span class="comment">/* user time of children, 已死掉子进程的 tms_utime + tms_cutime 时间总和 */</span></span><br><span class="line"> <span class="type">clock_t</span> tms_cstime; <span class="comment">/* system time of children, 已死掉子进程的 tms_stime + tms_cstime 时间总和 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="clock函数"><a href="#clock函数" class="headerlink" title="clock函数"></a>clock函数</h4><p>库函数 clock()提供了一个更为简单的方式用于进程时间，它的返回值描述了进程使用的总的 CPU 时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">clock</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>无参数。<br>返回值：返回值是到目前为止程序的进程时间，为 clock_t 类型，注意 clock()的返回值并不是系统节拍数，如果想要获得秒数，请除以 CLOCKS_PER_SEC（这是一个宏）。如果返回的进程时间不可用或其值无法表示，则该返回值是-1。<br>clock()函数虽然可以很方便的获取总的进程时间，但并不能获取到单独的用户 CPU 时间和系统 CPU 时间，在实际编程当中，根据自己的需要选择。</p><h4 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a>产生随机数</h4><p>rand()函数用于获取随机数。（是一种伪随机数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>返回值：返回一个介于 0 到 RAND_MAX（包含）之间的值，也就是数学上的[0, RAND_MAX]。程度当中调用 rand()可以得到[0, RAND_MAX]之间的伪随机数，多次调用 rand()便可以生成一组伪随机树序列，但是这里有个问题，就是每一次运行程序所得到的随机数序列都是相同的，那如何使得每一次启动应用程序所得到的随机数序列是不一样的呢？那就通过设置不同的随机数种子，可通过 srand()设置随机数种子。<br>如果没有调用 srand()设置随机数种子的情况下，rand()会将 1 作为随机数种子，如果随机数种子相同，那么每一次启动应用程序所得到的随机数序列就是一样的，所以每次启动应用程序需要设置不同的随机数种子，这样就可以使得程序每次运行所得到随机数序列不同。</p><p><strong>srand 函数</strong></p><p>使用 srand()函数为 rand()设置随机数种子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br></pre></td></tr></table></figure><p>seed：指定一个随机数中，int 类型的数据，一般尝尝将当前时间作为随机数种子赋值给参数 seed，譬如 time(NULL)，因为每次启动应用程序时间上是一样的，所以就能够使得程序中设置的随机数种子在每次启动程序时是不一样的。<br>返回值：void<br>常用的用法 srand(time(NULL))</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> random_number_arr[<span class="number">8</span>];</span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"> <span class="comment">/* 设置随机数种子 */</span></span><br><span class="line"> srand(time(<span class="literal">NULL</span>));</span><br><span class="line"> <span class="comment">/* 生成伪随机数 */</span></span><br><span class="line"> <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">8</span>; count++)</span><br><span class="line"> random_number_arr[count] = rand() % <span class="number">100</span>;</span><br><span class="line"> <span class="comment">/* 打印随机数数组 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">8</span>; count++) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, random_number_arr[count]);</span><br><span class="line"> <span class="keyword">if</span> (count != <span class="number">8</span> - <span class="number">1</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>有时需要将进程暂停或休眠一段时间，进入休眠状态之后，程序将暂停运行，直到休眠结束。常用的系统调用和 C 库函数有 sleep()、usleep()以及 nanosleep()，这些函数在应用程序当中通常作为延时使用。</p><p><strong>秒级休眠sleep</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p>seconds：休眠时长，以秒为单位。<br>返回值：如果休眠时长为参数 seconds 所指定的秒数，则返回 0；若被信号中断则返回剩余的秒数。<br>sleep()是一个秒级别休眠函数，程序在休眠过程中，是可以被其它信号所打断的。</p><p>微秒休眠usleep</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">usleep</span><span class="params">(<span class="type">useconds_t</span> usec)</span>;</span><br></pre></td></tr></table></figure><p>高精度休眠nanosleep</p><p>nanosleep()与 sleep()以及 usleep()类似，都用于程序休眠，但 nanosleep()具有更高精度来设置休眠时间长度，支持纳秒级时长设置。与 sleep()、usleep()不同的是，nanosleep()是一个 Linux 系统调用。</p><p>req：一个 struct timespec 结构体指针，指向一个 struct timespec 变量，用于设置休眠时间长度，可精确到纳秒级别。<br>rem：也是一个 struct timespec 结构体指针，指向一个 struct timespec 变量，也可设置 NULL。<br>返回值：在成功休眠达到请求的时间间隔后，nanosleep()返回 0；如果中途被信号中断或遇到错误，则返回-1，并将剩余时间记录在参数 rem 指向的 struct timespec 结构体变量中（参数 rem 不为 NULL 的情况下，如果为 NULL 表示不接收剩余时间），还会设置 errno 标识错误类型。</p><h3 id="申请堆内存"><a href="#申请堆内存" class="headerlink" title="申请堆内存"></a>申请堆内存</h3><p>在操作系统下，内存资源是由操作系统进行管理、分配的，当应用程序想要内存时（这里指的是堆内存），可以向操作系统申请内存，然后使用内存；当不再需要时，将申请的内存释放、归还给操作系统。</p><h4 id="堆上分配内存：malloc和free"><a href="#堆上分配内存：malloc和free" class="headerlink" title="堆上分配内存：malloc和free"></a>堆上分配内存：malloc和free</h4><p><strong>malloc</strong>为程序分配一段堆内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>size：需要分配的内存大小，以字节为单位。</p><p>返回值：返回值为 void *类型，如果申请分配内存成功，将返回一个指向该段内存的指针，void *并不是说没有返回值或者返回空指针，而是返回的指针类型未知,所以在调用 malloc()时通常需要进行强制类型转换，将 void *指针类型转换成我们希望的类型；如果分配内存失败（譬如系统堆内存不足）将返回 NULL，如果参数 size 为 0，返回值也是 NULL。</p><p>malloc()在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的，所以通常需要程序员对 malloc()分配的堆内存进行初始化操作。</p><p><strong>free</strong>释放堆内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p>ptr：指向需要被释放的堆内存对应的指针。<br>返回值：无返回值。</p><p><strong>用 calloc()分配内存</strong><br>calloc()函数用来动态地分配内存空间并初始化为 0，其函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>使用该函数同样也需要包含头文件。<br>calloc()在堆中动态地分配 nmemb 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 nmemb * size 个字节长度的内存空间，并且每个字节的值都是 0。<br>返回值：分配成功返回指向该内存的地址，失败则返回 NULL。<br>calloc()与 malloc()的一个重要区别是：calloc()在动态分配完内存后，自动初始化该内存空间为零，而malloc()不初始化，里边数据是未知的垃圾数据。下面的两种写法是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calloc()分配内存空间并初始化</span></span><br><span class="line"><span class="type">char</span> *buf1 = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// malloc()分配内存空间并用 memset()初始化</span></span><br><span class="line"><span class="type">char</span> *buf2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf2, <span class="number">0</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="分配对齐内存"><a href="#分配对齐内存" class="headerlink" title="分配对齐内存"></a>分配对齐内存</h4><p><a href="https://xie.infoq.cn/article/e071632f617563002552a7232">一文轻松理解内存对齐_</a></p><p>C 函数库中还提供了一系列在堆上分配对齐内存的函数，对齐内存在某些应用场合非常有必要，常用于分配对其内存的库函数有：posix_memalign()、aligned_alloc()、memalign()、valloc()、pvalloc()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">posix_memalign</span><span class="params">(<span class="type">void</span> **memptr, <span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">aligned_alloc</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">valloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">pvalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>posix_memalign()函数<br>posix_memalign()函数用于在堆上分配 size 个字节大小的对齐内存空间，将*memptr 指向分配的空间，分配的内存地址将是参数 alignment 的整数倍。参数 alignment 表示对齐字节数，alignment 必须是 2 的幂次方（譬如 2^4、2^5、2^8 等），同时也要是 sizeof(void *)的整数倍，对于 32 位系统来说sizeof(void *)等于4，如果是 64 位系统 sizeof(void *)等于 8。<br>函数参数和返回值含义如下：<br>memptr：void *<em>类型的指针，内存申请成功后会将分配的内存地址存放在</em>memptr 中。<br>alignment：设置内存对其的字节数，alignment 必须是 2 的幂次方（譬如 2^4、2^5、2^8 等），同时也要是 sizeof(void <em>)的整数倍。<br>size：设置分配的内存大小，以字节为单位，如果参数 size 等于 0，那么</em>memptr 中的值是 NULL。<br>返回值：成功将返回 0；失败返回非 0 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> *base = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 申请内存: 256 字节对齐 */</span></span><br><span class="line"> ret = posix_memalign((<span class="type">void</span> **)&amp;base, <span class="number">256</span>, <span class="number">1024</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> != ret) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;posix_memalign error\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* 使用内存 */</span></span><br><span class="line"> <span class="comment">// base[0] = 0;</span></span><br><span class="line"> <span class="comment">// base[1] = 1;</span></span><br><span class="line"> <span class="comment">// base[2] = 2;</span></span><br><span class="line"> <span class="comment">// base[3] = 3;</span></span><br><span class="line"> <span class="comment">/* 释放内存 */</span></span><br><span class="line"> <span class="built_in">free</span>(base);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="proc文件系统"></a>proc文件系统</h3><p>(1)proc是虚拟文件系统，虚拟的意思就是proc文件系统里的文件不对应硬盘上任何文件，我们用去查看proc目录下的文件大小都是零；<br>(2)proc文件系统是开放给上层了解内核运行状态的窗口，通过读取proc系统里的文件，可以知道内核中一些重要数据结构的数值，从而知道内核的运行情况，也可以方便调试内核和应用程序；<br>(3)proc文件系统的思路：在内核中构建一个虚拟文件系统&#x2F;proc，内核运行时将内核中一些关键的数据结构以文件的方式呈现在&#x2F;proc目录中的一些特定文件中，这样相当于将不可见的内核中的数据结构以可视化的方式呈现给内核的开发者</p><table><thead><tr><th align="center">文件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">&#x2F;proc&#x2F;cmdline</td><td align="center">查看内核的启动参数</td></tr><tr><td align="center">&#x2F;proc&#x2F;cpuinfo</td><td align="center">查看CPU的信息</td></tr><tr><td align="center">&#x2F;proc&#x2F;devices</td><td align="center">查看内核中已经注册的设备</td></tr><tr><td align="center">&#x2F;proc&#x2F;filesystems</td><td align="center">内核当前支持的文件系统类型</td></tr><tr><td align="center">&#x2F;proc&#x2F;interrupts</td><td align="center">中断的使用及触发次数，调试中断时很有用</td></tr><tr><td align="center">&#x2F;proc&#x2F;misc</td><td align="center">内核中注册的misc类设备</td></tr><tr><td align="center">&#x2F;proc&#x2F;modules</td><td align="center">已经加载的模块列表，对应lsmod命令</td></tr><tr><td align="center">&#x2F;proc&#x2F;partitions</td><td align="center">系统的分区表</td></tr><tr><td align="center">&#x2F;proc&#x2F;version</td><td align="center">系统的版本</td></tr><tr><td align="center">数字</td><td align="center">数字的文件夹都是相应的进程</td></tr><tr><td align="center">&#x2F;proc&#x2F;mounts</td><td align="center">已加载的文件系统的列表，对应mount命令</td></tr><tr><td align="center">&#x2F;proc&#x2F;meminfo</td><td align="center">内核的内存信息</td></tr><tr><td align="center">&#x2F;proc&#x2F;fb</td><td align="center">内核中注册的显示设备</td></tr></tbody></table><p><strong><u>proc 文件系统的使用就是去读取&#x2F;proc 目录下的这些文件，获取文件中记录的信息，可以直接使用 cat 命令读取，也可以在应用程序中调用 open()打开、然后再使用 read()函数读取。</u></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux调试工具gdb</title>
      <link href="/2022/12/12/2022-12-12-Linux%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/12/12/2022-12-12-Linux%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="linux中使用C-x2F-C-的调试工具gdb"><a href="#linux中使用C-x2F-C-的调试工具gdb" class="headerlink" title="linux中使用C&#x2F;C++的调试工具gdb"></a>linux中使用C&#x2F;C++的调试工具gdb</h3><p>gdb是GNU开源组织发布的一个强大的Linux下的程序调试工具。</p><p> 一般来说，GDB主要帮助你完成下面四个方面的功能：</p><p>1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</p><p>2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</p><p>3、当程序被停住时，可以检查此时你的程序中所发生的事。</p><p>4、你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。<br>首先要用gcc进行编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g 源文件 -o 目标文件</span><br></pre></td></tr></table></figure><p><strong><u>gdb的命令</u></strong></p><p>（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h</p><p>（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r</p><p>（gdb）start：单步执行，运行程序，停在第一执行语句</p><p>（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l</p><p>（gdb）set：设置变量的值</p><p>（gdb）next：单步调试（逐过程，函数直接执行）,简写n</p><p>（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s</p><p>（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt</p><p>（gdb）frame：切换函数的栈帧,简写f</p><p>（gdb）info：查看函数内部局部变量的数值,简写i</p><p>（gdb）finish：结束当前函数，返回到函数调用点</p><p>（gdb）continue：继续运行,简写c</p><p>（gdb）print：打印值及地址,简写p</p><p>（gdb）quit：退出gdb,简写q</p><p>（gdb）break+num：在第num行设置断点,简写b</p><p>（gdb）info breakpoints：查看当前设置的所有断点</p><p>（gdb）delete breakpoints num：删除第num个断点,简写d</p><p>（gdb）display：追踪查看具体变量值</p><p>（gdb）undisplay：取消追踪观察变量</p><p>（gdb）watch：被设置观察点的变量发生修改时，打印显示</p><p>（gdb）i watch：显示观察点</p><p>（gdb）enable breakpoints：启用断点</p><p>（gdb）disable breakpoints：禁用断点</p><p>（gdb）x：查看内存x&#x2F;20xw 显示20个单元，16进制，4字节每单元</p><p>（gdb）run argv[1] argv[2]：调试时命令行传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>; ilt;=<span class="number">100</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">           sum+=i;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">          result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result[1-100] = %d&quot;</span>, result );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result[1-250] = %d&quot;</span>, func(<span class="number">250</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">root&lt;span style=<span class="string">&quot;&quot;</span>&gt;@&lt;/span&gt;linux: /home/benben /test<span class="meta"># gdb tst &lt;---------- 启动GDB</span></span><br><span class="line">GNU gdb <span class="number">5.1</span><span class="number">.1</span></span><br><span class="line">Copyright <span class="number">2002</span> Free Software Foundation, Inc.</span><br><span class="line">GDB is <span class="built_in">free</span> software, covered by the GNU General Public License, and you are</span><br><span class="line">welcome to change it and/or distribute copies of it under certain conditions.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> to see the conditions.</span><br><span class="line">There is absolutely no warranty <span class="keyword">for</span> GDB. Type <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;i386-suse-linux&quot;</span>...</span><br><span class="line">(gdb) l &lt;-------------------- l命令相当于<span class="built_in">list</span>，从第一行开始例出原码。</span><br><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="type">int</span> func(<span class="type">int</span> n)</span><br><span class="line"><span class="number">4</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">0</span>; i</span><br><span class="line"><span class="number">7</span> &#123;</span><br><span class="line"><span class="number">8</span> sum+=i;</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span> sum;</span><br><span class="line">(gdb) &lt;-------------------- 直接回车表示，重复上一次命令</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> main()</span><br><span class="line"><span class="number">15</span> &#123;</span><br><span class="line"><span class="number">16</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">17</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line"><span class="number">19</span> &#123;</span><br><span class="line"><span class="number">20</span> result += i;</span><br><span class="line">(gdb) <span class="keyword">break</span> <span class="number">16</span> &lt;-------------------- 设置断点，在源程序第<span class="number">16</span>行处。</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x8048496</span>: file tst.c, line <span class="number">16.</span></span><br><span class="line">(gdb) <span class="keyword">break</span> func &lt;-------------------- 设置断点，在函数func()入口处。</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x8048456</span>: file tst.c, line <span class="number">5.</span></span><br><span class="line">(gdb) info <span class="keyword">break</span> &lt;-------------------- 查看断点信息。</span><br><span class="line">Num Type Disp Enb Address What</span><br><span class="line"><span class="number">1</span> breakpoint keep y <span class="number">0x08048496</span> in main at tst.c:<span class="number">16</span></span><br><span class="line"><span class="number">2</span> breakpoint keep y <span class="number">0x08048456</span> in func at tst.c:<span class="number">5</span></span><br><span class="line">(gdb) r &lt;--------------------- 运行程序，run命令简写</span><br><span class="line">Starting program: /home/benben /test/tst</span><br><span class="line"> </span><br><span class="line">Breakpoint <span class="number">1</span>, main () at tst.c:<span class="number">17</span> &lt;---------- 在断点处停住。</span><br><span class="line"><span class="number">17</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">(gdb) n &lt;--------------------- 单条语句执行，next命令简写。</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">20</span> result += i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">20</span> result += i;</span><br><span class="line">(gdb) c &lt;--------------------- 继续运行程序，<span class="keyword">continue</span>命令简写。</span><br><span class="line">Continuing.</span><br><span class="line">result[<span class="number">1</span><span class="number">-100</span>] = <span class="number">5050</span> &lt;----------程序输出。</span><br><span class="line"> </span><br><span class="line">Breakpoint <span class="number">2</span>, func (n=<span class="number">250</span>) at tst.c:<span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">(gdb) p i &lt;--------------------- 打印变量i的值，print命令简写。</span><br><span class="line">$<span class="number">1</span> = <span class="number">134513808</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">8</span> sum+=i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line">$<span class="number">2</span> = <span class="number">1</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">8</span> sum+=i;</span><br><span class="line">(gdb) p i</span><br><span class="line">$<span class="number">3</span> = <span class="number">2</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line">$<span class="number">4</span> = <span class="number">3</span></span><br><span class="line">(gdb) bt &lt;--------------------- 查看函数堆栈。</span><br><span class="line">#<span class="number">0</span> func (n=<span class="number">250</span>) at tst.c:<span class="number">5</span></span><br><span class="line"> </span><br><span class="line">#<span class="number">1</span> <span class="number">0x080484e4</span> in main () at tst.c:<span class="number">24</span></span><br><span class="line"> </span><br><span class="line">#<span class="number">2</span> <span class="number">0x400409ed</span> in __libc_start_main () from /lib/libc.so<span class="number">.6</span></span><br><span class="line">(gdb) finish &lt;--------------------- 退出函数。</span><br><span class="line">Run till <span class="built_in">exit</span> from #<span class="number">0</span> func (n=<span class="number">250</span>) at tst.c:<span class="number">5</span></span><br><span class="line"> </span><br><span class="line"><span class="number">0x080484e4</span> in main () at tst.c:<span class="number">24</span></span><br><span class="line"><span class="number">24</span> <span class="built_in">printf</span>(<span class="string">&quot;result[1-250] = %d&quot;</span>, func(<span class="number">250</span>) );</span><br><span class="line">Value returned is $<span class="number">6</span> = <span class="number">31375</span></span><br><span class="line">(gdb) c &lt;--------------------- 继续运行。</span><br><span class="line">Continuing.</span><br><span class="line">result[<span class="number">1</span><span class="number">-250</span>] = <span class="number">31375</span> &lt;----------程序输出。</span><br><span class="line"> </span><br><span class="line">Program exited with code <span class="number">027.</span> &lt;--------程序退出，调试结束。</span><br><span class="line">(gdb) q &lt;--------------------- 退出gdb。</span><br><span class="line">root@linux:/home/benben/test#</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/lvdongjie/p/8994092.html">【Linux】GDB用法详解(5小时快速教程)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习一个阶段的感受</title>
      <link href="/2022/12/04/2022-12-4-%E6%94%BE%E5%81%87/"/>
      <url>/2022/12/04/2022-12-4-%E6%94%BE%E5%81%87/</url>
      
        <content type="html"><![CDATA[<p>​因为疫情原因提前放假回家，大部分考试还不知道怎么考，现在要准备好材料，刷网课和弄选修论文，打算12月份学完C语言剩余两章，之后每天写个联系代码，linux方面继续应用层的编写学习，看看弄完后，可能要进入到C++，这样才能学习QT应用编程，东西还是不少的，先完成总的百分之40吧。</p><p>​待续。。。</p><p>​现在进入假期了，为了更好的使用linux的开发板，开始学习裸机开发，uboot和系统移植，驱动开发相关知识。</p><p>​看看之后学习C++，进入qt来更好的制作一个完整的项目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C issue1</title>
      <link href="/2022/11/25/2022-11-25-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/25/2022-11-25-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="scanf输入问题-输入缓冲区"><a href="#scanf输入问题-输入缓冲区" class="headerlink" title="scanf输入问题-输入缓冲区"></a>scanf输入问题-输入缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line"><span class="keyword">while</span>(b == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i++);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);\</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会得到</span></span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line">a<span class="comment">//输入a</span></span><br><span class="line"><span class="number">0</span>?a1?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因是因为scanf()函数会把回车、空格、Tab或一些不合理输入的字符当作此次输入的结束标志，它不会把这些字符输入到想要保存此次输入数据的变量中，而是把这些字符遗留在了输入缓冲区，那么，当下一次想要从标准输入中读取一个字符时，这个遗留的字符就正好充当了此次的输入字符。</p><p>程序在输入a后输入了回车来结束此次输入，那么回车就遗留在了输入缓冲区，当需要给c输入字符时，它自动的充当了输入的字符，因此，程序没有给我们输入c的字符的机会。</p><p>C语言为了解决这种问题，为我们提供了一种很方便的清空输入缓冲区的方式—-&gt;&gt;fflush()函数，fflush(stdin)它会把残留在输入缓冲区里的所有数据清空。头文件为stdio.h</p><p>或者使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//跳过该行剩下的内容。</span></span><br></pre></td></tr></table></figure><p><strong>C primer plus提供的输入程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> *st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * ret_val;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets( st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(st[i]!= <span class="string">&#x27;\n&#x27;</span> &amp;&amp;st[i]!= <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            i++;</span><br><span class="line">    <span class="keyword">if</span>(st[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            st[i] == <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span>(getchar()!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错题：位运算"><a href="#错题：位运算" class="headerlink" title="错题：位运算"></a>错题：位运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fun(<span class="number">2017</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">i = i&amp;(i<span class="number">-1</span>);<span class="comment">//i = i &amp; (i-1)，统计i二进制中有多少个1</span></span><br><span class="line">&#125;               <span class="comment">//i = i | (i+1)，统计i二进制中有多少个0</span></span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str[<span class="number">3</span>] =&#123;<span class="string">&quot;stra&quot;</span>, <span class="string">&quot;strb&quot;</span>, <span class="string">&quot;strc&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *p =str[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,p++);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char<a href="https://so.csdn.net/so/search?q=%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">指针数组</a>可以指向多个字符，直到遇到空为止。p本来指向第一个字符，但是因为是指针，所以要遇到空为止才算读完第一个‘字符’，后面p+1指向第二个字符，同样也是遇到空为止，同理p+2 所以输出为stra，tra，ra。注意循环里面是p++所以从p0开始打印啦。</p><h3 id="指针和自增自减的优先级"><a href="#指针和自增自减的优先级" class="headerlink" title="指针和自增自减的优先级"></a>指针和自增自减的优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">3668</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p++ );<span class="comment">//拿到arr[0]的值1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p++ ); <span class="comment">//上条语句结束后指针往后移动了一下，</span></span><br><span class="line"><span class="comment">//指到到arr[1]，然后又++，因为是后++，</span></span><br><span class="line"><span class="comment">//所以解得是arr[1]的值3668</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*p)++ );<span class="comment">//拿到上个++指向了arr[2],</span></span><br><span class="line"><span class="comment">//因为加了括号，所以先解值为5，然后++，</span></span><br><span class="line"><span class="comment">//把结果丢给了下语句。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*p)++ );<span class="comment">//括号优先级高，先解值，指针未移动，</span></span><br><span class="line"><span class="comment">//还指向着arr[2],拿到上个printf丢下来的值5+1=6，</span></span><br><span class="line"><span class="comment">//故解值为6，然6++,语句执行结束把6++结果丢给下一条语句。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h3><p>在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量&#x2F;函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。</p><h3 id="extern”C”-作用"><a href="#extern”C”-作用" class="headerlink" title="extern”C” 作用"></a>extern”C” 作用</h3><p>C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//把所有函数声明放在这。</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="if…-endif的作用"><a href="#if…-endif的作用" class="headerlink" title="#if…#endif的作用"></a>#if…#endif的作用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">code 执行代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">code 屏蔽代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>同样可以“屏蔽”一段代码，你想把说明文字写在里面也可以，这些和“&#x2F;* *&#x2F;”都一样，但不一样的是：第一它允许嵌套（层数上限由预处理器决定）、第二你随时可以把“#if 0”改成“#if 1”来取消对某段代码的“屏蔽。</p><h3 id="结构体大小"><a href="#结构体大小" class="headerlink" title="结构体大小"></a>结构体大小</h3><p>结构体计算遵循对齐原则：</p><p>1）结构体变量首地址能够背其最宽基本类型成员的大小所整除；</p><p>2）结构体<u>每个成员相对于结构体首地址的偏移量都是成员大小的整数倍</u>，如有比那一起会在成员之间加上填充字节；</p><p>3）结构体的<u>总大小为结构体最宽基本类型成员的大小的整数倍</u>，如有需要编译器会在最末一个成员之后加上填充字节。</p><p><strong>偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。</strong></p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> fname;<span class="comment">//第一个成员偏移量为0</span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//第二个成员偏移量等于0+第一个的大小1=1但是得是第二个成员大小的整数倍所以是4</span></span><br><span class="line">    <span class="type">double</span> time;<span class="comment">//第三个成员偏移量等于4+第二个的大小4=8但是得是第三个成员大小的整数倍所以是8</span></span><br><span class="line">    <span class="type">float</span> old;<span class="comment">//第四个成员偏移量等于8+第三个的大小8=16但是得是第四个成员大小的整数倍所以是16</span></span><br><span class="line">&#125;;<span class="comment">//16+4=20但是得是所有的整数倍所以是24；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">student</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>, <span class="keyword">sizeof</span>(student));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存对齐是什么</p><p><a href="https://xie.infoq.cn/article/e071632f617563002552a7232">一文轻松理解内存对齐_程序员_C语言与CPP编程</a></p><h3 id="为什么要用malloc何时用"><a href="#为什么要用malloc何时用" class="headerlink" title="为什么要用malloc何时用"></a>为什么要用malloc何时用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *malloc(unsigned int num_bytes);//分配num_bytes字节的内存块</span><br></pre></td></tr></table></figure><p>返回值是void指针，void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者其他数据类型），可以通过类型强制转化转化为其他任意类型指针。如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。</p><p>malloc（）是动态内存分配函数，用来向系统请求分配内存空间。当无法知道内存具体的位置时，想要绑定真正的内存空间，就要用到malloc（）函数。因为malloc只管分配内存空间，并不能对分配的空间进行初始化，所以申请到的内存中的值是随机的，经常会使用memset()进行置0操作后再使用。</p><p>与其配套的是free（），当申请到的空间不再使用时，要用free（）函数将内存空间释放掉，这样可以提高资源利用率，最重要的是—-就是因为它可以申请内存空间，然后根据需要进行释放，才被称为“动态内存分配”！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">　　p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">128</span>);</span><br><span class="line">　　　　<span class="comment">//分配128个整型存储单元，并将这128个连续的整型存储单元的首地址存储到指针变量p中</span></span><br><span class="line">　　<span class="type">double</span> *pd = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * <span class="number">12</span>);　　</span><br><span class="line">　　　　<span class="comment">//分配12个double型存储单元，并将首地址存储到指针变量pd中</span></span><br><span class="line">　　<span class="built_in">free</span>(p);</span><br><span class="line">　　<span class="built_in">free</span>(pd);</span><br><span class="line">　　p = <span class="literal">NULL</span>;</span><br><span class="line">　　pd = <span class="literal">NULL</span>;　　</span><br><span class="line">　　指针用完赋值<span class="literal">NULL</span>是一个很好的习惯。</span><br></pre></td></tr></table></figure><p>C语言中的联合</p><p>联合是在同一个内存空间中存储不同的数据类型（不能同时存在多个类型）。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> digit;</span><br><span class="line"><span class="type">double</span> bigf1;</span><br><span class="line"><span class="type">char</span> letter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上声明的结构只能存储整型或浮点型或者字符型的变量，不能同时存在。</p><p><u>初始化联合</u></p><p>有三种方法初始化联合：<br>1、把一个联合初始化为另一个同类型的联合</p><p>2、初始化联合的第一个成员</p><p>3、使用指定初始化器（C99标准）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">first_car</span>;</span></span><br><span class="line">first_car.car_name=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">sec_car</span>=</span>first_car; <span class="comment">//把一个联合初始化为另一个同类型的联合</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">car_a</span>=</span>&#123;<span class="string">&#x27;B&#x27;</span>&#125;;　　　　　<span class="comment">//初始化联合的第一个成员</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">car_b</span>=</span>&#123;.car_num=<span class="number">2</span>&#125;;　<span class="comment">//使用指定初始化器来初始化联合car_b</span></span><br></pre></td></tr></table></figure><p>用指针访问联合时候也是用-&gt;运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pu = &amp;fit;</span><br><span class="line">x = pu -&gt;digit;</span><br></pre></td></tr></table></figure><h3 id="传递结构体数组地址"><a href="#传递结构体数组地址" class="headerlink" title="传递结构体数组地址"></a>传递结构体数组地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTITL  40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXAUTL  40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBKS  100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> title [MAXTITL];</span><br><span class="line"><span class="type">char</span> author[MAXAUTL];</span><br><span class="line"><span class="type">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">srt</span><span class="params">( <span class="keyword">struct</span> book prt[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="keyword">struct</span> book pt[], <span class="type">int</span> m)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[<span class="title">MAXBKS</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">pst</span>;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">pst = &amp;library[<span class="number">0</span>];</span><br><span class="line">menu();</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; MAXBKS; i++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s_gets(library[i].title, MAXTITL) == <span class="literal">NULL</span> || library[i].title[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入作者\n&quot;</span>);</span><br><span class="line">s_gets(library[i].author, MAXAUTL);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入价格\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;library[i].value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入书名\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">srt(library, i);</span><br><span class="line"><span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; i; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;书名%s作者%s价格%.2f\n&quot;</span>, library[t].title, library[t].author, library[t].value);</span><br><span class="line">&#125;</span><br><span class="line">change(library, i);</span><br><span class="line"><span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; i; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;书名%s作者%s价格%.2f\n&quot;</span>, library[t].title, library[t].author, library[t].value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * ret_val;</span><br><span class="line"><span class="type">char</span> * find;</span><br><span class="line"></span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ret_val)</span><br><span class="line">&#123;</span><br><span class="line">find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(find)</span><br><span class="line">* find = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please enter the book title and author and value \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************************************************\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入书名\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">srt</span><span class="params">( <span class="keyword">struct</span> book prt[], <span class="type">int</span> n)</span><span class="comment">//价格排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">quantity</span>;</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)<span class="comment">//冒泡排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>-i; j++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(prt[j].value &gt; prt[j+<span class="number">1</span>].value)</span><br><span class="line">&#123;</span><br><span class="line">quantity = prt[j];</span><br><span class="line">prt[j] = prt[j+<span class="number">1</span>];</span><br><span class="line">prt[j+<span class="number">1</span>] = quantity;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="keyword">struct</span> book pt[], <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">letter</span>;</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; i++)                <span class="comment">//冒泡排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m<span class="number">-1</span>-i; j++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="type">int</span>)pt[j].title[<span class="number">0</span>]&gt;(<span class="type">int</span>)pt[j+<span class="number">1</span>].title[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">letter = pt[j];</span><br><span class="line">pt[j] = pt[j+<span class="number">1</span>];</span><br><span class="line">pt[j+<span class="number">1</span>] = letter;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="union问题"><a href="#union问题" class="headerlink" title="union问题"></a>union问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">2</span>];</span><br><span class="line">&#125;*p, u;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    p = &amp;u;</span><br><span class="line">    p-&gt;a[<span class="number">0</span>] = <span class="number">0x39</span>;</span><br><span class="line">    p-&gt;a[<span class="number">1</span>] = <span class="number">0x38</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="keyword">sizeof</span>(u));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——字符串处理</title>
      <link href="/2022/11/23/2022-11-23-Linux%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
      <url>/2022/11/23/2022-11-23-Linux%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h3><p>设备输出stdout、设备键盘输入stdin、设备错误显示stderr。</p><p>常用的字符串输入函数有putchar()、puts()、fputc()、fputs()只能输出字符串函数，不像printf可以格式化输出，所以一般用printf。</p><p><strong>puts</strong>函数原型可通过man 3 puts查看。</p><p>使用 puts()函数连换行符’ \n ‘都省了，函数内部会自动在其后添加一个换行符。</p><p><strong>putchar</strong>函数原型可通过man 3 putchar查看。</p><p>putchar()函数可以把参数 c 指定的字符（一个无符号字符）输出到标准输出设备，其输出可以是一个字符，可以是介于 0~127 之间的一个十进制整型数（包含 0 和 127，输出其对应的 ASCII 码字符），也可以是用 char 类型定义好的一个字符型变量。</p><p><strong>fputc</strong>函数原型可通过man 3 fputc查看</p><p>fputc()与 putchar()类似，也用于输出参数 c 指定的字符（一个无符号字符），与 putchar()区别在于，putchar()只能输出到标准输出设备，而 fputc()可把字符输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件。</p><p><strong>fputs</strong></p><p>fputs()与 puts()类似，也用于输出一条字符串，与 puts()区别在于，puts()只能输出到标准输出设备，而 fputs()可把字符串输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件。</p><h3 id="内存填充"><a href="#内存填充" class="headerlink" title="内存填充"></a>内存填充</h3><p>在编程中，经常需要将某一块内存中的数据全部设置为指定的值，譬如在定义数组、结构体这种类型变量时，通常需要对其进行初始化操作，而初始化操作一般都是将其占用的内存空间全部填充为 0。</p><p><strong>memset函数</strong>用于将某一块内存的数据全部设置为指定的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>s：需要进行数据填充的内存空间起始地址。<br>c：要被设置的值，该值以 int 类型传递。但在使用过程中是以无符号字符形式<br>n：填充的字节数。</p><p><strong>bzero函数</strong>用于将一块内存的数据都设置为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bzero</span><span class="params">(<span class="type">void</span> *s, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>s：内存空间的起始地址。<br>n：填充的字节数。<br>返回值：无返回值。</p><h3 id="Linux正则表达式"><a href="#Linux正则表达式" class="headerlink" title="Linux正则表达式"></a>Linux正则表达式</h3><p>正则表达式，又称为规则表达式（英语: Regular Expression），正则表达式通常被用来检索、替换那些符合某个模式（规则）的字符串，正则表达式描述了一种字符串的匹配模式（pattern），可以用来检查一个给定的字符串中是否含有某种子字符串、将匹配的字符串替换或者从某个字符串中取出符合某个条件的子字符串。</p><p>正则表达式其实也是一个字符串，该字符串由普通字符（譬如，数字 0~9、大小写字母以及其它字符）和特殊字符（称为“元字符”）所组成，由这些字符组成一个“规则字符串”，这个“规则字符串”用来表达对给定字符串的一种查找、匹配逻辑。</p><p><a href="https://www.runoob.com/regexp/regexp-intro.html">正则表达式 菜鸟教程</a></p><p>C语言中使用正则表达式一般分为三步：</p><p>1.编译正则表达式regcomp()</p><p>2匹配正则表达式regexec()</p><p>3释放正则表达式regfree()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">regmatch_t</span> pmatch = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">regex_t</span> reg;</span><br><span class="line"> <span class="type">char</span> errbuf[<span class="number">64</span>];</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">char</span> *sptr;</span><br><span class="line"> <span class="type">int</span> length;</span><br><span class="line"> <span class="type">int</span> nmatch; <span class="comment">//最多匹配出的结果</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">4</span> != argc) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="comment">/**********************************</span></span><br><span class="line"><span class="comment"> * 执行程序时需要传入两个参数:</span></span><br><span class="line"><span class="comment"> * arg1: 正则表达式</span></span><br><span class="line"><span class="comment"> * arg2: 待测试的字符串</span></span><br><span class="line"><span class="comment"> * arg3: 最多匹配出多少个结果</span></span><br><span class="line"><span class="comment"> **********************************/</span></span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;regex&gt; &lt;string&gt; &lt;nmatch&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(ret = regcomp(&amp;reg, argv[<span class="number">1</span>], REG_EXTENDED)) </span><br><span class="line">    &#123;</span><br><span class="line"> regerror(ret, &amp;reg, errbuf, <span class="keyword">sizeof</span>(errbuf));</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;regcomp error: %s\n&quot;</span>, errbuf);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 赋值操作 */</span></span><br><span class="line"> sptr = argv[<span class="number">2</span>]; <span class="comment">//待测试的字符串</span></span><br><span class="line"> length = <span class="built_in">strlen</span>(argv[<span class="number">2</span>]);<span class="comment">//获取字符串长度</span></span><br><span class="line"> nmatch = atoi(argv[<span class="number">3</span>]); <span class="comment">//获取最大匹配数</span></span><br><span class="line"> <span class="comment">/* 匹配正则表达式 */</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nmatch; j++) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="type">char</span> temp_str[<span class="number">100</span>];</span><br><span class="line"> <span class="comment">/* 调用 regexec 匹配正则表达式 */</span></span><br><span class="line"> <span class="keyword">if</span>(ret = regexec(&amp;reg, sptr, <span class="number">1</span>, &amp;pmatch, <span class="number">0</span>)) </span><br><span class="line">    &#123;</span><br><span class="line"> regerror(ret, &amp;reg, errbuf, <span class="keyword">sizeof</span>(errbuf));</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;regexec error: %s\n&quot;</span>, errbuf);</span><br><span class="line"> <span class="keyword">goto</span> out;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(<span class="number">-1</span> != pmatch.rm_so) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">if</span> (pmatch.rm_so == pmatch.rm_eo) </span><br><span class="line">        &#123;<span class="comment">//空字符串</span></span><br><span class="line"> sptr += <span class="number">1</span>;</span><br><span class="line"> length -= <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">//打印出空字符串</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt;= length)<span class="comment">//如果已经移动到字符串末尾、则退出</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">continue</span>; <span class="comment">//从 for 循环开始执行</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">memset</span>(temp_str, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(temp_str));<span class="comment">//清零缓冲区</span></span><br><span class="line"> <span class="built_in">memcpy</span>(temp_str, sptr + pmatch.rm_so,</span><br><span class="line"> pmatch.rm_eo - pmatch.rm_so);<span class="comment">//将匹配出来的子字符串拷贝到缓冲区</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, temp_str); <span class="comment">//打印字符串</span></span><br><span class="line">sptr += pmatch.rm_eo;</span><br><span class="line"> length -= pmatch.rm_eo;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt;= length)</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 释放正则表达式 */</span></span><br><span class="line">out:</span><br><span class="line"> regfree(&amp;reg);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习一个阶段的感受</title>
      <link href="/2022/11/18/2022-11-18-%E9%9A%8F%E7%AC%94/"/>
      <url>/2022/11/18/2022-11-18-%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>​目前在linux上学习了一个浅显的阶段，学会了命令行的一些常规的操作，也对Linux的内核有了少部分的了解，目前在C语言上的系统学习进入了尾声，之后应该就要时常复习C语言的编程，之前没有编写过底层，现在感觉C语言的应用编写确实复杂，主要是东西有点多，记不下来，打算趁着写选修论文的时候，用平时笔记复习复习，再加强一下C语言前些章节的编写能力，跨过这一阶段，再思考下一阶段科技树点哪的问题吧，科技树可真多呀，只能说还好现在课业不是很重。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文件属性</title>
      <link href="/2022/11/18/2022-11-18-Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/11/18/2022-11-18-Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>正所谓Linux下皆文件，系统下一共分为7种文件：</p><p><strong>①普通文件</strong></p><p>普通文件（regular file）在 Linux 系统下是最常见的，譬如文本文件、二进制文件，我们编写的源代码文件这些都是普通文件。</p><p>普通文件分为文本文件和二进制文件。</p><p>文本文件：文件中的内容是由文本构成的，所谓文本指的是 ASCII 码字符。文件中的内容其本质上都是数字。</p><p>二进制文件：二进制文件中存储的本质上也是数字，只不过对于二进制文件来说，这些数字并不是文本字符编码，而是真正的数字。譬如 Linux 系统下的可执行文件、C 代码编译之后得到的.o 文件、.bin 文件等都是二进制件。</p><p><strong>②目录文件</strong></p><p>目录（directory）就是文件夹，文件夹在 Linux 系统中也是一种文件，是一种特殊文件。</p><p><strong>③字符设备文件和块设备文件</strong></p><p>Linux 系统下，一切皆文件，也包括各种硬件设备。设备文件（字符设备文件、块设备文件）对应的是硬件设备，在 Linux 系统中，硬件设备会对应到一个设备文件，应用程序通过对设备文件的读写来操控、使用硬件设备。</p><p>Linux 系统中，可将硬件设备分为字符设备和块设备，所以就有了字符设备文件和块设备文件两种文件类型。虽然有设备文件，但是设备文件并不对应磁盘上的一个文件，也就是说设备文件并不存在于磁盘中，而是由文件系统虚拟出来的，一般是由内存来维护，当系统关机时，设备文件都会消失；字符设备文件一般存放在 Linux 系统&#x2F;dev&#x2F;目录下。</p><p><strong>④符号链接文件</strong></p><p>符号链接文件（link）类似于 Windows 系统中的快捷方式文件，是一种特殊文件，它的内容指向的是另一个文件路径，当对符号链接文件进行操作时，系统根据情况会对这个操作转移到它指向的文件上去，而不是对它本身进行操作。</p><p><strong>⑤管道文件</strong></p><p>管道文件（pipe）主要用于进程间通信。</p><p><strong>⑥套接字文件</strong></p><p>套接字文件（socket）也是一种进程间通信的方式，与管道文件不同的是，它们可以在不同主机上的进程间通信，实际上就是网络通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">stat</span> test_file<span class="comment">##可以查看文件属性</span></span></span><br></pre></td></tr></table></figure><p>这个命令内部就是通过调用 stat()函数来获取文件属性的，stat 函数是 Linux 中的系统调用，用于获取文件相关的信息，函数原型如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p>函数参数及返回值含义如下：<br>pathname：用于指定一个需要查看属性的文件路径。<br>buf：struct stat 类型指针，用于指向一个 struct stat 结构体变量。调用 stat 函数的时候需要传入一个 struct<br>stat 变量的指针，获取到的文件属性信息就记录在 struct stat 结构体中，稍后给大家介绍 struct stat 结构体中有记录了哪些信息。<br>返回值：成功返回 0；失败返回-1，并设置 error。</p><h4 id="struct-stat-结构体"><a href="#struct-stat-结构体" class="headerlink" title="struct stat 结构体"></a>struct stat 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">dev_t</span> st_dev; <span class="comment">/* 文件所在设备的 ID */</span></span><br><span class="line"> <span class="type">ino_t</span> st_ino; <span class="comment">/* 文件对应 inode 节点编号 */</span></span><br><span class="line"> <span class="type">mode_t</span> st_mode; <span class="comment">/* 文件对应的模式 */</span></span><br><span class="line"> <span class="type">nlink_t</span> st_nlink; <span class="comment">/* 文件的链接数 */</span></span><br><span class="line"> <span class="type">uid_t</span> st_uid; <span class="comment">/* 文件所有者的用户 ID */</span></span><br><span class="line"> <span class="type">gid_t</span> st_gid; <span class="comment">/* 文件所有者的组 ID */</span></span><br><span class="line"> <span class="type">dev_t</span> st_rdev; <span class="comment">/* 设备号（指针对设备文件） */</span></span><br><span class="line"> <span class="type">off_t</span> st_size; <span class="comment">/* 文件大小（以字节为单位） */</span></span><br><span class="line"> <span class="type">blksize_t</span> st_blksize; <span class="comment">/* 文件内容存储的块大小 */</span></span><br><span class="line"> <span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* 文件内容所占块数 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span> <span class="comment">/* 文件最后被访问的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span> <span class="comment">/* 文件内容最后被修改的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span> <span class="comment">/* 文件状态最后被改变的时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="st-mode变量"><a href="#st-mode变量" class="headerlink" title="st_mode变量"></a>st_mode变量</h4><p>st_mode 是 structstat 结构体中的一个成员变量，是一个 32 位无符号整形数据，该变量记录了文件的类型、文件的权限这些信息。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/st_mode.png"></p><p>这些 bit 位表达内容与 open 函数的 mode 参数相对应，这里不再重述。同样，在 mode 参数中表示权限的宏定义，在这里也是可以使用的，这些宏定义如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">S_IRWXU 00700 owner has read, write, and execute permission</span><br><span class="line">S_IRUSR 00400 owner has read permission</span><br><span class="line">S_IWUSR 00200 owner has write permission</span><br><span class="line">S_IXUSR 00100 owner has execute permission</span><br><span class="line">S_IRWXG 00070 group has read, write, and execute permission</span><br><span class="line">S_IRGRP 00040 group has read permission</span><br><span class="line">S_IWGRP 00020 group has write permission</span><br><span class="line">S_IXGRP 00010 group has execute permission</span><br><span class="line">S_IRWXO 00007 others (not in group) have read, write, and execute permission</span><br><span class="line">S_IROTH 00004 others have read permission</span><br><span class="line">S_IWOTH 00002 others have write permission</span><br><span class="line">S_IXOTH 00001 others have execute permission</span><br><span class="line"></span><br><span class="line">S_IFSOCK 0140000 socket（套接字文件）</span><br><span class="line">S_IFLNK 0120000 symbolic link（链接文件）</span><br><span class="line">S_IFREG 0100000 regular file（普通文件）</span><br><span class="line">S_IFBLK 0060000 block device（块设备文件）</span><br><span class="line">S_IFDIR 0040000 directory（目录）</span><br><span class="line">S_IFCHR 0020000 character device（字符设备文件）</span><br><span class="line">S_IFIFO 0010000 FIFO（管道文件）</span><br><span class="line"></span><br><span class="line">S_ISREG(m) #判断是不是普通文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISDIR(m) #判断是不是目录，如果是返回 true，否则返回 false</span><br><span class="line">S_ISCHR(m) #判断是不是字符设备文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISBLK(m) #判断是不是块设备文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISFIFO(m) #判断是不是管道文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISLNK(m) #判断是不是链接文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISSOCK(m) #判断是不是套接字文件，如果是返回 true，否则返回 false</span><br></pre></td></tr></table></figure><h4 id="struct-timespec结构体"><a href="#struct-timespec结构体" class="headerlink" title="struct timespec结构体"></a>struct timespec结构体</h4><p>该结构体定义在头文件中，是 Linux 系统中时间相关的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">time_t</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"> <span class="type">syscall_slong_t</span> tv_nsec; <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="fstat和lstat函数"><a href="#fstat和lstat函数" class="headerlink" title="fstat和lstat函数"></a>fstat和lstat函数</h4><p><strong>fstat函数</strong></p><p>fstat 与 stat 区别在于，stat 是从文件名出发得到文件属性信息，不需要先打开文件；而 fstat 函数则是从文件描述符出发得到文件属性信息，所以使用 fstat 函数之前需要先打开文件得到文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p><strong>lstat 函数</strong></p><p>lstat()与 stat、fstat 的区别在于，对于符号链接文件，stat、fstat 查阅的是符号链接文件所指向的文件对应的文件属性信息，而 lstat 查阅的是符号链接文件本身的属性信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><h3 id="文件属主"><a href="#文件属主" class="headerlink" title="文件属主"></a>文件属主</h3><p>Linux 是一个多用户操作系统，系统中一般存在着好几个不同的用户，而 Linux 系统中的每一个文件都有一个与之相关联的用户和用户组，通过这个信息可以判断文件的所有者和所属组。</p><p>文件所有者表示该文件属于“谁”，也就是属于哪个用户。一般来说文件在创建时，其所有者就是创建该文件的那个用户。文件所属组则表示该文件属于哪一个用户组。在 Linux 中，系统并不是通过用户名或用户组名来识别不同的用户和用户组，而是通过 ID。ID 就是一个编号，Linux 系统会为每一个用户或用户组分配一个 ID，将用户名或用户组名与对应的 ID 关联起来，所以系统通过用户 ID（UID）或组 ID（GID）就可以识别出不同的用户和用组。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/ID.png"></p><h4 id="有效用户-ID-和有效组-ID"><a href="#有效用户-ID-和有效组-ID" class="headerlink" title="有效用户 ID 和有效组 ID"></a>有效用户 ID 和有效组 ID</h4><p>这是进程所持有的概念，对于文件来说，并无此属性！有效用户 ID 和有效组 ID 是站在操作系统的角度，用于给操作系统判断当前执行该进程的用户在当前环境下对某个文件是否拥有相应的权限。</p><p>当进行权限检查时，并不是通过进程的实际用户和实际组来参与权限检查的，而是通过有效用户和有效组来参与文件权限检查。</p><p><strong>chown函数</strong></p><p>chown 是一个系统调用，该系统调用可用于改变文件的所有者（用户 ID）和所属组（组 ID）。其实在Linux 系统下也有一个 chown 命令，该命令的作用也是用于改变文件的所有者和所属组，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> root:root testApp.c<span class="comment">##该命令的作用也是用于改变文件的所有者和所属组</span></span></span><br></pre></td></tr></table></figure><h4 id="chown函数原型"><a href="#chown函数原型" class="headerlink" title="chown函数原型"></a>chown函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值如下所示：<br>pathname：用于指定一个需要修改所有者和所属组的文件路径。<br>owner：将文件的所有者修改为该参数指定的用户（以用户 ID 的形式描述）；<br>group：将文件的所属组修改为该参数指定的用户组（以用户组 ID 的形式描述）；<br>返回值：成功返回 0；失败将返回-1，兵并且会设置 errno。</p><p>有以下两个限制条件：</p><p>⚫ 只有超级用户进程能更改文件的用户 ID；<br>⚫ 普通用户进程可以将文件的组 ID 修改为其所从属的任意附属组 ID，前提条件是该进程的有效用户 ID 等于文件的用户 ID；而超级用户进程可以将文件的组 ID 修改为任意值。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == chown(<span class="string">&quot;./test_file&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;chown error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Linux 系统下，可以使用 getuid 和 getgid 两个系统调用分别用于获取当前进程的用户 ID 和用户组ID，这里说的进程的用户 ID 和用户组 ID 指的就是进程的实际用户 ID 和实际组 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;uid: %d\n&quot;</span>, getuid());</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == chown(<span class="string">&quot;./test_file&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;chown error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h3><p>struct stat 结构体中的 st_mode 字段记录了文件的访问权限位。当提及到文件时，并不仅仅指的是普通文件；所有文件类型（目录、设备文件）都有访问权限（access permission）。</p><p>文件的权限可以分为两个大类，分别是<u>普通权限和特殊权限</u>（也可称为附加权限）。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls-l##查看访问权限</span><br></pre></td></tr></table></figure><p><strong><u>-rwxrwxr-x</u></strong></p><p>-表示文件类型，前三位rwx为所有者权限，中间三位为同组用户权限，后三位为其它用户权限。</p><p>r表示具有读权限；w表示具有写权限；x表示具有执行权限；-表示没有权限</p><p><em><strong>当进程每次对文件进行读、写、执行等操作时，内核就会对文件进行访问权限检查，以确定该进程对文件是否拥有相应的权限。</strong></em>而对于进程来说，参与文件权限检查的是进程的有效用户、有效用户组以及进程的附属组用户。</p><p>如何判断权限，首先要搞清楚该进程对于需要进行操作的文件来说是属于哪一类“角色”：<br>⚫ 如果进程的有效用户 ID 等于文件所有者 ID（st_uid），意味着该进程以文件所有者的角色存在；<br>⚫ 如果进程的有效用户 ID 并不等于文件所有者 ID，意味着该进程并不是文件所有者身份；但是进程<br>的有效用户组 ID 或进程的附属组 ID 之一等于文件的组 ID（st_gid），那么意味着该进程以文件所<br>属组成员的角色存在，也就是文件所属组的同组用户成员。<br>⚫ 如果进程的有效用户 ID 不等于文件所有者 ID、并且进程的有效用户组 ID 或进程的所有附属组 ID<br>均不等于文件的组 ID（st_gid），那么意味着该进程以其它用户的角色存在。<br>⚫ 如果进程的有效用户 ID 等于 0（root 用户），则无需进行权限检查，直接对该文件拥有最高权限。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90.png"></p><p>宏定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S_ISUID 04000 set-user-ID bit</span><br><span class="line">S_ISGID 02000 set-group-ID bit (see below)</span><br><span class="line">S_ISVTX 01000 sticky bit (see below)</span><br></pre></td></tr></table></figure><p>譬如通过 st_mode 变量判断文件是否设置了 set-user-ID 位权限，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st.st_mode &amp; S_ISUID) &#123;</span><br><span class="line"><span class="comment">//设置了 set-user-ID 位权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//没有设置 set-user-ID 位权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种权限位的具体作用：</p><p>⚫ 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-user-ID 位权限被设置，内核会将进程的有效 ID 设置为该文件的用户 ID（文件所有者 ID），意味着该进程直接获取了文件所有的权限、以文件所有者的身份操作该文件。<br>⚫ 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-group-ID 位权限被设置，内核会将进程的有效用户组 ID 设置为该文件的用户组 ID（文件所属组 ID），意味着该进程直接获取了文件所属组成员的权限、以文件所属组成员的身份操作该文件。</p><h4 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h4><p>⚫ 目录的读权限：可列出（譬如：通过 ls 命令）目录之下的内容（即目录下有哪些文件）。<br>⚫ 目录的写权限：可以在目录下创建文件、删除文件。<br>⚫ 目录的执行权限：可访问目录下的文件，譬如对目录下的文件进行读、写、执行等操作。</p><p>要想访问目录下的文件，譬如查看文件的 inode 节点、大小、权限等信息，还需要对目录拥有执行权限。反之，若拥有对目录的执行权限、而无读权限，只要知道目录内文件的名称，仍可对其进行访问，但不能列出目录下的内容（即目录下包含的其它文件的名称）。要想在目录下创建文件或删除原有文件，需要同时拥有对该目录的执行和写权限。</p><h4 id="检查文件权限"><a href="#检查文件权限" class="headerlink" title="检查文件权限"></a>检查文件权限</h4><p>文件的权限检查不只关于文件本身的权限，还需要涉及到文件所在目录的权限，只有同时都满足了，才能通过操作系统的权限检查，进而才可以对文件进行相关操作。可以通过access来检查执行进程的用户是否对该文件拥有应的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要进行权限检查的文件路径。<br>mode：该参数可以取以下值：<br>pathname：需要进行权限检查的文件路径。<br>mode：该参数可以取以下值：<br>⚫ F_OK：检查文件是否存在<br>⚫ R_OK：检查是否拥有读权限<br>⚫ W_OK：检查是否拥有写权限<br>⚫ X_OK：检查是否拥有执行权限</p><p>返回值：检查项通过则返回 0，表示拥有相应的权限并且文件存在；否则返回-1，如果多个检查项组合在一起，只要其中任何一项不通过都会返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_FILE <span class="string">&quot;./test_file&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 检查文件是否存在 */</span></span><br><span class="line"> ret = access(MY_FILE, F_OK);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%: file does not exist.\n&quot;</span>, MY_FILE);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 检查权限 */</span></span><br><span class="line"> ret = access(MY_FILE, R_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Read permission: Yes\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Read permission: NO\n&quot;</span>);</span><br><span class="line"> ret = access(MY_FILE, W_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Write permission: Yes\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Write permission: NO\n&quot;</span>);</span><br><span class="line"> ret = access(MY_FILE, X_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Execution permission: Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Execution permission: NO\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>在 Linux 系统下，可以使用 chmod 命令修改文件权限，该命令内部实现方法其实是调用了 chmod 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要进行权限修改的文件路径，若该参数所指为符号链接，实际改变权限的文件是符号链接所指向的文件，而不是符号链接文件本身。<br>mode：该参数用于描述文件权限，与 open 函数的第三个参数一样，这里不再重述，可以直接使用八进制数据来描述，也可以使用相应的权限宏（单个或通过位或运算符” | “组合）。<br>返回值：成功返回 0；失败返回-1，并设置 errno。</p><p>fchmod()与 chmod()的区别在于使用了文件描述符来代替文件路径，就像是 fstat 与 stat 的区别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><h4 id="umask函数"><a href="#umask函数" class="headerlink" title="umask函数"></a>umask函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umask##查看/设置权限掩码</span><br></pre></td></tr></table></figure><p>权限掩码主要用于对新建文件的权限进行屏蔽。权限掩码的表示方式与文件权限的表示方式相同，但是需要去除特殊权限位，umask 不能对特殊权限位进行屏蔽。</p><p>umask 权限掩码是进程的一种属性，用于指明该进程新建文件或目录时，应屏蔽哪些权限位。进程的umask 通常继承至其父进程，譬如在 Ubuntu shell终端下执行的应用程序，它的 umask 继承至该 shell 进程。</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>mask：需要设置的权限掩码值，可以发现 make 参数的类型与 open 函数、chmod 函数中的 mode 参数对应的类型一样，所以其表示方式也是一样的，前面也给大家介绍了，既可以使用数字表示（譬如八进制数），也可以直接使用宏（S_IRUSR、S_IWUSR 等）。<br>返回值：返回设置之前的 umask 值，也就是旧的 umask。</p><h3 id="文件的时间属性"><a href="#文件的时间属性" class="headerlink" title="文件的时间属性"></a>文件的时间属性</h3><p>文件最后被访问的时间、文件内容最后被修改的时间以及文件状态最后被改变的时间，分别记录在 struct stat 结构体的 st_atim、st_mtim 以及 st_ctim 变量中。</p><table><thead><tr><th align="center">字段</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">st_atim</td><td align="center">文件最后被访问的时间</td></tr><tr><td align="center">st_mtim</td><td align="center">文件内容最后被修改的时间</td></tr><tr><td align="center">st_ctim</td><td align="center">文件状态最后被改变的时间</td></tr></tbody></table><p>⚫ 文件最后被访问的时间：访问指的是读取文件内容，文件内容最后一次被读取的时间，譬如使用read()函数读取文件内容便会改变该时间属性；<br>⚫ 文件内容最后被修改的时间：文件内容发生改变，譬如使用 write()函数写入数据到文件中便会改变该时间属性；<br>⚫ 文件状态最后被改变的时间：状态更改指的是该文件的 inode 节点最后一次被修改的时间，譬如更改文件的访问权限、更改文件的用户 ID、用户组 ID、更改链接数等，但它们并没有更改文件的实际内容，也没有访问（读取）文件内容。inode 中包含了很多文件信息，譬如：文件字节大小、文件所有者、文件对应的读&#x2F;写&#x2F;执行权限、文件时间戳（时间属性）、文件数据存储的 block（块）等，所以由此可知，状态的更改指的就是 inode 节点内容的更改。譬如 chmod()、chown()等<br>这些函数都能改变该时间属性。</p><p>列出了一些系统调用或 C 库函数对文件时间属性的影响，有些操作并不仅仅只会影响文件本身的时间属性，还会影响到其父目录的相关时间属性。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/time.png"></p><h4 id="utime-、utimes-修改时间属性"><a href="#utime-、utimes-修改时间属性" class="headerlink" title="utime()、utimes()修改时间属性"></a>utime()、utimes()修改时间属性</h4><p>utime()函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span>;</span><br></pre></td></tr></table></figure><p>filename：需要修改时间属性的文件路径。<br>times：将时间属性修改为该参数所指定的时间值，times 是一个 struct utimbuf 结构体类型的指针，如果times 参数设置为 NULL，则会将文件的访问时间和修改时间设置为系统当前时间。<br>返回值：成功返回值 0；失败将返回-1，并会设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">time_t</span> actime; <span class="comment">/* 访问时间 */</span></span><br><span class="line"><span class="type">time_t</span> modtime; <span class="comment">/* 内容修改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体中包含了两个 time_t 类型的成员，分别用于表示访问时间和内容修改时间，time_t 类型其实就是 long int 类型。</p><p>同样对于文件来说，时间属性也是文件非常重要的属性之一，对文件时间属性的修改也不是任何用户都可以随便修改的，只有以下两种进程可对其进行修改：<br>⚫ 超级用户进程（以 root 身份运行的进程）。<br>⚫ 有效用户 ID 与该文件用户 ID（文件所有者）相匹配的进程。<br>⚫ 在参数 times 等于 NULL 的情况下，对文件拥有写权限的进程。<br>除以上三种情况之外的用户进程将无法对文件时间戳进行修改。</p><p>utimes函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> timeval times[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>filename：需要修改时间属性的文件路径。<br>times：将时间属性修改为该参数所指定的时间值，times 是一个 struct timeval 结构体类型的数组，数组共有两个元素，第一个元素用于指定访问时间，第二个元素用于指定内容修改时间，稍后给大家介绍，如果times 参数为 NULL，则会将文件的访问时间和修改时间设置为当前时间。<br>返回值：成功返回 0；失败返回-1，并且会设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">long</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"><span class="type">long</span> tv_usec; <span class="comment">/* 微秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="futimens-、utimensat-修改时间属性"><a href="#futimens-、utimensat-修改时间属性" class="headerlink" title="futimens()、utimensat()修改时间属性"></a>futimens()、utimensat()修改时间属性</h4><p>futimens()、utimensat()函数是两个系统调用由于显示修改文件时间。</p><p>这两个系统调用相对于 utime 和 utimes 函数有以下三个优点：<br>⚫ 可按纳秒级精度设置时间戳。相对于提供微秒级精度的 utimes()，这是重大改进！<br>⚫ 可单独设置某一时间戳。譬如，只设置访问时间、而修改时间保持不变，如果要使用 utime()或 utimes()来实现此功能，则需要首先使用 stat()获取另一个时间戳的值，然后再将获取值与打算变更的时间戳一同指定。<br>⚫ 可独立将任一时间戳设置为当前时间。使用 utime()或 utimes()函数虽然也可以通过将 times 参数设置为NULL 来达到将时间戳设置为当前时间的效果，但是不能单独指定某一个时间戳，必须全部设置为当前时间（不考虑使用额外函数获取当前时间的方式，譬如 time()）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">futimens</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>fd：文件描述符。<br>times：将时间属性修改为该参数所指定的时间值，times 指向拥有 2 个 struct timespec 结构体类型变量的数组，数组共有两个元素，第一个元素用于指定访问时间，第二个元素用于指定内容修改时间。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>该函数的时间戳可以按下列 4 种方式之一进行指定：<br>⚫ 如果 times 参数是一个空指针，也就是 NULL，则表示将访问时间和修改时间都设置为当前时间。<br>⚫ 如果 times 参数指向两个 struct timespec 结构体类型变量的数组，任一数组元素的 tv_nsec 字段的值设置为 UTIME_NOW，则表示相应的时间戳设置为当前时间，此时忽略相应的 tv_sec 字段。<br>⚫ 如果 times 参数指向两个 struct timespec 结构体类型变量的数组，任一数组元素的 tv_nsec 字段的值设置为 UTIME_OMIT，则表示相应的时间戳保持不变，此时忽略 tv_sec 字段。<br>⚫ 如果 times 参数指向两个 struct timespec 结构体类型变量的数组，且 tv_nsec 字段的值既不是UTIME_NOW 也不是 UTIME_OMIT，在这种情况下，相应的时间戳设置为相应的 tv_sec 和 tv_nsec字段指定的值。</p><p>使用 <u>futimens()函数只有以下进程，可对文件时间戳进行修改：</u><br>⚫ 超级用户进程。<br>⚫ 在参数 times 等于 NULL 的情况下，对文件拥有写权限的进程。<br>⚫ 有效用户 ID 与该文件用户 ID（文件所有者）相匹配的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_FILE <span class="string">&quot;./test_file&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tmsp_arr</span>[2];</span></span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="comment">/* 检查文件是否存在 */</span></span><br><span class="line"> ret = access(MY_FILE, F_OK);</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Error: %s file does not exist!\n&quot;</span>, MY_FILE);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(MY_FILE, O_RDONLY);</span><br><span class="line"> <span class="keyword">if</span> (fd == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 修改文件时间戳 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"> ret = futimens(fd, <span class="literal">NULL</span>); <span class="comment">//同时设置为当前时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"> tmsp_arr[<span class="number">0</span>].tv_nsec = UTIME_OMIT;<span class="comment">//访问时间保持不变</span></span><br><span class="line"> tmsp_arr[<span class="number">1</span>].tv_nsec = UTIME_NOW;<span class="comment">//内容修改时间设置为当期时间</span></span><br><span class="line"> ret = futimens(fd, tmsp_arr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"> tmsp_arr[<span class="number">0</span>].tv_nsec = UTIME_NOW;<span class="comment">//访问时间设置为当前时间</span></span><br><span class="line"> tmsp_arr[<span class="number">1</span>].tv_nsec = UTIME_OMIT;<span class="comment">//内容修改时间保持不变</span></span><br><span class="line"> ret = futimens(fd, tmsp_arr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;futimens error&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line">err:</span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utimensat()函数功能也是一样的，具体可以使用man 2  utimensat查询用法</p><h3 id="符号链接与硬链接"><a href="#符号链接与硬链接" class="headerlink" title="符号链接与硬链接"></a>符号链接与硬链接</h3><p>在 Linux 系统中有两种链接文件，分为软链接（也叫符号链接）文件和硬链接文件，软链接文件也就是前面给大家的 Linux 系统下的七种文件类型之一，其作用类似于 Windows 下的快捷方式。硬链接两个文件相互影响。</p><p>复习一下shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ln</span> 源文件 链接文件<span class="comment">##硬链接</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ln-s 源文件 链接文件<span class="comment">##软链接</span></span></span><br></pre></td></tr></table></figure><p>使用 ln 命令创建的两个硬链接文件与源文件 test_file 都拥有相同的 inode 号，既然inode 相同，也就意味着它们指向了物理硬盘的同一个区块，仅仅只是文件名字不同而已，创建出来的硬链接文件与源文件对文件系统来说是完全平等的关系。</p><p>当为文件每创建一个硬链接，inode 节点上的链接数就会加一，每删除一个硬链接，inode 节点上的链接数就会减一，直到为 0，inode 节点和对应的数据块才会被文件系统所回收，也就意味着文件已经从文件系统中被删除了。</p><p>软链接文件与源文件有着不同的 inode 号，所以也就是意味着它们之间有着不同的数据块，但是软链接文件的数据块中存储的是源文件的路径名，链接文件可以通过这个路径找到被链接的源文件，它们之间类似于一种“主从”关系，当源文件被删除之后，软链接文件依然存在，但此时它指向的是一个无效的文件路径，这种链接文件被称为悬空链接。</p><p>⚫ 不能对目录创建硬链接（超级用户可以创建，但必须在底层文件系统支持的情况下）。<br>⚫ 硬链接通常要求链接文件和源文件位于同一文件系统中。<br>而软链接文件的使用并没有上述限制条件，优点如下所示：<br>⚫ 可以对目录创建软链接；<br>⚫ 可以跨越不同文件系统；<br>⚫ 可以对不存在的文件创建软链接。</p><h4 id="创建硬链接link"><a href="#创建硬链接link" class="headerlink" title="创建硬链接link"></a>创建硬链接link</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure><p>oldpath：用于指定被链接的源文件路径，应避免 oldpath 参数指定为软链接文件，为软链接文件创建硬链接没有意义，虽然并不会报错。<br>newpath：用于指定硬链接文件路径，如果 newpath 指定的文件路径已存在，则会产生错误。<br>返回值：成功返回 0；失败将返回-1，并且会设置 errno。</p><h4 id="创建软链接symlink"><a href="#创建软链接symlink" class="headerlink" title="创建软链接symlink"></a>创建软链接symlink</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>target：用于指定被链接的源文件路径，target 参数指定的也可以是一个软链接文件。<br>linkpath：用于指定硬链接文件路径，如果 newpath 指定的文件路径已存在，则会产生错误。<br>返回值：成功返回 0；失败将返回-1，并会设置 errno。<br>创建软链接时，并不要求 target 参数指定的文件路径已经存在，如果文件不存在，那么创建的软链接将成为“悬空链接”。</p><h4 id="读取软链接文件"><a href="#读取软链接文件" class="headerlink" title="读取软链接文件"></a>读取软链接文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *buf, <span class="type">size_t</span> bufsiz)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要读取的软链接文件路径。只能是软链接文件路径，不能是其它类型文件，否则调用函<br>数将报错。<br>buf：用于存放路径信息的缓冲区。<br>bufsiz：读取大小，一般读取的大小需要大于链接文件数据块中存储的文件路径信息字节大小。<br>返回值：失败将返回-1，并会设置 errno；成功将返回读取到的字节数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *buf, <span class="type">size_t</span> bufsiz)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要读取的软链接文件路径。只能是软链接文件路径，不能是其它类型文件，否则调用函数将报错。<br>buf：用于存放路径信息的缓冲区。<br>bufsiz：读取大小，一般读取的大小需要大于链接文件数据块中存储的文件路径信息字节大小。<br>返回值：失败将返回-1，并会设置 errno；成功将返回读取到的字节数。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="目录存储形式"><a href="#目录存储形式" class="headerlink" title="目录存储形式"></a>目录存储形式</h4><p>目录这种特殊文件在文件系统中的存储形式，其实目录在文件系统中的存储方式与常规文件类似，常规文件包括了 inode 节点以及文件内容数据存储块（block），但对于目录来说，其存储形式则是由 inode 节点和目录块所构成，目录块当中记录了有哪些文件组织在这个目录下，记录它们的文件名以及对应的 inode 编号。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/guazai.jpg"></p><p>目录块当中有多个目录项（或叫目录条目），每一个目录项（或目录条目）都会对应到该目录下的某一个文件，目录项当中记录了该文件的文件名以及它的 inode 节点编号，所以通过目录的目录块便可以遍历找到该目录下的所有文件以及所对应的 inode 节点。<br>所以对此总结如下：<br>⚫ 普通文件由 inode 节点和数据块构成<br>⚫ 目录由 inode 节点和目录块构成</p><h4 id="创建删除目录"><a href="#创建删除目录" class="headerlink" title="创建删除目录"></a>创建删除目录</h4><p><strong>mkdir函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要创建的目录路径。<br>mode：新建目录的权限设置，设置方式与 open 函数的 mode 参数一样，最终权限为（mode &amp; ~umask）。<br>返回值：成功返回 0；失败将返回-1，并会设置 errno。<br>pathname 参数指定的新建目录的路径，该路径名可以是相对路径，也可以是绝对路径，若指定的路径名已经存在，则调用 mkdir()将会失败。<br>mode 参数指定了新目录的权限，目录拥有与普通文件相同的权限位，但是其表示的含义与普通文件却有不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> ret = mkdir(<span class="string">&quot;./new_dir&quot;</span>, S_IRWXU |</span><br><span class="line"> S_IRGRP | S_IXGRP |</span><br><span class="line">S_IROTH | S_IXOTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;mkdir error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除目录rmdir</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要删除的目录对应的路径名，并且该目录必须是一个空目录，也就是该目录下只有.和..这两个目录项；pathname 指定的路径名不能是软链接文件，即使该链接文件指向了一个空目录。<br>返回值：成功返回 0；失败将返回-1，并会设置 errno。</p><p><strong>打开、读取以及关闭目录</strong></p><p><strong>opendir()函数</strong>用于打开一个目录，并返回指向该目录的句柄，供后续操作使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>name：指定需要打开的目录路径名，可以是绝对路径，也可以是相对路径。<br>返回值：成功将返回指向该目录的句柄，一个 DIR 指针（其实质是一个结构体指针），其作用类似于<br>open函数返回的文件描述符fd，后续对该目录的操作需要使用该DIR指针变量；若调用失败，则返回NULL。</p><p>**readdir()**用于读取目录，获取目录下所有文件的名称以及对应 inode 号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><p>dirp：目录句柄 DIR 指针。<br>返回值：返回一个指向 struct dirent 结构体的指针，该结构体表示 dirp 指向的目录流中的下一个目录条目。在到达目录流的末尾或发生错误时，它返回 NULL。</p><p><u>“流”这个概念是动态的，而不是静态的。编程当中提到这个概念，一般都是与 I&#x2F;O 相关，所以也经常叫做 I&#x2F;O 流；但对于目录这种特殊文件来说，这里将目录块中存储的数据称为目录流，存储了一个一个的目录项（目录条目）。</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">ino_t</span> d_ino; <span class="comment">/* inode 编号 */</span></span><br><span class="line"> <span class="type">off_t</span> d_off; <span class="comment">/* not an offset; see NOTES */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this record */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* type of file; not supported by all filesystem types */</span></span><br><span class="line"> <span class="type">char</span> d_name[<span class="number">256</span>]; <span class="comment">/* 文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每调用一次 readdir()，就会从 drip 所指向的目录流中读取下一条目录项（目录条目），并返回 struct dirent结构体指针，指向经静态分配而得的 struct dirent 类型结构，每次调用 readdir()都会覆盖该结构。一旦遇到目录结尾或是出错，readdir()将返回 NULL，针对后一种情况，还会设置 errno 以示具体错误。</p><p>那如何区别究竟是到了目录末尾还是出错了呢，可通过如下代码进行判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error = <span class="number">0</span>;</span><br><span class="line">direntp = readdir(dirp);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == direntp) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != error) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 出现了错误 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 已经到了目录末尾 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rewinddir()</strong><u>可将目录流重置为目录起点。</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewinddir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><p>dirp：目录句柄。<br>返回值：无返回值。</p><p>关闭目录close()函数用于关闭处于打开状态的目录，同时释放他所用的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><p>dirp：目录句柄。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p><strong>进程的当前工作目录</strong></p><p>Linux 下的每一个进程都有自己的当前工作目录（current working directory），当前工作目录是该进程解析、搜索相对路径名的起点。</p><p>一般情况下，运行一个进程时、其父进程的当前工作目录将被该进程所继承，成为该进程的当前工作目录。可通过 getcwd 函数来获取进程的当前工作目录，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>buf：getcwd()将内含当前工作目录绝对路径的字符串存放在 buf 缓冲区中。<br>size：缓冲区的大小，分配的缓冲区大小必须要大于字符串长度，否则调用将会失败。<br>返回值：如果调用成功将返回指向 buf 的指针，失败将返回 NULL，并设置 errno。</p><p><strong>改变当前工作目录</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchdir</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>path：将进程的当前工作目录更改为 path 参数指定的目录，可以是绝对路径、也可以是相对路径，指定的目录必须要存在，否则会报错。<br>fd：将进程的当前工作目录更改为 fd 文件描述符所指定的目录（譬如使用 open 函数打开一个目录）。<br>返回值：成功均返回 0；失败均返回-1，并设置 errno。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><strong>使用unlink函数删除一个文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要删除的文件路径，可使用相对路径、也可使用绝对路径，如果 pathname 参数指定的文件不存在，则调用 unlink()失败。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>unlink()系统调用实质上是移除 pathname 参数指定的文件路径对应的目录项（从其父级目录中移除该目录项），并将文件的 inode 链接计数将 1，如果该文件还有其它硬链接，则任可通过其它链接访问该文件的数据；只有当链接计数变为 0 时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内容—只要有进程打开了该文件，其内容也不能被删除。关闭一个文件时，内核会检查打开该文件的进程个数，如果这个计数达到 0，内核再去检查其链接计数，如果链接计数也是 0，那么就删除该文件对应的内容（也就是文件对应的 inode 以及数据块被回收，如果一个文件存在多个硬链接，删除其中任何一个硬链接，其inode 和数据块并没有被回收，还可通过其它硬链接访问文件的数据）。</p><p><strong>使用 remove 函数删除文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要删除的文件或目录路径，可以是相对路径、也可是决定路径。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。<br>pathname 参数指定的是一个非目录文件，那么 remove()去调用 unlink()，如果 pathname 参数指定的是一个目录，那么 remove()去调用 rmdir()。</p><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>本小节给大家介绍 rename()系统调用，借助于 rename()既可以对文件进行重命名，又可以将文件移至同一文件系统中的另一个目录下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure><p>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>根据 oldpath、newpath 的不同，有以下不同的情况需要进行说明：<br>⚫ 若 newpath 参数指定的文件或目录已经存在，则将其覆盖；<br>⚫ 若 newpath 和 oldpath 指向同一个文件，则不发生变化（且调用成功）。<br>⚫ rename()系统调用对其两个参数中的软链接均不进行解引用。如果 oldpath 是一个软链接，那么将重命名该软链接；如果 newpath 是一个软链接，则会将其移除、被覆盖。<br>⚫ 如果 oldpath 指代文件，而非目录，那么就不能将 newpath 指定为一个目录的路径名。要想重命名<br>一个文件到某一个目录下，newpath 必须包含新的文件名。<br>⚫ 如果 oldpath 指代为一个目录，在这种情况下，newpath 要么不存在，要么必须指定为一个空目录。<br>⚫ oldpath 和 newpath 所指代的文件必须位于同一文件系统。由前面的介绍，可以得出此结论！<br>⚫ 不能对.（当前目录）和..（上一级目录）进行重命名。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux标准IO库</title>
      <link href="/2022/11/12/2022-11-12-Linux%E6%A0%87%E5%87%86IO%E5%BA%93/"/>
      <url>/2022/11/12/2022-11-12-Linux%E6%A0%87%E5%87%86IO%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="标准IO库"><a href="#标准IO库" class="headerlink" title="标准IO库"></a>标准IO库</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓标准 I&#x2F;O 库则是标准 C 库中用于文件 I&#x2F;O 操作（譬如读文件、写文件等）相关的一系列库函数的集合，通常标准 I&#x2F;O 库函数相关的函数定义都在头文件中。</p><p><u>设计库函数是为了提供比底层系统调用更为方便、好用的调用接口，虽然标准 I&#x2F;O 构建于文件 I&#x2F;O 之上，但标准 I&#x2F;O 却有它自己的优势。</u></p><p>标准 I&#x2F;O 和文件 I&#x2F;O 的区别如下：</p><p>⚫ 虽然标准 I&#x2F;O 和文件 I&#x2F;O 都是 C 语言函数，但是标准 I&#x2F;O 是标准 C 库函数，而文件 I&#x2F;O 则是 Linux<br>系统调用；<br>⚫ 标准 I&#x2F;O 是由文件 I&#x2F;O 封装而来，标准 I&#x2F;O 内部实际上是调用文件 I&#x2F;O 来完成实际操作的；<br>⚫ 可移植性：标准 I&#x2F;O 相比于文件 I&#x2F;O 具有更好的可移植性。</p><p>⚫ 性能、效率：标准 I&#x2F;O 库在用户空间维护了自己的 stdio 缓冲区，所以标准 I&#x2F;O 是带有缓存的，而<br>文件 I&#x2F;O 在用户空间是不带有缓存的，所以在<em>性能、效率上，标准 I&#x2F;O 要优于文件 I&#x2F;O</em>。</p><h3 id="FILE-指针"><a href="#FILE-指针" class="headerlink" title="FILE 指针"></a>FILE 指针</h3><p>而对于标准 I&#x2F;O 库函数来说，它们的操作是围绕 FILE 指针进行的，当使用标准 I&#x2F;O 库函数打开或创建一个<br>文件时，会返回一个指向 FILE 类型对象的指针（FILE *），使用该 FILE 指针与被打开或创建的文件相关<br>联，然后该 FILE 指针就用于后续的标准 I&#x2F;O 操作（使用标准 I&#x2F;O 库函数进行 I&#x2F;O 操作），所以由此可知，<br>FILE 指针的作用相当于文件描述符，只不过 FILE 指针用于标准 I&#x2F;O 库函数中、而文件描述符则用于文件<br>I&#x2F;O 系统调用中。</p><p>FILE 是一个结构体数据类型，它包含了标准 I&#x2F;O 库函数为管理文件所需要的所有信息，包括用于实际<br>I&#x2F;O 的文件描述符、指向文件缓冲区的指针、缓冲区的长度、当前缓冲区中的字节数以及出错标志等。FILE<br>数据结构定义在标准 I&#x2F;O 库函数头文件 stdio.h 中。</p><h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p>所谓标准输入设备指的就是计算机系统的标准的输入设备，通常指的是计算机所连接的键盘；而标准输出设备指的是计算机系统中用于输出标准信息的设备，通常指的是计算机所连接的显示器；标准错误设备则指的是计算机系统中用于显示错误信息的设备，通常也指的是显示器设备。</p><p>用户通过标准输入设备与系统进行交互，进程将从标准输入（stdin）文件中得到输入数据，将正常输出<br>数据（譬如程序中 printf 打印输出的字符串）输出到标准输出（stdout）文件，而将错误信息（譬如函数调用报错打印的信息）输出到标准错误（stderr）文件。</p><h3 id="打开文件fopen"><a href="#打开文件fopen" class="headerlink" title="打开文件fopen()"></a>打开文件fopen()</h3><p>在标准 I&#x2F;O 中，我们将使用库函数fopen()打开或创建文件.函数原型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>path：参数 path 指向文件路径，可以是绝对路径、也可以是相对路径。<br>mode：参数 mode 指定了对该文件的读写权限，是一个字符串。<br>返回值：调用成功返回一个指向 FILE 类型对象的指针（FILE *），该指针与打开或创建的文件相关联，<br>后续的标准 I&#x2F;O 操作将围绕 FILE 指针进行。如果失败则返回 NULL，并设置 errno 以指示错误原因。</p><table><thead><tr><th>mode</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件</td></tr><tr><td>r+</td><td>以可读、可写方式打开文件</td></tr><tr><td>w</td><td>以只写方式打开文件，如果参数path指定的文件存在，将文件长度截断为0，不存在则创建该文件</td></tr><tr><td>w+</td><td>以可读、可写方式打开文件，如果参数 path 指定的文件存在，将文件长度截断为 0；如果指定文件不存在则创建该文件。</td></tr><tr><td>a</td><td>以只写方式打开文件，打开以进行追加内容（在文件末尾写入），如果文件不存在则创建该文件。</td></tr><tr><td>a+</td><td>以可读、可写方式打开文件，以追加方式写入（在文件末尾写入），如果文件不存在则创建该文件。</td></tr></tbody></table><p>虽然调用 fopen()函数新建文件时无法手动指定文件的权限，但却有一个默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH (0666)</span><br></pre></td></tr></table></figure><h3 id="fclose-关闭文件"><a href="#fclose-关闭文件" class="headerlink" title="fclose()关闭文件"></a>fclose()关闭文件</h3><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数 stream 为 FILE 类型指针，调用成功返回 0；失败将返回 EOF（也就是-1），并且会设置 errno 来<br>指示错误原因。</p><h3 id="读文件和写文件"><a href="#读文件和写文件" class="headerlink" title="读文件和写文件"></a>读文件和写文件</h3><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>库函数 fread()用于读取文件数据，其参数和返回值含义如下：</p><p>ptr：fread()将读取到的数据存放在参数 ptr 指向的缓冲区中；<br>size：fread()从文件读取 nmemb 个数据项，每一个数据项的大小为 size 个字节，所以总共读取的数据大<br>小为 nmemb * size 个字节。<br>nmemb：参数 nmemb 指定了读取数据项的个数。<br>stream：FILE 指针。<br>返回值：调用成功时返回读取到的数据项的数目（数据项数目并不等于实际读取的字节数，除非参数<br>size 等于 1）；如果发生错误或到达文件末尾，则 fread()返回的值将小于参数 nmemb，那么到底发生了错误还是到达了文件末尾，fread()不能区分文件结尾和错误，究竟是哪一种情况，此时可以使用 ferror()或 feof()函数来判断。</p><p>库函数 fwrite()用于将数据写入到文件中，其参数和返回值含义如下：<br>ptr：将参数 ptr 指向的缓冲区中的数据写入到文件中。<br>size：参数 size 指定了每个数据项的字节大小，与 fread()函数的 size 参数意义相同。<br>nmemb：参数 nmemb 指定了写入的数据项个数，与 fread()函数的 nmemb 参数意义相同。<br>stream：FILE 指针。<br>返回值：调用成功时返回写入的数据项的数目（数据项数目并不等于实际写入的字节数，除非参数 size<br>等于 1）；如果发生错误，则 fwrite()返回的值将小于参数 nmemb（或者等于 0）。<br>由此可知，库函数 fread()、fwrite()中指定读取或写入数据大小的方式与系统调用 read()、write()不同，<br>前者通过 nmemb（数据项个数）*size（每个数据项的大小）的方式来指定数据大小，而后者则直接通过一个 size 参数指定数据大小。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[] = <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line"> FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;./test_file&quot;</span>, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 写入数据 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(buf) &gt; fwrite(buf, <span class="number">1</span>, <span class="keyword">sizeof</span>(buf), fp)) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fwrite error\n&quot;</span>);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;数据写入成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">int</span> size;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">NULL</span> == (fp = fopen(<span class="string">&quot;./test_file&quot;</span>, <span class="string">&quot;r&quot;</span>))) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">12</span> &gt; (size = fread(buf, <span class="number">1</span>, <span class="number">12</span>, fp))) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ferror(fp)) &#123; <span class="comment">//使用 ferror 判断是否是发生错误</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fread error\n&quot;</span>);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 如果未发生错误则意味着已经到达了文件末尾 */</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;成功读取%d 个字节数据: %s\n&quot;</span>, size, buf);</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fseek定位"><a href="#fseek定位" class="headerlink" title="fseek定位"></a>fseek定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>stream：FILE 指针。<br>offset：与 lseek()函数的 offset 参数意义相同。<br>whence：与 lseek()函数的 whence 参数意义相同。<br>返回值：成功返回 0；发生错误将返回-1，并且会设置 errno 以指示错误原因；与 lseek()函数的返回值<br>意义不同，这里要注意！<br>调用库函数 fread()、fwrite()读写文件时，文件的读写位置偏移量会自动递增，使用 fseek()可手动设置<br>文件当前的读写位置偏移量。</p><p><u>将一个文件的打开写入文件数据，并进行读取要使用fseek来将读写位置移动到头部才能读取，否则fead</u></p><p><u>读取后面的空白信息，没有内容。</u></p><h3 id="ftell-函数"><a href="#ftell-函数" class="headerlink" title="ftell()函数"></a>ftell()函数</h3><p>用于获取文件当前的读写位置偏移量，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数 stream 指向对应的文件，函数调用成功将返回当前读写位置偏移量；调用失败将返回-1，并会设置<br>errno 以指示错误原因。</p><h3 id="feof函数"><a href="#feof函数" class="headerlink" title="feof函数"></a>feof函数</h3><p>库函数 feof()用于测试参数 stream 所指文件的 end-of-file 标志，如果 end-of-file 标志被设置了，则调用<br>feof()函数将返回一个非零值，如果 end-of-file 标志没有被设置，则返回 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="ferror-函数"><a href="#ferror-函数" class="headerlink" title="ferror()函数"></a>ferror()函数</h3><p>库函数 ferror()用于测试参数 stream 所指文件的错误标志，如果错误标志被设置了，则调用 ferror()函数<br>将返回一个非零值，如果错误标志没有被设置，则返回 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="clearerr函数"><a href="#clearerr函数" class="headerlink" title="clearerr函数"></a>clearerr函数</h3><p>库函数 clearerr()用于清除 end-of-file 标志和错误标志，当调用 feof()或 ferror()校验这些标志后，通常需<br>要清除这些标志，避免下次校验时使用到的是上一次设置的值，此时可以手动调用 clearerr()函数清除标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="IO缓冲"><a href="#IO缓冲" class="headerlink" title="IO缓冲"></a>IO缓冲</h3><p>调用 write()后仅仅只是将这 5 个字节数据拷贝到了内核空间的缓冲区中，拷贝完成之后函数就返回了，在后面的某个时刻，内核会将其缓冲区中的数据写入（刷新）到磁盘设备中，所以由此可知，系统调用 write()与磁盘操作并不是同步的，write()函数并不会等待数据真正写入到磁盘之后再返回。如果在此期间，其它进程调用 read()函数读取该文件的这几个字节数据，那么内核将自动从缓冲区中读取这几个字节数据返回给应用程序。</p><p>这个内核缓冲区就称为文件 I&#x2F;O 的内核缓冲。这样的设计，目的是为了提高文件 I&#x2F;O 的速度和效率，使得系统调用 read()、write()的操作更为快速，不需要等待磁盘操作（将数据写入到磁盘或从磁盘读取出数据），磁盘操作通常是比较缓慢的。同时这一设计也更为高效，减少了内核操作磁盘的次数，譬如线程1 调用 write()向文件写入数据”abcd”，线程 2 也调用 write()向文件写入数据”1234”，这样的话，数据”abcd”和”1234”都被缓存在了内核的缓冲区中，在稍后内核会将它们一起写入到磁盘中，只发起一次磁盘操作请求；加入没有内核缓冲区，那么每一次调用 write()，内核就会执行一次磁盘操作。</p><h4 id="刷新文件-I-x2F-O-的内核缓冲区"><a href="#刷新文件-I-x2F-O-的内核缓冲区" class="headerlink" title="刷新文件 I&#x2F;O 的内核缓冲区"></a>刷新文件 I&#x2F;O 的内核缓冲区</h4><p>当我们在 Ubuntu 系统下拷贝文件到 U 盘时，文件拷贝完成之后，通常在拔掉 U 盘之前，需要执行 sync 命令进行同步操作，这个同步操作其实就是将文件 I&#x2F;O 内核缓冲区中的数据更新到 U 盘硬件设备，所以如果在没有执行 sync 命令时拔掉 U 盘，很可能就会导致拷贝到 U 盘中的文件遭到破坏！</p><h4 id="fsync-函数"><a href="#fsync-函数" class="headerlink" title="fsync()函数"></a>fsync()函数</h4><p>系统调用 fsync()将参数 fd 所指文件的内容数据和元数据写入磁盘，只有在对磁盘设备的写入操作完成之后，fsync()函数才会返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>参数 fd 表示文件描述符，函数调用成功将返回 0，失败返回-1 并设置 errno 以指示错误原因。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_FILE <span class="string">&quot;./rfile&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_FILE <span class="string">&quot;./wfile&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> rfd, wfd;</span><br><span class="line"> <span class="type">size_t</span> size;</span><br><span class="line"> <span class="comment">/* 打开源文件 */</span></span><br><span class="line"> rfd = open(READ_FILE, O_RDONLY);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; rfd) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 打开目标文件 */</span></span><br><span class="line"> wfd = open(WRITE_FILE, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; wfd) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 拷贝数据 */</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">0</span> &lt; (size = read(rfd, buf, BUF_SIZE)))</span><br><span class="line"> write(wfd, buf, size);</span><br><span class="line"> <span class="comment">/* 对目标文件执行 fsync 同步 */</span></span><br><span class="line"> fsync(wfd);</span><br><span class="line"> <span class="comment">/* 关闭文件退出程序 */</span></span><br><span class="line"> close(rfd);</span><br><span class="line">  close(wfd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fdatasync-函数"><a href="#fdatasync-函数" class="headerlink" title="fdatasync()函数"></a>fdatasync()函数</h4><p>系统调用 fdatasync()与 fsync()类似，不同之处在于 fdatasync()仅将参数 fd 所指文件的内容数据写入磁<br>盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><h4 id="sync-函数"><a href="#sync-函数" class="headerlink" title="sync()函数"></a>sync()函数</h4><p>系统调用 sync()会将所有文件 I&#x2F;O 内核缓冲区中的文件内容数据和元数据全部更新到磁盘设备中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="O-DSYNC-标志"><a href="#O-DSYNC-标志" class="headerlink" title="O_DSYNC 标志"></a>O_DSYNC 标志</h4><p>在调用 open()函数时，指定 O_DSYNC 标志，其效果类似于在每个 write()调用之后调用 fdatasync()函数<br>进行数据同步。</p><h4 id="O-SYNC-标志"><a href="#O-SYNC-标志" class="headerlink" title="O_SYNC 标志"></a>O_SYNC 标志</h4><p>在调用 open()函数时，指定 O_SYNC 标志，使得每个 write()调用都会自动将文件内容数据和元数据刷<br>新到磁盘设备中，其效果类似于在每个 write()调用之后调用 fsync()函数进行数据同步</p><h4 id="直接IO"><a href="#直接IO" class="headerlink" title="直接IO"></a>直接IO</h4><p>Linux 允许应用程序在执行文件 I&#x2F;O 操作时绕过内核缓冲区，从用户空间直接将数据传递到文件或磁盘设备，把这种操作也称为直接 I&#x2F;O（direct I&#x2F;O）或裸 I&#x2F;O（raw I&#x2F;O）。</p><p>因为直接 I&#x2F;O 涉及到对磁盘设备的直接访问，所以在执行直接 I&#x2F;O 时，必须要遵守以下三个对齐限制要求：<br>⚫ 应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐；<br>⚫ 写文件时，文件的位置偏移量必须是块大小的整数倍；<br>⚫ 写入到文件的数据大小必须是块大小的整数倍。</p><h4 id="stdio缓冲"><a href="#stdio缓冲" class="headerlink" title="stdio缓冲"></a>stdio缓冲</h4><p>标准 I&#x2F;O（fopen、fread、fwrite、fclose、fseek 等）是 C 语言标准库函数，而文件 I&#x2F;O（open、read、write、close、lseek 等）是系统调用，虽然标准 I&#x2F;O 是在文件 I&#x2F;O 基础上进行封装而实现（譬如 fopen 内部实际上调用了 open、fread 内部调用了 read 等），但在效率、性能上标准 I&#x2F;O 要优于文件 I&#x2F;O，其原因在于标准 I&#x2F;O 实现维护了自己的缓冲区，把这个缓冲区称为 stdio 缓冲区。为了减少调用系统调用的次数，标准 I&#x2F;O 函数会将用户写入或读取文件的数据缓存在 stdio 缓冲区，然后再一次性将 stdio 缓冲区中缓存的数据通过调用系统调用I&#x2F;O（文件 I&#x2F;O）写入到文件 I&#x2F;O 内核缓冲区或者拷贝到应用程序的 buf 中。</p><h5 id="stdio缓冲区的函数"><a href="#stdio缓冲区的函数" class="headerlink" title="stdio缓冲区的函数"></a>stdio缓冲区的函数</h5><h5 id="setvbuf-函数"><a href="#setvbuf-函数" class="headerlink" title="setvbuf()函数"></a>setvbuf()函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>stream：FILE 指针，用于指定对应的文件，每一个文件都可以设置它对应的 stdio 缓冲区。<br>buf：如果参数 buf 不为 NULL，那么 buf 指向 size 大小的内存区域将作为该文件的 stdio 缓冲区，因为stdio 库会使用 buf 指向的缓冲区，所以应该以动态（分配在堆内存）或静态的方式在堆中为该缓冲区分配一块空间，而不是分配在栈上的函数内的自动变量（局部变量）。如果 buf 等于 NULL，那么 stdio 库会自动分配一块空间作为该文件的 stdio 缓冲区（除非参数 mode 配置为非缓冲模式）。<br>mode：参数 mode 用于指定缓冲区的缓冲类型，可取值如下：<br>⚫ _IONBF：不对 I&#x2F;O 进行缓冲（无缓冲）。意味着每个标准 I&#x2F;O 函数将立即调用 write()或者 read()，并且忽略 buf 和 size 参数，可以分别指定两个参数为 NULL 和 0。标准错误 stderr 默认属于这一种类型，从而保证错误信息能够立即输出。<br>⚫ _IOLBF：采用行缓冲 I&#x2F;O。在这种情况下，当在输入或输出中遇到换行符”\n”时，标准 I&#x2F;O 才会执行文件 I&#x2F;O 操作。对于输出流，在输出一个换行符前将数据缓存（除非缓冲区已经被填满），当输出换行符时，再将这一行数据通过文件 I&#x2F;O write()函数刷入到内核缓冲区中；对于输入流，每次读取一行数据。对于终端设备默认采用的就是行缓冲模式，譬如标准输入和标准输出。<br>⚫ _IOFBF：采用全缓冲 I&#x2F;O。在这种情况下，在填满 stdio 缓冲区后才进行文件 I&#x2F;O 操作（read、write）。对于输出流，当 fwrite 写入文件的数据填满缓冲区时，才调用 write()将 stdio 缓冲区中的数据刷入内核缓冲区；对于输入流，每次读取 stdio 缓冲区大小个字节数据。默认普通磁盘上的常规文件默认常用这种缓冲模式。<br>size：指定缓冲区的大小。<br>返回值：成功返回 0，失败将返回一个非 0 值，并且会设置 errno 来指示错误原因。</p><h5 id="setbuffer-函数"><a href="#setbuffer-函数" class="headerlink" title="setbuffer()函数"></a>setbuffer()函数</h5><p>setbuffer函数类似setbuf（）但是允许调用者指定buf缓冲区的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><h5 id="刷新-stdio-缓冲区"><a href="#刷新-stdio-缓冲区" class="headerlink" title="刷新 stdio 缓冲区"></a>刷新 stdio 缓冲区</h5><p>无论我们采取何种缓冲模式，在任何时候都可以使用库函数 fflush()来强制刷新（将输出到 stdio 缓冲区中的数据写入到内核缓冲区，通过 write()函数）stdio 缓冲区，该函数会刷新指定文件的 stdio 输出缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"> fflush(<span class="built_in">stdout</span>); <span class="comment">//刷新标准输出 stdio 缓冲区</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; )</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些其它的情况下，也会自动刷新 stdio 缓冲区，譬如当文件关闭时、程序退出时。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/set.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux深入文件IO</title>
      <link href="/2022/11/10/2022-11-10-Linux%E6%B7%B1%E5%85%A5%E6%96%87%E4%BB%B6IO/"/>
      <url>/2022/11/10/2022-11-10-Linux%E6%B7%B1%E5%85%A5%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux管理文件"><a href="#Linux管理文件" class="headerlink" title="Linux管理文件"></a>Linux管理文件</h3><h4 id="静态文件与inode"><a href="#静态文件与inode" class="headerlink" title="静态文件与inode"></a>静态文件与inode</h4><p>文件存放在磁盘文件系统中，并且以一种固定的形式进行存放，称为静态文件。调用 open 函数的时候，会将文件数据（文件内容）从磁盘等块设备读取到内存中，将文件数据在内存中进行维护，内存中的这份文件数据我们就把它称为动态文件。</p><p>硬盘的最小存储单位叫做“扇区”（Sector），每个扇区储存 512 字节（相当于 0.5KB），操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的4KB，即连续八个 sector 组成一个 block。</p><p>磁盘在进行分区、格式化的时候会将其分为两个区域，一个是数据区，用于存储文件中的数据；<br>另一个是 inode 区，用于存放 inode table（inode 表），inode table 中存放的是一个一个的 inode（也成为 inode节点），不同的 inode 就可以表示不同的文件，每一个文件都必须对应一个 inode。</p><p><a href="https://postimg.cc/JD4mjgVd"><img src="https://i.postimg.cc/DZ1Z3kCF/2022-11-10-142428.png" alt="2022-11-10-142428.png"></a></p><p>打开一个文件，系统内部会将这个过程分为三步：</p><ol><li>系统找到这个文件名所对应的 inode 编号；</li><li>通过 inode 编号从 inode table 中找到对应的 inode 结构体；</li><li>根据 inode 结构体中记录的信息，确定文件数据所在的 block，并读出数据。</li></ol><p>调用 open 函数去打开文件的时候，内核会申请一段内存（一段缓冲区），并且将静态文件的数据内容从磁盘这些存储设备中读取到内存中进行管理、缓存（也把内存中的这份文件数据叫做动态文件、内核缓冲区）。打开文件后，以后对这个文件的读写操作，都是针对内存中这一份动态文件进行相关的操作，而并不是针对磁盘中存放的静态文件。</p><p>因为磁盘、硬盘、U 盘等存储设备基本都是 Flash 块设备，因为块设备硬件本身有读写限制等特征，块设备是以一块一块为单位进行读写的（一个块包含多个扇区，而一个扇区包含多个字节），一个字节的改动也需要将该字节所在的 block 全部读取出来进行修改，修改完成之后再写入块设备中，所以导致对块设备的读写操作非常不灵活；而内存可以按字节为单位来操作，而且可以随机操作任意地址数据，非常地很灵活。</p><p>内核会为每个进程设置一个专门的数据结构用于管理该进程，譬如用于记录进程的状态信息、运行特征等，我们把这个称为进程控制块（Process control block，缩写PCB）。<br>PCB 数据结构体中有一个指针指向了文件描述符表（File descriptors），文件描述符表中的每一个元素索引到对应的文件表（File table），文件表也是一个数据结构体。</p><h4 id="返回错误处理与errno"><a href="#返回错误处理与errno" class="headerlink" title="返回错误处理与errno"></a>返回错误处理与errno</h4><p>在 Linux 系统下对常见的错误做了一个编号，每一个编号都代表着每一种不同的错误类型，当函数执行发生错误的时候，操作系统会将这个错误所对应的编号赋值给 errno 变量，每一个进程（程序）都维护了自己的 errno 变量，它是程序中的全局变量，该变量用于存储就近发生的函数执行错误编号，也就意味着下一次的错误码会覆盖上一次的错误码。</p><p>errno 本质上是一个 int 类型的变量，用于存储错误编号，但是需要注意的是，并不是执行所有的系统调用或 C 库函数出错时，操作系统都会设置 errno。</p><h5 id="常用的函数perror函数"><a href="#常用的函数perror函数" class="headerlink" title="常用的函数perror函数"></a>常用的函数perror函数</h5><p>一般用的最多的还是这个函数，调用此函数不需要传入 errno，函数内部会自己去获取 errno 变量的值，调用此函数会直接将错误提示字符串打印出来，而不是返回字符串。</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>s：在错误提示字符串信息之前，可加入自己的打印信息，也可不加，不加则传入空字符串即可。<br>返回值：void 无返回值。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">/* 打开文件 */</span></span><br><span class="line">fd = open(<span class="string">&quot;./test_file&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="exit、-exit、-Exit"><a href="#exit、-exit、-Exit" class="headerlink" title="exit、__exit、_Exit"></a>exit、__exit、_Exit</h4><p>在 Linux 系统下，进程（程序）退出可以分为正常退出和异常退出，注意这里说的异常并不是执行函数出现了错误这种情况，异常往往更多的是一种不可预料的系统异常，可能是执行了某个函数时发生的、也有可能是收到了某种信号等.</p><p>main 函数中使用 return 后返回，return 执行后把控制权交给调用函数，结束该进程。调用_exit()函数会清除其使用的内存空间，并销毁其在内核中的各种数据结构，关闭进程的所有文件描述符，并结束进程、将控制权交给操作系统。exit()是一个标准 C 库函数，而_exit()和_Exit()是系统调用。</p><p>__exit()函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>_Exit()函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _Exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>exit()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><h4 id="空洞文件"><a href="#空洞文件" class="headerlink" title="空洞文件"></a>空洞文件</h4><p>使用 write()函数对文件进行写入操作，也就是说此时将是从偏移文件头部 6000 个字节处开始写入数据，也就意味着 4096~6000 字节之间出现了一个空洞，因为这部分空间并没有写入任何数据，所以形成了空洞，这部分区域就被称为文件空洞，那么相应的该文件也被称为空洞文件。<br>文件空洞部分实际上并不会占用任何物理空间，直到在某个时刻对空洞部分进行写入数据时才会为它<br>分配对应的空间，但是空洞文件形成时，逻辑上该文件的大小是包含了空洞部分的大小的</p><p><u>空洞文件对多线程共同操作文件是及其有用的</u>，有时候我们创建一个很大的文件，如果单个线程从头开始依次构建该文件需要很长的时间，有一种思路就是将文件分为多段，然后使用多线程来操作，每个线程负责其中一段数据的写入。</p><p>eg：新建一个空洞文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(<span class="string">&quot;./hole_file&quot;</span>, O_WRONLY | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将文件读写位置移动到偏移文件头 4096 个字节(4K)处 */</span></span><br><span class="line"> ret = lseek(fd, <span class="number">4096</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 初始化 buffer 为 0xFF */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 循环写入 4 次，每次写入 1K */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例代码中，使用 open 函数新建了一个文件 hole_file，在 Linux 系统中，新建文件大小是 0，也就<br>是没有任何数据写入，此时使用lseek函数将读写偏移量移动到4K字节处，再使用write函数写入数据0xFF，每次写入 1K，一共写入 4 次，也就是写入了 4K 数据，也就意味着该文件前 4K 是文件空洞部分，而后 4K数据才是真正写入的数据。</p><h4 id="O-APPEND-和-O-TRUNC-标志"><a href="#O-APPEND-和-O-TRUNC-标志" class="headerlink" title="O_APPEND 和 O_TRUNC 标志"></a>O_APPEND 和 O_TRUNC 标志</h4><p>O_TRUNC 这个标志的作用是调用 open 函数打开文件的时候会将文件原本的内容全部丢弃，文件大小变为 0。</p><p><u><strong>O_APPEND</strong></u>标志作用open函数携带了O_APPEND，调用 open 函数打开文件，当每次使用 write()函数对文件进行写操作时，都会自动把文件当前位置偏移量移动到文件末尾，从文件末尾开始写入数据，也就是意味着每次写入数据都是从文件末尾开始。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_APPEND);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 初始化 buffer 中的数据 */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0x55</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 写入数据: 写入 4 个字节数据 */</span></span><br><span class="line"> ret = write(fd, buffer, <span class="number">4</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将 buffer 缓冲区中的数据全部清 0 */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 将位置偏移量移动到距离文件末尾 4 个字节处 */</span></span><br><span class="line"> ret = lseek(fd, <span class="number">-4</span>, SEEK_END);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line">    ret = read(fd, buffer, <span class="number">4</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;0x%x 0x%x 0x%x 0x%x\n&quot;</span>, buffer[<span class="number">0</span>], buffer[<span class="number">1</span>],</span><br><span class="line"> buffer[<span class="number">2</span>], buffer[<span class="number">3</span>]);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用O_APPEND多次打开同一个文件测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> buffer1[<span class="number">4</span>], buffer2[<span class="number">4</span>];</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL | O_APPEND,</span><br><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd1) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 再次打开 test_file 文件 */</span></span><br><span class="line"> fd2 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_APPEND);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd2) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* buffer 数据初始化 */</span></span><br><span class="line"> buffer1[<span class="number">0</span>] = <span class="number">0x11</span>;</span><br><span class="line"> buffer1[<span class="number">1</span>] = <span class="number">0x22</span>;</span><br><span class="line"> buffer1[<span class="number">2</span>] = <span class="number">0x33</span>;</span><br><span class="line"> buffer1[<span class="number">3</span>] = <span class="number">0x44</span>;</span><br><span class="line"> buffer2[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line"> buffer2[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line"> buffer2[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line"> buffer2[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line"> <span class="comment">/* 循环写入数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = write(fd2, buffer2, <span class="keyword">sizeof</span>(buffer2));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将读写位置偏移量移动到文件头 */</span></span><br><span class="line"> ret = lseek(fd1, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"> ret = read(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x%x%x%x&quot;</span>, buffer1[<span class="number">0</span>], buffer1[<span class="number">1</span>],</span><br><span class="line"> buffer1[<span class="number">2</span>], buffer1[<span class="number">3</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复制文件描述符"><a href="#复制文件描述符" class="headerlink" title="复制文件描述符"></a>复制文件描述符</h4><p>在 Linux 系统中，open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新的文件描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，复制得到的文件描述符和旧的文件描述符拥有相同的权限，譬如使用旧的文件描述符对文件有读写权限，那么新的文件描述符同样也具有读写权限。</p><p>dup函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br></pre></td></tr></table></figure><p>oldfd：需要被复制的文件描述符。<br>返回值：成功时将返回一个新的文件描述符，由操作系统分配，分配置原则遵循文件描述符分配原则；<br>如果复制失败将返回-1，并且会设置 errno 值</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> buffer1[<span class="number">4</span>], buffer2[<span class="number">4</span>];</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 复制文件描述符 */</span></span><br><span class="line"> fd2 = dup(fd1);</span><br><span class="line"> <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;dup error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d\nfd2: %d\n&quot;</span>, fd1, fd2);</span><br><span class="line"> <span class="comment">/* buffer 数据初始化 */</span></span><br><span class="line"> buffer1[<span class="number">0</span>] = <span class="number">0x11</span>;</span><br><span class="line"> buffer1[<span class="number">1</span>] = <span class="number">0x22</span>;</span><br><span class="line"> buffer1[<span class="number">2</span>] = <span class="number">0x33</span>;</span><br><span class="line"> buffer1[<span class="number">3</span>] = <span class="number">0x44</span>;</span><br><span class="line"> buffer2[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line"> buffer2[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line"> buffer2[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line"> buffer2[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line"> <span class="comment">/* 循环写入数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = write(fd2, buffer2, <span class="keyword">sizeof</span>(buffer2));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将读写位置偏移量移动到文件头 */</span></span><br><span class="line"> ret = lseek(fd1, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"> ret = read(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x%x%x%x&quot;</span>, buffer1[<span class="number">0</span>], buffer1[<span class="number">1</span>],</span><br><span class="line"> buffer1[<span class="number">2</span>], buffer1[<span class="number">3</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dup 系统调用分配的文件描述符是由系统分配的，遵循文件描述符分配原则，并不能自己指定一个文件<br>描述符，这是 dup 系统调用的一个缺陷；而 dup2 系统调用修复了这个缺陷，可以手动指定文件描述符，而不需要遵循文件描述符分配原则。dup2函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p>oldfd：需要被复制的文件描述符。<br>newfd：指定一个文件描述符（需要指定一个当前进程没有使用到的文件描述符）。<br>返回值：成功时将返回一个新的文件描述符，也就是手动指定的文件描述符 newfd；如果复制失败将返回-1，并且会设置 errno 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 复制文件描述符 */</span></span><br><span class="line"> fd2 = dup2(fd1, <span class="number">100</span>);</span><br><span class="line"> <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;dup error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d\nfd2: %d\n&quot;</span>, fd1, fd2);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>文件共享指的是同一个文件（譬如磁盘上的同一个文件，对应同一个 inode）被多个独立的读写体同时进行 IO 操作。同时进行 IO 操作指的是一个读写体操作文件尚未调用 close 关闭的情况下，另一个读写体去操作文件。</p><p>文件共享的意义有很多，多用于多进程或多线程编程环境中，譬如我们可以通过文件共享的方式来实现<br>多个线程同时操作同一个大文件，以减少文件读写时间、提升效率。<br><strong><u>文件共享的核心</strong></u>是：如何制造出多个不同的文件描述符来指向同一个文件。其实方法在上面的内容中都已经给大家介绍过了，譬如多次调用 open 函数重复打开同一个文件得到多个不同的文件描述符、使用 dup()或 dup2()函数对文件描述符进行复制以得到多个不同的文件描述符。</p><p><strong>常见三种文件共享实现方式</strong></p><p>(1)同一个进程中多次调用 open 函数打开同一个文件</p><p>(2)不同进程中分别使用 open 函数打开同一个文件</p><p>(3)同一个进程中通过 dup（dup2）函数对文件描述符进行复制</p><h4 id="原子操作和竞争冒险"><a href="#原子操作和竞争冒险" class="headerlink" title="原子操作和竞争冒险"></a>原子操作和竞争冒险</h4><p>[原子操作和竞争冒险]: <a href="https://copyfuture.com/blogs-details/202208241006207606">https://copyfuture.com/blogs-details/202208241006207606</a>“竞争冒险”</p><h4 id="截断文件"><a href="#截断文件" class="headerlink" title="截断文件"></a>截断文件</h4><p>truncate()或ftruncate()可将普通文件截断为指定字节长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p>这两个函数都可以对文件进行截断操作，将文件截断为参数 length 指定的字节长度，什么是截断？如<br>果文件目前的大小大于参数 length 所指定的大小，则多余的数据将被丢失，类似于多余的部分被“砍”掉<br>了；如果文件目前的大小小于参数 length 所指定的大小，则将其进行扩展，对扩展部分进行读取将得到空字节”\0”。</p><p>使用 ftruncate()函数进行文件截断操作之前，必须调用 open()函数打开该文件得到文件描述符，并且必<br>须要具有可写权限，也就是调用 open()打开文件时需要指定 O_WRONLY 或 O_RDWR。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="comment">/* 打开 file1 文件 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; (fd = open(<span class="string">&quot;./file1&quot;</span>, O_RDWR))) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 使用 ftruncate 将 file1 文件截断为长度 0 字节 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; ftruncate(fd, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;ftruncate error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 使用 truncate 将 file2 文件截断为长度 1024 字节 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; truncate(<span class="string">&quot;./file2&quot;</span>, <span class="number">1024</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;truncate error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 关闭 file1 退出程序 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Linux下的access函数"><a href="#Linux下的access函数" class="headerlink" title="Linux下的access函数"></a>Linux下的access函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p> pathname 是文件的路径名+文件名,mode：指定access的作用，取值如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">F_OK 值为<span class="number">0</span>，判断文件是否存在</span><br><span class="line"> </span><br><span class="line">X_OK 值为<span class="number">1</span>，判断对文件是可执行权限</span><br><span class="line"> </span><br><span class="line">W_OK 值为<span class="number">2</span>，判断对文件是否有写权限</span><br><span class="line"> </span><br><span class="line">R_OK 值为<span class="number">4</span>，判断对文件是否有读权限</span><br><span class="line"> </span><br><span class="line">注：后三种可以使用或“|”的方式，一起使用，如W_OK|R_OK</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——文件IO操作</title>
      <link href="/2022/11/08/2022-11-8-Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/11/08/2022-11-8-Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="文件IO基础"><a href="#文件IO基础" class="headerlink" title="文件IO基础"></a>文件IO基础</h3><p>文件IO是指对文件的输入输出操作。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>调用函数会有返回值，该返回值为一个文件描述符，对于Linux内核而言，所有打开文件都会通过文件描述符进行索引。</p><p>当调用open函数打开或者创建一个新文件，内核会向进程返回一个文件描述符，用于指带被打开的文件，所有执行 IO 操作的系统调用都是通过文件描述符来索引到对应的文件。一个进程可以打开多个文件，但是在 Linux 系统中，一个进程可以打开的文件数是有限制，并不是可以无限制打开很多的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -n<span class="comment">##查看进程打开文件的最大数量</span></span></span><br><span class="line">1024</span><br></pre></td></tr></table></figure><p>每一个被打开的文件在同一个进程中都有一个唯一的文件描述符，不会重复，如果文件被关闭后，它对应的文件描述符将会被释放，那么这个文件描述符将可以再次分配给其它打开的文件、与对应的文件绑定起来。</p><p>每次给打开的文件分配文件描述符都是从最小的没有被使用的文件描述符（0~1023）开始，当之前打开的文件被关闭之后，那么它对应的文件描述符会被释放，释放之后也就成为了一个没有被使用的文件描述符了。</p><p>但是 0、1、2 这三个文件描述符已经默认被系统占用了，分别分配给了系统标准输入（0）、标准输出（1）以及标准错误（2）。</p><h4 id="open打开文件"><a href="#open打开文件" class="headerlink" title="open打开文件"></a>open打开文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>open 函数用于打开文件，当然除了打开已经存在的文件之外，还可以创建一个新的文件。</p><p>在应用程序中调用 open 函数即可传入 2 个参数（pathname、flags）、也可传入 3 个参数（pathname、flags、mode），但是第三个参数 mode 需要在第二个参数 flags 满足条件时才会有效，稍后将对此进行说明；从图 2.3.1 可知，在应用程序中使用 open 函数时，需要包含 3 个头文件“#include<br>”、“#include ”、“#include ”。</p><p>函数参数和返回值定义</p><p>pathname：字符串类型，用于标识需要打开或创建的文件，可以包含路径（绝对路径或者相对路径）信息。</p><p>flags：调用open函数时需要提供的标志，包括文件访问模式标志以及其它文件相关标志，这些标志使用宏定义进行描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;./app.c&quot;</span>, O_RDWR)<span class="comment">//打开一个已经存在的文件，使用可读可写的方式打开</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line"><span class="keyword">return</span> fd;</span><br></pre></td></tr></table></figure><h4 id="write写文件"><a href="#write写文件" class="headerlink" title="write写文件"></a>write写文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>函数参数返回值含义如下：</p><p>fd：文件描述符。将进行写操作的文件所对应的文件描述符传递给 write 函数。<br>buf：指定写入数据对应的缓冲区。<br>count：指定写入的字节数。<br>返回值：如果成功将返回写入的字节数（0 表示未写入任何字节），如果此数字小于 count 参数，这不是错误，譬如磁盘空间已满，可能会发生这种情况；如果写入出错，则返回-1。</p><h4 id="read读文件"><a href="#read读文件" class="headerlink" title="read读文件"></a>read读文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>fd：文件描述符。与 write 函数的 fd 参数意义相同。</p><p>buf：指定用于存储读取数据的缓冲区。</p><p>count：指定需要读取的字节数。</p><p>返回值：如果读取成功将返回读取到的字节数，实际读取到的字节数可能会小于 count 参数指定的字节<br>数，也有可能会为 0，譬如进行读操作时，当前文件位置偏移量已经到了文件末尾。实际读取到的字节数少<br>于要求读取的字节数，譬如在到达文件末尾之前有 30 个字节数据，而要求读取 100 个字节，则 read 读取成<br>功只能返回 30；而下一次再调用 read 读，它将返回 0（文件末尾）。</p><h4 id="close关闭文件"><a href="#close关闭文件" class="headerlink" title="close关闭文件"></a>close关闭文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>fd：文件描述符，需要关闭的文件所对应的文件描述符。<br>返回值：如果成功返回 0，如果失败则返回-1。</p><h4 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>对于每个打开的文件，系统都会记录它的读写位置偏移量，我们也把这个读写位置偏移量称为读写偏移<br>量，记录了文件当前的读写位置，当调用 read()或 write()函数对文件进行读写操作时，就会从当前读写位置<br>偏移量开始进行数据读写。</p><p>读写偏移量用于指示 read()或 write()函数操作时文件的起始位置，会以相对于文件头部的位置偏移量来<br>表示，文件第一个字节数据的位置偏移量为 0。</p><p>函数参数和返回值含义如下：<br>fd：文件描述符。<br>offset：偏移量，以字节为单位。<br>whence：用于定义参数 offset 偏移量对应的参考值，该参数为下列其中一种（宏定义）：</p><p>SEEK_SET：读写偏移量将指向 offset 字节位置处（从文件头部开始算）</p><p>SEEK_CUR：读写偏移量将指向当前位置偏移量 + offset 字节位置处，offset 可以为正、也可以为负，如果是正数表示往后偏移，如果是负数则表示往前偏移；</p><p>SEEK_END：读写偏移量将指向文件末尾 + offset 字节位置处，同样 offset 可以为正、也可以为负，如果是正数表示往后偏移、如果是负数则表示往前偏移。</p><p>eg：<br>(1)将读写位置移动到文件开头处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(2)将读写位置移动到文件末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(3)将读写位置移动到偏移文件开头 100 个字节处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">100</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(4)获取当前读写位置偏移量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>函数执行成功将返回文件当前读写位置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——Shell脚本学习</title>
      <link href="/2022/10/23/2022-10-23-Linux%E2%80%94%E2%80%94Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/23/2022-10-23-Linux%E2%80%94%E2%80%94Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h3><p>Shell通常指的是命令行界面的解析器,也用于泛指所有为用户提供操作界面的程序，也就是程序和用户<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%A4%E4%BA%92&action=edit&redlink=1">交互</a>的层面。</p><p>Shell 执行shell程序，这些程序叫脚本。</p><p>创建脚本使用文本编辑器来创建包含指令的文件，这里使用vim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim bash.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash<span class="comment">##创建脚本文件时候必须在文件第一行指明要用到的shell</span></span></span><br><span class="line">for file in *#以#开头的行不会被shell处理</span><br><span class="line">do </span><br><span class="line">  if grep -q POSIX $file</span><br><span class="line">  then</span><br><span class="line">    echo $file</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>把脚本设置为可执行，</p><p>1、</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/bash bash.sh</span></span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x bash.sh<span class="comment">##改变文件权限，使这个文件可以被所有用户执行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bash.sh</span></span><br></pre></td></tr></table></figure><h3 id="Shell-语法"><a href="#Shell-语法" class="headerlink" title="Shell 语法"></a>Shell 语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>所有变量都被看作字符串并以字符串来存储.</p><p> 注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：（变量名称使用小写英文命名，因为系统中的全局变量是大写命名的，为防止重复定义就用小写）</p><p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>中间不能有空格，可以使用下划线 _。<br>不能使用标点符号。<br>不能使用bash里的关键字（可用help命令查看保留关键字）。</p><p>在shell中，可以通过在变量名前加上$符号来访问它的内容， 一种检查变量内容的简单方式就是变量前加上$再用echo命令将它的内容输出到终端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> salutation=Hello</span><br><span class="line"> echo $salutation</span><br><span class="line"> echo salutation</span><br><span class="line">Hello</span><br><span class="line">salutation</span><br></pre></td></tr></table></figure><p>read可以给变量复制相当于C语言的input</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> read salutation</span><br><span class="line"> echo $ salutation</span><br><span class="line">sa</span><br><span class="line">sa</span><br></pre></td></tr></table></figure><p>要想输出空格需要用双引号给引用出来，要想显示双引号可，以用单引号来显示出来，在显示信息中想要有美元符号，必须在前面加上\</p><p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。</p><p>可以通过&#96;反引号来将命令输出赋值给变量或者$()</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">testing = `<span class="built_in">date</span>`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">testing = $(<span class="built_in">date</span>)</span></span><br></pre></td></tr></table></figure><p>使用 unset 命令可以删除变量。</p><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>运行shell时，会同时存在三种变量：</p><ul><li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h4 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a>Shell数组</h4><p>bash支持一维数组，并且没有限制大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)#例如这样array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure><h5 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;数组名[下标]&#125;<span class="comment">#例如echo $&#123;array_name[@]&#125;</span></span></span><br></pre></td></tr></table></figure><h5 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取得数组元素的个数</span></span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取得数组单个元素的长度</span></span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure><p>bash shell脚本不支持浮点型运算，只支持整数运算，如果想要计算可用bash的计算器bc</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="if-else"><a href="#if-else" class="headerlink" title="if -else"></a>if -else</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>如果使用 ((…)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if (( $a == $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif (( $a &gt; $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif (( $a &lt; $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p><p>顺序输出当前列表中的数字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h4><p>until 循环执行一系列命令直至条件为 true 时停止。condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="case…-esac"><a href="#case…-esac" class="headerlink" title="case… esac"></a>case… esac</h4><p>case … esac 为多选择语句，与其他语言中的 switch … case 语句类似，是一种多分支选择结构，每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><u><strong>和C语言一样break用来跳出所有循环，continue是用来跳出当前循环。</strong></u></p><h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于等于则为真</td></tr><tr><td>-ge</td><td>小于等于则为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table><p>eg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个数相等！&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个数不相等！&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e文件名</td><td>如果文件存在则为真</td></tr><tr><td>-f文件名</td><td>如果文件存在且可读则为真</td></tr><tr><td>-w文件名</td><td>如果文件存在且可写则为真</td></tr><tr><td>-x文件名</td><td>如果文件存在且可执行则为真</td></tr><tr><td>-s文件名</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td>-d文件名</td><td>如果文件存在且为目录则为真</td></tr><tr><td>-f文件名</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td>-c文件名</td><td>如果文件存在且为字符型特殊文件则为真</td></tr><tr><td>-b文件名</td><td>如果文件存在且为块特殊文件则为真</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo &#x27;文件已存在!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;文件不存在!&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br></pre></td></tr></table></figure><p>传参</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数处理</th><th>说明</th></tr></thead><tbody><tr><td align="left">$#</td><td>传递到脚本或函数的参数个数</td></tr><tr><td align="left">$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td align="left">$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td align="left">$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td align="left">$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr><tr><td align="left">@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td align="left">$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言算法项</title>
      <link href="/2022/10/20/2022-10-20-C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/"/>
      <url>/2022/10/20/2022-10-20-C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正三角-反三角"><a href="#正三角-反三角" class="headerlink" title="正三角(反三角)"></a>正三角(反三角)</h3><p>使用为两个for循环进行嵌套</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="keyword">for</span>(a=<span class="number">0</span>;a&lt;<span class="number">6</span>;a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(b=<span class="number">0</span>;b&lt;a;b++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h3><p>使用为四个for进行循环思想核心为中间数量为行数n的两倍减去1，外层循环控制换行，内层三个控制空格以及他的打印数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rows,i,j,space,star;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp; rows);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=rows;++i)</span><br><span class="line">    &#123;</span><br><span class="line">         star = <span class="number">2</span>*i <span class="number">-1</span> ;     <span class="comment">//星号个数</span></span><br><span class="line">         space = rows - i;   <span class="comment">//空格个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//左边空格</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;star;++j)       <span class="comment">//中间 *</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//右边空格有没有都可以</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, space, rows, k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter number of rows: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;rows);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=rows; ++i, k=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(space=<span class="number">1</span>; space&lt;=rows-i; ++space)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k != <span class="number">2</span>*i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断一个数字是否素数</p><p>判断一个数字是否能被比他小的数整除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;yes!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;x;i++)</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//一旦判断不是，跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==x) <span class="built_in">puts</span>(<span class="string">&quot;yes!&quot;</span>);<span class="comment">//如果是的话，for循环一定执行到了i=x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C语言二分查找"><a href="#C语言二分查找" class="headerlink" title="C语言二分查找"></a>C语言二分查找</h3><p>找到最左边元素（low）和最右边元素（high），确定中间元素（mid），比较中间元素（mid）和目标元素（k）的大小，调整low和high，再确定新的mid….我们要不断确定mid直到找到k，自然需要用到循环，我们有明确的目标：找到k。因此选择while循环，找到k后循环不再进行，而当low和high之间还有元素，即low在high的左边或与之重合，k就依然可能存在，所以循环条件为low&lt;&#x3D;high，接下来的问题在于怎样调整low和high的值，mid和k比较无非就三种情况：mid&lt;k，mid&gt;k,mid&#x3D;k。第一种情况，k在mid的右边，我们将low调整为mid+1，high不用调整；第二种情况，k在mid的左边，我们将high调整为mid-1，low不用调整。最后一种情况最简单，我们已经找到了k，直接将mid打印出来就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bin_Search</span><span class="params">(<span class="type">int</span> *num,<span class="type">int</span> cnt,<span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> first = <span class="number">0</span>,last = cnt<span class="number">-1</span>,mid;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(first &lt;= last)</span><br><span class="line">&#123;</span><br><span class="line">counter ++;</span><br><span class="line">mid = (first + last) / <span class="number">2</span>;<span class="comment">//确定中间元素</span></span><br><span class="line"><span class="keyword">if</span>(num[mid] &gt; target)</span><br><span class="line">&#123;</span><br><span class="line">last = mid<span class="number">-1</span>; <span class="comment">//mid已经交换过了,last往前移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num[mid] &lt; target)</span><br><span class="line">&#123;</span><br><span class="line">first = mid+<span class="number">1</span>;<span class="comment">//mid已经交换过了,first往后移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//判断是否相等</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找次数:%d\n&quot;</span>,counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找次数:%d\n&quot;</span>,counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>,target;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您要查找的数字:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;target);</span><br><span class="line">flag = Bin_Search(num,<span class="number">10</span>,target);</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;已经找到该数字!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;无该数字!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找数组最大值"><a href="#查找数组最大值" class="headerlink" title="查找数组最大值"></a>查找数组最大值</h3><h4 id="循环对比"><a href="#循环对比" class="headerlink" title="循环对比"></a>循环对比</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">findMaxValue(arr) &#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>; <span class="comment">// 最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123; <span class="comment">// 当前值大于最大值，赋值为最大值</span></span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串排列顺序"><a href="#字符串排列顺序" class="headerlink" title="字符串排列顺序"></a>字符串排列顺序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HALT <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stsrt</span><span class="params">(<span class="type">char</span> *strings [], <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> input[LIM][SIZE];</span><br><span class="line"><span class="type">char</span> *ptstr[LIM];</span><br><span class="line"><span class="type">int</span> ct = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input up to %d lines, and I will sort them.\n&quot;</span>, LIM);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;To stop ,press the Enter key at a line&#x27;s start.\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(ct &lt; LIM &amp;&amp; s_gets(input[ct], SIZE) != <span class="literal">NULL</span> &amp;&amp; input[ct][<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptstr[ct] = input[ct];</span><br><span class="line">ct ++;</span><br><span class="line">&#125;</span><br><span class="line">stsrt(ptstr, ct);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nHere&#x27;s the sorted list:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; ct; k++)</span><br><span class="line"><span class="built_in">puts</span>(ptstr[k]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stsrt</span><span class="params">(<span class="type">char</span> * strings[], <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * temp;</span><br><span class="line"><span class="type">int</span> top, seek;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(top = <span class="number">0</span>; top &lt; num - <span class="number">1</span>; top++)</span><br><span class="line"><span class="keyword">for</span>(seek = top + <span class="number">1</span>; seek &lt; num; seek++)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(strings[top], strings[seek]) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = strings[top];</span><br><span class="line">strings[top] = strings[seek];</span><br><span class="line">strings[seek] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * ret_val;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret_val = fgets(st , n , <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ret_val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(st[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> len)</span><span class="comment">//函数实现</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)<span class="comment">//需要进行len-1趟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//flag=1，说明已经排好序</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i;j++)<span class="comment">//每趟两两比较较未排好序元素个数-1次。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p[j] &gt; p[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = p[j];</span><br><span class="line">p[j] = p[j + <span class="number">1</span>];</span><br><span class="line">p[j + <span class="number">1</span>] = tmp;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag==<span class="number">1</span>)<span class="comment">//判断是否排好序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">46</span>,<span class="number">79</span>,<span class="number">12</span> &#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span> arr / <span class="keyword">sizeof</span> arr[<span class="number">0</span>];</span><br><span class="line">bubble_sort(arr,sz);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux工具vim</title>
      <link href="/2022/10/20/2022-10-20-Linux%E5%B7%A5%E5%85%B7vim/"/>
      <url>/2022/10/20/2022-10-20-Linux%E5%B7%A5%E5%85%B7vim/</url>
      
        <content type="html"><![CDATA[<p>vi编辑器是所有Unix及<a href="http://www.2cto.com/os/linux/">Linux</a>系统下标准的编辑器，他就相当于<a href="http://www.2cto.com/os/windows/">windows</a>系统中的记事本一样，它的强大不逊色于任何最新的文本编辑器。他是我们使用Linux系统不能缺少的工具。<a href="https://so.csdn.net/so/search?q=vim&spm=1001.2101.3001.7020">vim</a> 具有程序编辑的能力，可以以字体颜色辨别语法的正确性。</p><p>vi可以分为三种状态，分别是一般模式、编辑模式和命令行模式</p><p>一般模式：<br>以vi打开一个文件就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用上下左右按键来移动光标，你可以使用删除字符或删除整行来处理文件内容， 也可以使用复制、粘贴来处理你的文件数据。</p><p>编辑模式：<br>在一般模式中可以进行删除、复制、粘贴等的操作，但是却无法编辑文件的内容，只有当你按下【i, I, o, O, a, A, r, R】等任何一个字母之后才会进入编辑模式。这时候屏幕的左下方会出现【INSERT或 REPLACE】的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下【Esc】即可退出编辑模式。</p><p>命令行模式：<br>输入【 : &#x2F; ? 】三个中的任何一个，就可以将光标移动到最底下那一行。在这个模式中， 可以提供查找、读取、存盘、替换字符、离开vi、显示行号等的动作则是在此模式中完成的！</p><p>针对程序员配置</p><p>打开高亮功能，vim会通过文件的扩展名自动决定哪些是关键字。</p><p>：syntax on</p><p>自动缩进</p><p>：set autoindent</p><p>设置tab键的空格数</p><p>：set shiftwidth&#x3D;4</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/vimopen.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/vimParenthesis.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/sn.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/close.png"></p><p>如何在vim中进行搜索</p><p>想要在 Vim 中进行搜索，必须处于 normal 模式。当你启动 Vim 编辑器的时候，你就在这个模式。 想要从其他任何模式回到正常模式，仅仅需要按 ESC 按键。</p><p>Vim 允许你使用<code>/</code>和<code>?</code>快速搜索文本。</p><p>想要向前搜索按<code>/</code>，想要向后搜索按<code>?</code>，输入搜索样式，并且按<code>Enter</code>进行搜索：</p><p>Vim 搜索的基本步骤如下：</p><p>01.按<code>/</code></p><p>02.输入搜索样式</p><p>03.按<code>Enter</code>进行搜索</p><p>04.按<code>n</code>搜索下一个匹配结果，或者<code>N</code>查找前面一个匹配结果。</p><p>例如搜索gnu输入&#x2F;\&lt;gnu\&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——进程管理</title>
      <link href="/2022/10/20/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/20/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>进程</p><p><u>进程是用来表示正在进行的程序。</u></p><p>内核中一些重要的进程信息如下：</p><p>进程的内存地址；</p><p>进程当前的状态；</p><p>进程正在使用的资源；</p><p>进程的优先级；</p><p>进程的属组；</p><p><strong>PID</strong>：进程的ID号</p><p><strong>PPID</strong>：父进程的PID</p><p>所有的进程都必须由另一个进程创建——除了系统在系统引导时，由内核自主创建并安装的进程。当一个进程被创建时，创建他的那个进程称为父进程。这个进程叫做子进程；PPID就是父进程的PID。</p><p>只有进程的创建者和root用户才有权对该进程进行操作，记录进程的创建者（属组）就必要了，进程的<strong>UID</strong>就是创建者的ID。</p><p>Linux为进程保存了有效用户ID号叫<strong>EUID</strong>，用来确定进程对某些资源和文件的访问权限。绝大部分情况，UID和EUID一样，除了seruid程序。</p><p>进程的<strong>GID</strong>是创建者所属组的ID号，进程同样有一个<strong>EGID</strong>号，当进程需要创建一个新文件时候，这个文件将采用该进程的GID。</p><h4 id="监视进程：PS命令"><a href="#监视进程：PS命令" class="headerlink" title="监视进程：PS命令"></a>监视进程：PS命令</h4><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d0ada7c0d.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d0ada7c0d.png" alt="屏幕截图 2022-10-20 123723.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line">$ ps lax##可以提供父进程ID（PPID）和谦让度（IN）</span><br></pre></td></tr></table></figure><h4 id="即时跟踪进程信息"><a href="#即时跟踪进程信息" class="headerlink" title="即时跟踪进程信息"></a>即时跟踪进程信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top##实时检测10更新一回q退出</span><br></pre></td></tr></table></figure><h4 id="查看占用文件的进程"><a href="#查看占用文件的进程" class="headerlink" title="查看占用文件的进程"></a>查看占用文件的进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof database.doc##查找文件的进程</span><br></pre></td></tr></table></figure><h4 id="向进程发送信号：kill"><a href="#向进程发送信号：kill" class="headerlink" title="向进程发送信号：kill"></a>向进程发送信号：kill</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d50bb4963.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d50bb4963.png" alt="屏幕截图 2022-10-20 125610.png"></a></p><h4 id="调整进程的谦让度（优先级的反义）nice和renice"><a href="#调整进程的谦让度（优先级的反义）nice和renice" class="headerlink" title="调整进程的谦让度（优先级的反义）nice和renice"></a>调整进程的谦让度（优先级的反义）nice和renice</h4><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d9a16f49d.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d9a16f49d.png" alt="屏幕截图 2022-10-20 131600.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——用户管理</title>
      <link href="/2022/10/19/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/19/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="添加新用户并建立主目录"><a href="#添加新用户并建立主目录" class="headerlink" title="添加新用户并建立主目录"></a>添加新用户并建立主目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uesradd -m john##添加用户叫john并建立主目录</span><br><span class="line">$ sudo passwd john##更改john的密码</span><br></pre></td></tr></table></figure><h4 id="添加用户命令行工具"><a href="#添加用户命令行工具" class="headerlink" title="添加用户命令行工具"></a>添加用户命令行工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useradd john##添加用户john</span><br><span class="line">$ passwd john##john设置密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -g users john##创立john并指定属于users组</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -s /bin/bash mike##建立mike用户并指定登陆后使用bash作为Shell</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd newgroup##在系统中太内疚newgroup的组</span><br></pre></td></tr></table></figure><h4 id="记录用户操作"><a href="#记录用户操作" class="headerlink" title="记录用户操作"></a>记录用户操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ history</span><br><span class="line">$ history 10##记录了最近用的10条指令</span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uesrdel mike##删除用户mike</span><br><span class="line">$ sudo userdel -r john##删除john删除其主目录</span><br></pre></td></tr></table></figure><h4 id="管理用户账号"><a href="#管理用户账号" class="headerlink" title="管理用户账号"></a>管理用户账号</h4><p><a href="https://cdn2.pandaimg.com/2022/10/19/634ff773348ce.png"><img src="https://cdn2.pandaimg.com/2022/10/19/634ff773348ce.png" alt="屏幕截图 2022-10-19 211029.png"></a></p><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ id hanfeng##查看用户的UID、GID及所属组的信息</span><br></pre></td></tr></table></figure><h4 id="用户转换"><a href="#用户转换" class="headerlink" title="用户转换"></a>用户转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su john##进入john用户</span><br><span class="line">$ exit##回到之前的用户</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇-压缩与解压缩</title>
      <link href="/2022/10/18/2022-10-18-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
      <url>/2022/10/18/2022-10-18-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h4 id="gzip压缩工具"><a href="#gzip压缩工具" class="headerlink" title="gzip压缩工具"></a>gzip压缩工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gzip gztest##压缩gztest</span><br><span class="line">$ gzip -d gztest##解压缩gztest</span><br><span class="line">$ gzip -r gztest##对文件夹压缩</span><br><span class="line">$ gzip -rd gztest.gz##对文件夹解压缩</span><br></pre></td></tr></table></figure><p>gzip 虽然对文件夹进行压缩，但是不能提供打包服务，只对文件夹<strong>内部的文件进行单独压缩。</strong></p><h4 id="bzip2压缩工具"><a href="#bzip2压缩工具" class="headerlink" title="bzip2压缩工具"></a>bzip2压缩工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bzip2 -z a.c##压缩</span><br><span class="line">$ bzip2 -d a.c.bz2##解压缩</span><br></pre></td></tr></table></figure><h4 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h4><p>tar工具提供打包服务，就是将多个文件打包。常用参数-f归档 ,-c创建新归档创建压缩文件，-x：从文档中解压缩</p><p>-j：使用bzip2压缩格式，-z 使用gzip压缩格式 -v 打印命令执行过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar -vxjf xxx.tar.bz2##解压缩</span><br><span class="line">$ tar -vcjf xxx.tar.bz2 xxx ##压缩</span><br><span class="line">$ tar -vxzfxxx.tar.gz##解压缩</span><br><span class="line">$ tar -vczf xxx.tar.gz xxx ##压缩</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇-软件包管理</title>
      <link href="/2022/10/16/2022-10-16-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/16/2022-10-16-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="管理-deb软件包"><a href="#管理-deb软件包" class="headerlink" title="管理.deb软件包"></a>管理.deb软件包</h4><h6 id="查看已安装的软件包"><a href="#查看已安装的软件包" class="headerlink" title="查看已安装的软件包"></a>查看已安装的软件包</h6><p> OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dpkg -l | grep openssh##查找openssh的版本信息</span><br><span class="line">$ dekg -s openssh##查看哪些文件是openssh带来的</span><br></pre></td></tr></table></figure><h6 id="安装卸载软件包"><a href="#安装卸载软件包" class="headerlink" title="安装卸载软件包"></a>安装卸载软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$sudo dpkg -i xxx.deb##安装xxx</span><br><span class="line"></span><br><span class="line">$sudo dpkg --remove opera##删除opera浏览器</span><br></pre></td></tr></table></figure><h4 id="管理RPM软件包"><a href="#管理RPM软件包" class="headerlink" title="管理RPM软件包"></a>管理RPM软件包</h4><h6 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -i -v -h dump-0.4b41-1.src.rpm##-i是安装命令-v显示正在执行工作-h打印提醒进度</span><br></pre></td></tr></table></figure><p>升级安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -Uvh dump-0.4b41-1.src.rpm</span><br></pre></td></tr></table></figure><p>查看已经安装的软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -q check##rpm -q命令可以查询已经安装的软件包是安装包文件的名字，不是文件的名字</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/16/634ba96fd0a8e.png"><img src="https://cdn2.pandaimg.com/2022/10/16/634ba96fd0a8e.png" alt="屏幕截图 2022-10-16 144841.png"></a></p><h6 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -e tcpdump##卸载tcpdump软件包</span><br></pre></td></tr></table></figure><h4 id="高级软件包工具APT"><a href="#高级软件包工具APT" class="headerlink" title="高级软件包工具APT"></a>高级软件包工具APT</h4><h6 id="下载和安装软件包"><a href="#下载和安装软件包" class="headerlink" title="下载和安装软件包"></a>下载和安装软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update##更新软件包</span><br><span class="line">$ sduo apt-get install wesnoth##下载安装wesnoth</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/16/634baf70f406c.png"><img src="https://cdn2.pandaimg.com/2022/10/16/634baf70f406c.png" alt="屏幕截图 2022-10-16 151437.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get -h##可以列出apt-get的完整用法</span><br></pre></td></tr></table></figure><h6 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache search flight##搜索带有flight的软件包</span><br><span class="line">$ apt-cache depends flightgear##查询flightgear的依赖关系</span><br></pre></td></tr></table></figure><p>apt-get是安装源放在&#x2F;etc&#x2F;apt&#x2F;source.list中，这是一个文本文件。</p><h6 id="源码文件安装"><a href="#源码文件安装" class="headerlink" title="源码文件安装"></a>源码文件安装</h6><p>make先编译</p><p>之后使用make install具体方法看软件安装要求</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——磁盘管理</title>
      <link href="/2022/10/16/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/16/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="磁盘管理三个常用的命令fdisk、du、df"><a href="#磁盘管理三个常用的命令fdisk、du、df" class="headerlink" title="磁盘管理三个常用的命令fdisk、du、df"></a>磁盘管理三个常用的命令fdisk、du、df</h4><p>df：检查文件系统的整体磁盘使用量</p><p>du：检查磁盘空间使用量</p><p>fdisk：用于磁盘的分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df [-ahikHTm][目录或文件名]##具体参数可以查看 df --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du [-ahskm] 文件或目录名称    ##具体参数可以查看 du --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk [-l] 装置名称##fdisk是Linux的磁盘分区表操作工具</span><br></pre></td></tr></table></figure><p>若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</p><p>linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。fsck（file system check）用来检查和维护不一致的文件系统。</p><p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck [-t 文件系统] [-ACay] 装置名称</span><br></pre></td></tr></table></figure><p>磁盘挂载使用mount卸载使用umount命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure><p>关于具体操作事例可以看<a href="https://zhuanlan.zhihu.com/p/296777898">一篇看懂！Linux磁盘的管理（分区、格式化、挂载），LVM逻辑卷，RAID磁盘阵列 - 知乎 (zhihu.com)</a></p><h4 id="创建并使用一个分区的步骤"><a href="#创建并使用一个分区的步骤" class="headerlink" title="创建并使用一个分区的步骤"></a>创建并使用一个分区的步骤</h4><p>①创建分区并分配空间</p><p>②磁盘格式化</p><p>③将格式化后的磁盘进行挂载</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——文件目录管理指令</title>
      <link href="/2022/10/13/2022-10-13-Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/10/13/2022-10-13-Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>linux系统不存在盘这个概念，用户通过操作目录来实现磁盘读写，Linux需要首先建立一个根‘“&#x2F;”文件系统，并在这个文件系统中建立一系列空目录，然后将其他硬盘分区中的 文件系统挂载到这些目录中。</p><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347abc1a4403.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347abc1a4403.png" alt="屏幕截图 2022-10-13 140836.png"></a></p><h6 id="用户间共享文件"><a href="#用户间共享文件" class="headerlink" title="用户间共享文件"></a>用户间共享文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##新建一个名为workgroup的用户组</span><br><span class="line">$ sudo groupadd workgroup</span><br><span class="line">##新建用户，并归入workgroup组</span><br><span class="line">$sudo useradd -G workgroup lucy</span><br><span class="line">$sudo passwd lucy##为用户lewis设置登录密码</span><br><span class="line">$sudo useradd -G workgroup lewis</span><br><span class="line">$sudo passwd lewis##为用户peter设置登录密码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="建立文件和目录"><a href="#建立文件和目录" class="headerlink" title="建立文件和目录"></a>建立文件和目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~##进入用户主目录</span><br><span class="line">$ mkdir document picture##新建两个目录</span><br><span class="line">$ mkdir ~/picture/temp##在主目录下新建名为temp的目录</span><br><span class="line">##如果没有中间的目录也就无法在下面创建一个新的文件或目录为此，使用-p选项</span><br><span class="line">$ mkdir -p ~/tempx/job##创建一个tempx文件夹在下面创建一个job文件夹</span><br></pre></td></tr></table></figure><h6 id="建立一个空文件"><a href="#建立一个空文件" class="headerlink" title="建立一个空文件"></a>建立一个空文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch hello##新建一个hello的文件</span><br><span class="line">$ touch hello##已经有hello的文件，所以可以更新hello文件的创建日期</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="移动和重命名"><a href="#移动和重命名" class="headerlink" title="移动和重命名"></a>移动和重命名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv hello bin/##移动hello到bin/中</span><br><span class="line">$ mv photos/桌面/   ##移动photos目录到桌面</span><br><span class="line">$ mv -i hello test/##使用防止替换同名文件并加以提示.</span><br><span class="line">$ mv -b hello test/##在目标目录的同名文件后面加上~，相当于重命名</span><br></pre></td></tr></table></figure><h6 id="复制文件和目录"><a href="#复制文件和目录" class="headerlink" title="复制文件和目录"></a>复制文件和目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp test.php test/##将test.php 放入到test下</span><br><span class="line">$ cp -i test.php test/##提示是否覆盖同名文件</span><br><span class="line">$ cp -r test/ 桌面/   ##连子目录带文件一起复制到下面</span><br></pre></td></tr></table></figure><h6 id="删除目录和文件"><a href="#删除目录和文件" class="headerlink" title="删除目录和文件"></a>删除目录和文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rmdir remove##删除目录</span><br><span class="line">$ rmdir text/*.php##删除test目录下的所有php文件</span><br><span class="line">$ rmdir -r test##删除前有提示</span><br><span class="line">$ rmdir -f##避免交互直接回答y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="改变文件所有权"><a href="#改变文件所有权" class="headerlink" title="改变文件所有权"></a>改变文件所有权</h6><p>chown语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [OPTION]... [OWNEr][:[GROUP]] FILE..</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347f350c425d.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347f350c425d.png" alt="屏幕截图 2022-10-13 191232.png"></a></p><p>sudo 提供-R选项用于改变一个目录及其下所有文件的所有权设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R lewis iso/##将iso/和下面所有文件交给lewis</span><br></pre></td></tr></table></figure><h6 id="改变目标文件权限"><a href="#改变目标文件权限" class="headerlink" title="改变目标文件权限"></a>改变目标文件权限</h6><p>chmod用于改变一个文件的权限。使用用户组+&#x2F;-权限的表达方式，来增加&#x2F;删除权限。用户组包括文件属主（u）、文件数组（g）、其他人（o）和所有人（a），权限包括读取（r）、写入（w）和执行（x）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod u+x days##增加属主对文件的执行权限</span><br><span class="line">$ chmod a-x days##删除所有人对days的执行权限</span><br><span class="line">$ chmod o=u days##将其他人的权限和属主一致</span><br></pre></td></tr></table></figure><p>chmod（change mode）命令是控制用户对文件的权限的命令，文件类型和文件权限由 10 个字符组成：<br>第 1 位表示文件的类型；<br>第 2 - 4 位表示文件所有者对文件的权限；<br>第 5 - 7 位表示文件所有者所在组的用户对文件的权限；<br>第 8 - 10 位表示其他用户对文件的权限；<br>其中 r 表示可读，w 表示可写，x 表示可执行，- 表示没有权限。<br>如果可读，权限二进制为 100，十进制是4；<br>如果可写，权限二进制为 010，十进制是2；<br>如果可执行，权限二进制为 001，十进制是1；</p><h6 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h6><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347f9e831a3c.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347f9e831a3c.png" alt="屏幕截图 2022-10-13 194308.png"></a></p><p>Linux有两类设备文件：字符设备和块设备文件。字符设备指的是能够从他那里读取成字符序列的设备，如磁带和串行线路，块设备指的是用来存储数据并对其各部分内容提供同等访问权的设备。如磁盘。</p><h6 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h6><p>符号链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s days my_days##建立一个my_days的符号链接指向文本文件days</span><br></pre></td></tr></table></figure><p>访问my_days就相当于访问days了。可以看作快捷方式删除并不会对源文件有影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s /usr/local/share/ local_share##建立一个指向/usr/local/share的符号链接local_share</span><br></pre></td></tr></table></figure><p>硬链接：将两个独立的文件联系在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln days hard_days##建立一个链接到days的新文件hard_days</span><br></pre></td></tr></table></figure><p>两个文件的改动会相互影响。</p><h6 id="输入输出重定向和管道"><a href="#输入输出重定向和管道" class="headerlink" title="输入输出重定向和管道"></a>输入输出重定向和管道</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls &gt; ~/ls_out##将ls的输出重定向到lsout文件中，ls的输出不显示在屏幕上</span><br></pre></td></tr></table></figure><p>如果ls_out不存在那么会尝试建立这个文件，如果已经存在会替换原来的文件内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; days##让程序从一个文件中获取输入</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/13/634808e94fcc6.png"><img src="https://cdn2.pandaimg.com/2022/10/13/634808e94fcc6.png" alt="屏幕截图 2022-10-13 204659.png"></a></p><h6 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h6><p><a href="https://cdn2.pandaimg.com/2022/10/13/6348095b998d1.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6348095b998d1.png" alt="屏幕截图 2022-10-13 204909.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——基本指令</title>
      <link href="/2022/10/12/2022-10-12-Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/10/12/2022-10-12-Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h6 id="浏览文件硬盘"><a href="#浏览文件硬盘" class="headerlink" title="浏览文件硬盘"></a>浏览文件硬盘</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /         ##进入根目录</span><br><span class="line">$ ls           ##列出文件和目录</span><br><span class="line">$ cat animal.c ##查看animal.c</span><br></pre></td></tr></table></figure><p>在输入文件名时候，只用输入前面几个字符按下TAB，Shell会自动补全。如果不止一个，shell会以列表形式全部打印出来。</p><h6 id="查看目录和文件"><a href="#查看目录和文件" class="headerlink" title="查看目录和文件"></a>查看目录和文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pwd                     ##显示当前目录</span><br></pre></td></tr></table></figure><h6 id="改变目录"><a href="#改变目录" class="headerlink" title="改变目录"></a>改变目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..##进入/usr子目录</span><br><span class="line">$ cd ../..##进入根目录即/目录</span><br><span class="line">$ cd ##回到用户主目录</span><br></pre></td></tr></table></figure><h6 id="列出目录"><a href="#列出目录" class="headerlink" title="列出目录"></a>列出目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -a##查看目录下的所有文件包含隐藏文件</span><br><span class="line">$ ls -1##查看文件的各种属性</span><br><span class="line">$ ls -F##区分目录下文件类型</span><br></pre></td></tr></table></figure><h6 id="列出目录-1"><a href="#列出目录-1" class="headerlink" title="列出目录"></a>列出目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dir##和ls一样</span><br><span class="line">$ vdir##相当于ls-1</span><br></pre></td></tr></table></figure><h6 id="查看文本文件"><a href="#查看文本文件" class="headerlink" title="查看文本文件"></a>查看文本文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat bool。c##查看bool.c文件的内容</span><br><span class="line">$ cat bool.c data.c##查看bool.c data.c 文件内容，可以查看不只一个文件内容</span><br><span class="line">$ cat -n bool.c##可以问内容前显示行数</span><br></pre></td></tr></table></figure><h6 id="阅读的文件开头和结尾"><a href="#阅读的文件开头和结尾" class="headerlink" title="阅读的文件开头和结尾"></a>阅读的文件开头和结尾</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ head data.c##显示data。c的开头</span><br><span class="line">$ head -n 2 data.c##显示data.c文件的前两行</span><br></pre></td></tr></table></figure><h6 id="文本阅读less"><a href="#文本阅读less" class="headerlink" title="文本阅读less"></a>文本阅读less</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ less /c/data.c##打开C下的data.c文件</span><br><span class="line">之后向下翻页按空格向上翻页按B使用/内容，可以查询高亮显示查询下一个再输入/</span><br><span class="line">按下q可退出</span><br></pre></td></tr></table></figure><h6 id="查找文件内容"><a href="#查找文件内容" class="headerlink" title="查找文件内容"></a>查找文件内容</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep main data.c##查找data.c中包含main的行</span><br><span class="line">$ grep main data.c animal.c     ##可以在多个文件中查找，查关键词时候要加上‘’单引号</span><br></pre></td></tr></table></figure><h6 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [OPTION] [path..] [expression]</span><br><span class="line">$ find c/d/2.c##c/d/2.c</span><br><span class="line">$ find c/d -name 2.c##c/d2.c</span><br><span class="line">$ find c/d -name 2.c -printf ok ##ok</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find c/d -type f -mtime -7 ##7天内修改过的文件</span><br></pre></td></tr></table></figure><h6 id="快速定位文件"><a href="#快速定位文件" class="headerlink" title="快速定位文件"></a>快速定位文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locate *.c</span><br></pre></td></tr></table></figure><h6 id="查找特定程序"><a href="#查找特定程序" class="headerlink" title="查找特定程序"></a>查找特定程序</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ whereis find##查找find</span><br><span class="line">$ whereis -b find##查找这个程序的二进制可执行文件</span><br></pre></td></tr></table></figure><h6 id="用户版本信息查看"><a href="#用户版本信息查看" class="headerlink" title="用户版本信息查看"></a>用户版本信息查看</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ who##看有哪些人登录</span><br><span class="line">$ whoami##我是谁</span><br></pre></td></tr></table></figure><h6 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a##显示系统版本信息</span><br><span class="line">$ uname -r##显示内核版本信息</span><br></pre></td></tr></table></figure><h6 id="寻求帮助指令"><a href="#寻求帮助指令" class="headerlink" title="寻求帮助指令"></a>寻求帮助指令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man find##获取find指令的信息</span><br></pre></td></tr></table></figure><h6 id="获取命令简介"><a href="#获取命令简介" class="headerlink" title="获取命令简介"></a>获取命令简介</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whatis uame##-printf system information</span><br></pre></td></tr></table></figure><h6 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h6><p>ldd可以列出一个程序所需要的共享库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldd animal##查询animal文件需要的animal文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32实战篇</title>
      <link href="/2022/10/09/2022-10-9-stm32%E5%AE%9E%E6%88%98%E7%AF%87/"/>
      <url>/2022/10/09/2022-10-9-stm32%E5%AE%9E%E6%88%98%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="实战第一篇跑马灯"><a href="#实战第一篇跑马灯" class="headerlink" title="实战第一篇跑马灯"></a>实战第一篇跑马灯</h2><p>第一篇没什么好说的，没什么新鲜的东西，就是使用cubemx进行建立工程，新建led.c和led.h文件，对引脚进行赋予高低电平，此次不一样的是在led.h文件中对相应的IO口用英文做了宏定义，防止以后进行重复混乱调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_PIN         GPIO_PIN_8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_GPIO_PORT   GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_PIN         GPIO_PIN_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_GPIO_PORT   GPIOD</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="实战第二篇按键检测"><a href="#实战第二篇按键检测" class="headerlink" title="实战第二篇按键检测"></a>实战第二篇按键检测</h2><h4 id="硬件消抖"><a href="#硬件消抖" class="headerlink" title="硬件消抖"></a>硬件消抖</h4><p>首先是硬件的设计，按下按键不会立即响应，有波纹信号，不方便检测需要进行滤波消抖。可以利用电容的放电延迟达到消除抖动的目的，这样只需要检测引脚的电平。</p><p><a href="https://postimg.cc/62dPcFkc"><img src="https://i.postimg.cc/hjwqDBMk/2022-09-27-181925.png" alt="2022-09-27-181925.png"></a></p><h4 id="软件消抖"><a href="#软件消抖" class="headerlink" title="软件消抖"></a>软件消抖</h4><p>当检测到按键状态变化后，先等待一个10ms左右的延时时间，让抖动消失后再进行一次按键状态检测，如果与刚才的状态相同，就是稳定了，但是有局限性。</p><p>查询相关IO口在cubemx中进行设置为输入状态。由于引脚的默认电平受按键电路影响，所以设置成“浮空&#x2F;上拉&#x2F;下拉”模式均没有区别。</p><p>arm汇编指令集</p><p><a href="https://postimg.cc/v413R6K1"><img src="https://i.postimg.cc/zG7MgCSk/2022-09-27-202146.png" alt="2022-09-27-202146.png"></a></p><p>栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部 SRAM 的大<br>小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。如果某一天，你<br>写的程序出现了莫名奇怪的错误，并进入了硬 fault 的时候，这时你就要考虑下是不是栈不够大，<br>溢出了。堆主要用来动态内存的分配</p><h2 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h2><p>设置系统时钟 SYSCLK、设置 AHB 分频因子（决定 HCLK 等于多少）、设置 APB2 分频因子（决<br>定 PCLK2 等于多少）、设置 APB1 分频因子（决定 PCLK1 等于多少）、设置各个外设的分频因子；<br>控制 AHB、APB2 和 APB1 这三条总线时钟的开启、控制每个外设的时钟的开启。</p><p>一般是：PCLK2 &#x3D; HCLK &#x3D; SYSCLK&#x3D;PLLCLK &#x3D; 72M，<br>               PCLK1&#x3D;HCLK&#x2F;2 &#x3D; 36M</p><p>HSE 是高速的外部时钟信号，可以由有源晶振或者无源晶振提供，频率从 4-16MHZ 不等。当<br>使用有源晶振时，时钟从 OSC_IN 引脚进入，OSC_OUT 引脚悬空，当选用无源晶振时，时钟从<br>OSC_IN 和 OSC_OUT 进入，并且要配谐振电容。</p><p>系统时钟 SYSCLK 经过 AHB 预分频器分频之后得到时钟叫 APB 总线时钟，即 HCLK。</p><p>APB2 总线时钟 PCLK2 由 HCLK 经过高速 APB2 预分频器得到，HCLK2 属于高速的总线时钟，片上<br>高速的外设就挂载到这条总线上。APB1 总线时钟 PCLK1 由 HCLK 经过低速 APB 预分频器得到，PCLK1 属于低速的总线时钟，最高为 36M，片上低速的外设就挂载到这条总线上，比如 USART2&#x2F;3&#x2F;4&#x2F;5、SPI2&#x2F;3，I2C1&#x2F;2 等。</p><p>USB 时钟是由 PLLCLK 经过 USB 预分频器得到，USB 对时钟要求比较高，所以 PLLCLK 只能是由 HSE 倍频得到，不能使用 HSI 倍频。</p><p>ADC 时钟由 PCLK2 经过 ADC 预分频器得到。</p><p>RTC 时钟可由 HSE&#x2F;128 分频得到，也可由低速外部时钟信号 LSE 提供，频率为 32.768KHZ，也可由<br>低速内部时钟信号LSI提供。独立看门狗的时钟由 LSI 提供，且只能是由 LSI 提供，LSI 是低速的内部时钟信号，频率为 30~60KHZ 直接不等，一般取 40KHZ。</p><h2 id="中断应用"><a href="#中断应用" class="headerlink" title="中断应用"></a>中断应用</h2><p>在 NVIC 有一个专门的寄存器：中断优先级寄存器 NVIC_IPRx，用来配置外部中断的优先级，IPR宽度为 8bit，原则上每个外部中断可配置的优先级为 0~255，数值越小，优先级越高。如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行，如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。</p><p>IRQn：用来设置中断源</p><p>PreemptionPriority：抢占优先级</p><p>SubPriority：子优先级</p><h5 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h5><p>EXTI（External interrupt&#x2F;event controller）—外部中断&#x2F;事件控制器，管理了控制器的 20 个中断&#x2F;事件线。每个中断&#x2F;事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。</p><p>产生中断线路目的是把输入信号输入到 NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。而产生事件线路目的就是传输一个脉冲信号给其他外设使用，并且是电路级别的信号传输，属于硬件级的。</p><p>cubemx进行引脚配置，对相应的IO引脚选择GPIO_EXITx,xi表示挂载在中断线几，如GPIO_EXTI0就是挂在中断线0上。</p><p>开启下降沿触发中断：即在 <strong>按下按键时</strong> 电平由高变为低时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Falling edge trigger detection</code> </p><p>开启上升沿触发中断：即在 <strong>按下按键后松开时</strong> 电平由低变为高时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising edge trigger detection</code> </p><p>开启下降沿上升沿都触发中断：即在 <strong>按下时触发，松开时再次触发</strong>，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising/Falling edge trigger detection</code></p><p>如果硬件上已外部上拉或下拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>No pull-up and no pull-down</code> 既不上拉也不下拉。</p><p>如果硬件外部没有上拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>Pull-up</code> 内部上拉电阻。</p><p>如果不希望电平跳变事件触发中断，就配置为事件模式，反之，配置为中断模式。</p><p>中断执行流程为先中断初始化，使用中断可以避免使用论询来检测，发生电平变化触发外部中断，进入中断服务函数，中断服务函数中会调用中断处理公用函数（使用cubemx会在stm32f1xx_it.c中自动生成），中断处理公用函数中会检测标志位，并清零执行回调函数，终端中要执行的事情就放入中断回调函数中。</p><p>可以在stm32f1xx_it.c中看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 0 */</span></span><br><span class="line">  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go to Defnition of HAL_GPIO_EXTI_IRQHandler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">  <span class="keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="number">0x00</span>u)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断并清除中断标志位，然后调用HAL_GPIO_EXTI_Callback(GPIO_Pin);处理中断，同样的方式找到HAL_GPIO_EXTI_Callback的定义，你可以看到这个函数的声明前面有一个__weak声明，这个声明表示这个函数一旦被重新声明，这里的函数就自动失效，其他函数调用的时候就会找到你新定义的同名函数。</p><h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h2><p>通讯协议，我们也以分层的方式来理解，最基本的是把它分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。串口通讯有很多标准，以下是RS-232标准</p><p><a href="https://postimg.cc/zHmFByDH"><img src="https://i.postimg.cc/d33H5Cz6/2022-09-30-200343.png" alt="2022-09-30-200343.png"></a></p><p>由于 RS-232 电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个“电平转换芯片”转换成控制器能识别的“TTL 标准”的电平信号，才能实现通讯。电平标准不同分为TTL标准和RS232电平标准</p><p><a href="https://postimg.cc/LhHzyFYp"><img src="https://i.postimg.cc/2jW2SzCV/2022-09-30-201456.png" alt="2022-09-30-201456.png"></a></p><p><a href="https://postimg.cc/MXCz6q7k"><img src="https://i.postimg.cc/zXBvkf3f/2022-09-30-201723.png" alt="2022-09-30-201723.png"></a></p><p>通用同步异步收发器 (Universal Synchronous Asynchronous Receiver and Transmitter) 是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。有别于 USART 还有一个 UART(UniversalAsynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能，只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</p><p>串口通信有三种方式，分别为论询方式、中断方式、DMA方式。串口的通讯协议由开始位，数据位，校验位，结束位构成。一般以一个低电平作为一帧数据的起始，接着跟随 8 位或者 9 位数据位，之后为校验位，分为奇校验，偶校验和无校验，最后以一个先高后低的脉冲表示结束位，长度可以设置为 0.5，1，1.5 或 2 位长度。</p><p>当使用校验位时，串口传输的长度将是 8 位的数据帧加上 1 位的校验位总共 9 位，此时 USART_CR1 寄存器的 M 位需要设置为 1，即 9 数据位。将 USART_CR1 寄存器的 PCE 位置 1 就可以启动奇偶校验控制，奇偶校验由硬件自动完成。启动了奇偶校验控制之后，在发送数据帧时会自动添加校验位，接收数据时自动验证校验位。接收<br>数据时如果出现奇偶校验位验证失败，会见 USART_SR 寄存器的 PE 位置 1，并可以产生奇偶校验中断。使能了奇偶校验控制后，每个字符帧的格式将变成：起始位 + 数据帧 + 校验位 + 停止位</p><p>​      什么是硬件流控呢？流控的概念源于 RS232 这个标准，在 RS232 标准里面包含了串口、流控的定义。大家一定了解，RS232 中的“RS”是Recommend Standard 的缩写，即”推荐标准“之意，它并不像 IEEE-1284、IEEE-1394 等标准，是由“委员会定制”。因而，不同的厂商在做 RS232 时，多少会有不同，流控也都会存在差异。</p><p>为什么需要流控?</p><p>　　数据在两个串口之间进行通讯的时候常常会出现丢失数据的现象，比如两台计算机或者是一台计算机和一个单片机之间进行通讯，当接收端的数据缓冲区已经满了，这个时候如果还有数据发送过来，因为接收端没有时间进行处理，那这样的数据就有可能会丢失。在工业现场或者其他领域，经常会遇到这种问题，本质原因是速度不匹配、处理能力不匹配。比如单片机的主频只有20M或30M，ARM的处理能力可能是200M，PC机的处理能力是几个G，这种处理能力的不匹配造成了传输的时候数据容易丢失。</p><p>　　硬件流控就是来解决这个速度匹配的问题。它的基本含义非常简单，当接收端接收到的数据处理不过来时，就向发送端发送不再接收的信号，发送端接收到这个信号之后就会停止发送，直到收到可以继续发送的信号再继续发送。因此流控本身是可以控制数据传输的进度，进而防止数据丢失。</p><p>　　一般常用的流控方式有两种：硬件流控和软件流控。</p><p>​硬件流控和软件流控的区别</p><p>　　软件流控是以特殊的字符来代表从机已经不能再接收新的数据了，基本的流程就是从机在接收数据很多的时候或主动给发送端发送一个特殊字符，当发送端接收到这个特殊字符后就不能再发送数据了。</p><p>　　软件流控很方便，不需要增加新的硬件，还是以前的TX、RX，但是使用了软件流控，它本身的字符也是数据，这个数据只不过是说在软件里把它设置了一个特殊的含义。如果它是一个全双工的通讯，在给另一个串口发送数据的时候如果也包含了这样一个特殊字符，对方就会误以为我让它不要再发送数据了，会有一定的概率出现错误，而硬件流控就不需要考虑这方面，只需要使用 CTS 和 RTS，所有的数据都是由硬件来操作的。具体可以看<img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230227_210206.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line">HAL_UART_Transmit();串口轮询模式发送，使用超时管理机制</span><br><span class="line">HAL_UART_Receive();串口轮询模式接收，使用超时管理机制</span><br><span class="line">HAL_UART_Transmit_IT();串口中断模式发送</span><br><span class="line">HAL_UART_Receive_IT();串口中断模S式接收</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式发送</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式接收</span><br><span class="line"><span class="number">2</span>、阻塞传输是调用这个函数并在等待时间内一直等待操作完成。</span><br><span class="line">HAL_UART_Transmit</span><br><span class="line">HAL_UART_Receive</span><br><span class="line">查询的方式一般少用，这里不做过多介绍。</span><br><span class="line"><span class="number">3</span>、串口中断</span><br><span class="line">串口中断函数</span><br><span class="line">HAL_UART_TxHalfCpltCallback();一半数据发送完成时调用</span><br><span class="line">HAL_UART_TxCpltCallback();数据完全发送完成后调用</span><br><span class="line">HAL_UART_RxHalfCpltCallback();一半数据接收完成时调用</span><br><span class="line">HAL_UART_RxCpltCallback();数据完全接受完成后调用</span><br><span class="line">HAL_UART_ErrorCallback();传输出现错误时调用</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Qxiaofei_/article/details/119029425">(具体配置) 【STM32】HAL库——串口中断通信(二)_Q大帅的博客-CSDN博客_hal 串口中断</a></p><p>当printf打印不好使时是因为工程中没有选Micro USB</p><p><a href="https://postimg.cc/Z9kXMvXH"><img src="https://i.postimg.cc/XvX3Xw8R/2022-10-04-193120.png" alt="2022-10-04-193120.png"></a></p><p><a href="https://blog.csdn.net/zxt510001/article/details/125892562">() STM32 HAL库串口串口通信基础知识+HAL库代码理解</a></p><h2 id="DMA-直接存储访问"><a href="#DMA-直接存储访问" class="headerlink" title="DMA-直接存储访问"></a>DMA-直接存储访问</h2><p>DMA是单片机外设，不占用CPU，传输数据时候CPU可以做别的。如果外设要想通过 DMA 来传输数据，必须先给 DMA 控制器发送 DMA 请求，DMA 收到请求信号之后，控制器会给外设一个应答信号，当外设应答后且 DMA 控制器收到应答信号之后，就会启动 DMA 的传输，直到传输完毕。DMA有12个可独立编程通道，每个通道对应不同的外设DMA请求，可以接受多个请求，但同时只能接受一个。仲裁器，处理响应顺序的问题，分为软件阶段和硬件阶段，可以在 DMA_CCRx 寄存器中设置，有 4 个等级：非常高、高、中和低四个优先级，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高。</p><p>MA 传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器。具体的方向 DMA_CCR 位 4 DIR 配置：0 表示从外设到存储器，1 表示从存储器到外设。</p><p>更多原理可参看<a href="https://blog.csdn.net/as480133937/article/details/104927922"> DMA原理</a></p><p>在cubemx的配置只需要加上相应设备的DMA模式便可以生成代码进行使用。</p><p>I2C协议</p><p>首先分为物理层和协议层，两方面来看。</p><h4 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h4><p>它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。</p><p>一个 I2C 总线只使用两条总线线路，一条双向串行数据线 (SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。</p><p> 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。</p><p>总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</p><p>多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p><p>具有三种传输模式：标准模式传输速率为 100kbit&#x2F;s ，快速模式为 400kbit&#x2F;s ，高速模式下可达 3.4Mbit&#x2F;s，但目前大多 I2C 设备尚不支持高速模式</p><h4 id="协议层："><a href="#协议层：" class="headerlink" title="协议层："></a>协议层：</h4><p>I2C 的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。</p><p>S 表示由主机的 I2C 接口产生的传输起始信号 (S)，这时连接到 I2C 总线上的所有从机都会接收到这个信号。<br>起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号 (SLAVE_ADDRESS)。在I2C 总线上，每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7位或 10 位。在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。从机接收到匹配的地址后，主机或从机会返回一个应答 (ACK) 或非应答 (NACK) 信号，只有接收<br>到应答信号后，主机才能继续发送或接收数据。</p><p>若是传输为写数据方向，接收到应答信号后，主机开始正式向从机传输数据 (DATA)，数据包的大小为 8 位那么主机每发送完一个字节数据，都要等待从机的应答信号 (ACK)。</p><p>若配置的方向传输位为“读数据”方向，接收到应答信号后，从机开始向主机返回数据 (DATA)，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号 (ACK)。</p><p><a href="https://cdn2.pandaimg.com/2022/10/11/634564df3130c.png"><img src="https://cdn2.pandaimg.com/2022/10/11/634564df3130c.png" alt="SDA.png"></a></p><h5 id="SCL处于1时-SDA由高变低↓—-gt-Start"><a href="#SCL处于1时-SDA由高变低↓—-gt-Start" class="headerlink" title="SCL处于1时, SDA由高变低↓—&gt;Start"></a>SCL处于1时, SDA由高变低↓—&gt;Start</h5><h5 id="图中末尾P为结束信号-SCL-x3D-1-SDA-由低变高"><a href="#图中末尾P为结束信号-SCL-x3D-1-SDA-由低变高" class="headerlink" title="图中末尾P为结束信号: SCL&#x3D;1, SDA 由低变高"></a>图中末尾P为结束信号: SCL&#x3D;1, SDA 由低变高</h5><h5 id="数据传送-每次数据传送都是8个字节-SCL-x3D-1时-SDA的数据不可以变化-只有SCL为低电平-数据线的数据才可以变化"><a href="#数据传送-每次数据传送都是8个字节-SCL-x3D-1时-SDA的数据不可以变化-只有SCL为低电平-数据线的数据才可以变化" class="headerlink" title="数据传送: 每次数据传送都是8个字节; SCL&#x3D;1时, SDA的数据不可以变化, 只有SCL为低电平, 数据线的数据才可以变化;"></a>数据传送: 每次数据传送都是8个字节; SCL&#x3D;1时, SDA的数据不可以变化, 只有SCL为低电平, 数据线的数据才可以变化;</h5><p><a href="%5B(88%E6%9D%A1%E6%B6%88%E6%81%AF"> IIchal相关函数分析</a> <a href="https://blog.csdn.net/kouxi1/article/details/123834448?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32hal%E5%BA%93iic&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-123834448.142%5Ev52%5Econtrol,201%5Ev3%5Econtrol&spm=1018.2226.3001.4187">015] [STM32] IIC协议详解与HAL库相关函数分析_柯西的彷徨的博客-CSDN博客</a>)</p><h2 id="SPI协议"><a href="#SPI协议" class="headerlink" title="SPI协议"></a>SPI协议</h2><p>SPI是一种高速全双工的通信总线</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>SPI 通讯使用 3 条总线及片选线，3 条总线分别为 SCK、MOSI、MISO，片选线</p><p>从设备选择信号线，常称为片选信号线，也称为 NSS、CS设备的其它信号线 SCK、MOSI 及 MIS O 同时并联到相同的 SPI 总线上，即无论有多少个从设备，都共同只使用这 3 条总线；而每个从设备都有独立的这一条 NSS 信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。而 SPI 协议中没有设备地址，它使用 NSS 信号线来寻址，当主机要选择从设备时，把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI 通讯。所以 SPI 通讯以 NSS 线置低电平为开始信号，以 NSS 线被拉高作为结束信号。</p><p>SCK ：时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样。<br> MOSI ：主设备输出&#x2F;从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。<br>MISO(Master Input,，Slave Output)：主设备输入&#x2F;从设备输出引脚。主机从这条信线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。</p><p><a href="https://cdn2.pandaimg.com/2022/10/11/63457405a869b.png"><img src="https://cdn2.pandaimg.com/2022/10/11/63457405a869b.png" alt="屏幕截图 2022-10-11 214647.png"></a></p><p>NSS 信号线由高变低，是 SPI 通讯的起始信号。NSS 是每个从机各自独占的信号线，当从机在自己的 NSS 线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号处，NSS 信号由低变高，是 SPI 通讯的停止信号，表示本次通讯结束，从机的选中状态被取消。</p><p>观察图中的标号处，MOSI 及 MISO 的数据在 SCK 的上升沿期间变化输出，在 SCK 的下降沿时被采样。即在 SCK 的下降沿时刻，MOSI 及 MISO 的数据有效，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效，MOSI 及 MISO 为下一次表示数据做准备。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32系统学习</title>
      <link href="/2022/09/24/2022-12-17-stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/24/2022-12-17-stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>stm32主系统由四个去驱动单元和四个被动单元构成。</strong></p><p>四个驱动是内核DCode总线；系统总线；通用DMA1；通用DMA2</p><p>四被动单元是AHB到APB的桥：连接所有APB的设备；内存FLASH；内部SRAM；FSMC</p><p>① ICode 总线：该总线将 M3 内核指令总线和闪存指令接口相连，指令的预取在该总线上<br>面完成。<br>② DCode 总线：该总线将 M3 内核的 DCode 总线与闪存存储器的数据接口相连接，常量<br>加载和调试访问在该总线上面完成。<br>③ 系统总线：该总线连接 M3 内核的系统总线到总线矩阵，总线矩阵协调内核和 DMA 间<br>访问。<br>④ DMA 总线：该总线将 DMA 的 AHB 主控接口与总线矩阵相连，总线矩阵协调 CPU 的<br>DCode 和 DMA 到 SRAM,闪存和外设的访问。<br>⑤ 总线矩阵：总线矩阵协调内核系统总线和 DMA 主控总线之间的访问仲裁，仲裁利用<br>轮换算法。<br>⑥ AHB&#x2F;APB 桥:这两个桥在 AHB 和 2 个 APB 总线间提供同步连接，APB1 操作速度限于<br>36MHz,APB2 操作速度全速。</p><p><strong>stm32的5个时钟源</strong></p><p>用来配置时钟树</p><p>①HSI 是高速内部时钟，RC 振荡器，频率为 8MHz。<br>②HSE 是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz到16MHz。<br>③LSI 是低速内部时钟，RC 振荡器，频率为 40kHz。独立看门狗的时钟源只能是 LSI，同<br>时 LSI 还可以作为 RTC 的时钟源。<br>④LSE 是低速外部时钟，使用频率为 32.768kHz 的石英晶体。这个主要是 RTC 的时钟源。<br>⑤PLL 为锁相环倍频输出，其时钟输入源可选择为 HSI&#x2F;2、HSE 或者 HSE&#x2F;2。倍频可选择为2到16 倍，但是其输出频率最大不得超过 72MHz。</p><p>程序执行顺序</p><p><a href="https://postimg.cc/68vJqYZh"><img src="https://i.postimg.cc/2SHzHt8g/liucheng.png" alt="liucheng.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32最小系统板制作</title>
      <link href="/2022/09/21/2022-09-21-stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/09/21/2022-09-21-stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>此次制作使用的为立创EDA，主要是快速上手制板，没有选择AD。</p><p>首先了解<strong>stm32最小系统电路</strong>构成如下：</p><p>复位电路、电源电路、SWD&#x2F;JTAG下载接口、晶振电路（时钟电路）、启动选择电路、stm32构成。</p><p>关于启动选择电路可以查看以下链接来了解。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">Boot模式选择</a> STM32中BOOT模式配置的作用_qq_22010549的博客-CSDN博客_stm32f103boot设置](<a href="https://blog.csdn.net/qq_22010549/article/details/123425814">https://blog.csdn.net/qq_22010549/article/details/123425814</a>))</p><p>可以将boot0和boot1的两个分别设计单刀双制开关接3.3V和GND</p><p>主闪存模式是用<strong>flash</strong>，使用串口下载，或者可以选择使用SWD，或者将串口接一个板载USB电路，使用usb接口来进行下载。</p><p>本款设计芯片选择stm32f103RCT６芯片。</p><p>晶振电路分别使用两种晶振８MＨｚ晶振提供外部时钟和３２．７６８ＫＨｚ内部晶振为RTC提供时钟信号。</p><p>复位电路由电容、电阻、开关组成，电路采用手动复位的方式，当开关闭合时电路导通，RSET为芯片的复位引脚信号，此时芯片复位引脚接通GND，芯片将会复位重启。其中的电容的功能则是储能，当开发板上电瞬间，电容开始充电，复位引脚为低电平，所以上电瞬间开发板也会复位重启，但随着电容充电完成，引脚变为高电平，则不会再进行复位重启。</p><p>为了方便下载程序设计JTAG电路</p><p>电源电路把电源电压稳压在3.3V给单片机供电。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">稳压电路选择</a> 5V降压转3.3V，5V转3V电路图芯片_usb type的博客-CSDN博客_5v转3.3v稳压芯片](<a href="https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142%5Ev49%5Econtrol,201%5Ev3%5Econtrol_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142^v49^control,201^v3^control_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187</a>))</p><p>大多数选择为LDO电路，使用的一般为LM1117或者AMS117芯片。</p><p>stm32的MCU接口VDD接正极3.3V，VSS接地，VBAT使用电池或者其他电源，</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arm-linux -ld、-objcopy和obdump</title>
      <link href="/2022/07/08/2022-7-8-arm-linux-ld%E5%92%8Carm-linux-objcopy/"/>
      <url>/2022/07/08/2022-7-8-arm-linux-ld%E5%92%8Carm-linux-objcopy/</url>
      
        <content type="html"><![CDATA[<p><strong>arm-linux-ld用于将多个目标文件、库文件连接成可执行文件。</strong></p><p>-T 直接指定代码段、数据段、bss段的起始地址,只用于连接Bootloader、内核等没有底层软件支持的软件</p><p>连接操作系统应用程序时候，无需-T，默认连接。</p><p>1.直接指定代码段、数据段、bss段的起始地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure><p>startaddr分别代表代码段、数据段、bss段的起始地址</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-ld -Ttext 0x000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure><p>代表代码段运行地址为0x000000，没有定义数据段、bss段起始地址所以被放入代码段的后面</p><p>2.使用连接脚本设置地址</p><p><strong>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可用不同于源文件的格式来输出目的文件，即可以进行格式转换。</strong></p><p>1、input-file、outfile分别是输入目标文件和输出目标文件，如果没有明确指定outfile，将创建一个临时文件来存放结果，用input-file的名字来命名。</p><p>2、 -l bfname或–input-target&#x3D;bfdname</p><p>用来指明源文件的格式，bfdname是BFD库描述的标准格式名，如果不指明格式，会自己分析源文件格式，去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</p><p>3、-O bfdname或–output-target&#x3D;bfdname</p><p>使用指定格式来输出文件，bdfname是BFD库中的标准格式名。</p><p><strong>arm-linux-objdump用于显示二进制文件信息</strong></p><p>未完待续。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32hal库</title>
      <link href="/2022/07/01/2022-7-1-stm32hal%E5%BA%93/"/>
      <url>/2022/07/01/2022-7-1-stm32hal%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>为方便使用，用typedef来给变量起名将以下放入main.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>  s32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int16_t</span> s16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int8_t</span>  s8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int32_t</span> sc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int16_t</span> sc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int8_t</span> sc8;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int32_t</span>  vs32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int16_t</span>  vs16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int8_t</span>   vs8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int32_t</span> vsc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int16_t</span> vsc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int8_t</span> vsc8;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span>  u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span>  u8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint32_t</span> uc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint16_t</span> uc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint8_t</span> uc8; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint32_t</span>  vu32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint16_t</span> vu16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint8_t</span>  vu8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint32_t</span> vuc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint16_t</span> vuc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint8_t</span> vuc8;  </span><br></pre></td></tr></table></figure><p>点亮led</p><p>GPIO用IO口的输出模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOF,GPIO_PIN_9,GPIO_PIN_SET);<span class="comment">//控制电平</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5);<span class="comment">//翻转电平</span></span><br><span class="line">HAL_GPIO_ReadPin(GPIOA, GPIO_Pin_8);<span class="comment">//读取电平</span></span><br></pre></td></tr></table></figure><p>点亮led就需要按键了，按键首先要看按键的引脚设置IO口为输入模式，写一个案件处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">static</span> u8 key_up=<span class="number">1</span>; <span class="comment">//按键松开标志</span></span><br><span class="line"> <span class="keyword">if</span>(mode==<span class="number">1</span>)key_up=<span class="number">1</span>; <span class="comment">//支持连按</span></span><br><span class="line"> <span class="keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="number">0</span>||KEY1==<span class="number">0</span>||WK_UP==<span class="number">1</span>))</span><br><span class="line"> &#123;</span><br><span class="line"> delay_ms(<span class="number">10</span>);</span><br><span class="line"> key_up=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(KEY0==<span class="number">0</span>) <span class="keyword">return</span> KEY0_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">0</span>) <span class="keyword">return</span> KEY1_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(WK_UP==<span class="number">1</span>) <span class="keyword">return</span> WKUP_PRES; </span><br><span class="line">ALIENTEK MiniSTM32 V3<span class="number">.0</span> 开发板教程</span><br><span class="line"><span class="number">137</span></span><br><span class="line">STM32 不完全手册(HAL 库版)</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">1</span>&amp;&amp;KEY1==<span class="number">1</span>&amp;&amp;WK_UP==<span class="number">0</span>)key_up=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在头文件中进行添加宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5) <span class="comment">//KEY0 按键 PC5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15) <span class="comment">//KEY1 按键 PA15</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WK_UP HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) <span class="comment">//WKUP 按键 PA0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0_PRES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRES 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WKUP_PRES 3</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>串口通信</p><p>usart和uart区别为 usart比uart多了同步时钟频率通信，都有异步时钟通信。</p><p>串口设置的一般步骤可以总结为如下几个步骤：</p><ol><li>串口时钟使能，GPIO 时钟使能。</li><li>设置引脚复用器映射：调用 GPIO_PinAFConfig 函数。</li><li>GPIO 初始化设置：要设置模式为复用功能。</li><li>串口参数初始化：设置波特率，字长，奇偶校验等参数。</li><li>开启中断并且初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）。</li><li>使能串口。</li><li>编写中断处理函数：函数名格式为 USARTxIRQHandler(x 对应串口号)。</li></ol><p>串口通信的结构体如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> uint32_t BaudRate; //波特率</span><br><span class="line"> uint32_t WordLength; //字长</span><br><span class="line"> uint32_t StopBits; //停止位</span><br><span class="line"> uint32_t Parity; //奇偶校验</span><br><span class="line"> uint32_t Mode; //收/发模式设置</span><br><span class="line"> uint32_t HwFlowCtl; //硬件流设置</span><br><span class="line"> uint32_t OverSampling; //过采样设置</span><br><span class="line">&#125;UART_InitTypeDef</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile的学习</title>
      <link href="/2022/06/30/2022-6-30-makefile/"/>
      <url>/2022/06/30/2022-6-30-makefile/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tieba.baidu.com/p/591519800">Makefile详解（超级好）【mingw吧】_百度贴吧 (baidu.com)</a></p><p>上面挂一个较好的makefile的教程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学</title>
      <link href="/2022/06/28/2022-06-28-linux%E5%88%9D%E5%AD%A6/"/>
      <url>/2022/06/28/2022-06-28-linux%E5%88%9D%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>一个C&#x2F;C++文件要经过预处理、编译、汇编、连接等四步才能变为可执行文件。</p><p>预处理就是要将包含（include）的文件插入到原文件中、宏定义展开、根据条件编译命令选择要使用的代码。</p><p>编译是把C&#x2F;C++代码翻译成汇编代码。</p><p>汇编是将输出的汇编代码翻译成一定格式的机器代码。</p><p>连接是将上部生成的OBJ和系统库的OBJ文件、库文件连接起来，最终生成可执行文件。</p><p>首先记录一些常用的linux指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~$ cd 目标文件夹名称                 导向目标文件夹所在终端</span><br><span class="line"></span><br><span class="line">~$ touch hel                               创建一个叫hel的文件</span><br><span class="line"></span><br><span class="line">~$ gedit hel.c                             创建一个叫hel.c的文件并用文本编辑器打开</span><br><span class="line"></span><br><span class="line">~$ gcc hel.c -o test                    编译hel.c为test可执行文件</span><br><span class="line"></span><br><span class="line">~$ ./test                                     执行test可执行文件</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多个.c文件使用命令将多个文件连接到一个可执行文件中，之后执行。</p><p>在C语言文件中调用math.h库报错只需要gcc将代码与链接库连接起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc two.c -lm -o two</span><br></pre></td></tr></table></figure><p>编译C语言文件会有警告以及报错，但是警告是不显示的，需要用指令进行显示。</p><p>比如显示hello.c文件的警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ gcc -Wll -c hello.c</span><br></pre></td></tr></table></figure><p>如果文件里有没定义的变量就会出现如下现象</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20145045.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目梗概</title>
      <link href="/2022/06/08/2022-7-8-%E9%A1%B9%E7%9B%AE%E6%A2%97%E6%A6%82/"/>
      <url>/2022/06/08/2022-7-8-%E9%A1%B9%E7%9B%AE%E6%A2%97%E6%A6%82/</url>
      
        <content type="html"><![CDATA[<h2 id="V2V"><a href="#V2V" class="headerlink" title="V2V"></a>V2V</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>两个设备，经过测试两个模组设备中间的通信速率延迟，最优为4毫秒发像呈锯齿状。先发送送。由此构成了一条工控机数据发送模组中间要发送4次到5次。因此判断锯齿状延迟图像的构成应该由第2次3次4次的相同时间数据减去后续接收的时间戳导致的。因此在第2个模组中就要将重复收到的数据信息变为最开始收到的那一个去掉多余时间戳。后再将它发送给工控机。因此就要想一个办法别这个信息，不然这个延迟将会增大整个数据延迟图的数据信息中，每一条都有ID信息的标记，因此提出ID信息进行比较最为关键。在模组接收线程中不一样ID信息的数据发出。一样ID信息的数据不要。 工控机发送的数据是一个结构体，但是这个结构体的变量是ros独有的，所以不能在工控机的程序中写一个一样的结构体，将数据进行解析。所以我修改了工控机的程序，将ID信息放在了数据结构首位。那c语言强制转换的办法提取了这个数据的ID信息，通过这个数据的ID判别出最新数据，后放入TCP发送线程中发给下一个工控机。<br>程序自启动，修改yocto文件系统中，添加中间层里添加自启动服务文件。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h3 id="死锁产生四个条件"><a href="#死锁产生四个条件" class="headerlink" title="死锁产生四个条件"></a>死锁产生四个条件</h3><h2 id="orin搭载ros控制汽车底盘"><a href="#orin搭载ros控制汽车底盘" class="headerlink" title="orin搭载ros控制汽车底盘"></a>orin搭载ros控制汽车底盘</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在orin上编译英伟达的内核和驱动，烧录镜像到orin中，配置ros在arm架构上的源，更新后安装ros，使用socket编写can协议传输信息，将底盘上的报文协议，编写接收发送线程，接收线程接收底盘反馈的数据帧，发送线程数据帧，话题订阅反馈的数据，发布发送的数据帧。</p><h3 id="底盘报文协议（可能是指一种特定的通信协议或数据格式）转换为数据帧"><a href="#底盘报文协议（可能是指一种特定的通信协议或数据格式）转换为数据帧" class="headerlink" title="底盘报文协议（可能是指一种特定的通信协议或数据格式）转换为数据帧"></a>底盘报文协议（可能是指一种特定的通信协议或数据格式）转换为数据帧</h3><ol><li><strong>理解底盘报文协议格式：</strong> 首先要明确底盘报文协议的结构和规范</li><li><strong>确定数据帧格式：</strong> 确定目标数据帧的格式和标准。</li><li><strong>解析底盘报文：</strong> 将接收到的底盘报文按照协议规范进行解析。</li><li><strong>构建数据帧：</strong> 将报文头信息转换为帧头，将数据内容放入帧的数据字段中，添加适当的帧尾和校验位。</li><li><strong>数据帧发送：</strong> 发送构建好的数据帧到目标设备或系统，确保发送过程中保持数据的完整性和正确性。</li><li><strong>错误处理和校验：</strong> 在整个转换过程中，需要实现错误处理机制和校验机制，以确保转换的准确性和报文的完整性。</li></ol><h3 id="ros1和ros2的区别"><a href="#ros1和ros2的区别" class="headerlink" title="ros1和ros2的区别"></a><strong>ros1和ros2的区别</strong></h3><h2 id="stm32hal控制步兵机器人底盘"><a href="#stm32hal控制步兵机器人底盘" class="headerlink" title="stm32hal控制步兵机器人底盘"></a>stm32hal控制步兵机器人底盘</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>stm32控制麦轮的全向移动以及云台的转向，摩擦轮的旋转。</p><p>stm32写一个串口的协议，前两位数据为底盘运动模式选择，后两位为云台偏转的两个偏差角度（上位机模式）</p><p>debus发送遥控命令数据</p><h3 id="麦轮移动算法"><a href="#麦轮移动算法" class="headerlink" title="麦轮移动算法"></a>麦轮移动算法</h3><p>运动学正向分解是指根据给定的底盘运动参数，计算每个麦克纳姆轮的理想速度（通常是线速度），</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void moveMecanum(float vx, float vy, float omega)//x轴方向速度，y轴方向速度，omega方向速度，</span><br><span class="line">&#123;</span><br><span class="line">    // 计算四个轮子的速度</span><br><span class="line">    float motor1_speed = vx - vy - omega;</span><br><span class="line">    float motor2_speed = vx + vy + omega;</span><br><span class="line">    float motor3_speed = vx + vy - omega;</span><br><span class="line">    float motor4_speed = vx - vy + omega;</span><br><span class="line"></span><br><span class="line">    // 将速度映射到PWM输出</span><br><span class="line">    uint16_t pwm_value1 = (uint16_t)(motor1_speed * TIM_PERIOD);</span><br><span class="line">    uint16_t pwm_value2 = (uint16_t)(motor2_speed * TIM_PERIOD);</span><br><span class="line">    uint16_t pwm_value3 = (uint16_t)(motor3_speed * TIM_PERIOD);</span><br><span class="line">    uint16_t pwm_value4 = (uint16_t)(motor4_speed * TIM_PERIOD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="云台pid偏转"><a href="#云台pid偏转" class="headerlink" title="云台pid偏转"></a>云台pid偏转</h3><p>需要初始化两个PID控制器，每个控制器都有自己的比例、积分和微分系数，以及设定的目标角度和当前角度。</p><h3 id="PID的比例积分微分"><a href="#PID的比例积分微分" class="headerlink" title="PID的比例积分微分"></a><strong>PID的比例积分微分</strong></h3><p>比例：增大比例减小静态误差，上升时间减小，加快响应，当比例过大会出现超调</p><p>积分：积分增大，减小振荡，积分过大，超调量增加</p><p>微分：引入微分，减小超调量，提高响应速度，稳定性增加，消除静态误差。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 梗概 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/03/hello-world/"/>
      <url>/2022/05/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
