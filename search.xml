<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git分支</title>
      <link href="/2023/09/18/2023-9-18-git%E5%88%86%E6%94%AF/"/>
      <url>/2023/09/18/2023-9-18-git%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p><p>当使用 git commit 新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p><p>现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20153420.png"></p><pre><code>                             单个提交对象在仓库中的数据结构</code></pre><p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。</p><h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><p>新建一个分支testing分支，可以使用git branch命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">git branch testing</span></span><br></pre></td></tr></table></figure><p><strong>这会在当前 commit 对象上新建一个分支指针</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20153937.png"></p><p>那么，Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。请注意它和你熟知的许多其他版本控制系统（比如 Subversion 或 CVS）里的 HEAD 概念大不相同。在 Git 中，它是一个指向你正在工作中的本地分支的指针（译注：将 HEAD 想象为当前分支的别名。）。<u>运行 git branch 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作。</u></p><p><strong>要切换到其他分支，可以执行 git checkout 命令。我们现在转换到新建的 testing 分支</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">git checkout testing</span></span><br></pre></td></tr></table></figure><h4 id="分支的新建和切换"><a href="#分支的新建和切换" class="headerlink" title="分支的新建和切换"></a>分支的新建和切换</h4><p>新建的分支取名为 iss53。要新建并切换到该分支，运行 git checkout 并加上 -b 参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b iss53</span></span><br></pre></td></tr></table></figure><p>相当于执行下面两条命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">git branch iss53</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">git checkout iss53</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20154827.png"></p><p>在提交了若干次更新后，iss53 分支的指针也会随着向前推进，因为它就是当前分支。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20154940.png"></p><p>切换分支前留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &#x27;hotfix&#x27;</span><br><span class="line">Switched to a new branch &quot;hotfix&quot;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &#x27;fixed the broken email address&#x27;</span><br><span class="line">[hotfix]: created 3a0874c: &quot;fixed the broken email address&quot;</span><br><span class="line"> 1 files changed, 0 insertions(+), 1 deletions(-)</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast forward</span><br><span class="line"> README |    1 -</span><br><span class="line"> 1 files changed, 0 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20155947.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>git branch 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>若要查看各个分支最后一个提交对象的信息，运行 git branch -v:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -v</span></span><br></pre></td></tr></table></figure><p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 –merge 和 –no-merged 选项（Git 1.5.6 以上版本）。比如用 git branch –merge 查看哪些分支已被并入当前分支（译注::也就是说哪些分支是当前分支的直接上游。）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged</span></span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>另外可以用 git branch –no-merged 查看尚未合并的工作:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --no-merged</span></span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><p>远程分支（ <em>remote branch</em> ）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p><p>eg:</p><p>假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为 origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为 origin&#x2F;master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20161538.png"></p><p>一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin&#x2F;master，并且将它们都指向 origin 上的 master 分支。</p><p>如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的 master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin&#x2F;master 指针仍然保持原位不会移动。</p><p>可以运行 <strong>git fetch origin 来同步远程服务器上的数据到本地</strong>。该命令首先找到 origin 是哪个服务器（本例为 git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin&#x2F;master 的指针移到它最新的位置上。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20161645.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL数据库</title>
      <link href="/2023/09/17/2023-9-17-%E6%95%B0%E6%8D%AE%E5%BA%93sql/"/>
      <url>/2023/09/17/2023-9-17-%E6%95%B0%E6%8D%AE%E5%BA%93sql/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库，是数据的集合，由一张张数据表组成，用来存放数据。</p><p>每一张表都有一个唯一标识，即主键，标识数据的唯一性。表与表之间可以 通过主键来互相联系，就是数据能够对应匹配，称之为联结。</p><h2 id="什么是SQLite"><a href="#什么是SQLite" class="headerlink" title="什么是SQLite"></a>什么是SQLite</h2><p>SQLite是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite是一个增长最快的数据库引擎。</p><p>SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。</p><h2 id="为什么要用SQLite"><a href="#为什么要用SQLite" class="headerlink" title="为什么要用SQLite"></a>为什么要用SQLite</h2><blockquote><p>不需要一个单独的服务器进程或操作的系统（无服务器的）。</p><p>SQLite 不需要配置，这意味着不需要安装或管理。</p><p>一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。</p><p>SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。</p><p>SQLite 是自给自足的，这意味着不需要任何外部的依赖。</p><p>SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</p><p>SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。</p><p>SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。</p><p>SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。</p></blockquote><p>安装sql ，可以先用命令查询自己系统是否安装过sqlite3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sqlite3</span></span><br></pre></td></tr></table></figure><p><a href="https://www.sqlite.org/download.html">SQLite Download Page</a></p><p>解压压缩包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar xvzf sqlite-autoconf-3401502.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> sqlite-autoconf-3401502</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo make install</span></span><br></pre></td></tr></table></figure><p>SQLite 注释是附加的注释，可以在 SQLite 代码中添加注释以增加其可读性，他们可以出现在任何空白处，包括在表达式内和其他 SQL 语句的中间，但它们不能嵌套。</p><p>SQL 注释以两个连续的 “-“ 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。</p><h3 id="在Qt中使用SQLite数据库"><a href="#在Qt中使用SQLite数据库" class="headerlink" title="在Qt中使用SQLite数据库"></a>在Qt中使用SQLite数据库</h3><p>要使用SQL的类定义，需要引用相关头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#incldue <span class="string">&lt;QSqlQuery&gt;</span></span></span><br></pre></td></tr></table></figure><p>在.pro文件中加入sql模块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT+= core gui sql</span><br></pre></td></tr></table></figure><blockquote><p>查询驱动</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QStringList drivers = QSqlDatabase::<span class="built_in">drivers</span>();</span><br><span class="line">    foreach(QString driver, drivers)</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; driver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>连接数据库</p></blockquote><p>数据库连接使用连接名来定义，而不是使用数据库名，可以向相同的数据库创建多个连接。QSqlDatabase也支持默认连接的概念，默认连接就是一个没有命名的连接。在使用QSqlQuery或者QSqlQueryModel的成员函数时需要指定一个连接名作为参数，如果没有指定，那么就会使用默认连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase database;<span class="comment">//建立了一个QSqlDatabase对象，后续的操作要使用这个对象</span></span><br><span class="line"><span class="keyword">if</span>(QSqlDatabase::<span class="built_in">contains</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>))<span class="comment">//qt_sql_default_connection默认连接</span></span><br><span class="line">&#123;</span><br><span class="line">    database = QSqlDatabase::<span class="built_in">database</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    database = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);<span class="comment">//创建连接，并添加数据库QSLITE是SQLite对应的驱动名</span></span><br><span class="line">    database.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;myDataBase.db&quot;</span>);<span class="comment">//数据库名字</span></span><br><span class="line">    database.<span class="built_in">setUserName</span>(<span class="string">&quot;moss&quot;</span>);<span class="comment">//用户名字</span></span><br><span class="line">    database.<span class="built_in">setPassword</span>(<span class="string">&quot;123456&quot;</span>);<span class="comment">//密码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打开数据库</p></blockquote><p>使用open()打开数据库，并判断是否成功。注意，在第一步检查连接是否存在时，如果连接存在，则在返回这个连接的时候，会默认将数据库打开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!database.<span class="built_in">open</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Error: Failed to connect database.&quot;</span> &lt;&lt; database.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关闭数据库</p></blockquote><p>数据库操作完成后，最好关闭。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><blockquote><p>执行sql语句</p></blockquote><p>QSqlQuery类提供了一个接口，用于执行SQL语句和浏览查询的结果集。要执行一个SQL语句，只需要简单的创建一个QSqlQuery对象，然后调用QSqlQuery::exec()函数即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">query.<span class="built_in">exec</span>(<span class="string">&quot;insert into student (id, name) values (1, &#x27;LI&#x27;)&quot;</span>);插入一条记录</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>处理数据</p></blockquote><p>同一时间插入多条记录，可以使用占位符来完成。Qt支持两种占位符：名称绑定和位置绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//名称绑定</span></span><br><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;insert into student (id, name) values (:id, :name)&quot;</span>);</span><br><span class="line"><span class="type">int</span> idValue = <span class="number">1</span>;</span><br><span class="line">QString nameValue = <span class="string">&quot;Li&quot;</span>;</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:id&quot;</span>, idValue);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:name&quot;</span>, nameValue);</span><br><span class="line">query.<span class="built_in">exec</span>();</span><br><span class="line"><span class="comment">//位置绑定</span></span><br><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;insert into student (id, name) values (?, ?)&quot;</span>);</span><br><span class="line"><span class="type">int</span> idValue = <span class="number">1</span>;</span><br><span class="line">QString nameValue = <span class="string">&quot;Li&quot;</span>;</span><br><span class="line">query.<span class="built_in">addBindValue</span>(idValue);</span><br><span class="line">query.<span class="built_in">addBindValue</span>(nameValue);</span><br><span class="line">query.<span class="built_in">exec</span>();</span><br></pre></td></tr></table></figure><p>当要插入多条记录时，只需要调用QSqlQuery::prepare()一次，然后使用多次bindValue()或者addBindValue()函数来绑定需要的数据，最后调用一次exec()函数就可以了。其实，进行多条数据插入时，还可以使用批处理进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;insert into student (id, name) values (?, ?)&quot;</span>);</span><br><span class="line">QVariantList ids;</span><br><span class="line">ids &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">query.<span class="built_in">addBindValue</span>(ids);</span><br><span class="line">QVariantList names;</span><br><span class="line">names &lt;&lt; <span class="string">&quot;Li&quot;</span> &lt;&lt; <span class="string">&quot;Wang&quot;</span> &lt;&lt; <span class="string">&quot;Liu&quot;</span>;</span><br><span class="line">query.<span class="built_in">addBindValue</span>(names);</span><br><span class="line"><span class="keyword">if</span>(!query.<span class="built_in">execBatch</span>()) </span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; query.<span class="built_in">lastError</span>();</span><br></pre></td></tr></table></figure><p>修改数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QString update_sql = <span class="string">&quot;update student set name = :name where id = :id&quot;</span>;</span><br><span class="line"><span class="comment">//update &lt;table_name&gt; set &lt;f1=value1&gt;, &lt;f2=value2&gt;… where ;</span></span><br><span class="line">sql_query.<span class="built_in">prepare</span>(update_sql);</span><br><span class="line">sql_query.<span class="built_in">bindValue</span>(<span class="string">&quot;:name&quot;</span>, <span class="string">&quot;Qt&quot;</span>);</span><br><span class="line">sql_query.<span class="built_in">bindValue</span>(<span class="string">&quot;:id&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;updated!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分查询数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QString select_sql = <span class="string">&quot;select id, name from student&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>(select_sql))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(sql_query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = sql_query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        QString name = sql_query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">QString</span>(<span class="string">&quot;id:%1    name:%2&quot;</span>).<span class="built_in">arg</span>(id).<span class="built_in">arg</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select , , … from <table_name>;&#x2F;&#x2F;部分查询指令</p><p>查询全部数据</p><p>QSqlQuery提供了对结果集的访问，可以一次访问一条记录。当执行完exec()函数后，QSqlQuery的内部指针会位于第一条记录前面的位置。必须调用一次QSqlQuery::next()函数来使其前进到第一条记录，然后可以重复使用next()函数来访问其他的记录，直到该函数的返回值为false，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(query.<span class="built_in">next</span>())</span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>() &lt;&lt; query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QString select_all_sql = <span class="string">&quot;select * from student&quot;</span>;</span><br><span class="line">sql_query.<span class="built_in">prepare</span>(select_all_sql);</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(sql_query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id = sql_query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        QString name = sql_query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">        <span class="type">int</span> age = sql_query.<span class="built_in">value</span>(<span class="number">2</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="built_in">QString</span>(<span class="string">&quot;id:%1    name:%2    age:%3&quot;</span>).<span class="built_in">arg</span>(id).<span class="built_in">arg</span>(name).<span class="built_in">arg</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句select * from <table_name>;查询所有数据用 * 表示。</p><p>用while(sql_query.next())用来遍历所有行。同样用value()获得数据。<br>（3）查询最大id</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QString select_max_sql = <span class="string">&quot;select max(id) from student&quot;</span>;</span><br><span class="line"><span class="type">int</span> max_id = <span class="number">0</span>;</span><br><span class="line">sql_query.<span class="built_in">prepare</span>(select_max_sql);</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(sql_query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        max_id = sql_query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;max id:%1&quot;</span>).<span class="built_in">arg</span>(max_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是在语句中用max来获取最大值。</p><p>删除与清空</p><p>（1）删除一条数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QString delete_sql = <span class="string">&quot;delete from student where id = ?&quot;</span>;</span><br><span class="line">sql_query.<span class="built_in">prepare</span>(delete_sql);</span><br><span class="line">sql_query.<span class="built_in">addBindValue</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;deleted!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句delete from <table_name> where &#x3D;<br>delete用于删除条目，用where给出限定条件。例如此处是删除 id &#x3D; 0的条目。<br>（2）清空表格（删除所有）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QString clear_sql = <span class="string">&quot;delete from student&quot;</span>;</span><br><span class="line">sql_query.<span class="built_in">prepare</span>(clear_sql);</span><br><span class="line"><span class="keyword">if</span>(!sql_query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; sql_query.<span class="built_in">lastError</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;table cleared&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlTableModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQueryModel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGridLayout&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QSqlDatabase sqldatabase;   <span class="comment">//数据连接对象</span></span><br><span class="line">    QSqlQueryModel *sqlQueryModel;<span class="comment">//用于查询数据</span></span><br><span class="line">    QComboBox *comboBox;    <span class="comment">//下拉选择框</span></span><br><span class="line">    <span class="comment">/* 网格布局 */</span></span><br><span class="line">    QGridLayout *gridLayout;</span><br><span class="line">    QSqlTableModel *model;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p>mainwindow.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlRecord&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    QStringList drivers = QSqlDatabase::<span class="built_in">drivers</span>();  <span class="comment">//查看本机可用的数据库</span></span><br><span class="line">    foreach(QString driver, drivers)&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;driver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(QSqlDatabase::<span class="built_in">contains</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>))<span class="comment">//查询是否默认连接</span></span><br><span class="line">    &#123;</span><br><span class="line">        sqldatabase = QSqlDatabase::<span class="built_in">database</span>(<span class="string">&quot;qt_sql_default_connection&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sqldatabase = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);<span class="comment">//创建连接，并添加数据库QSLITE是SQLite对应的驱动名</span></span><br><span class="line">        sqldatabase.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;la.db&quot;</span>);<span class="comment">//数据库名字</span></span><br><span class="line">        <span class="comment">//sqldatabase.setUserName(&quot;moss&quot;);//用户名字</span></span><br><span class="line">        <span class="comment">//sqldatabase.setPassword(&quot;123456&quot;);//密码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!sqldatabase.<span class="built_in">open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Error: Failed to connect database.&quot;</span> &lt;&lt; sqldatabase.<span class="built_in">lastError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;连接成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    <span class="keyword">if</span>(sqldatabase.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;users&quot;</span>)) &#123;</span><br><span class="line">           <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;table users already exists!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 表格不存在，则创建表格users</span></span><br><span class="line">           <span class="comment">// 创建表格users，1为普通用户，2为管理者</span></span><br><span class="line"></span><br><span class="line">           QString cmd = <span class="string">&quot;create table users(user varchar(50) primary key, pwd varchar(50),phone varchar(50), email varchar(50), identity varchar(20));&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(!query.<span class="built_in">exec</span>(cmd)) &#123;</span><br><span class="line">               <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;create users table error!&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sqldatabase.<span class="built_in">tables</span>().<span class="built_in">contains</span>(<span class="string">&quot;informations&quot;</span>)) &#123;</span><br><span class="line">          <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;table informations already exists!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 表格不存在，则创建表格informations</span></span><br><span class="line">        <span class="keyword">if</span>(!query.<span class="built_in">exec</span>(<span class="string">&quot;create table informations(id int primary key,name varchar(20));&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;create informations table error!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QString cmd = <span class="built_in">QString</span>(<span class="string">&quot;insert into informations values(3, &#x27;qiadu&#x27;)&quot;</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; cmd;</span><br><span class="line">    <span class="keyword">if</span>(query.<span class="built_in">exec</span>(cmd)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;insert ok!&quot;</span>;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;insert error!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;select * from informations&quot;</span>);<span class="comment">//选择表的所有信息</span></span><br><span class="line">    <span class="keyword">while</span>(query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>()&lt;&lt; query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    sqldatabase.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-17%20145322.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2023/09/15/2023-9-15-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/09/15/2023-9-15-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>QThread 线程类是实现多线程的核心类。 Qt 有两种多线程的方法，其中一种是继承 QThread的 run()函数，另外一种是把一个继承于 QObject 的类转移到一个 Thread 里。 Qt4.8 之前都是使用继承 QThread 的 run()这种方法，但是 Qt4.8 之后， Qt 官方建议使用第二种方法。两种方法区别不大，用起来都比较方便，但继承 QObject 的方法更加灵活。 所以 Qt 的帮助文档里给的参考是先给继承 QObject 的类，然后再给继承 QThread 的类。<br>另外 Qt 提供了 QMutex、 QMutexLocker、 QReadLocker 和 QWriteLocker 等类用于线程之间的同步，详细可以看 Qt 的帮助文档 </p><h3 id="继承-QThread-的线程"><a href="#继承-QThread-的线程" class="headerlink" title="继承 QThread 的线程"></a>继承 QThread 的线程</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-15%20095404.png"></p><p>run()方法是继承于 QThread 类的方法，用户需要重写这个方法，一般是把耗时的操作写在这个 run()方法里面 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用下面声明的 WorkerThread 线程类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerThread</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 在 MainWindow 类里声明对象 */</span></span><br><span class="line">WorkerThread *workerThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明一个按钮，使用此按钮点击后开启线程 */</span></span><br><span class="line">QPushButton *pushButton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="comment">/* 槽函数，用于接收线程发送的信号 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleResults</span><span class="params">(<span class="type">const</span> QString &amp;result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 点击按钮开启线程 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新建一个 WorkerThread 类继承于 QThread */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerThread</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 用到信号槽即需要此宏定义 */</span></span><br><span class="line"> Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">WorkerThread</span>(QWidget *parent = <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="built_in">Q_UNUSED</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重写 run 方法，继承 QThread 的类，只有 run 方法是在新的线程里 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">QString result = <span class="string">&quot;线程开启成功&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里写上比较耗时的操作 */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 延时 2s，把延时 2s 当作耗时操作</span></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* 发送结果准备好的信号 */</span></span><br><span class="line"><span class="function">emit <span class="title">resultReady</span><span class="params">(result)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">signals:</span><br><span class="line"><span class="comment">/* 声明一个信号，译结果准确好的信号 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resultReady</span><span class="params">(<span class="type">const</span> QString &amp;s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* 设置位置与大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"><span class="comment">/* 对象实例化 */</span></span><br><span class="line">pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">workerThread = <span class="keyword">new</span> <span class="built_in">WorkerThread</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/* 按钮设置大小与文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">resize</span>(<span class="number">100</span>, <span class="number">40</span>);</span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开启线程&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号槽连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(workerThread, <span class="built_in">SIGNAL</span>(<span class="built_in">resultReady</span>(QString)),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleResults</span>(QString)));</span><br><span class="line"><span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButtonClicked</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()<span class="comment">//析构函数里面退出函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 进程退出，注意本例 run()方法没写循环，此方法需要有循环才生效 */</span></span><br><span class="line">workerThread-&gt;<span class="built_in">quit</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阻塞等待 2000ms 检查一次进程是否已经退出 */</span></span><br><span class="line"><span class="keyword">if</span> (workerThread-&gt;<span class="built_in">wait</span>(<span class="number">2000</span>)) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;线程已经结束！ &quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::handleResults</span><span class="params">(<span class="type">const</span> QString &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 打印出线程发送过来的结果 */</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 检查线程是否在运行，如果没有则开始运行 */</span></span><br><span class="line"><span class="keyword">if</span> (!workerThread-&gt;<span class="built_in">isRunning</span>())</span><br><span class="line">workerThread-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承-QObject-的线程"><a href="#继承-QObject-的线程" class="headerlink" title="继承 QObject 的线程"></a>继承 QObject 的线程</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-15%20100121.png"></p><p>耗时的线程放入QThread线程里面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">ifndef MAINWINDOW_H</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMutexLocker&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMutex&gt;</span></span></span><br><span class="line"><span class="comment">/* 工人类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 开始线程按钮 */</span></span><br><span class="line">QPushButton *pushButton1;</span><br><span class="line"><span class="comment">/* 打断线程按钮 */</span></span><br><span class="line">QPushButton *pushButton2;</span><br><span class="line"><span class="comment">/* 全局线程 */</span></span><br><span class="line">QThread workerThread;</span><br><span class="line"><span class="comment">/* 工人类 */</span></span><br><span class="line">Worker *worker;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="comment">/* 按钮 1 点击开启线程 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButton1Clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* 按钮 2 点击打断线程 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButton2Clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* 用于接收工人是否在工作的信号 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleResults</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line">signals:</span><br><span class="line"><span class="comment">/* 工人开始工作（做些耗时的操作 ） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">startWork</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Worker 类，这个类声明了 doWork1 函数，将整个 Worker 类移至线程 workerThread*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 互斥锁 */</span></span><br><span class="line">QMutex lock;</span><br><span class="line"><span class="comment">/* 标志位 */</span></span><br><span class="line"><span class="type">bool</span> isCanRun;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="comment">/* 耗时的工作都放在槽函数下，工人可以有多份不同的工作，但是每次只能去做一份 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork1</span><span class="params">(<span class="type">const</span> QString &amp;parameter)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 标志位为真 */</span></span><br><span class="line">isCanRun = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* 死循环 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* 此&#123;&#125;作用是 QMutexLocker 与 lock 的作用范围，获取锁后，运行完成后即解锁 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;lock)</span></span>;</span><br><span class="line"><span class="comment">/* 如果标志位不为真 */</span></span><br><span class="line"><span class="keyword">if</span> (!isCanRun) &#123;</span><br><span class="line"><span class="comment">/* 跳出循环 */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用 QThread 里的延时函数，当作一个普通延时 */</span></span><br><span class="line">QThread::<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"><span class="function">emit <span class="title">resultReady</span><span class="params">(parameter + <span class="string">&quot;doWork1 函数&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* doWork1 运行完成，发送信号 */</span></span><br><span class="line"><span class="function">emit <span class="title">resultReady</span><span class="params">(<span class="string">&quot;打断 doWork1 函数&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// void doWork2();...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/* 打断线程（注意此方法不能放在槽函数下） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stopWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;打断线程&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取锁后，运行完成后即解锁 */</span></span><br><span class="line"><span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;lock)</span></span>;</span><br><span class="line">isCanRun = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">signals:</span><br><span class="line"><span class="comment">/* 工人工作函数状态的信号 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resultReady</span><span class="params">(<span class="type">const</span> QString &amp;result)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置显示位置与大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">pushButton1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">pushButton2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/* 设置按钮的位置大小 */</span></span><br><span class="line">pushButton1-&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>, <span class="number">200</span>, <span class="number">80</span>, <span class="number">40</span>);</span><br><span class="line">pushButton2-&gt;<span class="built_in">setGeometry</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">80</span>, <span class="number">40</span>);</span><br><span class="line">* 设置两个按钮的文本 */</span><br><span class="line">pushButton1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开启线程&quot;</span>);</span><br><span class="line">pushButton2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;打断线程&quot;</span>);</span><br><span class="line"><span class="comment">/* 工人类实例化 */</span></span><br><span class="line">worker = <span class="keyword">new</span> Worker;</span><br><span class="line"><span class="comment">/* 将 worker 类移至线程 workerThread */</span></span><br><span class="line">worker-&gt;<span class="built_in">moveToThread</span>(&amp;workerThread);</span><br><span class="line"><span class="comment">/* 信号槽连接 */</span></span><br><span class="line"><span class="comment">/* 线程完成销毁对象 */</span></span><br><span class="line"><span class="built_in">connect</span>(&amp;workerThread, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), worker, <span class="built_in">SLOT</span>(<span class="built_in">deleteLater</span>()));</span><br><span class="line"><span class="built_in">connect</span>(&amp;workerThread, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), &amp;workerThread, <span class="built_in">SLOT</span>(<span class="built_in">deleteLater</span>()));</span><br><span class="line"><span class="comment">/* 发送开始工作的信号，开始工作 */</span></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">startWork</span>(QString)), worker, <span class="built_in">SLOT</span>(<span class="built_in">doWork1</span>(QString)));</span><br><span class="line"><span class="comment">/* 接收到 worker 发送过来的信号 */</span></span><br><span class="line"><span class="built_in">connect</span>(worker, <span class="built_in">SIGNAL</span>(<span class="built_in">resultReady</span>(QString)),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">handleResults</span>(QString)));</span><br><span class="line"><span class="comment">/* 点击按钮开始线程 */</span></span><br><span class="line"><span class="built_in">connect</span>(pushButton1, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButton1Clicked</span>()));</span><br><span class="line"><span class="comment">/* 点击按钮打断线程 */</span></span><br><span class="line"><span class="built_in">connect</span>(pushButton2, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButton2Clicked</span>()));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 打断线程再退出 */</span></span><br><span class="line">worker-&gt;<span class="built_in">stopWork</span>();</span><br><span class="line">workerThread.<span class="built_in">quit</span>();</span><br><span class="line"><span class="comment">/* 阻塞线程 2000ms，判断线程是否结束 */</span></span><br><span class="line"><span class="keyword">if</span> (workerThread.<span class="built_in">wait</span>(<span class="number">2000</span>)) &#123;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;线程结束&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButton1Clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 字符串常量 */</span></span><br><span class="line"><span class="type">const</span> QString str = <span class="string">&quot;正在运行&quot;</span>;</span><br><span class="line"><span class="comment">/* 判断线程是否在运行 */</span></span><br><span class="line"><span class="keyword">if</span>(!workerThread.<span class="built_in">isRunning</span>()) &#123;</span><br><span class="line"><span class="comment">/* 开启线程 */</span></span><br><span class="line">workerThread.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 发送正在运行的信号，线程收到信号后执行后返回线程耗时函数 + 此字符串 */</span></span><br><span class="line">emit <span class="keyword">this</span>-&gt;<span class="built_in">startWork</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButton2Clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 如果线程在运行 */</span></span><br><span class="line"><span class="keyword">if</span>(workerThread.<span class="built_in">isRunning</span>()) &#123;</span><br><span class="line"><span class="comment">/* 停止耗时工作，跳出耗时工作的循环 */</span></span><br><span class="line">worker-&gt;<span class="built_in">stopWork</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::handleResults</span><span class="params">(<span class="type">const</span> QString &amp; results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 打印线程的状态 */</span></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;线程的状态： &quot;</span>&lt;&lt;results&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qchart放大缩小曲线图</title>
      <link href="/2023/09/14/2023-9-14-qchart%E7%BC%A9%E6%94%BE%E6%9B%B2%E7%BA%BF/"/>
      <url>/2023/09/14/2023-9-14-qchart%E7%BC%A9%E6%94%BE%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="曲线图绘制"><a href="#曲线图绘制" class="headerlink" title="曲线图绘制"></a>曲线图绘制</h3><p>qt的曲线绘制有三种类，分别是Qcustomplot、QChart、Qwt。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li><p><strong>美观方面：</strong></p><ul><li>Qcustomplot≈Qchart &gt; Qwt</li><li>Qcustomplot界面简洁大方；</li><li>Qchart界面华丽优美，在数据量大的时候会引响鼠标的缩放、移动图表操作；</li><li>Qwt界面老旧，在美观上不如Qcustomplot和Qchart ，并且在使用鼠标移动图表时会产生空白区域。</li></ul></li><li><p><strong>性能方面：</strong></p><ul><li><p>绘制数据性能：Qchart&gt;Qcustomplot &gt; Qwt</p></li><li><p>绘制数据数量：Qcustomplot &gt;Qchart&gt; Qwt</p></li><li><p>绘制1000个数据点时，qcustomplot平均耗时 13.6毫秒，Qwt平均耗时40毫秒，QChart平均耗时12.5毫秒;</p><p>绘制10000个数据点时，qcustomplot平均耗时 21.6毫秒，Qwt平均耗时78毫秒，QChart平均耗时13.5毫秒;</p><p>绘制100000个数据点时，qcustomplot平均耗时22.5毫秒，Qwt平均耗时524毫秒，QChart平均耗时20.7毫秒；</p><p>绘制500000个数据点时，qcustomplot平均耗时43.3毫秒，QChart平均耗时194.25毫秒。</p></li></ul></li><li><p><strong>功能方面：</strong></p><ul><li>QChart、Qwt功能比较齐全，并且可绘制图表种类多；</li><li>qcustomplot在图表种类上、常用功能上较少。</li></ul></li><li><p><strong>使用方面：</strong></p><ul><li>QChart无需配置，主要在安装Qt时勾选就可以，在程序编写时上手较慢，许多功能需要重写；</li><li>Qwt安装配置比较复杂；</li><li>QCustomPlot体积小、简单易用，上手快，并且QCustomPlot只有两个源文件，可直接添加进工程，更容易直接修改源码。</li></ul></li></ul><p><a href="https://sourceforge.net/projects/qwt/files/qwt/">Qwt 下载地址</a></p><p><a href="https://www.qcustomplot.com/index.php/download">Qcustomplot下载地址</a></p><p>QChart不用下载，只需在安装qt时候进行选择组件。</p><p>在这里我使用的是QChart来进行设计的毕设，首先是对.pro文件进行追加代码charts</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QT      += core gui</span><br><span class="line">QT  += charts</span><br></pre></td></tr></table></figure><p>进行编写mainwindow.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QChartView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineSeries&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QChart&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QValueAxis&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGraphicsSimpleTextItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSplineSeries&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_CHARTS_USE_NAMESPACE</span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//实现对于图线的缩放平移，定义的鼠标事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wheelEvent</span><span class="params">(QWheelEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line"></span><br><span class="line">    QPoint m_pointUsed;                             <span class="comment">//保存旧坐标</span></span><br><span class="line">    <span class="type">bool</span> m_isPress;                                 <span class="comment">//是否按下鼠标</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> m_dMinX, m_dMaxX, m_dMinY, m_dMaxY;      <span class="comment">//保存图表轴初始大小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receivedData</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="type">int</span> maxX;</span><br><span class="line">    <span class="type">int</span> maxY;</span><br><span class="line">    QValueAxis *axisY;</span><br><span class="line">    QValueAxis *axisX;</span><br><span class="line">    QList&lt;<span class="type">int</span>&gt;data;</span><br><span class="line">    QSplineSeries *splineSeries;    <span class="comment">//曲线</span></span><br><span class="line">    QChart *chart;</span><br><span class="line">    QChartView *chartView;</span><br><span class="line">    QTimer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mainwindow.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRandomGenerator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolTip&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置最显示位置与大小 */</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    <span class="comment">/* 最大储存 maxSize - 1 个数据 */</span></span><br><span class="line">    maxSize = <span class="number">1000</span><span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* x 轴上的最大值 */</span></span><br><span class="line">    maxX = <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">/* y 轴最大值 */</span></span><br><span class="line">    maxY = <span class="number">64000</span>;</span><br><span class="line">    <span class="comment">/* splineSeries 曲线实例化（折线用 QLineSeries） */</span></span><br><span class="line">    splineSeries = <span class="keyword">new</span> <span class="built_in">QSplineSeries</span>();</span><br><span class="line">    splineSeries-&gt;<span class="built_in">setName</span>(<span class="string">&quot;第一条线&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 图表实例化 */</span></span><br><span class="line">    chart = <span class="keyword">new</span> <span class="built_in">QChart</span>();</span><br><span class="line">    <span class="comment">/* 图表视图实例化 */</span></span><br><span class="line">    chartView = <span class="keyword">new</span> <span class="built_in">QChartView</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 坐标轴 */</span></span><br><span class="line">    axisY = <span class="keyword">new</span> <span class="built_in">QValueAxis</span>();</span><br><span class="line">    axisX = <span class="keyword">new</span> <span class="built_in">QValueAxis</span>();</span><br><span class="line">    <span class="comment">/* 定时器 */</span></span><br><span class="line">    timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* legend 译图例类型，以绘图的颜色区分， 本例设置为隐藏 */</span></span><br><span class="line">    chart-&gt;<span class="built_in">legend</span>()-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    <span class="comment">/* chart 设置标题 */</span></span><br><span class="line">    chart-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;拉曼光谱&quot;</span>);</span><br><span class="line">    <span class="comment">/* 添加一条曲线 splineSeries */</span></span><br><span class="line">    chart-&gt;<span class="built_in">addSeries</span>(splineSeries);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置显示格式 */</span></span><br><span class="line">    axisY-&gt;<span class="built_in">setLabelFormat</span>(<span class="string">&quot;%i&quot;</span>);</span><br><span class="line">    <span class="comment">/* y 轴标题 */</span></span><br><span class="line">    axisY-&gt;<span class="built_in">setTitleText</span>(<span class="string">&quot;强度&quot;</span>);</span><br><span class="line">    <span class="comment">/* y 轴标题位置（设置坐标轴的方向） */</span></span><br><span class="line">    chart-&gt;<span class="built_in">addAxis</span>(axisY, Qt::AlignLeft);</span><br><span class="line">    <span class="comment">/* 设置 y 轴范围 */</span></span><br><span class="line">    axisY-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, maxY);</span><br><span class="line">    <span class="comment">/* 将 splineSeries 附加于 y 轴上 */</span></span><br><span class="line">    splineSeries-&gt;<span class="built_in">attachAxis</span>(axisY);</span><br><span class="line">    <span class="comment">/* 设置显示格式 */</span></span><br><span class="line">    axisX-&gt;<span class="built_in">setLabelFormat</span>(<span class="string">&quot;%i&quot;</span>);</span><br><span class="line">    <span class="comment">/* x 轴标题 */</span></span><br><span class="line">    axisX-&gt;<span class="built_in">setTitleText</span>(<span class="string">&quot;拉曼位移(cm-1)&quot;</span>);</span><br><span class="line">    <span class="comment">/* x 轴标题位置（设置坐标轴的方向） */</span></span><br><span class="line">    chart-&gt;<span class="built_in">addAxis</span>(axisX, Qt::AlignBottom);</span><br><span class="line">    <span class="comment">/* 设置 x 轴范围 */</span></span><br><span class="line">    axisX-&gt;<span class="built_in">setRange</span>(<span class="number">-28000</span>, maxX);</span><br><span class="line">    <span class="comment">/* 将 splineSeries 附加于 x 轴上 */</span></span><br><span class="line">    splineSeries-&gt;<span class="built_in">attachAxis</span>(axisX);</span><br><span class="line">    <span class="comment">/* 将图表的内容设置在图表视图上 */</span></span><br><span class="line">    chartView-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line">    <span class="comment">/* 设置抗锯齿 */</span></span><br><span class="line">    chartView-&gt;<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    <span class="comment">/* 设置为图表视图为中心部件 */</span></span><br><span class="line">    <span class="built_in">setCentralWidget</span>(chartView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用定时器更新数据</span></span><br><span class="line">    timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);                                                  <span class="comment">//初始化定时器</span></span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout,</span><br><span class="line">    [&amp;]()</span><br><span class="line">    &#123;</span><br><span class="line">        QVector&lt;QPointF&gt; <span class="built_in">point</span>(maxSize + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxSize + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            point[i].<span class="built_in">setX</span>(i);</span><br><span class="line">            point[i].<span class="built_in">setY</span>((<span class="type">int</span>)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">1</span>,<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        splineSeries-&gt;<span class="built_in">replace</span>(point);                                                 <span class="comment">//更新数据</span></span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标按下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)                       <span class="comment">//鼠标左键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pointUsed = event-&gt;<span class="built_in">pos</span>();                              <span class="comment">//保存当前坐标</span></span><br><span class="line">        m_isPress = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::MidButton)                    <span class="comment">//鼠标中键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        QLineSeries* l_series = (QLineSeries*)<span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">series</span>().<span class="built_in">at</span>(<span class="number">0</span>);      <span class="comment">//获取序列中的值</span></span><br><span class="line">        QVector&lt;QPointF&gt; l_vpointF = l_series-&gt;<span class="built_in">pointsVector</span>();</span><br><span class="line">        QPointF l_curVal = <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">mapToValue</span>(event-&gt;<span class="built_in">pos</span>());               <span class="comment">//返回鼠标处的值</span></span><br><span class="line">        QPointF l_pointF = l_vpointF.<span class="built_in">at</span>(<span class="built_in">qRound</span>(l_curVal.<span class="built_in">x</span>()));                    <span class="comment">//获取离鼠标的横坐标最近的点</span></span><br><span class="line"></span><br><span class="line">        QString l_strPos = <span class="built_in">QString</span>(<span class="string">&quot;x：%0 y：%1&quot;</span>).<span class="built_in">arg</span>(l_pointF.<span class="built_in">x</span>()).<span class="built_in">arg</span>(l_pointF.<span class="built_in">y</span>());</span><br><span class="line">        QString l_stStyle = <span class="string">&quot;&lt;p style=\&quot;background:#00FFFF; border-radius: 1px 5px;font:12pt &#x27;宋体&#x27;\&quot;&gt;%1&lt;/p&gt;&quot;</span>;</span><br><span class="line">        QToolTip::<span class="built_in">showText</span>(<span class="built_in">cursor</span>().<span class="built_in">pos</span>(), l_stStyle.<span class="built_in">arg</span>(l_strPos), <span class="keyword">this</span>, <span class="built_in">QRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>), <span class="number">10000</span>); <span class="comment">//在点击位置显示提示信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标双击</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">button</span>() == Qt::RightButton)                        <span class="comment">//鼠标右键双击恢复最初大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Horizontal).<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">setRange</span>(m_dMinX, m_dMaxX);</span><br><span class="line">        <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Vertical).<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">setRange</span>(m_dMinY, m_dMaxY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_isPress)</span><br><span class="line">    &#123;</span><br><span class="line">        QPoint l_pointDiff = event-&gt;<span class="built_in">pos</span>() - m_pointUsed;              <span class="comment">//当前坐标与按下鼠标处的坐标差</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">scroll</span>(-l_pointDiff.<span class="built_in">x</span>(), l_pointDiff.<span class="built_in">y</span>());     <span class="comment">//移动图表</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_pointUsed = event-&gt;<span class="built_in">pos</span>();                                       <span class="comment">//保存当前坐标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isPress = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标滚轮缩放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::wheelEvent</span><span class="params">(QWheelEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPointF l_curVal = <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">mapToValue</span>(event-&gt;<span class="built_in">pos</span>());               <span class="comment">//返回鼠标处的值</span></span><br><span class="line"></span><br><span class="line">    QValueAxis *l_axisX = (QValueAxis*)<span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Horizontal).<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">double</span> l_fMinX = l_axisX-&gt;<span class="built_in">min</span>();</span><br><span class="line">    <span class="type">double</span> l_fMaxX = l_axisX-&gt;<span class="built_in">max</span>();</span><br><span class="line">    QValueAxis *l_axisY = (QValueAxis*)<span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Vertical).<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">double</span> l_fMinY = l_axisY-&gt;<span class="built_in">min</span>();</span><br><span class="line">    <span class="type">double</span> l_fMaxY = l_axisY-&gt;<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> l_fZoomMinX,l_fZoomMaxX,l_fZoomMinY,l_fZoomMaxY;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">delta</span>() &gt; <span class="number">0</span>)                                                   <span class="comment">//获取放大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        l_fZoomMinX = l_curVal.<span class="built_in">x</span>() - (l_curVal.<span class="built_in">x</span>() - l_fMinX) / <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMaxX = l_curVal.<span class="built_in">x</span>() + (l_fMaxX - l_curVal.<span class="built_in">x</span>()) / <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMinY = l_curVal.<span class="built_in">y</span>() - (l_curVal.<span class="built_in">y</span>() - l_fMinY) / <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMaxY = l_curVal.<span class="built_in">y</span>() + (l_fMaxY - l_curVal.<span class="built_in">y</span>()) / <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                                     <span class="comment">//获取缩小值</span></span><br><span class="line">    &#123;</span><br><span class="line">        l_fZoomMinX = l_curVal.<span class="built_in">x</span>() - (l_curVal.<span class="built_in">x</span>() - l_fMinX) * <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMaxX = l_curVal.<span class="built_in">x</span>() + (l_fMaxX - l_curVal.<span class="built_in">x</span>()) * <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMinY = l_curVal.<span class="built_in">y</span>() - (l_curVal.<span class="built_in">y</span>() - l_fMinY) * <span class="number">1.5</span>;</span><br><span class="line">        l_fZoomMaxY = l_curVal.<span class="built_in">y</span>() + (l_fMaxY - l_curVal.<span class="built_in">y</span>()) * <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Vertical).<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">setRange</span>(l_fZoomMinY, l_fZoomMaxY);   <span class="comment">//设置轴范围</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;chart-&gt;<span class="built_in">axes</span>(Qt::Horizontal).<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">setRange</span>(l_fZoomMinX, l_fZoomMaxX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt容器</title>
      <link href="/2023/09/11/2023-9-10-qt%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/09/11/2023-9-10-qt%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>各个控件的名称依次解释如下。<br>（1） Group Box:组框</p><p>QGroupBox 为构建分组框提供了支持。分组框通常带有一个边<br>框和一个标题栏，作为容器部件来使用，在其中可以布置各种窗口部件。布局时可用作一组控<br>件的容器，但是需要注意的是，内部通常使用布局控件（如 QBoxLayout）进行布局。 </p><p>（2） Scroll Area:滚动区域</p><p>滚动区域用于在框架中显示子部件的内容。如果小<br>部件超过框架的大小，视图就会出现滚动条，以便可以查看子小部件的整个区域。 </p><p>（3） Tool Box:工具箱</p><p>QToolBox 类提供了一列选项卡小部件项。工具箱是一个小部件，<br>它显示一列选项卡在另一列的上面，当前项显示在当前选项卡的下面。 </p><p>（4） Tab Widget:标签小部件</p><p>abWidget 类提供了一组选项卡（多页面）小部件。 QTabWidget<br>主要是用来分页显示的，每一页一个界面，众多界面公用一块区域，节省了界面大小，很方便<br>的为用户显示更多的信息。 </p><p>（5） Stacked WIdget:堆叠小部件</p><p>QStackedWidget 类提供了一个小部件堆栈，其中一次只能<br>看到一个小部件，与 QQ 的设置面板类似。 QStackedWidget 可用于创建类似于 QTabWidget 提<br>供的用户界面。它是构建在 QStackedLayout 类之上的一个方便的布局小部件。 </p><p>（6） Frame:帧<br>（7） Widget:小部件<br>（8） MDI Area:MDI 区域<br>（9） Dock Widget:停靠窗体部件 </p><p>Qt提供了多个基于模板 的容器类，这些容器类可以用于存储指定类型的数据项，容器类是基于模板的类，如常用的容器类QList<T>, T是一个具体的类型，可以是int、float等简单类型，也可以是QString、QDate 等类，但不能是QObject或任何其子类。 T 必须是一个可赋值的类型，即T 必须提供一个缺省的构造函数，一个可复制构造函数和–个赋值运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt;list; //定义一个字符串列表</span><br></pre></td></tr></table></figure><p>Qt的容器类分为有序容器( sequential containers) 和关联容器( associative containers)</p><p>Qt的有序容器类有QList、QLinkedList、 QVector、 QStack 和QQueue。</p><p>Qt 还提供关联容器类QMap、QMultiMap、QHash、 QMultiHash 和QSet。</p><p>QTabWidget 继承 QWidget， QTabWidget 类提供了一组选项卡（多页面）小部件。 QTabWidget 主要是用来分页显示的，每一页一个界面，众多界面公用一块区域，节省了界面大小，很方便的为用户显示更多的信息。类似浏览器的多标签页面，所以这个控件在实际项目中也会经常用到 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget *widget;</span><br><span class="line">    QTabWidget *tabWidget;</span><br><span class="line">    QHBoxLayout *hBoxLayout;</span><br><span class="line">    QLabel *label[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(widget);</span><br><span class="line">    tabWidget = <span class="keyword">new</span> <span class="built_in">QTabWidget</span>();</span><br><span class="line">    hBoxLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    QList&lt;QString&gt;strLabelList;</span><br><span class="line">    strLabelList&lt;&lt;<span class="string">&quot;标签1&quot;</span>&lt;&lt;<span class="string">&quot;标签2&quot;</span>&lt;&lt;<span class="string">&quot;标签3&quot;</span>;</span><br><span class="line">    QList&lt;QString&gt;strTabList;</span><br><span class="line">    strTabList&lt;&lt;<span class="string">&quot;页面1&quot;</span>&lt;&lt;<span class="string">&quot;页面2&quot;</span>&lt;&lt;<span class="string">&quot;页面3&quot;</span>;</span><br><span class="line">    QList &lt;QString&gt;iconList;</span><br><span class="line">    iconList&lt;&lt;<span class="string">&quot;:/icons/icon1&quot;</span>&lt;&lt;<span class="string">&quot;:/icons/icon2&quot;</span>&lt;&lt;<span class="string">&quot;:/icons/icon3&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        label[i] = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">        label[i] -&gt;<span class="built_in">setText</span>(strLabelList[i]);</span><br><span class="line">        label[i] -&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">        tabWidget -&gt; <span class="built_in">addTab</span>(label[i], <span class="built_in">QIcon</span>(iconList[i]), strTabList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    hBoxLayout-&gt;<span class="built_in">addWidget</span>(tabWidget);</span><br><span class="line">    widget-&gt;<span class="built_in">setLayout</span>(hBoxLayout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-10%20151408.png"></p><p>QstackedWidget</p><p>QStackedWidget 继承 QFrame。 QStackedWidget 类提供了一个小部件堆栈，其中一次只能看到一个小部件，与 QQ 的设置面板类似。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStackedWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QListWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget  *widget;</span><br><span class="line">    QHBoxLayout *hBoxLayout;</span><br><span class="line">    QListWidget *listWidget;</span><br><span class="line">    QStackedWidget *stackedWidget;</span><br><span class="line">    QLabel *label[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(widget);</span><br><span class="line">    hBoxLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    stackedWidget = <span class="keyword">new</span> <span class="built_in">QStackedWidget</span>();</span><br><span class="line">    listWidget = <span class="keyword">new</span> <span class="built_in">QListWidget</span>();</span><br><span class="line"></span><br><span class="line">    QList &lt;QString&gt;strListWidgetList;</span><br><span class="line">    strListWidgetList&lt;&lt;<span class="string">&quot;窗口一&quot;</span>&lt;&lt;<span class="string">&quot;窗口二&quot;</span>&lt;&lt;<span class="string">&quot;窗口三&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        listWidget -&gt; <span class="built_in">insertItem</span>(i, strListWidgetList[i] );</span><br><span class="line">    &#125;</span><br><span class="line">    QList&lt;QString&gt;strLabelList;</span><br><span class="line">    strLabelList&lt;&lt;<span class="string">&quot;标签一&quot;</span>&lt;&lt;<span class="string">&quot;标签二&quot;</span>&lt;&lt;<span class="string">&quot;标签三&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        label[i] = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">        label[i] -&gt;<span class="built_in">setText</span>(strLabelList[i]);</span><br><span class="line">        label[i] -&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">        stackedWidget-&gt;<span class="built_in">addWidget</span>(label[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    listWidget-&gt;<span class="built_in">setMaximumWidth</span>(<span class="number">200</span>);</span><br><span class="line">    hBoxLayout-&gt;<span class="built_in">addWidget</span>(listWidget);</span><br><span class="line">    hBoxLayout-&gt;<span class="built_in">addWidget</span>(stackedWidget);</span><br><span class="line">    widget-&gt;<span class="built_in">setLayout</span>(hBoxLayout);</span><br><span class="line">    <span class="built_in">connect</span>(listWidget, <span class="built_in">SIGNAL</span>(<span class="built_in">currentRowChanged</span>(<span class="type">int</span>)),stackedWidget, <span class="built_in">SLOT</span>(<span class="built_in">setCurrentIndex</span>(<span class="type">int</span>)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-10%20164258.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>界面跳转设计</title>
      <link href="/2023/09/11/2023-9-11-%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/09/11/2023-9-11-%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="Qt中的lambda表达式"><a href="#Qt中的lambda表达式" class="headerlink" title="Qt中的lambda表达式"></a>Qt中的lambda表达式</h3><p>跳转界面前先学习一个知识点是lambda表达式。</p><p><strong>Lambda</strong>我们可以将其理解为一个未命名的<a href="https://so.csdn.net/so/search?q=%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">内联函数</a>。<br>与任何函数类似，一个<a href="https://so.csdn.net/so/search?q=lambda&spm=1001.2101.3001.7020">lambda</a>具有一个返回类型，一个参数列表和一个函数体。但与函数不同,lambda可能定义在函数内部。<br>一个lambda表达式具有如下形式：<br><strong>[capture list] (parameter list) -&gt;return type {function body}</strong><br><strong>capture list: 捕获列表，是一个lambda所在函数中定义的局部变量列表（通常为空）</strong><br><strong>parameter list:参数列表</strong><br><strong>return type:返回类型</strong><br><strong>function body:函数体</strong><br><strong>但是与普通函数不同，lambda必须使用尾置返回来指定返回类型</strong><br><strong>我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">QPushButton *pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;开关&quot;</span>， <span class="keyword">this</span>);</span><br><span class="line">pushButton -&gt; <span class="built_in">setGeometry</span>( <span class="number">200</span>, <span class="number">100</span>, <span class="number">40</span> ,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">connect</span>( pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果就是可以点击开关就可以关闭界面。</p><h3 id="设计界面（画图）"><a href="#设计界面（画图）" class="headerlink" title="设计界面（画图）"></a>设计界面（画图）</h3><h4 id="添加资源文件"><a href="#添加资源文件" class="headerlink" title="添加资源文件"></a>添加资源文件</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20155808.png"></p><p>添加一个界面的ui图片。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20155853.png"></p><p>之后还是添加一个文件，这个文件是作为一个下一个界面的文件。要勾选QMainWindow作为基类。<img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20160251.png"></p><p>进行绘图</p><p>在mypage.cpp中编写界面大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mypage.h&quot;</span></span></span><br><span class="line">mypage::<span class="built_in">mypage</span>(QWidget *parent) : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1080</span>, <span class="number">900</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mainwindow.h中添加绘图的函数，因为在MainWindow的构造函数只运行一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPaintEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123; <span class="keyword">class</span> <span class="title class_">MainWindow</span>; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QPushButton *pushButton;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mainwindow.cpp文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mypage.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>( <span class="number">800</span>, <span class="number">480</span> );</span><br><span class="line">    QPushButton *pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;jump&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    pushButton-&gt;<span class="built_in">setGeometry</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">40</span>, <span class="number">30</span>);</span><br><span class="line">    mypage *scene = <span class="keyword">new</span> mypage;</span><br><span class="line">    <span class="built_in">connect</span>(pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>,[=]()&#123; <span class="comment">//跳转界面</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">        scene-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::paintEvent</span><span class="params">(QPaintEvent *)</span><span class="comment">//ui主界面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/ig.png&quot;</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>(), pixmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击完界面的按钮就能进入下一个界面。</p><p>从新界面点击按钮在返回主界面。</p><p>在mypage.h文件中加入信号，这个信号是为了在次界面点击按钮时候来激发信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signals:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">returnpage</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>修改mypage.cpp文件，加入按钮，并连接槽函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mypage.h&quot;</span></span></span><br><span class="line">mypage::<span class="built_in">mypage</span>(QWidget *parent) : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    pushButton1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;返回&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    pushButton1 -&gt; <span class="built_in">setGeometry</span>( <span class="number">400</span>, <span class="number">300</span>, <span class="number">40</span> ,<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">connect</span>(pushButton1, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">chooseBack</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回修改mainwindow.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mypage.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>( <span class="number">800</span>, <span class="number">480</span> );</span><br><span class="line">    QPushButton *pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;jump&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    pushButton-&gt;<span class="built_in">setGeometry</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">40</span>, <span class="number">30</span>);</span><br><span class="line">    mypage *scene = <span class="keyword">new</span> mypage;</span><br><span class="line">    <span class="built_in">connect</span>(pushButton, &amp;QPushButton::clicked, <span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">        scene-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(scene, &amp;mypage::chooseBack, <span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">        scene-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::paintEvent</span><span class="params">(QPaintEvent *)</span><span class="comment">//ui主界面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/ig.png&quot;</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>-&gt;<span class="built_in">width</span>(), <span class="keyword">this</span>-&gt;<span class="built_in">height</span>(), pixmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20164756.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-11%20164820.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt控件③</title>
      <link href="/2023/09/09/2023-9-9-qt%E6%8E%A7%E4%BB%B63/"/>
      <url>/2023/09/09/2023-9-9-qt%E6%8E%A7%E4%BB%B63/</url>
      
        <content type="html"><![CDATA[<p>QLabel控件</p><p>用来设计UI界面，给界面添加图片。右键项目名称来添加资源文件，选择Add New。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20131129.png"></p><p>填上资源文件的名称（可随意写一个），默认添加项目路径下。后面的步骤默认即可，点击完成。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20131307.png"></p><p>添加 qss 文件。 QSS 文件是使用 Qt 程序相关联的样式表文件。它由 GUI 元素的外观和感觉，包括布局，颜色，鼠标的行为，大小和字体。它的风格，一个可以合并到一个 UI（用户界面）。 与 HTML 的 CSS 类似， Qt 的样式表是纯文本的格式定义，在应用程序运行时可以载入和解析这些样式定义，从而使应用程序的界面呈现不同的效果。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20131456.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel *labelString;</span><br><span class="line">    QLabel *labelImage;</span><br><span class="line">    QPushButton *pushButton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushButtoncheckedchanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/ig.png&quot;</span>)</span></span>;</span><br><span class="line">    labelImage = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    labelImage -&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span> , <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    labelImage -&gt;<span class="built_in">setPixmap</span>(pixmap);</span><br><span class="line">    labelImage-&gt;<span class="built_in">setScaledContents</span>(<span class="literal">true</span>);</span><br><span class="line">    labelString = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    labelString -&gt;<span class="built_in">setText</span>(<span class="string">&quot;标签演示文本&quot;</span>);</span><br><span class="line">    labelString -&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">    pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;关闭窗口&quot;</span> ,<span class="keyword">this</span>);</span><br><span class="line">    pushButton-&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>,<span class="number">200</span>,<span class="number">80</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButtoncheckedchanged</span>()));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtoncheckedchanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20131652.png"></p><p>QDateEdit和QDateTimeEdit控件</p><p>QDateTimeEdit类提供一个用于编辑日期和时间的小部件，QDateTImeEdit允许用户使用键盘或箭头编辑日期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTimeEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimeEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateEdit&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QDateTimeEdit *dateTimeEdit;</span><br><span class="line">    QTimeEdit *timeEdit;</span><br><span class="line">    QDateEdit *dateEdit;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    dateTimeEdit = <span class="keyword">new</span> <span class="built_in">QDateTimeEdit</span>(QDateTime::<span class="built_in">currentDateTime</span>(), <span class="keyword">this</span>);</span><br><span class="line">    dateTimeEdit -&gt; <span class="built_in">setGeometry</span>( <span class="number">300</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">    timeEdit = <span class="keyword">new</span> <span class="built_in">QTimeEdit</span>(QTime :: <span class="built_in">currentTime</span>(), <span class="keyword">this</span>);</span><br><span class="line">    timeEdit -&gt;<span class="built_in">setGeometry</span>( <span class="number">300</span>, <span class="number">240</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">    dateEdit = <span class="keyword">new</span> <span class="built_in">QDateEdit</span>(QDate::<span class="built_in">currentDate</span>(), <span class="keyword">this</span>);</span><br><span class="line">    dateEdit -&gt;<span class="built_in">setGeometry</span>( <span class="number">300</span>, <span class="number">280</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20132644.png"></p><p>QProgressBar控件</p><p>QProgressBar 继承 QWidget。 QProgressBar 小部件提供了一个水平或垂直的进度条。进度条用于向用户显示操作的进度，并向他们确认应用程序仍在运行。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProgressBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 声明对象 */</span></span><br><span class="line">QProgressBar *progressBar;</span><br><span class="line">QTimer *timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于设置当前 QProgressBar 的值 */</span></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="comment">/* 槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timerTimeOut</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置主窗体位置与大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">progressBar = <span class="keyword">new</span> <span class="built_in">QProgressBar</span>(<span class="keyword">this</span>);</span><br><span class="line">progressBar-&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">60</span>);</span><br><span class="line"><span class="comment">/*样式表设置，常用使用 setStyleSheet 来设置样式（实现界面美化的功能）， * 具体可参考 styleSheet */</span></span><br><span class="line">progressBar-&gt;<span class="built_in">setStyleSheet</span> (</span><br><span class="line"> <span class="string">&quot;QProgressBar&#123;border:8px solid #FFFFFF;&quot;</span></span><br><span class="line"><span class="string">&quot;height:30;&quot;</span></span><br><span class="line"><span class="string">&quot;border-image:url(:/images/battery.png);&quot;</span> <span class="comment">//背景图片</span></span><br><span class="line"><span class="string">&quot;text-align:center;&quot;</span> <span class="comment">// 文字居中</span></span><br><span class="line"><span class="string">&quot;color:rgb(255,0,255);&quot;</span></span><br><span class="line"><span class="string">&quot;font:20px;&quot;</span> <span class="comment">// 字体大小为 20px</span></span><br><span class="line"><span class="string">&quot;border-radius:10px;&#125;&quot;</span></span><br><span class="line"><span class="string">&quot;QProgressBar::chunk&#123;&quot;</span></span><br><span class="line"><span class="string">&quot;border-radius:5px;&quot;</span> <span class="comment">// 斑马线圆角</span></span><br><span class="line"><span class="string">&quot;border:1px solid black;&quot;</span> <span class="comment">// 黑边，默认无边</span></span><br><span class="line"><span class="string">&quot;background-color:skyblue;&quot;</span></span><br><span class="line"><span class="string">&quot;width:10px;margin:1px;&#125;&quot;</span> <span class="comment">// 宽度和间距</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">/* 设置 progressBar 的范围值 */</span></span><br><span class="line">progressBar-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">/* 初始化 value 为 0 */</span></span><br><span class="line">value = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 给 progressBar 设置当前值 */</span></span><br><span class="line">progressBar-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line"><span class="comment">/* 设置当前文本字符串的显示格式 */</span></span><br><span class="line">progressBar-&gt;<span class="built_in">setFormat</span>(<span class="string">&quot;充电中%p%&quot;</span>);</span><br><span class="line"><span class="comment">/* 定时器实例化设置每 100ms 发送一个 timeout 信号 */</span></span><br><span class="line">timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">/* 信号槽连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(timer, <span class="built_in">SIGNAL</span>(<span class="built_in">timeout</span>()),<span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">timerTimeOut</span>()));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::timerTimeOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 定显示器时间到， value 值自加一 */</span></span><br><span class="line">value ++;</span><br><span class="line">progressBar-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line"><span class="comment">/* 若 value 值大于 100，令 value 再回到 0 */</span></span><br><span class="line"><span class="keyword">if</span>(value&gt;<span class="number">100</span>)</span><br><span class="line">value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QFrame类</p><p>QFrame 继承 QWidget。 QFrame 类是有框架的窗口部件的基类，它绘制框架并且调用一个虚函数 drawContents()来填充这个框架。这个函数是被子类重新实现的。这里至少还有两个有用的函数： drawFrame()和 frameChanged()。</p><p>QPopupMenu 使用这个来把菜单“升高”，高于周围屏幕。 QProgressBar 有“凹陷”的外观。QLabel 有平坦的外观。这些有框架的窗口部件可以被改变。</p><blockquote><p>QFrame::Shape 这个枚举类型定义了 QFrame 的框架所使用的外形。当前定义的效果有：<br>NoFrame - QFrame 不画任何东西<br>Box - QFrame 在它的内容周围画一个框<br>Panel - QFrame 画一个平板使内容看起来凸起或者凹陷<br>WinPanel - 像 Panel，但 QFrame 绘制三维效果的方式和 Microsoft Windows 95（及其它）的一样<br>ToolBarPanel - QFrame 调用 QStyle::drawToolBarPanel()<br>MenuBarPanel - QFrame 调用 QStyle::drawMenuBarPanel()<br>HLine - QFrame 绘制一个水平线，但没有框任何东西（作为分隔是有用的）<br>VLine - QFrame 绘制一个竖直线，但没有框任何东西（作为分隔是有用的）<br>StyledPanel - QFrame 调用 QStyle::drawPanel()<br>PopupPanel - QFrame 调用 QStyle::drawPopupPanel()<br>阴影风格有：<br>Plain 使用调色板的前景颜色绘制（没有任何三维效果）。<br>Raised 使用当前颜色组的亮和暗颜色绘制三维的凸起线。<br>Sunken 使用当前颜色组的亮和暗颜色绘制三维的凹陷线。 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFrame&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 声明对象 */</span></span><br><span class="line">QFrame *hline;</span><br><span class="line">QFrame *vline;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置主窗体的显示位置与大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"><span class="comment">/* 实例化 */</span></span><br><span class="line">hline = <span class="keyword">new</span> <span class="built_in">QFrame</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/* 确定起始点，设置长和宽，绘制距形 */</span></span><br><span class="line">hline-&gt;<span class="built_in">setGeometry</span>(<span class="built_in">QRect</span>(<span class="number">200</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">40</span>));</span><br><span class="line"><span class="comment">/* 设置框架样式为 Hline，水平，可设置为其他样式例如 Box，</span></span><br><span class="line"><span class="comment">* 由于是样式选择 HLine，所以只显示一条水平直线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">hline-&gt;<span class="built_in">setFrameShape</span>(QFrame::HLine);</span><br><span class="line"><span class="comment">/* 绘制阴影 */</span></span><br><span class="line">hline-&gt;<span class="built_in">setFrameShadow</span>(QFrame::Sunken);</span><br><span class="line"><span class="comment">/* 实例化 */</span></span><br><span class="line">vline = <span class="keyword">new</span> <span class="built_in">QFrame</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/* 确定起始点，设置长和宽，绘制距形 */</span></span><br><span class="line">vline-&gt;<span class="built_in">setGeometry</span>(<span class="built_in">QRect</span>(<span class="number">300</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">200</span>));</span><br><span class="line"><span class="comment">/* 设置框架样式为 Vline，垂直，可设置为其他样式例如 Box，</span></span><br><span class="line"><span class="comment">* 由于是样式选择 Vline，所以只显示一条垂直直线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vline-&gt;<span class="built_in">setFrameShape</span>(QFrame::VLine);</span><br><span class="line"><span class="comment">/* 绘制阴影 */</span></span><br><span class="line">vline-&gt;<span class="built_in">setFrameShadow</span>(QFrame::Sunken);</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20134737.png"></p><p>QBoxLayout类</p><p>QBoxLayout 继承 QLayout。 QBoxLayout 类提供水平或垂直地排列子部件。 QBoxLayout 获取从它的父布局或从 parentWidget()中所获得的空间，将其分成一列框，并使每个托管小部件填充一个框。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPushButton *pushButton[<span class="number">6</span>];</span><br><span class="line">    QWidget *hWidget;</span><br><span class="line">    QWidget *vWidget;</span><br><span class="line">    QHBoxLayout *hLayout; </span><br><span class="line">    QVBoxLayout *vLayout;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span> , <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    hWidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    hWidget -&gt; <span class="built_in">setGeometry</span>( <span class="number">0</span> , <span class="number">0</span>, <span class="number">800</span>, <span class="number">240</span>);</span><br><span class="line">    vWidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    vWidget -&gt; <span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">240</span>, <span class="number">800</span>, <span class="number">240</span>);</span><br><span class="line">    hLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    vLayout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">    QList&lt;QString&gt;list; <span class="comment">//list放入字符串</span></span><br><span class="line">    list&lt;&lt;<span class="string">&quot;one&quot;</span>&lt;&lt;<span class="string">&quot;two&quot;</span>&lt;&lt;<span class="string">&quot;three&quot;</span>&lt;&lt;<span class="string">&quot;four&quot;</span>&lt;&lt;<span class="string">&quot;five&quot;</span>&lt;&lt;<span class="string">&quot;six&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pushButton[i] = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">        pushButton[i]-&gt;<span class="built_in">setText</span>(list[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            hLayout-&gt;<span class="built_in">addWidget</span>(pushButton[i]);<span class="comment">//水平放置按钮</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vLayout-&gt;<span class="built_in">addWidget</span>(pushButton[i]);<span class="comment">//垂直放置按钮</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hLayout-&gt;<span class="built_in">setSpacing</span>(<span class="number">50</span>);<span class="comment">//间隔</span></span><br><span class="line">    hWidget-&gt;<span class="built_in">setLayout</span>(hLayout);</span><br><span class="line">    vWidget-&gt;<span class="built_in">setLayout</span>(vLayout);</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20150844.png"></p><p>QFormLayout布局</p><p>QFormLayout 继承 QLayout。 QFormLayout 类管理输入小部件及其关联标签的表单。 QFormLayout 是一个方便的布局类，它以两列的形式布局其子类。左列由标签组成，右列由“字段”小部件(QLineEdit(行编辑器)、 QSpinBox(旋转框等))组成。 </p><p>可以用来规划用户密码登录的界面布局。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFormLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QWidget *fwidget;</span><br><span class="line">    QLineEdit *userLineEdit;</span><br><span class="line">    QLineEdit *passwordLineEdit;</span><br><span class="line">    QFormLayout *formLayout;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    fwidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    fwidget -&gt;<span class="built_in">setGeometry</span>( <span class="number">250</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">200</span> );</span><br><span class="line">    userLineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">    passwordLineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">    formLayout = <span class="keyword">new</span> <span class="built_in">QFormLayout</span>();</span><br><span class="line">    formLayout -&gt;<span class="built_in">addRow</span>(<span class="string">&quot;用户名&quot;</span>,userLineEdit);</span><br><span class="line">    formLayout -&gt;<span class="built_in">addRow</span>(<span class="string">&quot;密码&quot;</span>, passwordLineEdit);</span><br><span class="line">    formLayout-&gt;<span class="built_in">setSpacing</span>(<span class="number">10</span>); <span class="comment">//水平垂直间距</span></span><br><span class="line">    formLayout-&gt;<span class="built_in">setMargin</span>(<span class="number">20</span>); <span class="comment">//布局外框宽度</span></span><br><span class="line">    fwidget-&gt;<span class="built_in">setLayout</span>(formLayout);<span class="comment">//将formLayout布局到fwidget里</span></span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20154712.png"></p><p>QSpacerItem<br>QSpacerItem 继承 QLayoutItem。 QSpacerItem 类在布局中提供空白(空间间隔)。所以 QSpacerItem 是在布局中使用的。 </p><p>可以用来布局一些按钮图标之类的。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-09%20155105.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent  = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QPushButton *bt[<span class="number">4</span>];</span><br><span class="line">QSpacerItem *vSpacer; <span class="comment">//垂直间隔</span></span><br><span class="line">QSpacerItem *hSpacer;<span class="comment">//水平间隔</span></span><br><span class="line">QWidget *widget;<span class="comment">//声明一个weidget来放布局</span></span><br><span class="line">QHBoxLayout *mainLayout;<span class="comment">//主布局</span></span><br><span class="line">QVBoxLayout *vBoxLayout;<span class="comment">//垂直布局</span></span><br><span class="line">QHBxoLayout *hBoxLayout;<span class="comment">//水平布局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">:<span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    </span><br><span class="line">    widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(widget);</span><br><span class="line">    vSpacer = <span class="keyword">new</span> <span class="built_in">QSpacerItem</span>( <span class="number">10</span> , <span class="number">10</span>, QSizePolicy::Minimum, QSizePolicy::Expanding);</span><br><span class="line">    hSpacer = <span class="keyword">new</span> <span class="built_in">QSpacerItem</span>( <span class="number">10</span> , <span class="number">10</span>, QSizePolicy::Expanding, QSizePolicy :: Minimum);</span><br><span class="line">    </span><br><span class="line">    vBoxLayout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>();</span><br><span class="line">    hBxoLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    mainLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">    </span><br><span class="line">    vBoxLayout-&gt;<span class="built_in">addSpacerItem</span>(vSpacer);<span class="comment">//vBoxLayout添加垂直间隔</span></span><br><span class="line">    QList &lt;QString&gt;list;<span class="comment">//字符串插入list</span></span><br><span class="line">    </span><br><span class="line">    list &lt;&lt; <span class="string">&quot;按钮1&quot;</span>&lt;&lt; <span class="string">&quot; 按钮2&quot;</span>&lt;&lt; <span class="string">&quot;按钮3&quot;</span>&lt;&lt; <span class="string">&quot;按钮4&quot;</span>；</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">//实例化按钮</span></span><br><span class="line">    &#123;</span><br><span class="line">        bt[i] = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">        bt[i] = <span class="built_in">setText</span>(list[i]);</span><br><span class="line">        bt[i] -&gt;<span class="built_in">setFixedSize</span>( <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">        hBoxLayout-&gt;<span class="built_in">addWidget</span>(bt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    hBoxLayout-&gt;<span class="built_in">addSpacerItem</span>(hSpacer);<span class="comment">//hBoxLayout加入水平间隔</span></span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(vBoxLayout); <span class="comment">//主布局里加入垂直间隔</span></span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(hBoxLayout); <span class="comment">//主布局里加入水平间隔</span></span><br><span class="line">    mainLayout-&gt;<span class="built_in">setSpacing</span>(<span class="number">50</span>);<span class="comment">//设置部件间距</span></span><br><span class="line">    widget-&gt;<span class="built_in">setLayout</span>(mainLayout);<span class="comment">//主布局为widget布局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpinBox，DoubleSpinBox控件（数值调整控件）</p><p>数字显示框，显示整型和浮点型的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDoubleSpinbox&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QDoubleSpinBox *doubleSpinBox;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">:<span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    doubleSpinBox = <span class="keyword">new</span> <span class="built_in">QDoubleSpinBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    doubleSpinBox -&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">/* 设置前缀 */</span></span><br><span class="line">doubleSpinBox-&gt;<span class="built_in">setPrefix</span>(<span class="string">&quot;激光功率&quot;</span>);</span><br><span class="line"><span class="comment">/* 设置后缀 */</span></span><br><span class="line">doubleSpinBox-&gt;<span class="built_in">setSuffix</span>(<span class="string">&quot;%&quot;</span>);</span><br><span class="line">    <span class="comment">/* 设置范围 */</span></span><br><span class="line">doubleSpinBox-&gt;<span class="built_in">setRange</span>(<span class="number">00.00</span>, <span class="number">100.00</span>);</span><br><span class="line"><span class="comment">/* 设置初始值 */</span></span><br><span class="line">doubleSpinBox-&gt;<span class="built_in">setValue</span>(<span class="number">20.00</span>);</span><br><span class="line"><span class="comment">/* 设置步长 */</span></span><br><span class="line">doubleSpinBox-&gt;<span class="built_in">setSingleStep</span>(<span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt控件②</title>
      <link href="/2023/09/06/2023-9-7-qt%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%8E%A7%E4%BB%B62/"/>
      <url>/2023/09/06/2023-9-7-qt%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%8E%A7%E4%BB%B62/</url>
      
        <content type="html"><![CDATA[<p>以下qt控件的学习记录是做毕设应该是需要用到的。</p><p>QPushButton控件</p><p>QPushButton是实现按钮点击的控件。在mainwindow.h文件中改写代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="comment">/* 引入 QPushButton 类 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">/* 声明一个 QPushButton 对象 pushButton1 */</span></span><br><span class="line">QPushButton *pushButton1;</span><br><span class="line"> <span class="comment">/* 声明一个 QPushButton 对象 pushButton2 */</span></span><br><span class="line">QPushButton *pushButton2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="comment">/* 声明对象 pushButton1 的槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButton1_Clicked</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* 声明对象 pushButton2 的槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButton2_Clicked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>之后编写mainwindow.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置宽高为 800×480,位置在 0, 0。（0, 0）代表原点， Qt 默认最左上角的点为原</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化两个按钮对象，并设置其显示文本为窗口皮肤 1 和窗口皮肤 2 */</span></span><br><span class="line">pushButton1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;窗口皮肤 1&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">pushButton2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;窗口皮肤 2&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定两个 QPushButton 对象的位置 */</span></span><br><span class="line">pushButton1-&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>,<span class="number">200</span>,<span class="number">80</span>,<span class="number">40</span>);</span><br><span class="line">pushButton2-&gt;<span class="built_in">setGeometry</span>(<span class="number">400</span>,<span class="number">200</span>,<span class="number">80</span>,<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号槽连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(pushButton1, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">pushButton1_Clicked</span>()));</span><br><span class="line"><span class="built_in">connect</span>(pushButton2, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">pushButton2_Clicked</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 槽函数的实现 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButton1_Clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 设置主窗口的样式 1 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QMainWindow &#123; background-color: rgba(255, 245,238, 100%); &#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 槽函数的实现 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButton2_Clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 设置主窗口的样式 2 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QMainWindow &#123; background-color: rgba(238, 122,233, 100%); &#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QToolButton控件</p><p>工具按钮是带图标的，跟一般的按钮不一样。其实跟PushButton差不多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"> <span class="comment">/* 引入 QToolButton 类 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolButton&gt;</span></span></span><br><span class="line"> <span class="comment">/* 引入 QToolBar 类 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 声明一个 QToolButton 对象 */</span></span><br><span class="line">QToolButton *toolButton;</span><br><span class="line"><span class="comment">/* 声明一个 QToolBar 对象 */</span></span><br><span class="line">QToolBar *toolBar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p>Main window.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStyle&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置主窗体的位置和大小 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化 QToolBar 对象 */</span></span><br><span class="line">toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/* 设置 toolBar 的位置和大小 */</span></span><br><span class="line">toolBar-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化 QStyle 类对象，用于设置风格，调用系统类自带的图标 */</span></span><br><span class="line">QStyle *style = QApplication::<span class="built_in">style</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 Qt 自带的标准图标，可以在帮助文档里搜索 QStyle::StandardPixmap */</span></span><br><span class="line"> QIcon icon =style-&gt;<span class="built_in">standardIcon</span>(QStyle::SP_TitleBarContextHelpButton);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化 QToolButton 对象 */</span></span><br><span class="line">toolButton = <span class="keyword">new</span> <span class="built_in">QToolButton</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 设置图标 */</span></span><br><span class="line">toolButton-&gt;<span class="built_in">setIcon</span>(icon);</span><br><span class="line"><span class="comment">/* 设置要显示的文本 */</span></span><br><span class="line">toolButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;帮助&quot;</span>);</span><br><span class="line"><span class="comment">/* 调用 setToolButtonStyle()方法，设置 toolButoon 的样式，设置为文本置于图标下方 */</span></span><br><span class="line">toolButton-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonTextUnderIcon);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最后将 toolButton 添加到 ToolBar 里 */</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addWidget</span>(toolButton);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QCheckBox控件</p><p>QCheckBox 继承 QAbstractButton。三态选择框，复选按钮（复选框）与 RadioButton 的区别是选择模式，单选按钮提供多选一，复选按钮提供多选多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="comment">/* 引入 QCheckBox */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCheckBox&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* 声明一个 QCheckBox 对象 */</span></span><br><span class="line">QCheckBox *checkBox;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"><span class="comment">/* 声明 QCheckBox 的槽函数，并带参数传递，用这个参数接收信号的参数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkBoxStateChanged</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>mainwindow.cpp </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">: <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*（ 主窗体设置位置和显示的大小及背景颜色 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QMainWindow &#123;background-color: rgba(100, 100,100, 100%);&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化对象 */</span></span><br><span class="line">checkBox = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 QCheckBox 位置和显示大小 */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setGeometry</span>(<span class="number">350</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">/* 初始化三态复选框的状态为 Checked */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setCheckState</span>(Qt::Checked);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示的文本 */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setText</span>(<span class="string">&quot;初始化为 Checked 状态&quot;</span>);</span><br><span class="line"><span class="comment">/* 开启三态模式，必须开启，否则只有两种状态，即 Checked 和 Unchecked */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setTristate</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 连接 checkBox 的信号 stateChanged(int)，与我们定义的槽</span></span><br><span class="line"><span class="comment">checkBoxStateChanged(int)连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(checkBox, <span class="built_in">SIGNAL</span>(<span class="built_in">stateChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">checkBoxStateChanged</span>(<span class="type">int</span>)));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 槽函数的实现 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::checkBoxStateChanged</span><span class="params">(<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 判断 checkBox 的 state 状态，设置 checkBox 的文本 */</span></span><br><span class="line"><span class="keyword">switch</span> (state) &#123;</span><br><span class="line"><span class="keyword">case</span> Qt::Checked:</span><br><span class="line"><span class="comment">/* 选中状态 */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Checked 状态&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::Unchecked:</span><br><span class="line"><span class="comment">/* 未选中状态 */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Unchecked 状态&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Qt::PartiallyChecked:</span><br><span class="line"><span class="comment">/* 半选状态 */</span></span><br><span class="line">checkBox-&gt;<span class="built_in">setText</span>(<span class="string">&quot;PartiallyChecked 状态&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lineEdit控件</p><p>QLineEdit 小部件是一个单行文本编辑器。行编辑允许用户使用一组有用的编辑函数输入和编辑一行纯文本。 编写输入密码的窗口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLineEdit *lineEdit;</span><br><span class="line">    QPushButton *pushButton;</span><br><span class="line">    QLabel *label1;</span><br><span class="line">    QLabel *label2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">pushButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><p>mainwindow.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QString&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span> , <span class="number">0</span>, <span class="number">800</span> , <span class="number">480</span>);</span><br><span class="line">    lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">    lineEdit -&gt; <span class="built_in">setGeometry</span>( <span class="number">280</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">20</span>);</span><br><span class="line">    pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    pushButton-&gt;<span class="built_in">setGeometry</span>( <span class="number">280</span>, <span class="number">280</span>, <span class="number">100</span>, <span class="number">21</span>);</span><br><span class="line">    pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;确认&quot;</span>);</span><br><span class="line">    label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    label1 -&gt;<span class="built_in">setGeometry</span>( <span class="number">280</span>, <span class="number">240</span>, <span class="number">400</span>, <span class="number">20</span>);</span><br><span class="line">    label1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;请输入密码:&quot;</span>);</span><br><span class="line">    label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    label2 -&gt;<span class="built_in">setGeometry</span>(<span class="number">280</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButtonClicked</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str1;</span><br><span class="line">    QString str2;</span><br><span class="line">    QString str3;</span><br><span class="line">    str3 = lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">    str1 = <span class="string">&quot;你输入的内容是&quot;</span>;</span><br><span class="line">    str2 = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(QString::<span class="built_in">compare</span>(str2, str3, Qt::CaseSensitive) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        label2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;密码正确&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        label2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    str1 += lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">    label1-&gt;<span class="built_in">setText</span>(str1);</span><br><span class="line">    lineEdit-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-07%20211317.png"></p><p>QFontComboBox控件</p><p>调整字体的控件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFontComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QFontComboBox *fontComboBox;</span><br><span class="line">    QLabel *label;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fontComboBoxFontChanged</span><span class="params">(QFont)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    fontComboBox = <span class="keyword">new</span> <span class="built_in">QFontComboBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    fontComboBox -&gt;<span class="built_in">setGeometry</span>(<span class="number">280</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">    label-&gt;<span class="built_in">setGeometry</span>( <span class="number">280</span>, <span class="number">250</span>, <span class="number">300</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">connect</span>(fontComboBox, <span class="built_in">SIGNAL</span>(<span class="built_in">currentFontChanged</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">fontComboBoxFontChanged</span>(QFont)));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::fontComboBoxFontChanged</span><span class="params">(QFont font)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    label-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">    QString str = <span class="string">&quot;设置的字体为：&quot;</span> + fontComboBox-&gt; <span class="built_in">itemText</span>(fontComboBox-&gt;<span class="built_in">currentIndex</span>());</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-07%20211206.png">QcomboBox控件</p><p>可以使用在单位的选择上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QComboBox *comboBox;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">comboBoxIndexChanged</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setGeometry</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">480</span>);</span><br><span class="line">    comboBox = <span class="keyword">new</span> <span class="built_in">QComboBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    comboBox -&gt;<span class="built_in">setGeometry</span>(<span class="number">300</span>, <span class="number">200</span>, <span class="number">150</span>, <span class="number">30</span>);</span><br><span class="line">    comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;cm(默认)&quot;</span>);</span><br><span class="line">    comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;mm&quot;</span>);</span><br><span class="line">    comboBox-&gt;<span class="built_in">addItem</span>(<span class="string">&quot;dm&quot;</span>);</span><br><span class="line">    <span class="built_in">connect</span>(comboBox, <span class="built_in">SIGNAL</span>(<span class="built_in">currentIndexChanged</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">comboBoxIndexChanged</span>(<span class="type">int</span>)));</span><br><span class="line">&#125;</span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::comboBoxIndexChanged</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 打印出选择的省份 */</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;您选择的省份是&quot;</span>&lt;&lt; comboBox-&gt;<span class="built_in">itemText</span>(index)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-07%20211109.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt控件①</title>
      <link href="/2023/09/04/2023-9-5-qt%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%8E%A7%E4%BB%B61/"/>
      <url>/2023/09/04/2023-9-5-qt%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%8E%A7%E4%BB%B61/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><h4 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h4><p>QString 提供了一个二元的“+”操作符用于组合两个字符串，<strong>并提供一个+&#x3D;操作符将一个字符串追加到另一个字符串的结尾</strong>，<strong>另一种方法QString::append()函数具有同样功能。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QString str1 = <span class="string">&quot;welcome&quot;</span>;</span><br><span class="line">str1 = str1 + <span class="string">&quot;to you&quot;</span>;<span class="comment">//str1 = &quot;welcome to you&quot;;</span></span><br><span class="line">QString.<span class="built_in">append</span>(<span class="string">&quot;!&quot;</span>);<span class="comment">//str = &quot;welcome to you !&quot;;</span></span><br></pre></td></tr></table></figure><p>其他组合字符串作用函数：</p><table><thead><tr><th>insert()函数</th><th>原字符串特定位置插入另一个字符串</th></tr></thead><tbody><tr><td><strong>prepend()函数</strong></td><td><strong>原字符串的开头插入另一个字符串</strong></td></tr><tr><td><strong>replace()函数</strong></td><td><strong>用指定的字符串代替另一个字符串</strong></td></tr><tr><td><strong>arg()函数</strong></td><td><strong>重载数据类型</strong></td></tr><tr><td><strong>trimmed()函数</strong></td><td><strong>移除字符串两端的空白字符</strong></td></tr><tr><td><strong>simplified()函数</strong></td><td><strong>移除字符串两端的空白字符，使用单个空格字符”“代替字符串中出现的空白字符。</strong></td></tr></tbody></table><p><strong>查询字符串数据</strong></p><p>QString::startsWith()函数判断一个字符串是否以第一个参数的字符串开头，第二个参数是是否大小写敏感。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str= <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">QString::<span class="built_in">startsWith</span>(<span class="string">&quot;hello&quot;</span>, Qt::CaseSensitive); <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure><p>同理QString::endWith是判断一个字符串是否以第一个参数的字符串结尾。</p><p>QString::contains判断一个指定字符串是否出现过。</p><p>localeAwareCompare(const QSring&amp;, const QString&amp;):静态函数比较前后两个字符串。</p><p><strong>字符串转换函数</strong></p><p>QString::toInt()函数将字符串转换为整型数值，类似的函数还有 toDouble() 、 toFloat() 、toLong() 、 toLongLong()等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString str=<span class="string">&quot;l25&quot;</span>; <span class="comment">//初始化一个 &quot;125&quot; 的字符串</span></span><br><span class="line"><span class="type">bool</span> ok;</span><br><span class="line"><span class="type">int</span> hex=str. <span class="built_in">toInt</span> (&amp;ok, <span class="number">16</span>) ; / / ok=<span class="literal">true</span>, hex=<span class="number">2</span> <span class="number">93</span></span><br><span class="line"><span class="type">int</span> dec=str.<span class="built_in">toint</span>(&amp;ok,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>第一个参数bool类型指针用于返回转换状态。成功true，失败false。第二个参数指定了转换基数，0x为16基数16，0为基数8，其他都是10;</p><p>① toAsciiO~ 返回一个 ASCII 编码的 8 位字符串。<br>② toLatinlO: 返回一个 Latin-I 0S08859-1) 编码的 8 位字符串。<br>③ toUtf80: 返回一个 UTF-8 编码的 8 位字符串 (UTF-8 是 ASCII 码的超集<br>④ toLocal8Bit0: 返回一个系统本地 (locale) 编码的 8 位字符串。 </p><h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>Qt库提供了一套通用的基于模板的容器类，可以用这些类存储指定类型的项。比如，你需要一个大小可变的QString的数组，则使用QVector<QString>。</p><p>这些容器类比STL（C++标准模板库）容器设计得更轻量、更安全并且更易于使用。如果对STL不熟悉，或者倾向于用“Qt的方式”，那么你可以使用这些类，而不去使用STL的类。</p><p>存储在 Qt 容器中的数据必须是可赋值的数据类型，也就是说，这种数据类型必须提供一个默认的构造函数（不需要参数的构造函数）、一个复制构造函数和一个赋值操作运算符。 </p><h4 id="QList-类、QLinkedList-类和-QVector-类"><a href="#QList-类、QLinkedList-类和-QVector-类" class="headerlink" title="QList 类、QLinkedList 类和 QVector 类"></a>QList 类、QLinkedList 类和 QVector 类</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-05%20154308.png"></h4><table><thead><tr><th>类</th><th>概述</th></tr></thead><tbody><tr><td>QList<T></td><td>这是目前<strong>使用最频繁的容器类</strong>，它存储了指定类型(T)的一串值，可以通过索引来获得。本质上QList是用数组实现的，从而保证基于索引的访问非常快。</td></tr><tr><td>QLinkedList<T></td><td>类似于QList，但它使用迭代器而不是整数索引来获得项。当在一个很大的list中间插入项时，它提供了更好的性能，并且它有更好的迭代器机制。</td></tr><tr><td>QVector<T></td><td>在内存中相邻的位置存储一组值，在开头或中间插入会非常慢，因为它会导致内存中很多项移动一个位置。</td></tr><tr><td>QStack<T></td><td>QVector的一个子类，提供后进先出的机制。在当前的QVector中增加了几个方法：push()、pos()、top()。</td></tr><tr><td>QQueue<T></td><td>QList的一个子类，提供了先进先出的机制，在当前的QList中增加了几个方法：enqueue()、dequeue()、head()。</td></tr><tr><td>QSet<T></td><td>单值的数学集合，能够快速查找。</td></tr><tr><td>QMap&lt;Key, T&gt;</td><td>提供了字典（关联数组）将类型Key的键对应类型T的值。通常一个键对应一个值，QMap以Key的顺序存储数据，如果顺序不重要，QHash是一个更快的选择。</td></tr><tr><td>QMultiMap&lt;Key, T&gt;</td><td>QMap的子类，提供了多值的接口，一个键对应多个值。</td></tr><tr><td>QHash&lt;Key, T&gt;</td><td>和QMap几乎有着相同的接口，但查找起来更快。QHash存储数据没有什么顺序。</td></tr><tr><td>QMultiHash&lt;Key, T&gt;</td><td>QHash的子类，提供了多值的接口。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span></span><br><span class="line"><span class="function">    QList&lt;<span class="type">int</span>&gt; list</span>;</span><br><span class="line">    list&lt;&lt;<span class="number">1</span> &lt;&lt; <span class="number">2</span>&lt;&lt; <span class="number">3</span>&lt;&lt; <span class="number">4</span>&lt;&lt; <span class="number">5</span>;</span><br><span class="line">    <span class="function">QListIterator&lt;<span class="type">int</span>&gt; <span class="title">i</span> <span class="params">(list)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(; i.<span class="built_in">hasNext</span>();)</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; i.<span class="built_in">next</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QVariant-类"><a href="#QVariant-类" class="headerlink" title="QVariant 类"></a>QVariant 类</h3><p>QVariant 类类似千 C++的联合 (union) 数据类型，它不仅能保存很多 Qt 类型的值，包括QColor 、 QBrush 、 QFont 、 QPen 、 QRect 、 QString 和 QSize 等，而且也能存放 Qt 的容器类型的值。 </p><p>新建QtWidgets Application基类选择QWidget，取消创建界面复选框。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Qdebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColor&gt;</span></span></span><br><span class="line">Widget :: <span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">:<span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">QVariant <span class="title">v</span><span class="params">(<span class="number">709</span>)</span></span>;<span class="comment">//声明了一个QVariant变量v,并初始化为整数</span></span><br><span class="line">    <span class="built_in">QDebug</span>() &lt;&lt; v.<span class="built_in">toInt</span>();<span class="comment">//调用QVariant::toInt函数将QVariant变量包含的内容换为整数并输出。</span></span><br><span class="line">    <span class="function">QVariant <span class="title">w</span><span class="params">(<span class="string">&quot;How are you ?&quot;</span>)</span></span>; <span class="comment">//声明一个QVariant变量w初始化为字符串</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; w.<span class="built_in">toString</span>();<span class="comment">//调用QVariant::toString函数将QVariant变量包含的内容换为整数并输出。</span></span><br><span class="line">    QMap&lt;QString, QVariant&gt; map;<span class="comment">//声明一个 QMap 变量 map, 使用字符串作为键， QVariant变量作为值。</span></span><br><span class="line">    map[<span class="string">&quot;int&quot;</span>] = <span class="number">709</span>;</span><br><span class="line">    map[<span class="string">&quot;int&quot;</span>J=<span class="number">709</span>;</span><br><span class="line">map[<span class="string">&quot;double&quot;</span>)=<span class="number">709.</span> <span class="number">709</span>;</span><br><span class="line">map [<span class="string">&quot;string&quot;</span>) =<span class="string">&quot;How are you! &quot;</span>;</span><br><span class="line">map[<span class="string">&quot;color&quot;</span>)=<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">qDebug</span> () &lt;&lt;map [<span class="string">&quot;int&quot;</span>]&lt;&lt; map[<span class="string">&quot;int&quot;</span>] .<span class="built_in">toint</span>();</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;map[<span class="string">&quot;double&quot;</span>]&lt;&lt; map[<span class="string">&quot;double&quot;</span>].<span class="built_in">toDouble</span>();</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;map[<span class="string">&quot;string&quot;</span>J&lt;&lt; map[<span class="string">&quot;string&quot;</span>] .<span class="built_in">toString</span>();</span><br><span class="line"><span class="built_in">qDebug</span> () &lt;&lt;map [<span class="string">&quot;color&quot;</span>]&lt;&lt; map [<span class="string">&quot;color&quot;</span>]. <span class="built_in">value</span>&lt;QColor&gt; (); <span class="comment">//在 QVariant 变量中保存了一个 QColor 对象，并使用模板 QVariant: :value()还原为 QColor, 然后输出。</span></span><br><span class="line">QStringList sl; <span class="comment">//创建一个字符串列表</span></span><br><span class="line">sl&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;<span class="string">&quot;D&quot;</span>;</span><br><span class="line"><span class="function">QVariant <span class="title">slv</span><span class="params">(sl)</span></span>; <span class="comment">//将该列表保存在一个 QVariant 变量中</span></span><br><span class="line"><span class="keyword">if</span> (slv. <span class="built_in">type</span>() ==QVariant:: StringList) <span class="comment">//QVariant: :type() 函数返回存储在 QVariant 变量中的值的数据类型。 </span></span><br><span class="line">&#123;</span><br><span class="line">QStringLis 七 list=slv.<span class="built_in">toStringList</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=O;i&lt;list.<span class="built_in">size</span>() ;++i)</span><br><span class="line"><span class="built_in">qDebug</span> ()«list. <span class="built_in">at</span> (i); / /输出列表内容    </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法及正则表达式"><a href="#算法及正则表达式" class="headerlink" title="算法及正则表达式"></a>算法及正则表达式</h3><blockquote><p>常用的算法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a0</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">-19.3</span>, b=<span class="number">9.7</span>;</span><br><span class="line">    <span class="type">double</span> c =<span class="built_in">aAbs</span>(a);</span><br><span class="line">    <span class="type">double</span> max = <span class="built_in">aMax</span>(b, c);</span><br><span class="line">    <span class="type">int</span> bn = <span class="built_in">qRound</span>(b);</span><br><span class="line">    <span class="type">int</span> cn = <span class="built_in">qRound</span>(c);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;a= &quot;</span>&lt;&lt; a;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;b= &quot;</span>&lt;&lt; b;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;c = qAbs(a)= &quot;</span> &lt;&lt; c;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;c=qAbs(a)= &quot;</span>&lt;&lt;c;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;qMax(b,c)= &quot;</span>&lt;&lt;max;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;bn=qRound(b)= &quot;</span>&lt;&lt;bn;</span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;cn=qRound(c)= &quot;</span>&lt;&lt;en;</span><br><span class="line"><span class="built_in">qSwap</span> (bn, en); </span><br><span class="line">／／调用 <span class="built_in">qDebug</span> ()函数输出所有的计算结果</span><br><span class="line"><span class="built_in">qDebug</span> () &lt;&lt;<span class="string">&quot;qSwap (l?n, en) : &quot;</span>&lt;&lt;<span class="string">&quot;bn=&quot;</span>&lt;&lt;bn&lt;&lt;<span class="string">&quot; cn=&quot;</span>&lt;&lt;cn;</span><br><span class="line"><span class="keyword">return</span> aO. <span class="built_in">exec</span>() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>正则表达式</p></blockquote><p><strong>正则表达式由表达式、量词、断言组成。</strong></p><ol><li><p>最简单的表达式是一个字符。</p></li><li><p>量词说明表达式出现的次数。</p><table><thead><tr><th>量词</th><th>含义</th><th>量词</th><th>含义</th></tr></thead><tbody><tr><td>E?</td><td>匹配0次或1次</td><td>E[n,]</td><td>至少匹配n次</td></tr><tr><td>E+</td><td>匹配1次或多次</td><td>E[,m]</td><td>最多匹配m次</td></tr><tr><td>E*</td><td>匹配0次或多次</td><td>E[n,m]</td><td>至少匹配n次，最多匹配m次</td></tr><tr><td>E[n]</td><td>匹配n次</td><td></td><td></td></tr></tbody></table></li><li><p>“^””$””\b”都是正则表达式的断言，</p></li></ol><table><thead><tr><th align="center">符号</th><th align="center">含义</th><th align="center">符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">表示在字符串开头进行匹配</td><td align="center">\B</td><td align="center">非单词边界</td></tr><tr><td align="center">$$</td><td align="center">表示字符串结尾进行匹配</td><td align="center">(?&#x3D;E)</td><td align="center">表示表达式后跟随E才匹配</td></tr><tr><td align="center">\b</td><td align="center">单词边界</td><td align="center">(?!E)</td><td align="center">表示表达式后不跟随E才匹配</td></tr></tbody></table><p>例如，若要只有在 using 后面是 namespace 时才匹配 using, 则可以使用 “using(?&#x3D;E\s+namespace)” </p><h3 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h3><p>QWidget 是所有 Qt GUI 界面类的基类，它接收鼠标、键盘及其他窗口事件，并在显示器上绘制自己。通过传入 QWidget 构造函数的参数（或者调用 QWidget: :setWindowFlagsQ和 QWidget::setParentO 函数）可以指定一个窗口部件的窗口标识 (window flags) 和父窗口部件。 </p><p>窗口部件的窗口标识 (window flags) 定义了窗口部件的窗口类型和窗口提示 (hint) 。窗口类型指定了窗口部件的窗口系统属性 (window-system properties), 一个窗口部件只有一个窗口类型窗口提示定义了顶层窗口的外观，一个窗口可以有多个提示（提示能够进行按位或操作）。没有父窗口部件的 Widget 对象是一个窗口，窗口通常具有一个窗口边框 (frame) 和一个标题栏。 </p><p>QMainWindow 和所有的 QDialog 对话框子类都是经常使用的窗口类型，而子窗口部件通常处在父窗口部件的内部，没有窗口边框和标题栏。 </p><p>QWidget 窗口部件的构造函数为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QWidget(QWidget *parent=O,Qt::WindowFlags f=O)</span><br></pre></td></tr></table></figure><p>参数 parent 指定了窗口部件的父窗口部件，如果 parent&#x3D;O C 默认值），则新建的窗口部件将是一个窗口；否则，新建的窗口部件是 parent 的子窗口部件 。</p><p><strong>创建窗口</strong></p><p>如果 Widget 未使用父级进行创建，则在显示时视为窗口或顶层 Widget。由于顶层 Widget没有父级对象类来确保在其不再被使用时就被删除，所以需要开发人员在应用程序中对其进行跟踪。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QWidget *window= <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line">window-&gt;<span class="built_in">resize</span>(<span class="number">320</span>, <span class="number">240</span>);</span><br><span class="line">window-&gt;<span class="built_in">show</span>();</span><br><span class="line">QPushButton *button= <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="built_in">tr</span>(<span class="string">&quot;Press me&quot;</span>), window); <span class="comment">//通过将 window 作为父级传递给其构造器来向窗口添加子 Widget:button</span></span><br><span class="line">button-&gt;<span class="built_in">move</span> (<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">button-&gt;<span class="built_in">show</span> ();</span><br></pre></td></tr></table></figure><p>使用布局<br>通常，子 Widget 是通过使用布局对象在窗口中进行排列的，而不是通过指定位置和大小进行排列的。在此，构造一个并排排列的标签和行编辑框 Widget:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="built_in">tr</span>(<span class="string">&quot;Name:&quot;</span>));</span><br><span class="line">QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">QHBoxLayout * layout<span class="string">&quot;&quot;</span> <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span> (&#125;;</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span> (label);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span> (lineEdit);</span><br><span class="line">window-&gt;<span class="built_in">setLayout</span>(layout);</span><br></pre></td></tr></table></figure><p>构造的布局对象管理通过 addWidgetO函数提供 Widget 的位置和大小。布局本身是通过调用setLayout 函数提供给窗口的。布局仅可通过其对所管理的 Widget C 或其他布局）的显示效果来展示。 </p><h4 id="输入控件"><a href="#输入控件" class="headerlink" title="输入控件"></a>输入控件</h4><p>QCheckBox是一个选项按钮，可以打开（选中）或关闭（未选中）。复选框通常用于表示应用程序中可以启用或禁用而不影响其他功能的功能。可以实现不同类型的行为。提供了多选多的选择模式。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>setText(const QString &amp;text)</td><td>设置显示文本</td></tr><tr><td>setChecked(bool)</td><td>未开启三态模式设置选中状态，默认为未选中，true为选中</td></tr><tr><td>isChecked()</td><td>判断是否选中</td></tr><tr><td>setTristate(bool y &#x3D; true)</td><td>true为开启三态模式</td></tr><tr><td>setCheckState(Qt::CheckState state)</td><td>开启三态模式后设置选中状态</td></tr></tbody></table><p>Qt::CheckState类型</p><table><thead><tr><th>类型</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Qt::Unchecked</td><td>0</td><td>未选中</td></tr><tr><td>Qt::PartiallyChecked</td><td>1</td><td>半选中</td></tr><tr><td>Qt::Checked</td><td>2</td><td>选中</td></tr></tbody></table><p>常用信号</p><table><thead><tr><th>信号</th><th>描述</th></tr></thead><tbody><tr><td>stateChanged(int)</td><td>选中状态改变触发该信号</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发板Qt环境搭建</title>
      <link href="/2023/09/01/2023-9-1-%E5%BC%80%E5%8F%91%E6%9D%BFqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/09/01/2023-9-1-%E5%BC%80%E5%8F%91%E6%9D%BFqt%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="搭建Qt环境"><a href="#搭建Qt环境" class="headerlink" title="搭建Qt环境"></a>搭建Qt环境</h3><p>防止因为运行qt程序导致网络中断，从而通过NFS挂载的根文件系统断联，串口中断没有反应，运行慢等情况，所以使用mfgtool进行固化系统到开发板上在进行，搭建qt。</p><h3 id="烧录文件系统"><a href="#烧录文件系统" class="headerlink" title="烧录文件系统"></a>烧录文件系统</h3><p>烧录文件系统之前有过，但是并不全面，这回进行整个系统的固化。</p><p>首先编译u-boot，编译方法跟以前一样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mx6ull_alientek_emmc.sh</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20162850.png"></p><p>用到的文件是u-boot.imx。打开固化文件工具</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20163125.png"></p><p>进入文件夹中打开boot，将自己的uboot文件照着重命名后进行替换。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20163252.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20163303.png"></p><p>使用自构建的系统镜像和设备树文件进行重命名为以上的名字，来进行替换。</p><p>最后替换根文件系统，根文件系统不是替换文件，而是替换压缩包。</p><p>所以进行对根文件系统压缩。</p><p>首先我的压缩是在rootfs的外部使用的命令压缩，但是固化系统失败了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -vcjf rootfs.tar.bz2</span><br></pre></td></tr></table></figure><p>查询原因是应该变为内部打包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd rootfs</span><br><span class="line">tar -vcjf rootfs.tar.bz2 *</span><br></pre></td></tr></table></figure><p>这个*是打包所有文件包括了隐藏文件所以可能是这个问题。解决可以固化系统了。</p><p>之后打开串口软件观察，从内部emmc中进行启动。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20164227.png"></p><p>卡住了，这是因为这时的uboot是新的，一个白板，所以要进行设置命令给它，让其从emmc启动板子。分别设置bootcmd和bootargs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-14x14-emmc-4.3-800x480-c.dtb; bootz 80800000 - 83000000;&#x27;</span><br><span class="line">setenv bootargs &#x27;console = tty1 console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">saveenv</span><br><span class="line">boot</span><br></pre></td></tr></table></figure><p>ok 启动成功了。因为文件系统是之前写驱动的文件系统，所以可以设置bootargs来使用屏幕</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20164515.png"></p><p>烧录之后的新系统是不支持网络的，所以在uboot中ping通网络设置，添加网络相关环境变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv ipaddr 192.168.1.102</span><br><span class="line">setenv ethaddr 00:04:9f:04:d2:35</span><br><span class="line">setenv gatewap ip 192.168.1.1</span><br><span class="line">setenv netmask 255.255.255.0</span><br><span class="line">setenv serverip 192.168.1.128</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>搭建Qt运行环境</p><p>qt使用版本为5.12.9,此版本为长期支持版本，到qt网站进行下载,之后进行压缩包的解压。这个压缩包还是编译完挺大的有7个G，提前预留好地方，不然会提示空间不够，还要重新弄，只要在虚拟机外面设置空大硬盘空间，之后使用Gparted来进行分配多余的硬盘空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf qt-everywhere-src-5.12.9.tar.xz</span><br></pre></td></tr></table></figure><p>修改qmake.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf</span><br></pre></td></tr></table></figure><p>改完后为以下文本，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># qmake configuration for building with arm-linux-gnueabi-g++</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">MAKEFILE_GENERATOR = UNIX</span></span><br><span class="line">CONFIG += incremental</span><br><span class="line">QMAKE_INCREMENTAL_STYLE = sublib</span><br><span class="line">QT_QPA_DEFAULT_PLATFORM = linuxfb</span><br><span class="line">QMAKE_CFLAGS += -O2 -march=armv7-a -mtune=cortex-a7 -mfpu=neon -mfloat-abi=hard</span><br><span class="line">QMAKE_CXXFLAGS += -O2 -march=armv7-a -mtune=cortex-a7 -mfpu=neon -mfloat-abi=hard</span><br><span class="line">include(../common/linux.conf)</span><br><span class="line">include(../common/gcc-base-unix.conf)</span><br><span class="line">include(../common/g++-unix.conf)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modifications to g++.conf</span></span><br><span class="line">QMAKE_CC = arm-linux-gnueabihf-gcc</span><br><span class="line">QMAKE_CXX = arm-linux-gnueabihf-g++</span><br><span class="line">QMAKE_LINK = arm-linux-gnueabihf-g++</span><br><span class="line">QMAKE_LINK_SHLIB = arm-linux-gnueabihf-g++</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modifications to linux.conf</span></span><br><span class="line">QMAKE_AR = arm-linux-gnueabihf-ar cqs</span><br><span class="line">QMAKE_OBJCOPY = arm-linux-gnueabihf-objcopy</span><br><span class="line">QMAKE_NM = arm-linux-gnueabihf-nm -P</span><br><span class="line">QMAKE_STRIP = arm-linux-gnueabihf-strip</span><br><span class="line">load(qt_config)</span><br></pre></td></tr></table></figure><p><strong>配置编译选项</strong></p><p>可执行文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">./configure -prefix /home/moss/linux/qt-everywhere-src-5.12.9/arm-qt \</span><br><span class="line">-opensource \</span><br><span class="line">-confirm-license \</span><br><span class="line">-release \</span><br><span class="line">-strip \</span><br><span class="line">-shared \</span><br><span class="line">-xplatform linux-arm-gnueabi-g++ \</span><br><span class="line">-optimized-qmake \</span><br><span class="line">-c++std c++11 \</span><br><span class="line">--rpath=no \</span><br><span class="line">-pch \</span><br><span class="line">-skip qt3d \</span><br><span class="line">-skip qtactiveqt \</span><br><span class="line">-skip qtandroidextras \</span><br><span class="line">-skip qtcanvas3d \</span><br><span class="line">-skip qtconnectivity \</span><br><span class="line">-skip qtdatavis3d \</span><br><span class="line">-skip qtdoc \</span><br><span class="line">-skip qtgamepad \</span><br><span class="line">-skip qtlocation \</span><br><span class="line">-skip qtmacextras \</span><br><span class="line">-skip qtnetworkauth \</span><br><span class="line">-skip qtpurchasing \</span><br><span class="line">-skip qtremoteobjects \</span><br><span class="line">-skip qtscript \</span><br><span class="line">-skip qtscxml \</span><br><span class="line">-skip qtsensors \</span><br><span class="line">-skip qtspeech \</span><br><span class="line">-skip qtsvg \</span><br><span class="line">-skip qttools \</span><br><span class="line">-skip qttranslations \</span><br><span class="line">-skip qtwayland \</span><br><span class="line">-skip qtwebengine \</span><br><span class="line">-skip qtwebview \</span><br><span class="line">-skip qtwinextras \</span><br><span class="line">-skip qtx11extras \</span><br><span class="line">-skip qtxmlpatterns \</span><br><span class="line">-make libs \</span><br><span class="line">-make examples \</span><br><span class="line">-nomake tools -nomake tests \</span><br><span class="line">-gui \</span><br><span class="line">-widgets \</span><br><span class="line">-dbus-runtime \</span><br><span class="line">--glib=no \</span><br><span class="line">--iconv=no \</span><br><span class="line">--pcre=qt \</span><br><span class="line">--zlib=qt \</span><br><span class="line">-no-openssl \</span><br><span class="line">--freetype=qt \</span><br><span class="line">--harfbuzz=qt \</span><br><span class="line">-no-opengl \</span><br><span class="line">-linuxfb \</span><br><span class="line">--xcb=no \</span><br><span class="line">-tslib \</span><br><span class="line">--libpng=qt \</span><br><span class="line">--libjpeg=qt \</span><br><span class="line">--sqlite=qt \</span><br><span class="line">-plugin-sql-sqlite \</span><br><span class="line">-I/home/moss/linux/tool/tslib/include \</span><br><span class="line">-L/home/moss/linux/tool/tslib/lib \</span><br><span class="line">-recheck-all</span><br></pre></td></tr></table></figure><p>赋予脚本可执行权限。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x autoconfigure.sh</span><br></pre></td></tr></table></figure><p>直接执行 autoconfigure.sh。 配置需要一段时间，请耐心等待！配置前请先安装 g++</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++ </span><br><span class="line">./autoconfigure.sh</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-03%20170414.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 16</span><br></pre></td></tr></table></figure><p>编译，之后执行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="移植Qt到文件系统"><a href="#移植Qt到文件系统" class="headerlink" title="移植Qt到文件系统"></a>移植Qt到文件系统</h3><p>首先按照正常的步骤来将需要移植tslib的库，但是如果是开发过触摸屏驱动的话，可以发现你已经移植过了，经过测试用之前移植的tslib库以及编写的&#x2F;etc&#x2F;profile，是完全能够使用的。所以移植tslib库的步骤请参考触摸屏幕驱动后半部分。</p><p><strong>下载arm平台的qt源码</strong><a href="https://download.qt.io/archive/qt/5.12/5.12.9/single/">https://download.qt.io/archive/qt/5.12/5.12.9/single/</a></p><p>将qt的源码压缩包进行解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf qt-everywhere-src-5.12.9.tar.xz</span><br></pre></td></tr></table></figure><p>编辑 mkspecs&#x2F;qws&#x2F;linux-arm-gnueabi-g++&#x2F;qmake.conf， 配置相关编译器及路径。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># qmake configuration for building with arm-linux-gnueabi-g++</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">MAKEFILE_GENERATOR = UNIX</span></span><br><span class="line">CONFIG += incremental</span><br><span class="line">QMAKE_INCREMENTAL_STYLE = sublib</span><br><span class="line">QT_QPA_DEFAULT_PLATFORM = linuxfb</span><br><span class="line">QMAKE_CFLAGS += -O2 -march=armv7-a -mtune=cortex-a7 -mfpu=neon -mfloat-abi=hard</span><br><span class="line">QMAKE_CXXFLAGS += -O2 -march=armv7-a -mtune=cortex-a7 -mfpu=neon -mfloat-abi=hard</span><br><span class="line">include(../common/linux.conf)</span><br><span class="line">include(../common/gcc-base-unix.conf)</span><br><span class="line">include(../common/g++-unix.conf)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modifications to g++.conf</span></span><br><span class="line">QMAKE_CC = arm-linux-gnueabihf-gcc</span><br><span class="line">QMAKE_CXX = arm-linux-gnueabihf-g++</span><br><span class="line">QMAKE_LINK = arm-linux-gnueabihf-g++</span><br><span class="line">QMAKE_LINK_SHLIB = arm-linux-gnueabihf-g++</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modifications to linux.conf</span></span><br><span class="line">QMAKE_AR = arm-linux-gnueabihf-ar cqs</span><br><span class="line">QMAKE_OBJCOPY = arm-linux-gnueabihf-objcopy</span><br><span class="line">QMAKE_NM = arm-linux-gnueabihf-nm -P</span><br><span class="line">QMAKE_STRIP = arm-linux-gnueabihf-strip</span><br><span class="line">load(qt_config)</span><br></pre></td></tr></table></figure><p>进行配置编译选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/configure -prefix /home/moss/linux/qt-everywhere-src-5.12.9/arm-qt \</span><br><span class="line">-opensource \</span><br><span class="line">-confirm-license \</span><br><span class="line">-release \</span><br><span class="line">-strip \</span><br><span class="line">-shared \</span><br><span class="line">-xplatform linux-arm-gnueabi-g++ \</span><br><span class="line">-optimized-qmake \</span><br><span class="line">-c++std c++11 \</span><br><span class="line">--rpath=no \</span><br><span class="line">-pch \</span><br><span class="line">-skip qt3d \</span><br><span class="line">-skip qtactiveqt \</span><br><span class="line">-skip qtandroidextras \</span><br><span class="line">-skip qtcanvas3d \</span><br><span class="line">-skip qtconnectivity \</span><br><span class="line">-skip qtdatavis3d \</span><br><span class="line">-skip qtdoc \</span><br><span class="line">-skip qtgamepad \</span><br><span class="line">-skip qtlocation \</span><br><span class="line">-skip qtmacextras \</span><br><span class="line">-skip qtnetworkauth \</span><br><span class="line">-skip qtpurchasing \</span><br><span class="line">-skip qtremoteobjects \</span><br><span class="line">-skip qtscript \</span><br><span class="line">-skip qtscxml \</span><br><span class="line">-skip qtsensors \</span><br><span class="line">-skip qtspeech \</span><br><span class="line">-skip qtsvg \</span><br><span class="line">-skip qttools \</span><br><span class="line">-skip qttranslations \</span><br><span class="line">-skip qtwayland \</span><br><span class="line">-skip qtwebengine \</span><br><span class="line">-skip qtwebview \</span><br><span class="line">-skip qtwinextras \</span><br><span class="line">-skip qtx11extras \</span><br><span class="line">-skip qtxmlpatterns \</span><br><span class="line">-make libs \</span><br><span class="line">-make examples \</span><br><span class="line">-nomake tools -nomake tests \</span><br><span class="line">-gui \</span><br><span class="line">-widgets \</span><br><span class="line">-dbus-runtime \</span><br><span class="line">--glib=no \</span><br><span class="line">--iconv=no \</span><br><span class="line">--pcre=qt \</span><br><span class="line">--zlib=qt \</span><br><span class="line">-no-openssl \</span><br><span class="line">--freetype=qt \</span><br><span class="line">--harfbuzz=qt \</span><br><span class="line">-no-opengl \</span><br><span class="line">-linuxfb \</span><br><span class="line">--xcb=no \</span><br><span class="line">-tslib \</span><br><span class="line">--libpng=qt \</span><br><span class="line">--libjpeg=qt \</span><br><span class="line">--sqlite=qt \</span><br><span class="line">-plugin-sql-sqlite \</span><br><span class="line">-I/home/moss/linux/tool/tslib/include \</span><br><span class="line">-L/home/moss/linux/tool/tslib/lib \</span><br><span class="line">-recheck-all</span><br></pre></td></tr></table></figure><p>可以把上述配置变成可执行的脚本文件，之后赋予脚本可执行权限,后编译源码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod +x autoconfigure.sh</span><br><span class="line">sudo apt-get install g++ // 配置前请先安装 g++</span><br><span class="line">./autoconfigure.sh</span><br><span class="line">make -j16</span><br></pre></td></tr></table></figure><p>之后将arm-qt移动到&#x2F;usr&#x2F;lib的目录下。编译qt5的环境变量。编辑&#x2F;etc&#x2F;profile，在末尾添加以下内容。 如下图红色框内。 注意要改为个人实际的路径。要<br>想 Qt 程序显示中文，请自行将 windows 下的（路径 C:\Windows\Fonts） 下的中文字库放到新建一个&#x2F;usr&#x2F;share&#x2F;fonts&#x2F;目录下就可以了 。以下是&#x2F;etc&#x2F;profile的环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">export TERM=vt100</span><br><span class="line">export TERMINFO=/usr/share/terminfo</span><br><span class="line"></span><br><span class="line">export TSLIB_TSDEVICE=/dev/input/event2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">event2是我的触摸屏序号</span></span><br><span class="line">export TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line">export TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line">export TSLIB_PLUGINDIR=/lib/ts</span><br><span class="line">export TSLIB_CONSOLEDEVICE=none</span><br><span class="line">export TSLIB_FBDEVICE=/dev/fb0</span><br><span class="line"></span><br><span class="line">export QT_ROOT=/usr/lib/arm-qt</span><br><span class="line">export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event2</span><br><span class="line">export QT_QPA_FONTDIR=/usr/share/fonts</span><br><span class="line">export QT_QPA_PLATFORM_PLUGIN_PATH=$QT_ROOT/plugins</span><br><span class="line">export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0</span><br><span class="line">export QT_PLUGIN_PATH=$QT_ROOT/plugins</span><br><span class="line">export LD_LIBRARY_PATH=$QT_ROOT/lib:$QT_ROOT/plugins/platforms</span><br><span class="line">export QML2_IMPORT_PATH=$QT_ROOT/qml</span><br><span class="line">export QT_QPA_FB_TSLIB=1</span><br><span class="line"></span><br><span class="line">export ALSA_CONFIG_PATH=/usr/share/arm-alsa/alsa.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后使能环境变量，测试程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line">/usr/lib/arm-qt/examples/widgets/animation/animatedtiles/animatedtiles</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-04%20173550.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt信号和槽</title>
      <link href="/2023/08/30/2023-8-30-%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/"/>
      <url>/2023/08/30/2023-8-30-%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h3><p>信号和槽本质上是两个类在进行通信。<br>信号或是传递值，或者是传递动作变化，槽函数响应信号或是接受值，或者根据动作变化来做出对应操作。<br><strong>信号本质</strong><br>信号是由于用户对窗口或者控件做了操作，导致窗口或者控件产生了某个特定事件，这时候对应的窗口类会发出某个信号，以此对用户的挑选做出反应。<br>信号是qt对象中特殊的函数，本质上是一种函数指针，事件发生时调用，不是在信号所属的对象中直接执行。<br>信号的呈现形式就是函数，也就是说某个事件产生了，qt框架会调用某个对应的信号函数，通知使用者。<br><strong>槽的本质</strong><br>槽的职责是对qt框架中产生的信号进行处理。<br>槽是qt对象中普通成员函数，用于处理信号发生时的动作。一个槽可以连接一个或者多个信号，当信号触发时，与之连接的槽会被调用。</p><p><strong>信号和槽机制优点</strong></p><p>①类型安全：需要关联的信号和槽的签名必须是等同的。</p><p>②松散耦合：槽和信号不需要知道对方（信号不用知道是哪个槽接收的，槽不用知道哪些信号关联自己）</p><p><strong>连接</strong><br>连接是信号和槽之间的桥梁，它将一个信号与一个槽相关联。当信号发生时，连接会调用与之关联的槽。连接的建立通常通过函数实现。</p><p>信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</span><br></pre></td></tr></table></figure><p>connect() 是 QObject 类的一个静态函数，而 QObject 是所有 Qt 类的基类，在实际调用<br>时可以忽略前面的限定符，所以可以直接写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));</span><br></pre></td></tr></table></figure><p>其中， sender 是发射信号的对象的名称， signal() 是信号名称。信号可以看做是特殊的函数，需要带括号，有参数时还需要指明参数。 receiver 是接收信号的对象名称， slot() 是槽函数的名称，需要带括号，有参数时还需要指明参数。<br>SIGNAL 和 SLOT 是 Qt 的宏，用于指明信号和槽，并将它们的参数转换成为相应的字符串。<br>###创建一个UI项目<br><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20153047.png"><br><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20153805.png"><br>点击mainwindow.ui文件进入ui界面设计地步。<br><strong>ui界面英文含义</strong></p><table><thead><tr><th>Layouts</th><th>布局</th></tr></thead><tbody><tr><td>vertical Layouts</td><td>垂直布局</td></tr><tr><td>Horizontal Layouts</td><td>水平布局</td></tr><tr><td>gridLayouts</td><td>网格布局</td></tr><tr><td>formLayouts</td><td>表格布局</td></tr><tr><td>Horizontal spacer</td><td>水平部件</td></tr><tr><td>vertical   spacer</td><td>垂直部件</td></tr><tr><td>pushbutton</td><td>下压按钮</td></tr><tr><td>toolbutton</td><td>工具按钮</td></tr><tr><td>radiobutton</td><td>选择按钮</td></tr><tr><td>checkbutton</td><td>复选按钮</td></tr><tr><td>command check button</td><td>命令链接按钮</td></tr><tr><td>dialog button box</td><td>对话框按钮</td></tr><tr><td>listview</td><td>列表视图</td></tr><tr><td>treeview</td><td>树视图</td></tr><tr><td>tableview</td><td>表视图</td></tr><tr><td>columnview</td><td>列视图</td></tr><tr><td>undoview</td><td>撤销视图</td></tr><tr><td>widget</td><td>控件</td></tr><tr><td>显示hello world，把控件中的文本控件拽出，并打字hello world就可以编译运行了。</td><td></td></tr><tr><td>创建一个简单的UI按键项目</td><td></td></tr><tr><td>将控件push button 拿出，打字关闭程序，这时候就要将控件以及信号槽连接。</td><td></td></tr><tr><td><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20162155.png"></td><td></td></tr><tr><td><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-30%20162336.png"></td><td></td></tr><tr><td>选择按钮的 clicked()信号，将其连接 MainWindow 对象的 close()槽。这样就完成了信号与槽的连接。</td><td></td></tr><tr><td>在使用信号与槽的类中，必须在类的定义中加入宏 Q_OBJECT（特别重要）。</td><td></td></tr><tr><td>当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。</td><td></td></tr><tr><td>只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码。</td><td></td></tr><tr><td>总结如下图， 可以看到发送者与发送的信号是在一起的，接收者与接收的信号&#x2F;槽是在一起的。 它们不能在 connect()方法里写乱顺序！ 由发送者发送出信号到接收者用信号&#x2F;槽接收。</td><td></td></tr></tbody></table><p><strong>如何在项目中创建槽</strong><br>创建槽的方法也很简单， 也是直接在 mianwindow.h 里直接声明槽，在 mianwindow.cpp 里实现槽的定义， 声明槽必须写槽的定义(定义指函数体的实现)，否则编译器编译时将会报错。<br>槽有以下特点：</p><ol><li><p><strong>槽可以是任何成员函数、普通全局函数、静态函数</strong></p></li><li><p><strong>槽函数和信号的参数和返回值要一致</strong><br> mainwindow.h 添加槽函数后的代码</p></li></ol>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAINWINDOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="comment">/* 引入 QPushButton */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"><span class="comment">/* 声明一个信号，只需声明，无需定义 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButtonTextChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line"><span class="comment">/* 声明一个槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeButtonText</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明按钮点击的槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushButtonClicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">/* 声明一个对象 pushButton */</span></span><br><span class="line">QPushButton *pushButton;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><p>  在 mainwindow.cpp 里 实 现 声 明 的 槽 函 数 void changeButtonText(); 和 voidpushButtonClicked();。 同时还实例化了 pushButton 对象。代码如下。<br>  mainwindow.cpp 添加槽的实现代码</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent): <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置窗体的宽为 800,高为 480 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(<span class="number">800</span>,<span class="number">480</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化 pushButton 对象 */</span></span><br><span class="line">pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 setText()方法设定按钮的文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;我是一个按钮&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现按钮点击槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 使用 emit 发送信号 */</span></span><br><span class="line"><span class="function">emit <span class="title">pushButtonTextChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现按钮文本改变的槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::changeButtonText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 在槽函数里改变按钮的文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;被点击了！ &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>如何在项目中连接信号与槽</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">pushButtonClicked</span>()));</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">pushButtonTextChanged</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">changeButtonText</span>()));</span><br></pre></td></tr></table></figure><p>  注意，发送信号的对象，和接收的信号的对象。 因为我们 pushButtonClicked()是本类里定义的槽，所以用 this 来接收。同理， pushButtonTextChanged()也是本类定义的信号。所以发送者写成 this。 changeButtonText()也是本类的槽函数，所以接收槽的对象也是 this。</p><p>  在 mainwindow.cpp 中信号槽连接的代码如下。<br>  mainwindow.cpp 实现连接信号槽</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent): <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置窗体的宽为 800,高为 480 */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(<span class="number">800</span>,<span class="number">480</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化 pushButton 对象 */</span></span><br><span class="line">pushButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 setText()方法设定按钮的文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;我是一个按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 信号与槽连接 */</span></span><br><span class="line"><span class="built_in">connect</span>(pushButton, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">pushButtonClicked</span>()));</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">pushButtonTextChanged</span>()), <span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">changeButtonText</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现按钮点击槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::pushButtonClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 使用 emit 发送信号 */</span></span><br><span class="line"><span class="function">emit <span class="title">pushButtonTextChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现按钮文本改变的槽函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::changeButtonText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* 在槽函数里改变按钮的文本 */</span></span><br><span class="line">pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;被点击了！ &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++浅学</title>
      <link href="/2023/08/20/2023-8-20-c++%E6%B5%85%E5%AD%A6/"/>
      <url>/2023/08/20/2023-8-20-c++%E6%B5%85%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>浅学一下C++ ，为qt打基础写一个上位机软件来做毕设。</p><h3 id="C-编译器"><a href="#C-编译器" class="headerlink" title="C++编译器"></a>C++编译器</h3><p>C语言的编译器是gcc，但是C++的编译器是g++，可以通过命令行进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure><p>###hello world</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//iostream是输入和输出的库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//使用空间名词std</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;<span class="comment">//cout为</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;<span class="comment">//输出运算符&lt;&lt;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">std:: cout &lt;&lt; std:: endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cc -o hello</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>cin和cout都是std命名空间下的东西，std::cout和std::cin表示std命名空间下的cout和cin。</p><p>命名空间示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">namespace A</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A namespace&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">using namespace A</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fun();</span><br><span class="line">    A::x = <span class="number">3</span>;<span class="comment">//对命名空间的X进行复制</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A :: x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    A::fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类和对象</strong></p><p>从类中实例化对象分两种方法，一种是从栈中实例化对象，一种是从堆中实例化对象。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thing</span><span class="comment">//定义一个类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//访问限定符 public（公有的）， 此外还有 private（私有的） 和 protected（受保护的）</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;物品数量是&quot;</span>&lt;&lt; number &lt;&lt; <span class="string">&quot;物品名字是&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thing thing1;<span class="comment">//从栈中实例化一个对象</span></span><br><span class="line">    thing1.name = <span class="string">&quot;伞&quot;</span>;</span><br><span class="line">    thing1.number = <span class="number">1</span>;</span><br><span class="line">    thing1.<span class="built_in">print</span>();</span><br><span class="line">thing *thing2 = <span class="keyword">new</span> <span class="built_in">thing</span>();<span class="comment">//使用关键字 new 的都是从堆中实例化对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == thing2) &#123;<span class="comment">//判断指针指向开辟内存</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">thing2-&gt;name = <span class="string">&quot;桌子&quot;</span>;</span><br><span class="line">thing2-&gt;number = <span class="number">2</span>;</span><br><span class="line"> thing2-&gt;<span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">delete</span> thing2;</span><br><span class="line">thing2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造函数和析构函数</strong></p><p>构造函数的特点如下：<br>（1） 构造函数必须与类名同名；<br>（2） 可以重载，（重载？新概念，后面学到什么是重载。）；<br>（3） 没有返回类型，即使是 void 也不行。<br>什么是析构函数？与构造函数相反， 在对象结束其生命周期时系统自动执行析构函数。 实<br>际上定义类时，编译器会生成一个析构函数。<br>析构函数的特点如下：<br>（1） 析构函数的格式为~类名()；<br>（2） 调用时释放内存（资源）；<br>（3） ~类名()不能加参数；<br>（4） 没有返回值，即使是 void 也不行。 </p><blockquote><ol><li>构造函数在实例化对象时自动被调用，且在每个对象的生命期仅被调用一次。</li><li>可以被重载。</li><li>若程序员没有主动给类定义构造函数，编译器自动给一个缺省的构造函数。</li><li>一旦程序员定义了一个构造函数，系统将不会再给出缺省构造函数。</li><li>除了系统缺省的构造函数外，只要构造函数无参或者参数有缺省值， 编译器会认为它就是缺省构造函数。缺省的构造函数同时只能有1个。</li></ol></blockquote><p>缺省构造函数：即无参或参数有缺省值。仅仅是为了构造对象，一种是构造函数不含形参，另一种是构造函数含有形参，并且形参被赋有默认值。</p><p><strong>this指针</strong></p><p>每个对象都拥有一个 this 指针， this 指针记录对象的内存地址。<br>在 C++中， this 指针是指向类自身数据的指针， 简单的来说就是指向当前类的当前实例对象。关于类的 this 指针有以下特点：<br>（1） <strong>this 只能在成员函数中使用， 全局函数、静态函数都不能使用 this。 实际上，成员函数默认第一个参数为 T * const this。</strong> 也就是一个类里面的成员了函数 int func(int p)， func 的原型在编译器看来应该是 int func(T * const this,int p)。<br>（2） this 在成员函数的开始前构造，在成员函数的结束后清除。<br>（3） this 指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。 </p><p><strong>继承</strong></p><p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 </p><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>-<span class="keyword">class</span>: access-specifier base-<span class="keyword">class</span></span><br></pre></td></tr></table></figure><p>与类的访问修饰限定符一样，继承的方式也有几种。 其中，访问修饰符 access-specifier 是public、 protected 或 private 其中的一个， base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 </p><ol><li>公有继承（public）：当一个类派生继承公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li><li>保护继承（protected）： 当一个类派生继承保护基类时，基类的公有和保护成员将成为派生类的保护成员。</li><li>私有继承（private）：当一个类派生继承私有基类时，基类的公有和保护成员将成为派生类的私有成员。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*动物类，抽象出下面两种属性，</span></span><br><span class="line"><span class="comment">*颜色和体重，是每种动物都具有的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line"><span class="comment">/* 颜色成员变量 */</span></span><br><span class="line"><span class="built_in">string</span> color;</span><br><span class="line"><span class="comment">/* 体重成员变量 */</span></span><br><span class="line"><span class="type">int</span> weight;原子哥在线教学:www.yuanzige.com 论坛:www.openedv.com</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*让狗类继承这个动物类，并在狗类里写自己的属性。</span></span><br><span class="line"><span class="comment">*狗类拥有自己的属性 name， age， run()方法，同时也继承了</span></span><br><span class="line"><span class="comment">*动物类的 color 和 weight 的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Dog dog;</span><br><span class="line">dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">dog.age = <span class="number">2</span>;</span><br><span class="line">dog.color = <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line">dog.weight = <span class="number">120</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;狗的名字叫： &quot;</span>&lt;&lt;dog.name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;狗的年龄是： &quot;</span>&lt;&lt;dog.age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;狗的毛发颜色是： &quot;</span>&lt;&lt;dog.color&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;狗的体重是： &quot;</span>&lt;&lt;dog.weight&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重载</strong><br>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为<strong>函数重载和运算符重载。</strong><br>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。<br>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="number">3</span> using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line"><span class="class">6 &#123;</span></span><br><span class="line"><span class="number">7</span> public:</span><br><span class="line"><span class="number">8</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="number">9</span> <span class="type">void</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> weight)</span> &#123;</span><br><span class="line"><span class="number">10</span> <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;的体重是： &quot;</span>&lt;&lt;weight&lt;&lt;<span class="string">&quot;kG&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">double</span> weight)</span> &#123;</span><br><span class="line"><span class="number">14</span> <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;的体重是： &quot;</span>&lt;&lt;weight&lt;&lt;<span class="string">&quot;kG&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> &#125;;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">19 &#123;</span><br><span class="line"><span class="number">20</span> Dog dog;</span><br><span class="line"><span class="number">21</span> dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line"><span class="number">22</span> dog.getWeight(<span class="number">10</span>);</span><br><span class="line"><span class="number">23</span> dog.getWeight(<span class="number">10.5</span>);</span><br><span class="line"><span class="number">24</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">25</span> &#125;</span><br></pre></td></tr></table></figure><p>程序中getWeight两个同名函数拥有不同的参数类型，这就是函数重载。</p><p>运算符重载的实质就是函数重载或函数多态。运算符重载是一种形式的 C++多态。目的在于让人能够用同名的函数来完成不同的基本操作要重载运算符，需要使用被称为运算符函数的特殊函数形式，运算符函数形式： operatorp（argument-list）， operator 后面的’p’为要重载的运<br>算符符号。 重载运算符的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回类型说明符&gt; <span class="keyword">operator</span> &lt;运算符符号&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">&lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多态</strong><br>C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数；<br>形成多态必须具备三个条件：</p><ol><li>必须存在继承关系；</li><li>继承关系必须有同名虚函数（其中虚函数是在基类中使用关键字 virtual 声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数）；</li><li>存在基类类型的指针或者引用，通过该指针或引用调用虚函数</li></ol><p><strong>虚函数：</strong><br>是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，<br>会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 虚函数声明如下： virtualReturnType FunctionName(Parameter) 虚函数必须实现，如果不实现，编译器将报错<br>纯虚函数：<br>若在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 纯虚函数声明如下：<br>virtual void funtion1()&#x3D;0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。<br>包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。 </p><p><strong>数据封装</strong><br>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。<br>数据封装是一种把数据和操作数据的函数捆绑在一起的机制， 数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制， C++ 通过创建类来支持封装和数据隐藏（public、protected、 private）。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础知识</title>
      <link href="/2023/08/19/2023-8-18-tcpip%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/19/2023-8-18-tcpip%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>开一个新的篇章，同时进行学习，只学习一种知识点太枯燥了，有点难啃。并且看到有的招聘网站上需要tcp&#x2F;ip协议的科技树，所以学习一下。</p><p><u>参考书为《图解TCP_IP》</u></p><p>计算机网络根据规模分为 了WAN（广域网）和LAN（局域网）。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20211031.png"></p><p>TCP&#x2F;IP协议是IP、TCP、HTTP等协议的集合。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20212831.png"></p><p>在计算机通信中，事先达成一个详细的约定，并且遵守这一约定进行处理尤为重要，这种约定就是“协议”。</p><p>分组交换是将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。计算机通信会在每一个分组附加上源主机地址和目标主机地址给通信线路。**<u>这些发送端地址、接收端地址以及分组序号写入的部分称为”报文首部“</u>**</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-17%20214246.png"></p><p>一个较大的数据被分为多个分组时，为了表明是原始数据的哪一部分，就有必要将分组的序号写入包中。接收端会根据这个序号，再将每个分组按照序号重新分配。</p><p>通信协议中通常会规定报文首部应该写入哪些信息、如何处理。</p><p>OSI参考模型将通信功能分为7个分层，称作OSI参考模型。OSI协议以OSI参考模型为基础界定了每个阶层的协议和每个阶层之间的接口标准。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20110837.png"></p><p>物理层中，将数据0、1转换为电压和脉冲光传输给物理的传输介质，而相互直连的设备之间使用地址实现传输。这种地址称为MAC地址（物理地址或者硬件地址）。</p><p><strong>应用层</strong></p><p>为应用层序提供服务并规定应用程序中通信相关的细节，包括文件传输、电子邮件、远程登录等协议。</p><p><strong>表示层</strong></p><p>将应用处理的信息转换为适合网络传输的格式，或来自下一层的数据转换为上层能处理的格式。</p><p><strong>会话层</strong></p><p>负责建立和断开通信连接，以及数据的分割等数据传输相关的管理。</p><p><strong>传输层</strong>（4~7层交换机处理传输层以上网络传输）</p><p>起着可靠传输的作用，只在通信双方节点上处理无需路由器上处理。</p><p><strong>网络层</strong>（路由器&#x2F;3层交换机）</p><p>将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。</p><p><strong>数据链路层</strong>（网桥&#x2F;2层交换机）</p><p>负责将物理层面上互连的、节点之间的通信传输。例如一个以太网相连的2个节点之间的通信。</p><p><strong>物理层</strong>（中继器物理层上延长设备）</p><p>负责0、1比特流与电压高低、光亮灭之间的转换。</p><p><strong>网络层与数据链接层都是基于目标地址将数据发送给接收端，但是网络层负责将整个数据发送给最终目标地址，而数据链接层则只负责发送一个分段内的数据。</strong></p><hr><p><u>7层之间通信</u>：每个分层上，在处理由上一层传过来的数据时可以附加上当前封层协议所必须的<strong>首部信息</strong>，然后接收端对收到的数据进行数据首部与内容的分离，再转发给上一层，并最终将发送端的数据恢复为原状。<img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20201355.png"></p><p>地址具有唯一性和层次性。一个地址必须明确表示也给主体对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIO驱动</title>
      <link href="/2023/08/17/2023-8-17-IIO%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/08/17/2023-8-17-IIO%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="IIO介绍"><a href="#IIO介绍" class="headerlink" title="IIO介绍"></a>IIO介绍</h3><p>IIO 全称是 Industrial I&#x2F;O，翻译过来就是工业 I&#x2F;O，大家不要看到“工业”两个字就觉得 IIO是只用于工业领域的。大家一般在搜索 IIO 子系统的时候，会发现大多数讲的都是 ADC，这是因为 IIO 就是为 ADC 类传感器准备的，当然了 DAC 也是可以的。</p><p>1、 iio_dev 结构体<br>IIO 子系统使用结构体 iio_dev 来描述一个具体 IIO 设备，此设备结构体定义在include&#x2F;linux&#x2F;iio&#x2F;iio.h 文件中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">474</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> &#123;</span></span><br><span class="line"><span class="number">475</span> <span class="type">int</span> id;</span><br><span class="line"><span class="number">476</span></span><br><span class="line"><span class="number">477</span> <span class="type">int</span> modes;<span class="comment">//为设备支持模式</span></span><br><span class="line">    <span class="comment">/*INDIO_DIRECT_MODE 提供 sysfs 接口。</span></span><br><span class="line"><span class="comment">INDIO_BUFFER_TRIGGERED 支持硬件缓冲触发。</span></span><br><span class="line"><span class="comment">INDIO_BUFFER_SOFTWARE 支持软件缓冲触发。</span></span><br><span class="line"><span class="comment">INDIO_BUFFER_HARDWARE 支持硬件缓冲区。*/</span></span><br><span class="line"><span class="number">478</span> <span class="type">int</span> currentmode;<span class="comment">//currentmode 为当前模式。</span></span><br><span class="line"><span class="number">479</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"><span class="number">480</span></span><br><span class="line"><span class="number">481</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_event_interface</span> *<span class="title">event_interface</span>;</span></span><br><span class="line"><span class="number">482</span></span><br><span class="line"><span class="number">483</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer</span> *<span class="title">buffer</span>;</span><span class="comment">//缓冲区</span></span><br><span class="line"><span class="number">484</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffer_list</span>;</span><span class="comment">//buffer_list 为当前匹配的缓冲区列表。</span></span><br><span class="line"><span class="number">485</span> <span class="type">int</span> scan_bytes;<span class="comment">//scan_bytes 为捕获到，并且提供给缓冲区的字节数</span></span><br><span class="line"><span class="number">486</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mlock</span>;</span><span class="comment">//available_scan_masks 为可选的扫描位掩码，使用触发缓冲区的时候可以通过设</span></span><br><span class="line"><span class="number">487</span><span class="comment">//置掩码来确定使能哪些通道，使能以后的通道会将捕获到的数据发送到 IIO 缓冲区。</span></span><br><span class="line"><span class="number">488</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *available_scan_masks;</span><br><span class="line"><span class="number">489</span> <span class="type">unsigned</span> masklength;</span><br><span class="line"><span class="number">490</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *active_scan_mask;<span class="comment">//active_scan_mask 为缓冲区已经开启的通道掩码。只有这些使能了的通道数据才能被发送到缓冲区</span></span><br><span class="line"><span class="number">491</span> <span class="type">bool</span> scan_timestamp; <span class="comment">//scan_timestamp 为扫描时间戳，如果使能以后会将捕获时间戳放到缓冲区里面。</span></span><br><span class="line"><span class="number">492</span> <span class="type">unsigned</span> scan_index_timestamp;</span><br><span class="line"><span class="number">493</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger</span> *<span class="title">trig</span>;</span><span class="comment">//触发器</span></span><br><span class="line"><span class="number">494</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_poll_func</span> *<span class="title">pollfunc</span>;</span><span class="comment">//pollfunc 为一个函数，在接收到的触发器上运行</span></span><br><span class="line"><span class="number">495</span></span><br><span class="line"><span class="number">496</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">const</span> *<span class="title">channels</span>;</span><span class="comment">// IIO 设备通道</span></span><br><span class="line"><span class="number">497</span> <span class="type">int</span> num_channels;<span class="comment">//num_channels 为 IIO 设备的通道数</span></span><br><span class="line"><span class="number">498</span></span><br><span class="line"><span class="number">499</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">channel_attr_list</span>;</span></span><br><span class="line"><span class="number">500</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">chan_attr_group</span>;</span></span><br><span class="line"><span class="number">501</span> <span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//name 为 IIO 设备名字</span></span><br><span class="line"><span class="number">502</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span> *<span class="title">info</span>;</span></span><br><span class="line"><span class="number">503</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">info_exist_lock</span>;</span></span><br><span class="line"><span class="number">504</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_setup_ops</span> *<span class="title">setup_ops</span>;</span></span><br><span class="line"><span class="number">505</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">chrdev</span>;</span><span class="comment">// chrdev 为字符设备，由 IIO 内核创建</span></span><br><span class="line">......</span><br><span class="line"><span class="number">515</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="操作集合iio-buffer-setup-ops"><a href="#操作集合iio-buffer-setup-ops" class="headerlink" title="操作集合iio_buffer_setup_ops"></a>操作集合iio_buffer_setup_ops</h4><p>第 504 行， 为 iio_buffer_setup_ops 结构体类型，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">427</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_setup_ops</span> &#123;</span></span><br><span class="line"><span class="number">428</span> <span class="type">int</span> (*preenable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区使能之前调用 */</span></span><br><span class="line"><span class="number">429</span> <span class="type">int</span> (*postenable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区使能之后调用 */</span></span><br><span class="line"><span class="number">430</span> <span class="type">int</span> (*predisable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区禁用之前调用 */</span></span><br><span class="line"><span class="number">431</span> <span class="type">int</span> (*postdisable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区禁用之后调用 */</span></span><br><span class="line"><span class="number">432</span> <span class="type">bool</span> (*validate_scan_mask)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line"><span class="number">433</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *scan_mask); <span class="comment">/* 检查扫描掩码是否有效 */</span></span><br><span class="line"><span class="number">434</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="iio-dev-申请与释放"><a href="#iio-dev-申请与释放" class="headerlink" title="iio_dev 申请与释放"></a>iio_dev 申请与释放</h4><p>在使用之前要先申请 iio_dev，申请函数为 iio_device_alloc，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> iio_dev *<span class="title function_">iio_device_alloc</span><span class="params">(<span class="type">int</span> sizeof_priv)</span></span><br></pre></td></tr></table></figure><p>sizeof_priv： 私有数据内存空间大小，一般我们会将自己定义的设备结构体变量作为 iio_dev的私有数据，这样可以直接通过 iio_device_alloc 函数同时完成 iio_dev 和设备结构体变量的内存申请。 申请成功以后使用 iio_priv 函数来得到自定义的设备结构体变量首地址。<br>返回值：如果申请成功就返回 iio_dev 首地址，如果失败就返回 NULL。<br>一般 iio_device_alloc 和 iio_priv 之间的配合使用如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span>;</span><span class="comment">// icm20608_dev 是自定义的设备结构体。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> *<span class="title">indio_dev</span>;</span><span class="comment">// indio_dev 是 iio_dev 结构体变量指针。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1、申请 iio_dev 内存 */</span></span><br><span class="line">indio_dev = iio_device_alloc(<span class="keyword">sizeof</span>(*dev));<span class="comment">//使用 iio_device_alloc 函数来申请 iio_dev，并且一起申请了icm2060_dev 的内存。</span></span><br><span class="line"><span class="keyword">if</span> (!indio_dev)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、获取设备结构体变量地址 */</span>c</span><br><span class="line">dev = iio_priv(indio_dev);<span class="comment">//使用 iio_priv 函数从 iio_dev 中提取出私有数据，也就是 icm2608_dev 这个自定义结构体变量首地址。</span></span><br></pre></td></tr></table></figure><p>如果要释放 iio_dev，需要使用 iio_device_free 函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iio_device_free</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev)</span><span class="comment">//indio_dev： 需要释放的 iio_dev。</span></span><br></pre></td></tr></table></figure><h4 id="iio-dev-注册与注销"><a href="#iio-dev-注册与注销" class="headerlink" title="iio_dev 注册与注销"></a>iio_dev 注册与注销</h4><p>前面分配好 iio_dev 以后就要初始化各种成员变量，初始化完成以后就需要将 iio_dev 注册到内核中，需要用到 iio_device_register 函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">iio_device_register</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev)</span><span class="comment">//indio_dev： 需要注册的 iio_dev。</span></span><br></pre></td></tr></table></figure><p>返回值： 0，成功；其他值，失败。<br>如果要注销 iio_dev 使用 iio_device_unregister 函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iio_device_unregister</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev)</span><span class="comment">//indio_dev： 需要注销的 iio_dev。</span></span><br></pre></td></tr></table></figure><p>返回值： 0，成功；其他值，失败</p><h4 id="iio-info"><a href="#iio-info" class="headerlink" title="iio_info"></a>iio_info</h4><p>iio_dev 有个成员变量： info，为 iio_info 结构体指针变量，这个是我们在编写 IIO 驱动的时候需要着重去实现的，因为用户空间对设备的具体操作最终都会反映到 iio_info 里面。 iio_info结构体定义在 include&#x2F;linux&#x2F;iio&#x2F;iio.h 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">352</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span> &#123;</span></span><br><span class="line"><span class="number">353</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">driver_module</span>;</span></span><br><span class="line"><span class="number">354</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> *<span class="title">event_attrs</span>;</span></span><br><span class="line"><span class="number">355</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> *<span class="title">attrs</span>;</span><span class="comment">//attrs 是通用的设备属性。</span></span><br><span class="line"><span class="number">356</span></span><br><span class="line"><span class="number">357</span> <span class="type">int</span> (*read_raw)(<span class="keyword">struct</span> iio_dev *indio_dev, <span class="comment">//读设备内部数据函数 indio_dev为读写设备</span></span><br><span class="line"><span class="number">358</span> <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,<span class="comment">//需要读取的通道</span></span><br><span class="line"><span class="number">359</span> <span class="type">int</span> *val,<span class="comment">// 是数据值，val 是整数部分， val2 是小数部分</span></span><br><span class="line"><span class="number">360</span> <span class="type">int</span> *val2,</span><br><span class="line"><span class="number">361</span> <span class="type">long</span> mask); <span class="comment">//掩码</span></span><br><span class="line">......</span><br><span class="line"><span class="number">369</span></span><br><span class="line"><span class="number">370</span> <span class="type">int</span> (*write_raw)(<span class="keyword">struct</span> iio_dev *indio_dev,<span class="comment">//写设备内部数据函数</span></span><br><span class="line"><span class="number">371</span> <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span><br><span class="line"><span class="number">372</span> <span class="type">int</span> val,<span class="comment">//应用程序从内核空间读取到数据</span></span><br><span class="line"><span class="number">373</span> <span class="type">int</span> val2,</span><br><span class="line"><span class="number">374</span> <span class="type">long</span> mask);</span><br><span class="line"><span class="number">375</span></span><br><span class="line"><span class="number">376</span> <span class="type">int</span> (*write_raw_get_fmt)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line"><span class="number">377</span> <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span><br><span class="line"><span class="number">378</span> <span class="type">long</span> mask);</span><br><span class="line">......</span><br><span class="line"><span class="number">415</span> &#125;;</span><br></pre></td></tr></table></figure><p>Linux 内核使用 iio_chan_spec 结构体来描述通道，定义在 include&#x2F;linux&#x2F;iio&#x2F;iio.h 文件中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">223</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> &#123;</span></span><br><span class="line"><span class="number">224</span> <span class="class"><span class="keyword">enum</span> <span class="title">iio_chan_type</span> <span class="title">type</span>;</span></span><br><span class="line"><span class="number">225</span> <span class="type">int</span> channel;</span><br><span class="line"><span class="number">226</span> <span class="type">int</span> channel2;</span><br><span class="line"><span class="number">227</span> <span class="type">unsigned</span> <span class="type">long</span> address;</span><br><span class="line"><span class="number">228</span> <span class="type">int</span> scan_index;</span><br><span class="line"><span class="number">229</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="number">230</span> <span class="type">char</span> sign;</span><br><span class="line"><span class="number">231</span> u8 realbits;</span><br><span class="line"><span class="number">232</span> u8 storagebits;</span><br><span class="line"><span class="number">233</span> u8 shift;</span><br><span class="line"><span class="number">234</span> u8 repeat;</span><br><span class="line"><span class="number">235</span> <span class="class"><span class="keyword">enum</span> <span class="title">iio_endian</span> <span class="title">endianness</span>;</span></span><br><span class="line"><span class="number">236</span> &#125; scan_type;</span><br><span class="line"><span class="number">237</span> <span class="type">long</span> info_mask_separate;</span><br><span class="line"><span class="number">238</span> <span class="type">long</span> info_mask_shared_by_type;<span class="comment">// info_mask_shared_by_type 标记导出的信息由相同类型的通道共享。</span></span><br><span class="line"><span class="number">239</span> <span class="type">long</span> info_mask_shared_by_dir;<span class="comment">//info_mask_shared_by_dir 标记某些导出的信息由相同方向的通道共享。</span></span><br><span class="line"><span class="number">240</span> <span class="type">long</span> info_mask_shared_by_all;</span><br><span class="line"><span class="number">241</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_event_spec</span> *<span class="title">event_spec</span>;</span></span><br><span class="line"><span class="number">242</span> <span class="type">unsigned</span> <span class="type">int</span> num_event_specs;</span><br><span class="line"><span class="number">243</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec_ext_info</span> *<span class="title">ext_info</span>;</span></span><br><span class="line"><span class="number">244</span> <span class="type">const</span> <span class="type">char</span> *extend_name;</span><br><span class="line"><span class="number">245</span> <span class="type">const</span> <span class="type">char</span> *datasheet_name;</span><br><span class="line"><span class="number">246</span> <span class="type">unsigned</span> modified:<span class="number">1</span>;<span class="comment">//modified 为 1 的时候， channel2 为通道修饰符。</span></span><br><span class="line"><span class="number">247</span> <span class="type">unsigned</span> indexed:<span class="number">1</span>;<span class="comment">//indexed 为 1 的时候， channel 为通道索引。</span></span><br><span class="line"><span class="number">248</span> <span class="type">unsigned</span> output:<span class="number">1</span>;<span class="comment">//</span></span><br><span class="line"><span class="number">249</span> <span class="type">unsigned</span> differential:<span class="number">1</span>;<span class="comment">//differential为差分通道</span></span><br><span class="line"><span class="number">250</span> &#125;;</span><br></pre></td></tr></table></figure><p>来看一下 iio_chan_spec 结构体中一些比较重要的成员变量：<br>第 224 行， type 为通道类型， iio_chan_type 是一个枚举类型，列举出了可以选择的通道类型，定义在 include&#x2F;uapi&#x2F;linux&#x2F;iio&#x2F;types.h 文件里面，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span> <span class="class"><span class="keyword">enum</span> <span class="title">iio_chan_type</span> &#123;</span></span><br><span class="line"><span class="number">14</span> IIO_VOLTAGE, <span class="comment">/* 电压类型 */</span></span><br><span class="line"><span class="number">15</span> IIO_CURRENT, <span class="comment">/* 电流类型 */</span></span><br><span class="line"><span class="number">16</span> IIO_POWER, <span class="comment">/* 功率类型 */</span></span><br><span class="line"><span class="number">17</span> IIO_ACCEL, <span class="comment">/* 加速度类型 */</span></span><br><span class="line"><span class="number">18</span> IIO_ANGL_VEL, <span class="comment">/* 角度类型(陀螺仪) */</span></span><br><span class="line"><span class="number">19</span> IIO_MAGN, <span class="comment">/* 电磁类型(磁力计) */</span></span><br><span class="line"><span class="number">20</span> IIO_LIGHT, <span class="comment">/* 灯光类型 */</span></span><br><span class="line"><span class="number">21</span> IIO_INTENSITY, <span class="comment">/* 强度类型(光强传感器) */</span></span><br><span class="line"><span class="number">22</span> IIO_PROXIMITY, <span class="comment">/* 接近类型(接近传感器) */</span></span><br><span class="line"><span class="number">23</span> IIO_TEMP, <span class="comment">/* 温度类型 */</span></span><br><span class="line"><span class="number">24</span> IIO_INCLI, <span class="comment">/* 倾角类型(倾角测量传感器) */</span></span><br><span class="line"><span class="number">25</span> IIO_ROT, <span class="comment">/* 旋转角度类型 */</span></span><br><span class="line"><span class="number">26</span> IIO_ANGL, <span class="comment">/* 转动角度类型(电机旋转角度测量传感器) */</span></span><br><span class="line"><span class="number">27</span> IIO_TIMESTAMP, <span class="comment">/* 时间戳类型 */</span></span><br><span class="line"><span class="number">28</span> IIO_CAPACITANCE, <span class="comment">/* 电容类型 */</span></span><br><span class="line"><span class="number">29</span> IIO_ALTVOLTAGE, <span class="comment">/* 频率类型 */</span></span><br><span class="line"><span class="number">30</span> IIO_CCT, <span class="comment">/* 笔者暂时未知的类型 */</span></span><br><span class="line"><span class="number">31</span> IIO_PRESSURE, <span class="comment">/* 压力类型 */</span></span><br><span class="line"><span class="number">32</span> IIO_HUMIDITYRELATIVE, <span class="comment">/* 湿度类型 */</span></span><br><span class="line"><span class="number">33</span> IIO_ACTIVITY, <span class="comment">/* 活动类型(计步传感器) */</span></span><br><span class="line"><span class="number">34</span> IIO_STEPS, <span class="comment">/* 步数类型 */</span></span><br><span class="line"><span class="number">35</span> IIO_ENERGY, <span class="comment">/* 能量类型(卡路里) */</span></span><br><span class="line"><span class="number">36</span> IIO_DISTANCE, <span class="comment">/* 距离类型 */</span></span><br><span class="line"><span class="number">37</span> IIO_VELOCITY, <span class="comment">/* 速度类型 */</span></span><br><span class="line"><span class="number">38</span> &#125;;</span><br></pre></td></tr></table></figure><p>目前 Linux 内核支持的传感器类型非常丰富，而且支持类型也会不断的增加。如果是 ADC，那就是 IIO_VOLTAGE 类型。如果是 ICM20608 这样的多轴传感器，那么就是复合类型了，陀螺仪部分是 IIO_ANGL_VEL 类型，加速度计部分是IIO_ACCEL 类型，温度部分是IIO_TEMP。</p><h3 id="设备驱动框架"><a href="#设备驱动框架" class="headerlink" title="设备驱动框架"></a>设备驱动框架</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 自定义设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span>;</span> <span class="comment">/* spi 设备 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *<span class="title">regmap</span>;</span> <span class="comment">/* regmap */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap_config</span> <span class="title">regmap_config</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通道数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">xxx_channels</span>[] =</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 读函数，当读取 sysfs 中的文件的时候最终此函数会执行，</span></span><br><span class="line"><span class="comment">* ：此函数里面会从传感器里面读取各种数据，然后上传给应用。</span></span><br><span class="line"><span class="comment">* @param - indio_dev : IIO 设备</span></span><br><span class="line"><span class="comment">* @param - chan : 通道</span></span><br><span class="line"><span class="comment">* @param - val : 读取的值，如果是小数值的话， val 是整数部分。</span></span><br><span class="line"><span class="comment">* @param - val2 : 读取的值，如果是小数值的话， val2 是小数部分。</span></span><br><span class="line"><span class="comment">* @param - mask : 掩码。</span></span><br><span class="line"><span class="comment">* @return : 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_read_raw</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev,<span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,<span class="type">int</span> *val, <span class="type">int</span> *val2, </span></span><br><span class="line"><span class="params">                        <span class="type">long</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 写函数，当向 sysfs 中的文件写数据的时候最终此函数</span></span><br><span class="line"><span class="comment">* ：会执行，一般在此函数里面设置传感器，比如量程等。</span></span><br><span class="line"><span class="comment">* @param - indio_dev : IIO 设备</span></span><br><span class="line"><span class="comment">* @param - chan : 通道</span></span><br><span class="line"><span class="comment">* @param - val : 应用程序写入值，如果是小数的话， val 是整数部分。</span></span><br><span class="line"><span class="comment">* @param - val2 : 应用程序写入值，如果是小数的话， val2 是小数部分。</span></span><br><span class="line"><span class="comment">* @return : 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_write_raw</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span></span><br><span class="line"><span class="params"><span class="type">int</span> val, <span class="type">int</span> val2, <span class="type">long</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : 用户空间写数据格式，比如我们在用户空间操作 sysfs 来设</span></span><br><span class="line"><span class="comment">* ：置传感器的分辨率，如果分辨率带小数，那么这个小数传递到</span></span><br><span class="line"><span class="comment">* : 内核空间应该扩大多少倍，此函数就是用来设置这个的。</span></span><br><span class="line"><span class="comment">* @param - indio_dev : iio_dev</span></span><br><span class="line"><span class="comment">* @param - chan : 通道</span></span><br><span class="line"><span class="comment">* @param - mask : 掩码</span></span><br><span class="line"><span class="comment">* @return : 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_write_raw_get_fmt</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan, <span class="type">long</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* iio_info 结构体变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span> <span class="title">xxx_info</span> =</span> &#123;</span><br><span class="line">.read_raw = xxx_read_raw,</span><br><span class="line">.write_raw = xxx_write_raw,</span><br><span class="line">.write_raw_get_fmt = &amp;xxx_write_raw_get_fmt,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : spi 驱动的 probe 函数，当驱动与</span></span><br><span class="line"><span class="comment">* 设备匹配以后此函数就会执行</span></span><br><span class="line"><span class="comment">* @param - spi : spi 设备</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> *<span class="title">indio_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1、申请 iio_dev 内存 */</span></span><br><span class="line">indio_dev = devm_iio_device_alloc(&amp;spi-&gt;dev, <span class="keyword">sizeof</span>(*data));</span><br><span class="line"><span class="keyword">if</span> (!indio_dev)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、获取 xxx_dev 结构体地址 */</span></span><br><span class="line">data = iio_priv(indio_dev);</span><br><span class="line">data-&gt;spi = spi;</span><br><span class="line">spi_set_drvdata(spi, indio_dev);</span><br><span class="line">mutex_init(&amp;data-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、初始化 iio_dev 成员变量 */</span></span><br><span class="line">indio_dev-&gt;dev.parent = &amp;spi-&gt;dev;</span><br><span class="line">indio_dev-&gt;info = &amp;xxx_info;</span><br><span class="line">indio_dev-&gt;name = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">indio_dev-&gt;modes = INDIO_DIRECT_MODE; <span class="comment">/* 直接模式 /</span></span><br><span class="line"><span class="comment">indio_dev-&gt;channels = xxx_channels;</span></span><br><span class="line"><span class="comment">indio_dev-&gt;num_channels = ARRAY_SIZE(xxx_channels);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">iio_device_register(indio_dev);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/* 4、 regmap 相关设置 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、 SPI 相关设置*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6、芯片初始化 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @description : spi 驱动的 remove 函数，移除 spi 驱动的时候此函数会执行</span></span><br><span class="line"><span class="comment">* @param - spi : spi 设备</span></span><br><span class="line"><span class="comment">* @return : 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> *<span class="title">indio_dev</span> =</span> spi_get_drvdata(spi);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">data</span>;</span></span><br><span class="line">data = iio_priv(indio_dev); ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1、其他资源的注销以及释放 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、注销 IIO */</span></span><br><span class="line">iio_device_unregister(indio_dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络驱动</title>
      <link href="/2023/08/13/2023-8-13-%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/08/13/2023-8-13-%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="网络驱动硬件"><a href="#网络驱动硬件" class="headerlink" title="网络驱动硬件"></a>网络驱动硬件</h3><p>嵌入式网络硬件分为两部分： MAC 和 PHY，大家都是通过看数据手册来判断一款 SOC 是否支持网络，如果一款芯片数据手册说自己支持网络，一般都是说的这款 SOC 内置 MAC， MAC 类似 I2C 控制器、 SPI 控制器一样的外设。但是光有 MAC还不能直接驱动网络，还需要另外一个芯片： PHY，因此对于内置 MAC 的 SOC，其外部必须搭配一个 PHY 芯片。但是有些 SOC 内部没有 MAC，那也就没法搭配 PHY 芯片了，这些内部没有网络 MAC 的芯片如何上网呢？这里就要牵扯出常见的两个嵌入式网络硬件方案了 </p><p><strong>1、 SOC 内部没有网络 MAC 外设</strong><br>我们一般说某个 SOC 不支持网络，说的就是它没有网络 MAC。那么这个芯片就不能上网了吗？显然不是的，既然没有内部 MAC，那么可以找个外置的 MAC 芯片啊，不过一般这种外置的网络芯片都是 MAC+PHY 一体的。 </p><p>这种方案的优点就是让不支持网络的 SOC 能够另辟蹊径，实现网络功能，但是缺点就是网络效率不高，因为一般芯片内置的 MAC 会有网络加速引擎，比如网络专用 DMA，网络处理效率会很高。而且此类芯片网速都不快，基本就是 10&#x2F;100M。 </p><p><strong>2、 SOC 内部集成网络 MAC 外设</strong></p><p>我们一般说某个 SOC 支持网络，说的就是他内部集成网络 MAC 外设，此时我们还需要外接一个网络 PHY 芯片。</p><p>内部集成网络 MAC 的优点如下： </p><p>①、内部 MAC 外设会有专用的加速模块，比如专用的 DMA，加速网速数据的处理。<br>②、网速快，可以支持 10&#x2F;100&#x2F;1000M 网速。<br>③、外接 PHY 可选择性多，成本低。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-13%20130028.png"></p><p>MII接口</p><p>MII 全称是 Media Independent Interface，直译过来就是介质独立接口，它是 IEEE-802.3 定义的以太网标准接口 。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-13%20130138.png"></p><p>MII接口一共16根线，</p><p>TX_CLK： 发送时钟，如果网速为 100M 的话时钟频率为 25MHz， 10M 网速的话时钟频率为 2.5MHz，此时钟由 PHY 产生并发送给 MAC。<br>TX_EN： 发送使能信号。<br>TX_ER： 发送错误信号，高电平有效，表示 TX_ER 有效期内传输的数据无效。 10Mpbs 网速下 TX_ER 不起作用。<br>TXD[3:0]：发送数据信号线，一共 4 根。<br>RXD[3:0]： 接收数据信号线，一共 4 根。<br>RX_CLK： 接收时钟信号，如果网速为 100M 的话时钟频率为 25MHz， 10M 网速的话时钟频率为 2.5MHz， RX_CLK 也是由 PHY 产生的。<br>RX_ER： 接收错误信号，高电平有效，表示 RX_ER 有效期内传输的数据无效。 10Mpbs 网速下 RX_ER 不起作用。<br>RX_DV： 接收数据有效，作用类似 TX_EN。<br>CRS： 载波侦听信号。<br>COL： 冲突检测信号 </p><p>RMII 全称是 Reduced Media Independent Interface，翻译过来就是精简的介质独立接口，也就是 MII 接口的精简版本。 RMII 接口只需要 7 根数据线， </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-13%20130321.png"></p><p>TX_EN： 发送使能信号。<br>TXD[1:0]： 发送数据信号线，一共 2 根。<br>RXD[1:0]：接收数据信号线，一共 2 根。<br>CRS_DV： 相当于 MII 接口中的 RX_DV 和 CRS 这两个信号的混合。<br>REF_CLK： 参考时钟，由外部时钟源提供， 频率为 50MHz。这里与 MII 不同， MII 的接收和发送时钟是独立分开的，而且都是由 PHY 芯片提供的。</p><p><strong>嵌入式网络硬件框图</strong></p><p>一个 MAC 连接一个 PHY 芯片形成一个完整网络接口 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-13%20133933.png"></p><p>PHY 是 IEEE 802.3 规定的一个标准模块，前面说了， SOC 可以对 PHY 进行配置或者读取PHY 相关状态，这个就需要 PHY 内部寄存器去实现了。 PHY 芯片寄存器地址空间为 5 位，地址 0<del>31 共 32 个寄存器， IEEE 定义了 0</del>15 这 16 个寄存器的功能， 16~31 这 16 个寄存器由厂商自行实现。 后面16位的引脚为不同厂商的特色功能引脚，前16位就能保证基本的网络数据通信。</p><h3 id="LAN8720A-（PHY芯片）详解"><a href="#LAN8720A-（PHY芯片）详解" class="headerlink" title="LAN8720A （PHY芯片）详解"></a>LAN8720A （PHY芯片）详解</h3><p>1、 LAN8720A 简介<br>LAN8720A 是低功耗的 10&#x2F;100M 单以太网 PHY 层芯片， 可应用于机顶盒、网络打印机、嵌入式通信设备、 IP 电话等领域。 I&#x2F;O 引脚电压符合 IEEE802.3-2005 标准。 LAN8720A 支持通过 RMII 接口与以太网 MAC 层通信，内置 10-BASE-T&#x2F;100BASE-TX 全双工传输模块，支持10Mbps 和 100Mbps。 LAN8720A 可以通过自协商的方式选择与目的主机最佳的连接方式(速度和双工模式)。支持 HP Auto-MDIX 自动翻转功能，无需更换网线即可将连接更改为直连或交叉连接。<br>LAN8720A 的主要特点如下：<br>· 高性能的 10&#x2F;100M 以太网传输模块<br>· 支持 RMII 接口以减少引脚数<br>· 支持全双工和半双工模式<br>· 两个状态 LED 输出<br>· 可以使用 25M 晶振以降低成本<br>· 支持自协商模式<br>· 支持 HP Auto-MDIX 自动翻转功能<br>· 支持 SMI 串行管理接口<br>· 支持 MAC 接口 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-14%20110141.png"></p><p>LAN8720A 的器件管理接口支持非 IEEE 802.3 规范的中断功能。当一个中断事件发生并且相应事件的中断位使能， LAN8720A 就会在 nINT(14 脚)产生一个低电平有效的中断信号。LAN8720A 的中断系统提供两种中断模式：主中断模式和复用中断模式。主中断模式是默认中断模式， LAN8720A 上电或复位后就工作在主中断模式，当模式控制&#x2F;状态寄存器(十进制地址为 17)的 ALTINT 位为 0 时 LAN8720A 工作在主模式，当 ALTINT 位为 1 时工作在复用中断模式。 </p><p>MAC 层通过 MDIO&#x2F;MDC 总线对 PHY 进行读写操作， MDIO 最多可以控制 32 个 PHY 芯片，通过不同的 PHY 芯片地址来对不同的 PHY 操作。 LAN8720A 通过设置 RXER&#x2F;PHYAD0引脚来设置其 PHY 地址，默认情况下为 0，其地址设置如表 </p><table><thead><tr><th>RXER&#x2F;PHYAD0 引脚状态</th><th>PHY 地址</th></tr></thead><tbody><tr><td>上拉</td><td>0X01</td></tr><tr><td>下拉(默认)</td><td>0X00</td></tr></tbody></table><p>nINTSEL 引脚(2 号引脚)用于设置 nINT&#x2F;REFCLKO 引脚(14 号引脚)的功能。 nINTSEL 配置如表 </p><table><thead><tr><th>nINTSEL 引脚值</th><th>模式</th><th>nINT&#x2F;REFCLKO 引脚功能</th></tr></thead><tbody><tr><td>nINTSEL&#x3D; 0</td><td>REF_CLK Out 模式</td><td>nINT&#x2F;REFCLKO 作为 REF_CLK 时钟源</td></tr><tr><td>nINTSEL &#x3D; 1(默认)</td><td>REF_CLK In 模式</td><td>nINT&#x2F;REFCLKO 作为中断引脚</td></tr></tbody></table><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-14%20110621.png"></p><p>LAN8720寄存器引脚</p><table><thead><tr><th>位</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>15</td><td>软件复位 1：软件复位，此位自动清零</td><td>R&#x2F;W</td></tr><tr><td>14</td><td>回测 0：正常运行 1：使能回测模式</td><td>R&#x2F;W</td></tr><tr><td>13</td><td>速度选择 0： 10Mbps 1： 100Mbps 注意：当使用自动协商功能时此位失能</td><td>R&#x2F;W</td></tr><tr><td>12</td><td>自动协商功能 0：关闭自动协商功能 1：打开自动协商功能</td><td>R&#x2F;W</td></tr><tr><td>11</td><td>掉电（ power down） 0：正常运行 1：进入掉电模式 注意:进入掉电模式前自动协商必须失能</td><td>R&#x2F;W</td></tr><tr><td>10</td><td>隔离 0：正常运行</td><td>R&#x2F;W</td></tr><tr><td>9</td><td>重启自动协商功能 0：正常运行 1：重启自动协商功能 注意:此位会被自动清零</td><td>R&#x2F;W SC</td></tr><tr><td>8</td><td>双工模式 0：半双工 1：全双工 注意:开启自动协商功能后此位失效</td><td>R&#x2F;W</td></tr><tr><td>7:0</td><td>保留</td><td>RO</td></tr></tbody></table><h3 id="Linux内核网络驱动框架"><a href="#Linux内核网络驱动框架" class="headerlink" title="Linux内核网络驱动框架"></a>Linux内核网络驱动框架</h3><p>Linux 内核使用 net_device 结构体表示一个具体的网络设备， <strong>net_device</strong> 是整个网络驱动的灵魂。网络驱动的<strong>核心就是初始化 net_device 结构体中的各个成员变量</strong>，然后将初始化完成以后的 net_device <strong>注册到 Linux 内核中</strong>。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">char</span> name[IFNAMSIZ];<span class="comment">//name 是网络设备的名字。</span></span><br><span class="line"><span class="number">3</span> <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">name_hlist</span>;</span></span><br><span class="line"><span class="number">4</span> <span class="type">char</span> *ifalias;</span><br><span class="line"><span class="number">5</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">6 * I/O specific fields</span></span><br><span class="line"><span class="comment">7 * <span class="doctag">FIXME:</span> Merge these and struct ifmap into one</span></span><br><span class="line"><span class="comment">8 */</span></span><br><span class="line"><span class="number">9</span> <span class="type">unsigned</span> <span class="type">long</span> mem_end;<span class="comment">//mem_end 是共享内存结束地址。</span></span><br><span class="line"><span class="number">10</span> <span class="type">unsigned</span> <span class="type">long</span> mem_start;<span class="comment">//mem_start 是共享内存起始地址。</span></span><br><span class="line"><span class="number">11</span> <span class="type">unsigned</span> <span class="type">long</span> base_addr;<span class="comment">//base_addr 是网络设备 I/O 地址。</span></span><br><span class="line"><span class="number">12</span> <span class="type">int</span> irq;<span class="comment">//irq 是网络设备的中断号。</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="type">atomic_t</span> carrier_changes;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">17 * Some hardware also needs these fields (state,dev_list,</span></span><br><span class="line"><span class="comment">18 * napi_list,unreg_list,close_list) but they are not</span></span><br><span class="line"><span class="comment">19 * part of the usual set specified in Space.c.</span></span><br><span class="line"><span class="comment">20 */</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dev_list</span>;</span><span class="comment">//dev_list 是全局网络设备列表。</span></span><br><span class="line"><span class="number">25</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">napi_list</span>;</span><span class="comment">//napi_list 是 napi 网络设备的列表入口。</span></span><br><span class="line"><span class="number">26</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">unreg_list</span>;</span><span class="comment">//unreg_list 是注销(unregister)的网络设备列表入口。</span></span><br><span class="line"><span class="number">27</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">close_list</span>;</span><span class="comment">//close_list 是关闭的网络设备列表入口。</span></span><br><span class="line">......</span><br><span class="line"><span class="number">60</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> *<span class="title">netdev_ops</span>;</span><span class="comment">/*netdev_ops 是网络设备的操作集函数，包含了一系列的网络设备操作回调函数，类似字符设备中的 file_operations，稍后会讲解 netdev_ops 结构体。*/</span></span><br><span class="line"><span class="number">61</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_ops</span> *<span class="title">ethtool_ops</span>;</span><span class="comment">/*ethtool_ops 是网络管理工具相关函数集，用户空间网络管理工具会调用此结构体中的相关函数获取网卡状态或者配置网卡。*/</span></span><br><span class="line"><span class="number">62</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_SWITCHDEV</span></span><br><span class="line"><span class="number">63</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">swdev_ops</span> *<span class="title">swdev_ops</span>;</span></span><br><span class="line"><span class="number">64</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="number">66</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">header_ops</span> *<span class="title">header_ops</span>;</span><span class="comment">// header_ops 是头部的相关操作函数集，比如创建、解析、缓冲等。</span></span><br><span class="line"><span class="number">67</span></span><br><span class="line"><span class="number">68</span> <span class="type">unsigned</span> <span class="type">int</span> flags;<span class="comment">//flags 是网络接口标志</span></span><br><span class="line">......</span><br><span class="line"><span class="number">77</span> <span class="type">unsigned</span> <span class="type">char</span> if_port;<span class="comment">//if_port 指定接口的端口类型，如果设备支持多端口的话就通过 if_port 来指定所使用的端口类型。</span></span><br><span class="line"><span class="number">78</span> <span class="type">unsigned</span> <span class="type">char</span> dma;<span class="comment">//dma 是网络设备所使用的 DMA 通道，不是所有的设备都会用到 DMA。</span></span><br><span class="line"><span class="number">79</span></span><br><span class="line"><span class="number">80</span> <span class="type">unsigned</span> <span class="type">int</span> mtu;<span class="comment">//mtu 是网络最大传输单元，为 1500</span></span><br><span class="line"><span class="number">81</span> <span class="type">unsigned</span> <span class="type">short</span> type;<span class="comment">//type 用于指定 ARP 模块的类型，以太网的 ARP 接口为 ARPHRD_ETHER</span></span><br><span class="line"><span class="number">82</span> <span class="type">unsigned</span> <span class="type">short</span> hard_header_len;<span class="comment">//perm_addr 是永久的硬件地址</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">84</span> <span class="type">unsigned</span> <span class="type">short</span> needed_headroom;</span><br><span class="line"><span class="number">85</span> <span class="type">unsigned</span> <span class="type">short</span> needed_tailroom;</span><br><span class="line"><span class="number">86</span></span><br><span class="line"><span class="number">87</span> <span class="comment">/* Interface address info. */</span></span><br><span class="line"><span class="number">88</span> <span class="type">unsigned</span> <span class="type">char</span> perm_addr[MAX_ADDR_LEN];</span><br><span class="line"><span class="number">89</span> <span class="type">unsigned</span> <span class="type">char</span> addr_assign_type;</span><br><span class="line"><span class="number">90</span> <span class="type">unsigned</span> <span class="type">char</span> addr_len;<span class="comment">//addr_len 是硬件地址长度</span></span><br><span class="line">......</span><br><span class="line"><span class="number">130</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">131 * Cache lines mostly used on receive path (including</span></span><br><span class="line"><span class="comment">eth_type_trans())</span></span><br><span class="line"><span class="comment">132 */</span></span><br><span class="line"><span class="number">133</span> <span class="type">unsigned</span> <span class="type">long</span> last_rx;<span class="comment">//last_rx 是最后接收的数据包时间戳，记录的是 jiffies</span></span><br><span class="line"><span class="number">134</span></span><br><span class="line"><span class="number">135</span> <span class="comment">/* Interface address info used in eth_type_trans() */</span></span><br><span class="line"><span class="number">136</span> <span class="type">unsigned</span> <span class="type">char</span> *dev_addr;<span class="comment">//dev_addr 也是硬件地址，是当前分配的 MAC 地址，可以通过软件修改。</span></span><br><span class="line"><span class="number">137</span></span><br><span class="line"><span class="number">138</span></span><br><span class="line"><span class="number">139</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line"><span class="number">140</span> <span class="class"><span class="keyword">struct</span> <span class="title">netdev_rx_queue</span> *_<span class="title">rx</span>;</span><span class="comment">//_rx 是接收队列。</span></span><br><span class="line"><span class="number">141</span></span><br><span class="line"><span class="number">142</span> <span class="type">unsigned</span> <span class="type">int</span> num_rx_queues;<span class="comment">/*num_rx_queues 是接收队列数量，在调用 register_netdev 注册网络设备的时候会</span></span><br><span class="line"><span class="comment">分配指定数量的接收队列。*/</span></span><br><span class="line"><span class="number">143</span> <span class="type">unsigned</span> <span class="type">int</span> real_num_rx_queues;<span class="comment">//real_num_rx_queues 是当前活动的队列数量。</span></span><br><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">145</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line"><span class="number">158</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">159 * Cache lines mostly used on transmit path</span></span><br><span class="line"><span class="comment">160 */</span></span><br><span class="line"><span class="number">161</span> <span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span> *_<span class="title">tx</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span><span class="comment">//_tx 是发送队列。</span></span><br><span class="line"><span class="number">162</span> <span class="type">unsigned</span> <span class="type">int</span> num_tx_queues;<span class="comment">/*num_tx_queues 是发送队列数量，通过 alloc_netdev_mq 函数分配指定数量的发</span></span><br><span class="line"><span class="comment">送队列。*/</span></span><br><span class="line"><span class="number">163</span> <span class="type">unsigned</span> <span class="type">int</span> real_num_tx_queues;<span class="comment">//real_num_tx_queues 是当前有效的发送队列数量。</span></span><br><span class="line"><span class="number">164</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">qdisc</span>;</span></span><br><span class="line"><span class="number">165</span> <span class="type">unsigned</span> <span class="type">long</span> tx_queue_len;</span><br><span class="line"><span class="number">166</span> <span class="type">spinlock_t</span> tx_global_lock;</span><br><span class="line"><span class="number">167</span> <span class="type">int</span> watchdog_timeo;</span><br><span class="line">......</span><br><span class="line"><span class="number">173</span> <span class="comment">/* These may be needed for future network-power-down code. */</span></span><br><span class="line"><span class="number">174</span></span><br><span class="line"><span class="number">175</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">176 * trans_start here is expensive for high speed devices on SMP,</span></span><br><span class="line"><span class="comment">177 * please use netdev_queue-&gt;trans_start instead.</span></span><br><span class="line"><span class="comment">178 */</span></span><br><span class="line"><span class="number">179</span> <span class="type">unsigned</span> <span class="type">long</span> trans_start;<span class="comment">//trans_start 是最后的数据包发送的时间戳，记录的是 jiffies。</span></span><br><span class="line">......</span><br><span class="line"><span class="number">248</span> <span class="class"><span class="keyword">struct</span> <span class="title">phy_device</span> *<span class="title">phydev</span>;</span><span class="comment">//phydev 是对应的 PHY 设备。</span></span><br><span class="line"><span class="number">249</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">qdisc_tx_busylock</span>;</span></span><br><span class="line"><span class="number">250</span> &#125;;</span><br></pre></td></tr></table></figure><p>申请 net_device<br>编写网络驱动的时候首先要申请 net_device，使用 alloc_netdev 函数来申请 net_device，这是一个宏，宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_netdev(sizeof_priv, name, name_assign_type, setup) alloc_netdev_mqs(sizeof_priv, name, name_assign_type, setup, 1, 1)</span></span><br></pre></td></tr></table></figure><p>可以看出 alloc_netdev 的本质是 alloc_netdev_mqs 函数，此函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> net_device * <span class="title function_">alloc_netdev_mqs</span> <span class="params">( <span class="type">int</span> sizeof_priv,<span class="comment">//sizeof_priv： 私有数据块大小。</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name,<span class="comment">//name： 设备名字。</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> (*setup) (<span class="keyword">struct</span> net_device *))</span><span class="comment">//setup： 回调函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> txqs,<span class="comment">//txqs： 分配的发送队列数量。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rxqs);<span class="comment">//rxqs： 分配的接收队列数量。</span></span><br></pre></td></tr></table></figure><p>返回值： 如果申请成功的话就返回申请到的 net_device 指针，失败的话就返回 NULL。</p><p>以太网的网络初始化封装为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_etherdev_mq(sizeof_priv, count)alloc_etherdev_mqs(sizeof_priv, count, count)</span></span><br></pre></td></tr></table></figure><p>ether_setup 函数会对 net_device 做初步的初始化，函数内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ether_setup</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;header_ops = &amp;eth_header_ops;</span><br><span class="line">dev-&gt;type = ARPHRD_ETHER;</span><br><span class="line">dev-&gt;hard_header_len = ETH_HLEN;</span><br><span class="line">dev-&gt;mtu = ETH_DATA_LEN;</span><br><span class="line">dev-&gt;addr_len = ETH_ALEN;</span><br><span class="line">dev-&gt;tx_queue_len = <span class="number">1000</span>; <span class="comment">/* Ethernet wants good queues */</span></span><br><span class="line">dev-&gt;flags = IFF_BROADCAST|IFF_MULTICAST;</span><br><span class="line">dev-&gt;priv_flags |= IFF_TX_SKB_SHARING;</span><br><span class="line">eth_broadcast_addr(dev-&gt;broadcast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于网络设备而言，使用 alloc_etherdev 或alloc_etherdev_mqs 来申请 net_device。 NXP 官方编写的网络驱动就是采用alloc_etherdev_mqs来申请 net_device。 </p><p>删除 net_device<br>当注销网络驱动的时候需要释放掉前面已经申请到的 net_device，释放函数为free_netdev，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span><span class="comment">//dev： 要释放掉的 net_device 指针。</span></span><br></pre></td></tr></table></figure><p>注册 net_device<br>net_device 申请并初始化完成以后就需要向内核注册 net_device，要用到函数 register_netdev，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span><span class="comment">//dev： 要注册的 net_device 指针。返回值： 0 注册成功，负值 注册失败。</span></span><br></pre></td></tr></table></figure><p>注销 net_device<br>既然有注册，那么必然有注销，注销 net_device 使用函数 unregister_netdev，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unregister_netdev</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span><span class="comment">//dev： 要注销的 net_device 指针。</span></span><br></pre></td></tr></table></figure><p><strong>操作集</strong></p><p>net_device 有个非常重要的成员变量： netdev_ops，为 net_device_ops 结构体指针类型，这就是网络设备的操作集。 net_device_ops 结构体定义在 include&#x2F;linux&#x2F;netdevice.h 文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> (*ndo_init)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//当第一次注册网络设备的时候此函数会执行</span></span><br><span class="line"><span class="number">3</span> <span class="type">void</span> (*ndo_uninit)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//卸载网络设备的时候此函数会执行</span></span><br><span class="line"><span class="number">4</span> <span class="type">int</span> (*ndo_open)(<span class="keyword">struct</span> net_device *dev);</span><br><span class="line"><span class="comment">/*·使能网络外设时钟。</span></span><br><span class="line"><span class="comment">·申请网络所使用的环形缓冲区。</span></span><br><span class="line"><span class="comment">·初始化 MAC 外设。</span></span><br><span class="line"><span class="comment">·绑定接口对应的 PHY。</span></span><br><span class="line"><span class="comment">·如果使用 NAPI 的话要使能 NAPI 模块，通过 napi_enable 函数来使能。</span></span><br><span class="line"><span class="comment">·开启 PHY。</span></span><br><span class="line"><span class="comment">·调用 netif_tx_start_all_queues 来使能传输队列，也可能调用 netif_start_queue 函数。等*/</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> (*ndo_stop)(<span class="keyword">struct</span> net_device *dev);</span><br><span class="line"><span class="number">6</span> <span class="type">netdev_tx_t</span> (*ndo_start_xmit) (<span class="keyword">struct</span> sk_buff *skb, <span class="comment">/*需要发送数据的时候此函数就会执行， sk_buff 保存了上层传</span></span><br><span class="line"><span class="comment">递给网络驱动层的数据。*/</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">struct</span> net_device *dev);</span><br><span class="line"><span class="number">8</span> u16 (*ndo_select_queue)(<span class="keyword">struct</span> net_device *dev,<span class="comment">//当设备支持多传输队列的时候选择使用哪个队列。</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">struct</span> sk_buff *skb,</span><br><span class="line"><span class="number">10</span> <span class="type">void</span> *accel_priv,</span><br><span class="line"><span class="number">11</span> <span class="type">select_queue_fallback_t</span> fallback);</span><br><span class="line"><span class="number">12</span> <span class="type">void</span> (*ndo_change_rx_flags)(<span class="keyword">struct</span> net_device *dev,</span><br><span class="line"><span class="number">13</span> <span class="type">int</span> flags);</span><br><span class="line"><span class="number">14</span> <span class="type">void</span> (*ndo_set_rx_mode)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//此函数用于改变地址过滤列表，根据 net_device 的 flags成员变量来设置 SOC 的网络外设寄存器</span></span><br><span class="line"><span class="number">15</span> <span class="type">int</span> (*ndo_set_mac_address)(<span class="keyword">struct</span> net_device *dev,<span class="comment">//此函数用于修改网卡的 MAC 地址，并且将 MAC 地址写入到网络外设的硬件寄存器中。</span></span><br><span class="line"><span class="number">16</span> <span class="type">void</span> *addr);</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> (*ndo_validate_addr)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//验证 MAC 地址是否合法</span></span><br><span class="line"><span class="number">18</span> <span class="type">int</span> (*ndo_do_ioctl)(<span class="keyword">struct</span> net_device *dev,<span class="comment">//用户程序调用 ioctl 的时候此函数就会执行用户程序调用 ioctl 的时候此函数就会执行</span></span><br><span class="line"><span class="number">19</span> <span class="keyword">struct</span> ifreq *ifr, <span class="type">int</span> cmd);</span><br><span class="line"><span class="number">20</span> <span class="type">int</span> (*ndo_set_config)(<span class="keyword">struct</span> net_device *dev,</span><br><span class="line"><span class="number">21</span> <span class="keyword">struct</span> ifmap *<span class="built_in">map</span>);</span><br><span class="line"><span class="number">22</span> <span class="type">int</span> (*ndo_change_mtu)(<span class="keyword">struct</span> net_device *dev,<span class="comment">//更改 MTU(最大传输单元)大小</span></span><br><span class="line"><span class="number">23</span> <span class="type">int</span> new_mtu);</span><br><span class="line"><span class="number">24</span> <span class="type">int</span> (*ndo_neigh_setup)(<span class="keyword">struct</span> net_device *dev,</span><br><span class="line"><span class="number">25</span> <span class="keyword">struct</span> neigh_parms *);</span><br><span class="line"><span class="number">26</span> <span class="type">void</span> (*ndo_tx_timeout) (<span class="keyword">struct</span> net_device *dev);<span class="comment">//当发送超时的时候函数会执行，一般可能会重启 MAC 和 PHY，重新开始数据发送等</span></span><br><span class="line">......</span><br><span class="line"><span class="number">36</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class="line"><span class="number">37</span> <span class="type">void</span> (*ndo_poll_controller)(<span class="keyword">struct</span> net_device *dev);<span class="comment">//使用查询方式来处理网卡数据的收发。</span></span><br><span class="line"><span class="number">38</span> <span class="type">int</span> (*ndo_netpoll_setup)(<span class="keyword">struct</span> net_device *dev,</span><br><span class="line"><span class="number">39</span> <span class="keyword">struct</span> netpoll_info *info);</span><br><span class="line"><span class="number">40</span> <span class="type">void</span> (*ndo_netpoll_cleanup)(<span class="keyword">struct</span> net_device *dev);</span><br><span class="line"><span class="number">41</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line"><span class="number">104</span> <span class="type">int</span> (*ndo_set_features)(<span class="keyword">struct</span> net_device *dev,<span class="comment">//修改 net_device 的 features 属性，设置相应的硬件属性</span></span><br><span class="line"><span class="number">105</span> <span class="type">netdev_features_t</span> features);</span><br><span class="line">......</span><br><span class="line"><span class="number">166</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="NAPI机制"><a href="#NAPI机制" class="headerlink" title="NAPI机制"></a>NAPI机制</h3><p>如果玩过单片机的话应该都知道，像 IIC、 SPI、网络等这些通信接口，接收数据有两种方法：轮询或中断。 Linux 里面的网络数据接收也轮询和中断两种，中断的好处就是响应快，数据量小的时候处理及时，速度快，但是一旦当数据量大，而且都是短帧的时候会导致中断频繁发生，消耗大量的 CPU 处理时间在中断自身处理上。轮询恰好相反，响应没有中断及时，但是在处理大量数据的时候不需要消耗过多的 CPU 处理时间。</p><p>Linux 在这两个处理方式的基础上提出了另外一种网络数据接收的处理方法： NAPI(New API)， NAPI 是一种高效的网络处理技术。NAPI 的核心思想就是不全部采用中断来读取网络数据，而是采用中断来唤醒数据接收服务程序，在接收服务程序中采用 POLL 的方法来轮询处理数据。这种方法的好处就是可以提高短数据包的接收效率，减少中断处理的时间。目前 NAPI 已经在 Linux 的网络驱动中得到了大量的应用，  </p><p>1、<strong>初始化 NAPI</strong><br>首先要初始化一个 napi_struct 实例，使用 netif_napi_add 函数，此函数定义在 net&#x2F;core&#x2F;dev.c中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_napi_add</span><span class="params">(<span class="keyword">struct</span> net_device *dev,<span class="comment">// 每个 NAPI 必须关联一个网络设备，此参数指定 NAPI 要关联的网络设备</span></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> napi_struct *napi,<span class="comment">//要初始化的 NAPI 实例</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> (*poll)(<span class="keyword">struct</span> napi_struct *, <span class="type">int</span>),<span class="comment">//NAPI 所使用的轮询函数，一般在此完成网络数据接收</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> weight)</span><span class="comment">//NAPI 默认权重(weight)，一般为 NAPI_POLL_WEIGHT。</span></span><br></pre></td></tr></table></figure><p>2、<strong>删除 NAPI</strong><br>如果要删除 NAPI，使用 netif_napi_del 函数即可，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">netif_napi_del</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi)</span><span class="comment">//napi： 要删除的 NAPI。</span></span><br></pre></td></tr></table></figure><p>3、 <strong>使能 NAPI</strong><br>初始化完 NAPI 以后，必须使能才能使用，使用函数 napi_enable，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">napi_enable</span><span class="params">(<span class="keyword">struct</span> napi_struct *n)</span><span class="comment">//n： 要使能的 NAPI。</span></span><br></pre></td></tr></table></figure><p>4、<strong>关闭 NAPI</strong><br>关闭 NAPI 使用 napi_disable 函数即可，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">napi_disable</span><span class="params">(<span class="keyword">struct</span> napi_struct *n)</span><span class="comment">//n： 要关闭的 NAPI。</span></span><br></pre></td></tr></table></figure><p>5、<strong>检查 NAPI 是否可以进行调度</strong><br>使用 napi_schedule_prep 函数检查 NAPI 是否可以进行调度，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">napi_schedule_prep</span><span class="params">(<span class="keyword">struct</span> napi_struct *n)</span><span class="comment">//n： 要检查的 NAPI。返回值可调度为真</span></span><br></pre></td></tr></table></figure><p>6、<strong>NAPI 调度</strong><br>如果可以调度的话就进行调度，使用napi_schedule 函数完成 NAPI 调度，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __napi_schedule(<span class="keyword">struct</span> napi_struct *n)<span class="comment">//n： 要调度的 NAPI。</span></span><br></pre></td></tr></table></figure><p>7、 <strong>NAPI 处理完成</strong><br>NAPI 处理完成以后需要调用 napi_complete 函数来标记 NAPI 处理完成，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">napi_complete</span><span class="params">(<span class="keyword">struct</span> napi_struct *n)</span><span class="comment">//n： 处理完成的 NAPI。</span></span><br></pre></td></tr></table></figure><h3 id="网络外设驱动树"><a href="#网络外设驱动树" class="headerlink" title="网络外设驱动树"></a>网络外设驱动树</h3><p>NXP 的 I.MX 系 列 SOC 网 络 绑 定 文 档 为<br>Documentation&#x2F;devicetree&#x2F;bindings&#x2F;net&#x2F;fsl-fec.txt，此绑定文档描述了 I.MX 系列 SOC 网络设备树节点的要求。<br><strong>①、 必要属性</strong><br>compatible： 这个肯定是必须的，一般是“fsl,<soc>-fec”，比如 I.MX6ULL 的 compatible 属<br>性就是”fsl,imx6ul-fec”,和”fsl,imx6q-fec”。<br>reg： SOC 网络外设寄存器地址范围。<br>interrupts：网络中断。<br>phy-mode： 网络所使用的 PHY 接口模式，是 MII 还是 RMII。<br><strong>②、 可选属性</strong><br>phy-reset-gpios： PHY 芯片的复位引脚。<br>phy-reset-duration： PHY 复位引脚复位持续时间，单位为毫秒。只有当设置了 phy-resetgpios 属性此属性才会有效，如果不设置此属性的话 PHY 芯片复位引脚的复位持续时间默认为1 毫秒，数值不能大于 1000 毫秒，大于 1000 毫秒的话就会强制设置为 1 毫秒。<br>phy-supply： PHY 芯片的电源调节。<br>phy-handle：连接到此网络设备的 PHY 芯片句柄。<br>fsl,num-tx-queues： 此属性指定发送队列的数量，如果不指定的话默认为 1。<br>fsl,num-rx-queues： 此属性指定接收队列的数量，如果不指定的话默认为 2。<br>fsl,magic-packet： 此属性不用设置具体的值，直接将此属性名字写到设备树里面即可，表示支持硬件魔术帧唤醒。<br>fsl,wakeup_irq： 此属性设置唤醒中断索引。<br>stop-mode： 如果此属性存在的话表明 SOC 需要设置 GPR 位来请求停止模式。<br>③、可选子节点<br>mdio：可以设置名为“mdio”的子节点，此子节点用于指定网络外设所使用的 MDIO 总线，主要作为 PHY 节点的容器，也就是在 mdio 子节点下指定 PHY 相关的属性信息，具体信息可以参考 PHY 的绑定文档 Documentation&#x2F;devicetree&#x2F;bindings&#x2F;net&#x2F;phy.txt。<br>PHY 节点相关属性内容如下：<br>interrupts：中断属性，可以不需要。<br>interrupt-parent： 中断控制器句柄，可以不需要。<br>reg： PHY 芯片地址，必须的！<br>compatible： 兼容性列表，一般为“ethernet-phy-ieee802.3-c22”或“ethernet-phy-ieee802.3-c45”，分别对应 IEEE802.3 的 22 簇和 45 簇，默认是 22 簇。也可以设置为其他值，如果 PHY的 ID 不知道的话可以 compatible 属性可以设置为“ethernet-phy-idAAAA.BBBB”， AAAA 和BBBB 的含义如下：<br>AAAA： PHY 的 16 位 ID 寄存器 1 值，也就是 OUI 的 bit3<del>18， 16 进制格式。<br>BBBB： PHY 的 16 位 ID 寄存器 2 值，也就是 OUI 的 bit19</del>24， 16 进制格式。<br>max-speed： PHY 支持的最高速度，比如 10、 100 或 1000。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>块设备驱动开发</title>
      <link href="/2023/08/08/2023-8-8-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/08/08/2023-8-8-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="块设备介绍"><a href="#块设备介绍" class="headerlink" title="块设备介绍"></a>块设备介绍</h3><p>块设备是针对存储设备的，比如 SD 卡、 EMMC、 NAND Flash、 Nor Flash、 SPI Flash、机械硬盘、固态硬盘等。因此块设备驱动其实就是这些存储设备驱动，块设备驱动相比字符设备驱动的主要区别如下：<br>①、块设备只能以块为单位进行读写访问，块是 linux 虚拟文件系统(VFS)基本的数据传输单位。字符设备是以字节为单位进行数据传输的，不需要缓冲。<br>②、块设备在结构上是可以进行随机访问的，对于这些设备的读写都是按块进行的，块设备使用缓冲区来暂时存放数据，等到条件成熟以后再一次性将缓冲区中的数据写入块设备中。 </p><p>linux 内 核 使 用 block_device 表 示 块 设 备 ， block_device 为 一 个 结 构 体 ， 定 义 在include&#x2F;linux&#x2F;fs.h 文件中，结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">dev_t</span> bd_dev; <span class="comment">/* not a kdev_t - it&#x27;s a search key */</span></span><br><span class="line"><span class="number">3</span> <span class="type">int</span> bd_openers;</span><br><span class="line"><span class="number">4</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">bd_inode</span>;</span> <span class="comment">/* will die */</span></span><br><span class="line"><span class="number">5</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">bd_super</span>;</span></span><br><span class="line"><span class="number">6</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bd_mutex</span>;</span> <span class="comment">/* open/close mutex */</span></span><br><span class="line"><span class="number">7</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">bd_inodes</span>;</span></span><br><span class="line"><span class="number">8</span><span class="type">void</span> * bd_claiming;</span><br><span class="line"><span class="number">9</span> <span class="type">void</span> * bd_holder;</span><br><span class="line"><span class="number">10</span> <span class="type">int</span> bd_holders;</span><br><span class="line"><span class="number">11</span> <span class="type">bool</span> bd_write_holder;</span><br><span class="line"><span class="number">12</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line"><span class="number">13</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">bd_holder_disks</span>;</span></span><br><span class="line"><span class="number">14</span><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">15</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bd_contains</span>;</span></span><br><span class="line"><span class="number">16</span> <span class="type">unsigned</span> bd_block_size;</span><br><span class="line"><span class="number">17</span> <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> *<span class="title">bd_part</span>;</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/*number of times partitions within this device have been opened.*/</span></span><br><span class="line"><span class="number">19</span> <span class="type">unsigned</span> bd_part_count;</span><br><span class="line"><span class="number">20</span> <span class="type">int</span> bd_invalidated;</span><br><span class="line"><span class="number">21</span> <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">bd_disk</span>;</span></span><br><span class="line"><span class="number">22</span> <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">bd_queue</span>;</span></span><br><span class="line"><span class="number">23</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">bd_list</span>;</span></span><br><span class="line"><span class="number">24</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">25 * Private data. You must have bd_claim&#x27;ed the block_device</span></span><br><span class="line"><span class="comment">26 * to use this. <span class="doctag">NOTE:</span> bd_claim allows an owner to claim</span></span><br><span class="line"><span class="comment">27 * the same device multiple times, the owner must take special</span></span><br><span class="line"><span class="comment">28 * care to not mess up bd_private for that case.</span></span><br><span class="line"><span class="comment">29 */</span></span><br><span class="line"><span class="number">30</span> <span class="type">unsigned</span> <span class="type">long</span> bd_private;</span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="number">32</span> <span class="comment">/* The counter of freeze processes */</span></span><br><span class="line"><span class="number">33</span> <span class="type">int</span> bd_fsfreeze_count;</span><br><span class="line"><span class="number">34</span> <span class="comment">/* Mutex for freeze */</span></span><br><span class="line"><span class="number">35</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bd_fsfreeze_mutex</span>;</span></span><br><span class="line"><span class="number">36</span> &#125;;</span><br></pre></td></tr></table></figure><p>注册块设备和注销块设备和字符设备驱动一样，我们需要向内核注册新的块设备、申请设备号，块设备注册函数为register_blkdev，如果不使用某个块设备了，那么就需要注销掉，函数为unregister_blkdev，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_blkdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span><span class="comment">/*如果参数 major 在 1~255 之间的话表示自定义主设备号，那么返回 0 表示注册成功，如果返回负值的话表示注册失败。如果 major 为 0 的话表示由系统自动分配主设备号，那么返回值就是系统分配的主设备号(1~255)，如果返回负值那就表示注册失败。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_blkdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span><span class="comment">//无返回值</span></span><br><span class="line"><span class="comment">//major： 主设备号，name： 块设备名字。</span></span><br></pre></td></tr></table></figure><p><strong>linux 内核使用 gendisk 来描述一个磁盘设备</strong>，这是一个结构体，定义在 include&#x2F;linux&#x2F;genhd.h中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="comment">/* major, first_minor and minors are input parameters only,</span></span><br><span class="line"><span class="comment">3 * don&#x27;t use directly. Use disk_devt() and disk_max_parts().</span></span><br><span class="line"><span class="comment">4 */</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> major; <span class="comment">/* major number of driver */</span></span><br><span class="line"><span class="number">6</span> <span class="type">int</span> first_minor;</span><br><span class="line"><span class="number">7</span> <span class="type">int</span> minors; <span class="comment">/* maximum number of minors, =1 for disks that can&#x27;t be partitioned. */</span></span><br><span class="line"><span class="number">8</span> </span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">char</span> disk_name[DISK_NAME_LEN]; <span class="comment">/* name of major driver */</span></span><br><span class="line"><span class="number">11</span> <span class="type">char</span> *(*devnode)(<span class="keyword">struct</span> gendisk *gd, <span class="type">umode_t</span> *mode);</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">unsigned</span> <span class="type">int</span> events; <span class="comment">/* supported events */</span></span><br><span class="line"><span class="number">14</span> <span class="type">unsigned</span> <span class="type">int</span> async_events; <span class="comment">/* async events, subset of all */</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="comment">/* Array of pointers to partitions indexed by partno.</span></span><br><span class="line"><span class="comment">17 * Protected with matching bdev lock but stat and other</span></span><br><span class="line"><span class="comment">18 * non-critical accesses use RCU. Always access through</span></span><br><span class="line"><span class="comment">19 * helpers.</span></span><br><span class="line"><span class="comment">20 */</span></span><br><span class="line"><span class="number">21</span> <span class="class"><span class="keyword">struct</span> <span class="title">disk_part_tbl</span> __<span class="title">rcu</span> *<span class="title">part_tbl</span>;</span><span class="comment">//磁盘对应的分区表</span></span><br><span class="line"><span class="number">22</span> <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> <span class="title">part0</span>;</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line"><span class="number">25</span> <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span><span class="comment">//为磁盘对应的请求队列</span></span><br><span class="line"><span class="number">26</span> <span class="type">void</span> *private_data;</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="number">29</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">driverfs_dev</span>;</span> <span class="comment">// <span class="doctag">FIXME:</span> remove</span></span><br><span class="line"><span class="number">30</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">slave_dir</span>;</span></span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="number">32</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_rand_state</span> *<span class="title">random</span>;</span></span><br><span class="line"><span class="number">33</span> <span class="type">atomic_t</span> sync_io; <span class="comment">/* RAID */</span></span><br><span class="line"><span class="number">34</span> <span class="class"><span class="keyword">struct</span> <span class="title">disk_events</span> *<span class="title">ev</span>;</span></span><br><span class="line"><span class="number">35</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INTEGRITY</span></span><br><span class="line"><span class="number">36</span> <span class="class"><span class="keyword">struct</span> <span class="title">blk_integrity</span> *<span class="title">integrity</span>;</span></span><br><span class="line"><span class="number">37</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">38</span> <span class="type">int</span> node_id;</span><br><span class="line"><span class="number">39</span> &#125;;</span><br></pre></td></tr></table></figure><p>关于编写块的设备驱动的时候需要分配并初始化一个 gendisk，使用的 API 函数。 </p><p>1、 申请 gendisk<br>使用 gendisk 之前要先申请， allo_disk 函数用于申请一个 gendisk，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> gendisk *<span class="title function_">alloc_disk</span><span class="params">(<span class="type">int</span> minors)</span></span><br><span class="line"><span class="comment">//minors： 次设备号数量， 也就是 gendisk 对应的分区数量。</span></span><br><span class="line"><span class="comment">//返回值： 成功：返回申请到的 gendisk，失败： NULL。</span></span><br></pre></td></tr></table></figure><p>2、删除 gendisk<br>如果要删除 gendisk 的话可以使用函数 del_gendisk，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del_gendisk</span><span class="params">(<span class="keyword">struct</span> gendisk *gp)</span></span><br><span class="line"><span class="comment">//gp： 要删除的 gendisk。无返回值</span></span><br></pre></td></tr></table></figure><p>3、将 gendisk 添加到内核<br>使用 alloc_disk 申请到 gendisk 以后系统还不能使用，必须使用 add_disk 函数将申请到的gendisk 添加到内核中， add_disk 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span></span><br><span class="line"><span class="comment">//disk： 要添加到内核的 gendisk。返回值： 无。</span></span><br></pre></td></tr></table></figure><p>4、设置 gendisk 容量<br>每一个磁盘都有容量，所以在初始化 gendisk 的时候也需要设置其容量，使用函数set_capacity，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_capacity</span><span class="params">(<span class="keyword">struct</span> gendisk *disk, <span class="type">sector_t</span> size)</span></span><br><span class="line"><span class="comment">/*disk： 要设置容量的 gendisk。</span></span><br><span class="line"><span class="comment">size： 磁盘容量大小，注意这里是扇区数量。块设备中最小的可寻址单元是扇区，一个扇区一般是 512 字节，有些设备的物理扇区可能不是 512 字节。不管物理扇区是多少，内核和块设备驱动之间的扇区都是 512 字节。所以 set_capacity 函数设置的大小就是块设备实际容量除以512 字节得到的扇区数量。比如一个 2MB 的磁盘，其扇区数量就是(2*1024*1024)/512=4096。</span></span><br><span class="line"><span class="comment">返回值： 无。*/</span></span><br></pre></td></tr></table></figure><p>块设备中最小的可寻址单元为扇区，扇区大小一般是2的整数倍，最常见的大小是512字节，扇区大小是设备的物理属性，扇区是所有块设备的基本单元，块设备无法对比它还小的单元进行寻址和操作，不过许多块设备能够一次传输多个扇区。</p><p>5、调整 gendisk 引用计数<br>内核会通过 get_disk 和 put_disk 这两个函数来调整 gendisk 的引用计数， get_disk 是增加 gendisk 的引用计数， put_disk 是减少 gendisk 的引用计数，这两个函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> kobject *<span class="title function_">get_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_disk</span><span class="params">(<span class="keyword">struct</span> gendisk *disk)</span></span><br></pre></td></tr></table></figure><p>块设备也有操作集，为结构体 block_device_operations，此结构体定义在 include&#x2F;linux&#x2F;blkdev.h 中，结构体内容如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> (*open) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>);</span><br><span class="line"><span class="number">3</span> <span class="type">void</span> (*release) (<span class="keyword">struct</span> gendisk *, <span class="type">fmode_t</span>);</span><br><span class="line"><span class="number">4</span> <span class="type">int</span> (*rw_page)(<span class="keyword">struct</span> block_device *, <span class="type">sector_t</span>, <span class="keyword">struct</span> page *,<span class="type">int</span> rw);<span class="comment">//读写指定的页</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>,<span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">//用于块设备的 I/O 控制，在32位系统</span></span><br><span class="line"><span class="number">6</span> <span class="type">int</span> (*compat_ioctl) (<span class="keyword">struct</span> block_device *, <span class="type">fmode_t</span>, <span class="type">unsigned</span>,<span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">//用于块设备的 I/O 控制，64位</span></span><br><span class="line"><span class="number">7</span> <span class="type">long</span> (*direct_access)(<span class="keyword">struct</span> block_device *, <span class="type">sector_t</span>,</span><br><span class="line"><span class="number">8</span> <span class="type">void</span> **, <span class="type">unsigned</span> <span class="type">long</span> *pfn, <span class="type">long</span> size);</span><br><span class="line"><span class="number">9</span> <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*check_events)</span> <span class="params">(<span class="keyword">struct</span> gendisk *disk,</span></span><br><span class="line"><span class="params"><span class="number">10</span> <span class="type">unsigned</span> <span class="type">int</span> clearing)</span>;</span><br><span class="line"><span class="number">11</span> <span class="comment">/* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span></span><br><span class="line"><span class="number">12</span> <span class="type">int</span> (*media_changed) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line"><span class="number">13</span> <span class="type">void</span> (*unlock_native_capacity) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line"><span class="number">14</span> <span class="type">int</span> (*revalidate_disk) (<span class="keyword">struct</span> gendisk *);</span><br><span class="line"><span class="number">15</span> <span class="type">int</span> (*getgeo)(<span class="keyword">struct</span> block_device *, <span class="keyword">struct</span> hd_geometry *);<span class="comment">//用于获取磁盘信息，包括磁头、柱面和扇区等信息。</span></span><br><span class="line"><span class="number">16</span> <span class="comment">/* this callback is with swap_lock and sometimes page table lockheld */</span></span><br><span class="line"><span class="number">17</span> <span class="type">void</span> (*swap_slot_free_notify) (<span class="keyword">struct</span> block_device *,<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="number">18</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">//表示此结构体属于哪个模块，一般直接设置为 THIS_MODULE。</span></span><br><span class="line"><span class="number">19</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="块设备-I-x2F-O-请求过程"><a href="#块设备-I-x2F-O-请求过程" class="headerlink" title="块设备 I&#x2F;O 请求过程"></a>块设备 I&#x2F;O 请求过程</h3><p>在编写块设备驱动的时候，每个磁盘(gendisk)都要分配一个 request_queue ，内核将对块设备的读写都发送到请求队列 request_queue 中， request_queue 中是大量的request(请求结构体)，而 request 又包含了 bio， bio 保存了读写相关数据。</p><p>通常一个bio对应一个I&#x2F;O请求。调度算法可以将连续的bio合并成一个请求，所以一个请求包含多个bio。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20143303.png"></p><p><strong>请求队列API函数解析</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">request_queue *<span class="title function_">blk_init_queue</span><span class="params">(request_fn_proc *rfn, <span class="type">spinlock_t</span> *lock)</span></span><br><span class="line"><span class="comment">/*rfn： 请求处理函数指针 lock： 自旋锁指针，需要驱动编写人员定义一个自旋锁，然后传递进来。，请求队列会使用</span></span><br><span class="line"><span class="comment">这个自旋锁。返回值： 如果为 NULL 的话表示失败，成功的话就返回申请到的 request_queue 地址。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_cleanup_queue</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line"> <span class="comment">/*q： 需要删除的请求队列。返回值： 无。*/</span></span><br><span class="line"><span class="keyword">struct</span> request_queue *<span class="title function_">blk_alloc_queue</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span></span><br><span class="line"> <span class="comment">/*gfp_mask： 内存分配掩码，返回值： 申请到的无 I/O 调度的 request_queue。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_queue_make_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q, make_request_fn *mfn)</span></span><br><span class="line"> <span class="comment">/*q： 需要绑定的请求队列，也就是 blk_alloc_queue 申请到的请求队列。mfn：需要绑定的“制造”请求函数*/</span></span><br><span class="line"><span class="title function_">void</span> <span class="params">(make_request_fn)</span> <span class="params">(<span class="keyword">struct</span> request_queue *q, <span class="keyword">struct</span> bio *bio)</span></span><br><span class="line"> <span class="comment">/*返回值： 无*/</span></span><br></pre></td></tr></table></figure><p><strong>请求API函数解析</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">request *<span class="title function_">blk_peek_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line"><span class="comment">/*q： 指定 request_queue。</span></span><br><span class="line"><span class="comment">返回值： request_queue 中下一个要处理的请求(request)，如果没有要处理的请求就返回NULL。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blk_start_request</span><span class="params">(<span class="keyword">struct</span> request *req)</span></span><br><span class="line"><span class="comment">/*req： 要开始处理的请求。返回值： 无。*/</span></span><br><span class="line"><span class="comment">//一步到位处理请求</span></span><br><span class="line"><span class="keyword">struct</span> request *<span class="title function_">blk_fetch_request</span><span class="params">(<span class="keyword">struct</span> request_queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>;</span></span><br><span class="line">rq = blk_peek_request(q);</span><br><span class="line"><span class="keyword">if</span> (rq)</span><br><span class="line">blk_start_request(rq);</span><br><span class="line"><span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20211257.png"></p><p>每个 request 里面会有多个 bio， bio 保存着最终要读写的数据、地址等信息。上层应用程序对于块设备的读写会被构造成一个或多个 bio 结构， bio 结构描述了要读写的起始扇区、要读写的扇区数量、是读取还是写入、页偏移、数据长度等等信息。上层会将 bio 提交给 I&#x2F;O 调度器，I&#x2F;O 调度器会将这些 bio 构造成 request 结构，而一个物理存储设备对应一个 request_queue，request_queue 里面顺序存放着一系列的 request。新产生的 bio 可能被合并到 request_queue 里现有的 request 中，也可能产生新的 request，然后插入到 request_queue 中合适的位置，这一切都是由 I&#x2F;O 调度器来完成的。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20141959.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bio 是个结构体，定义在 include/linux/blk_types.h 中</span></span><br><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bi_next</span>;</span> <span class="comment">/* 请求队列的下一个 bio */</span></span><br><span class="line"><span class="number">3</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bi_bdev</span>;</span> <span class="comment">/* 指向块设备 */</span></span><br><span class="line"><span class="number">4</span> <span class="type">unsigned</span> <span class="type">long</span> bi_flags; <span class="comment">/* bio 状态等信息 */</span></span><br><span class="line"><span class="number">5</span> <span class="type">unsigned</span> <span class="type">long</span> bi_rw; <span class="comment">/* I/O 操作,读或写 */</span></span><br><span class="line"><span class="number">6</span><span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span> <span class="title">bi_iter</span>;</span> <span class="comment">/* I/O 操作,读或写 */</span></span><br><span class="line"><span class="number">7</span> <span class="type">unsigned</span> <span class="type">int</span> bi_phys_segments;</span><br><span class="line"><span class="number">8</span> <span class="type">unsigned</span> <span class="type">int</span> bi_seg_front_size;</span><br><span class="line"><span class="number">9</span> <span class="type">unsigned</span> <span class="type">int</span> bi_seg_back_size;</span><br><span class="line"><span class="number">10</span> <span class="type">atomic_t</span> bi_remaining;</span><br><span class="line"><span class="number">11</span> <span class="type">bio_end_io_t</span> *bi_end_io;</span><br><span class="line"><span class="number">12</span> <span class="type">void</span> *bi_private;</span><br><span class="line"><span class="number">13</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line"><span class="number">14</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">15 * Optional ioc and css associated with this bio. Put on bio</span></span><br><span class="line"><span class="comment">16 * release. Read comment on top of bio_associate_current().</span></span><br><span class="line"><span class="comment">17 */</span></span><br><span class="line"><span class="number">18</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_context</span> *<span class="title">bi_ioc</span>;</span></span><br><span class="line"><span class="number">19</span> <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> *<span class="title">bi_css</span>;</span></span><br><span class="line"><span class="number">20</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">21</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="number">22</span> <span class="meta">#<span class="keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line"><span class="number">23</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span></span><br><span class="line"><span class="number">24</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">25</span> &#125;;</span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span> <span class="type">unsigned</span> <span class="type">short</span> bi_vcnt; <span class="comment">/* bio_vec 列表中元素数量 */</span></span><br><span class="line"><span class="number">28</span> <span class="type">unsigned</span> <span class="type">short</span> bi_max_vecs; <span class="comment">/* bio_vec 列表长度 */</span></span><br><span class="line"><span class="number">29</span> <span class="type">atomic_t</span> bi_cnt; <span class="comment">/* pin count */</span></span><br><span class="line"><span class="number">30</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> *<span class="title">bi_io_vec</span>;</span> <span class="comment">/* bio_vec 列表 */</span></span><br><span class="line"><span class="number">31</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_set</span> *<span class="title">bi_pool</span>;</span></span><br><span class="line"><span class="number">32</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> <span class="title">bi_inline_vecs</span>[0];</span></span><br><span class="line"><span class="number">33</span> &#125;;</span><br></pre></td></tr></table></figure><p>重点来看一下第 6 行和第 30 行，第 6 行为 bvec_iter 结构体类型的成员变量，第 30 行为bio_vec 结构体指针类型的成员变量。<br>bvec_iter 结构体描述了要操作的设备扇区等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span> &#123;</span></span><br><span class="line"><span class="type">sector_t</span> bi_sector; <span class="comment">/*I/O 请求的设备起始扇区(512 字节) */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bi_size; <span class="comment">/* 剩余的 I/O 数量 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bi_idx; <span class="comment">/* blv_vec 中当前索引 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bi_bvec_done; <span class="comment">/* 当前 bvec 中已经处理完成的字节数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">bv_page</span>;</span> <span class="comment">/* 页 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bv_len; <span class="comment">/* 长度 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bv_offset; <span class="comment">/* 偏移 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-09%20213733.png"></p><p><strong>①、遍历请求中的 bio</strong><br>请求中包含有大量的 bio，因此就涉及到遍历请求中所有 bio 并进行处理。遍历请求中的 bio 使用函数______rq_for_each_bio,这是一个宏，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __rq_for_each_bio(_bio, rq)  <span class="keyword">if</span> ((rq-&gt;bio)) for (_bio = (rq)-&gt;bio; _bio; _bio = _bio-&gt;bi_next)</span></span><br></pre></td></tr></table></figure><p>_bio 就是遍历出来的每个 bio， rq 是要进行遍历操作的请求， _bio 参数为 bio 结构体指针类型， rq 参数为 request 结构体指针类型。<br><strong>②、遍历 bio 中的所有段</strong><br>bio 包含了最终要操作的数据，因此还需要遍历 bio 中的所有段，这里要用到bio_for_each_segment 函数，此函数也是一个宏，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bio_for_each_segment(bvl, bio, iter) __bio_for_each_segment(bvl, bio, iter, (bio)-&gt;bi_iter)</span></span><br></pre></td></tr></table></figure><p>第一个 bvl 参数就是遍历出来的每个 bio_vec，第二个 bio 参数就是要遍历的 bio，类型为bio 结构体指针，第三个 iter 参数保存要遍历的 bio 中 bi_iter 成员变量。<br><strong>③、通知 bio 处理结束</strong><br>如果使用“制造请求”，也就是抛开 I&#x2F;O 调度器直接处理 bio 的话，在 bio 处理完成以后要通过内核 bio 处理完成，使用 bio_endio 函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bvoid <span class="title function_">bio_endio</span><span class="params">(<span class="keyword">struct</span> bio *bio, <span class="type">int</span> error)</span></span><br></pre></td></tr></table></figure><p>bio： 要结束的 bio。<br>error： 如果 bio 处理成功的话就直接填 0，如果失败的话就填个负值，比如-EIO。<br>返回值： 无</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><p>block_device: 描述一个分区或整个磁盘对内核的一个块设备实例<br>gendisk: 描述一个通用硬盘（generic hard disk）对象。<br>hd_struct: 描述分区应有的分区信息<br>bio: 描述块数据传送时怎样完成填充或读取块给driver<br>request: 描述向内核请求一个列表准备做队列处理。<br>request_queue: 描述内核申请request资源建立请求链表并填写BIO形成队列。</p></blockquote><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-10%20172007.png"></p><blockquote><p>在Linux中，驱动对块设备的输入或输出(I&#x2F;O)操作，都会向块设备发出一个请求，在驱动中用&gt;request结构体描述。但对于一些磁盘设备而言请求的速度很慢，这时候内核就提供一种队列的机制把这些I&#x2F;O请求添加到队列中（即：请求队列），在驱动中用request_queue结构体描述。在向块设备提交这些请求前内核会先执行请求的合并和排序预操作，以提高访问的效率，然后再由内核中的I&#x2F;O调度程序子系统来负责提交 I&#x2F;O 请求， 调度程序将磁盘资源分配给系统中所有挂起的块 I&#x2F;O 请求，其工作是管理块设备的请求队列，决定队列中的请求的排列顺序以及什么时候派发请求到设备。<br>由通用块层(Generic Block Layer)负责维持一个I&#x2F;O请求在上层文件系统与底层物理磁盘之间的关系。在通用块层中，通常用一个bio结构体来对应一个I&#x2F;O请求。<br>Linux提供了一个gendisk数据结构体，用来表示一个独立的磁盘设备或分区，用于对底层物理磁盘进行访问。在gendisk中有一个类似字符设备中file_operations的硬件操作结构指针，是block_device_operations结构体。<br>当多个请求提交给块设备时，执行效率依赖于请求的顺序。如果所有的请求是同一个方向（如：写数据），执行效率是最大的。内核在调用块设备驱动程序例程处理请求之前，先收集I&#x2F;O请求并将请求排序，然后，将连续扇区操作的多个请求进行合并以提高执行效率（内核算法会自己做，不用你管），对I&#x2F;O请求排序的算法称为电梯算法（elevator algorithm）。电梯算法在I&#x2F;O调度层完成。</p></blockquote><p><strong>代码框架</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-12%20212433.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>can通信协议</title>
      <link href="/2023/08/07/2023-8-7-can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/08/07/2023-8-7-can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="CAN通信协议"><a href="#CAN通信协议" class="headerlink" title="CAN通信协议"></a>CAN通信协议</h2><p>CAN 的特点主要有一下几点：<br>①、多主控制<br>②、系统的柔软性<br>③、通信速度快，距离远<br>④、具有错误检测、错误通知和错误恢复功能<br>⑤、故障封闭功能<br>⑥、连接节点多</p><h3 id="CAN-电气属性"><a href="#CAN-电气属性" class="headerlink" title="CAN 电气属性"></a>CAN 电气属性</h3><p>CAN 总线使用两根线来连接各个单元：CAN_H 和 CAN_L， CAN 控制器通过判断这两根线上的电位差来得到总线电平， CAN 总线电平分为显性电平和隐性电平两种。显性电平表示逻辑“0”，此时 CAN_H 电平比 CAN_L 高，分别为 3.5V 和 1.5V，电位差为 2V。隐形电平表示逻辑“1”，此时 CAN_H 和 CAN_L 电压都为 2.5V 左右，电位差为 0V。 CAN 总线就通过显性和隐形电平的变化来将具体的数据发送出去 。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20185240.png"></p><p>CAN 总线上没有节点传输数据的时候一直处于隐性状态，也就是说总线空闲状态的时候一直处于隐性。 </p><h3 id="CAN协议帧"><a href="#CAN协议帧" class="headerlink" title="CAN协议帧"></a>CAN协议帧</h3><p>CAN 协议提供了 5 种帧格式来传输数据：数据帧、遥控帧、错误帧、过载帧和帧间隔。其中数据帧和遥控帧有标准格式和扩展格式两种，标准格式有 11 位标识符(ID)，扩展格式有 29 个标识符(ID)。 </p><table><thead><tr><th align="center">帧类型</th><th align="center">帧用途</th></tr></thead><tbody><tr><td align="center">数据帧</td><td align="center">用于 CAN 节点单元之间进行数据传输的帧</td></tr><tr><td align="center">遥控帧</td><td align="center">用于接收单元向具有相同 ID 的发送单元请求数据的帧</td></tr><tr><td align="center">错误帧</td><td align="center">用于当检测出错误时向其它单元通知错误的帧</td></tr><tr><td align="center">过载帧</td><td align="center">用于接收单元通知其尚未做好接收准备的帧</td></tr><tr><td align="center">间隔帧</td><td align="center">用于将数据帧及遥控帧与前面的帧分离开来的帧</td></tr></tbody></table><p>D为显性0，R为隐形1。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE_202308071734_13201%203.jpg"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE_202308071734_11851%201.jpg"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE_202308071734_14251%204.jpg"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE_202308071734_15346%205.jpg"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/can%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE_202308071734_12590%202.jpg"></p><h3 id="CAN速率"><a href="#CAN速率" class="headerlink" title="CAN速率"></a>CAN速率</h3><p>CAN 总线以帧的形式发送数据，但是最终到总线上的就是“0”和“1”这样的二进制数据，这里就涉及到了通信速率，也就是每秒钟发送多少位数据， CAN2.0 最高速度为1Mbps&#x2F;S。对于 CAN 总线，一个位分为 4 段：<br>①、同步段(SS)<br>②、传播时间段(PTS)<br>③、相位缓冲段 1(PBS1)<br>④、相位缓冲段 2(PBS2)<br>这些段由 Tq(Time Quantum)组成， <strong>Tq 是 CAN 总线的最小时间单位。帧由位构成，一个位由 4 个段构成，每个段又由若干个 Tq 组成，这个就是位时序。</strong> 1 位由多少个 Tq 构成、每个段又由多少个 Tq 构成等，可以任意设定位时序。通过设定位时序，多个单元可同时采样，也可任意设定采样点。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20191029.png"></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20191432.png"></p><h3 id="can传输仲裁"><a href="#can传输仲裁" class="headerlink" title="can传输仲裁"></a>can传输仲裁</h3><p>在总线空闲态，最先开始发送消息的单元获得发送权。当多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的单元可继续发送。 </p><p><img src="C:\Users\hanfeng\AppData\Roaming\Typora\typora-user-images\1691407245638.png" alt="1691407245638"></p><p>单元 1 和单元 2 同时开始向总线发送数据，开始部分他们的数据格式是一样的，故无法区分优先级，直到 T 时刻，单元 1 输出隐性电平，而单元 2 输出显性电平，此时单元 1 仲裁失利，立刻转入接收状态工作，不再与单元 2 竞争，而单元 2 则顺利获得总线使用权，继续发送自己的数据。这就实现了仲裁，让连续发送显性电平多的单元获得总线使用权。 </p><p><a href="https://gitee.com/hanfengdyh/code/blob/master/CAN%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.pdf">CAN入门教程.pdf · 码云 </a></p><h3 id="FlexCAN（CAN外设）"><a href="#FlexCAN（CAN外设）" class="headerlink" title="FlexCAN（CAN外设）"></a>FlexCAN（CAN外设）</h3><p> FlexCAN 符合 CAN2.0B 协议。 FlexCAN完全符合CAN协议，支持标准格式和扩展格式，支持 64个消息缓冲。I.MX6ULL自带的FlexCAN模块特性如下：<br>①、支持 CAN2.0B 协议，数据帧和遥控帧支持标准和扩展两种格式，数据长度支持 0~8 字<br>节，可编程速度，最高 1Mbit&#x2F;S。<br>②、灵活的消息邮箱，最高支持 8 个字节。<br>③、每个消息邮箱可以配置为接收或发送，都支持标准和扩展这两种格式的消息。<br>④、每个消息邮箱都有独立的接收掩码寄存器。<br>⑤、强大的接收 FIFO ID 过滤。<br>⑥、未使用的空间可以用作通用 RAM。<br>⑦、可编程的回测模式，用于进行自测。<br>⑧、可编程的优先级组合。</p><p>FlexCAN 支持四种模式：正常模式(Normal)、冻结模式(Freeze)、仅监听模式(Listen-Only)和回环模式(Loop-Back)，另外还有两种低功耗模式：禁止模式(Disable)和停止模式(Stop)。<br>①、正常模式(Normal)<br>在正常模式下， FlexCAN 正常接收或发送消息帧，所有的 CAN 协议功能都使能。<br>②、冻结模式(Freeze)<br>当 MCR 寄存器的 FRZ 位置 1 的时候使能此模式，在此模式下无法进行帧的发送或接收，CAN 总线同步丢失。<br>③、仅监听模式(Listen-Onley)<br>当 CTRL 寄存器的 LOM 位置 1 的时候使能此模式，在此模式下帧发送被禁止，所有错误计数器被冻结， CAN 控制器工作在被动错误模式，此时只会接收其他 CAN 单元发出的 ACK 消息。<br>④、 回环模式(Loop-Back)<br>当 CTRL 寄存器的 LPB 位置 1 的时候进入此模式，此模式下 FlexCAN 工作在内部回环模式，一般用来进行自测。从模式下发送出来的数据流直接反馈给内部接收单元。 </p><p>控制寄存器 CTRL 用于设置这些位时序， CTRL 寄存器中的 PRESDIV、 PROPSEG、 PSEG1、PSEG2 和 RJW 这 5 个位域用于设置 CAN 位时序。<br>PRESDIV 为 CAN 分频值，也即是设置 CAN 协议中的 Tq 值，公式如下：<br>$$<br>𝑓_{𝑇𝑞} &#x3D;𝑓_{𝐶𝐴𝑁𝐶𝐿𝐾}&#x2F;PRESDIV + 1<br>$$<br><strong>fCANCLK为 FlexCAN 模块时钟，这个根据时钟章节设置即可，设置好以后就是一个定值，因此只需要修改 PRESDIV 即可修改 FlexCAN 的 Tq 频率值。</strong><br>Tq 定了以后我们结合各个段来看一下如何设置 FlexCAN 的速率：</p><p>SS： 同步段(Synchronization Segment)，在 I.MX6ULL 参考手册中叫做 SYNC_SEG，此段固定为 1 个 Tq 长度，因此不需要去设置。<br>PTS： 传播时间段(Propagatin Segment)， FlexCAN 的 CTRL 寄存器中的 PROPSEG 位域设置此段，可以设置为 0<del>7，对应 1</del>8 个 Tq。<br>PBS1： 相位缓冲段 1(Phase Buffer Segment 1)， FlexCAN 的 CRTL 寄存器中的 PSEG1 位域设置此段，可以设置为 0<del>7，对应 1</del>8 个 Tq。<br>PBS2：相位缓冲段 2(Phase Buffer Segment 2)， FlexCAN 的 CRTL 寄存器中的 PSEG2 位域设置此段，可以设置为 1<del>7，对应 2</del>8 个 Tq。<br>SJW： 再同步补偿宽度(reSynchronization Jump Width)， FlexCAN 的 CRTL 寄存器中的 RJW位域设置此段，可以设置 0<del>3，对应 1</del>4 个 Tq。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-07%20195038.png"></p><p>SYNC+SEG+(PROP_SEG+PSEG1+2)+(PSEG2+1)就是总的 Tq，因此FlexCAN 的波特率就是：<br>$$<br>𝐶𝐴𝑁波特率 &#x3D; 𝑓_{𝑇𝑞}&#x2F;总Tq<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux开发板安装第三方库</title>
      <link href="/2023/08/06/2023-8-6-%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
      <url>/2023/08/06/2023-8-6-%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="第三方库的安装配置"><a href="#第三方库的安装配置" class="headerlink" title="第三方库的安装配置"></a>第三方库的安装配置</h2><h3 id="串口（minicom和ncurse）"><a href="#串口（minicom和ncurse）" class="headerlink" title="串口（minicom和ncurse）"></a>串口（minicom和ncurse）</h3><p>ncurses (new curses)库是System V Release 4.0及curses更高版本中的免费软件仿真库。它使用terminfo格式，支持pads和color ，多种高亮显示，多形式字符和功能键映射，该库很容易移植到任何符合ANSI&#x2F; posix的类unix系统中运行。</p><p>下载地址<a href="https://directory.fsf.org/wiki/Ncurses">Ncurses - Free Software </a></p><p>具体编译构建步骤如下：</p><h5 id="1、构建配置"><a href="#1、构建配置" class="headerlink" title="1、构建配置"></a>1、构建配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/moss/linux/tool/ncurse --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf --with-shared --without-profile --disable-stripping --without-progs --with-manpages --without-tests</span><br></pre></td></tr></table></figure><ul><li>configure ：配置脚本。（在命令行终端下运行）</li><li>–prefix： 用于指定编译结果的保存目录。</li><li>–host： 用于指定编译器前缀，这里设置为 “arm-linux-gnueabihf”。</li><li>–target ：用于指定目标，这里设置为“arm-linux-gnueabihf”。</li></ul><p>配置结果：<img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20124119.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make#make进行编译</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20124530.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install#进行安装</span><br></pre></td></tr></table></figure><p>可能会有报错，可能是找不到交叉编译位置，可以使用命令转到root的模式下进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo -s //切换到 root </span><br><span class="line">source /etc/profile //执行/etc/profile</span><br><span class="line">make install //安装，此时已经工作在 root 下，因此不需要加“sudo”</span><br><span class="line">su moss //编译完成以后回原来的用户</span><br></pre></td></tr></table></figure><p>安装成功以后查看一下前面创建的“ncurses”文件夹，会发现里面多了一些东西，</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20125053.png"></p><p>我们需要将 include、 lib 和 share 这三个目录中存放的文件分别拷贝到开发板根文件系统中的&#x2F;usr&#x2F;include、 &#x2F;usr&#x2F;lib 和&#x2F;usr&#x2F;share 这三个目录中，如果哪个目录不存在的话请自行创建！！拷贝命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp lib/* /home/moss/linux/nfs/rootfs/usr/lib/ -rfa</span><br><span class="line">sudo cp share/* /home/moss/linux/nfs/rootfs/usr/share/ -rfa</span><br><span class="line">sudo cp include/* /home/moss/linux/nfs/rootfs/usr/include/ -rfa</span><br></pre></td></tr></table></figure><p>然后在开发板根目录的&#x2F;etc&#x2F;profile(没有的话自己创建一个)文件中添加如下所示内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH</span><br><span class="line">export LD_LIBRARY_PATH</span><br><span class="line">export TERM=vt100</span><br><span class="line">export TERMINFO=/usr/share/terminfo </span><br></pre></td></tr></table></figure><p>minicom是一个命令行终端中由菜单驱动的串行通信调试程序。</p><p>下载地址<a href="https://fossies.org/linux/misc/minicom-2.8.tar.bz2/">minicom 2.8 - Download| Fossies Archive</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure CC=arm-linux-gnueabihf-gcc --prefix=/home/moss/linux/tool/minicom --host=arm-linux-gnueabihf CPPFLAGS=-I/home/moss/linux/tool/ncurses/include LDFLAGS=-L/home/moss/linux/tool/ncurses/lib -enable-cfg-dir=/etc/minicom              </span><br></pre></td></tr></table></figure><p> CC 表示要使用的 gcc 交叉编译器， –prefix 指定编译出来的文件存放目录，肯定要存放前面创建的 minicom 目录中。 –host 指定交叉编译器前缀， CPPFLAGS 指定 ncurses 的头文件路径，LDFLAGS 指定ncurses的库路径。配置成功后</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20130403.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20130558.png"></p><p>装完后文件生成如图。将 minicom 目录中 bin 子目录下的所有文件拷贝到开发板根目录中的&#x2F;usr&#x2F;bin 目录下，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp bin/* /home/moss/linux/nfs/rootfs/usr/bin/ </span><br></pre></td></tr></table></figure><p>之后打开开发板的根文件系统，新建&#x2F;etc&#x2F;passwd 文件，然后在 passwd 文件里面输入如下所示内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/sh</span><br></pre></td></tr></table></figure><h3 id="音频声卡"><a href="#音频声卡" class="headerlink" title="音频声卡"></a>音频声卡</h3><p>alsa-lib 和 alsa-utils 源 码 ， 下 载 地 址 为 ： <a href="http://www.alsa-project.org/main/index.php/Main_Page">Advanced Linux Sound Architecture</a></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20131711.png"></p><p><strong>alsa-lib 移植</strong><br>注意 alsa-lib 编译过程中会生成一些配置文件，而这些配置信息的路径都是绝对路径，因此为了保证 ubuntu 和开发板根文件系统中的路径一致！在 ubuntu 和开发板中各创建一个路径和名字完全一样的目录，这里我们都创建一个&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录， ubuntu 中创建命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share </span><br><span class="line">sudo mkdir arm-alsa </span><br></pre></td></tr></table></figure><p>最后在开发板根文件系统中也创建一个&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/share/arm-alsa -p </span><br></pre></td></tr></table></figure><p>这样 ubuntu 和开发板根文件系统都有一个“&#x2F;usr&#x2F;share&#x2F;arm-alsa”目录，交叉编译的时候就不怕存在引用绝对路径了，因为 ubuntu 和开发板中的配置文件路径都是一模一样的。由于 alsa-utils 要用到 alsa-lib 库，因此要先编译 alsa-lib 库。 alsa-lib 就是 ALSA 相关库文件，应用程序通过调用 ALSA 库来对 ALSA 框架下的声卡进行操作。先创建一个名为“alsa-lib”的目录用来保存 alsa-lib 的编译结果，然后将 alsa-lib-1.2.2.tar.bz2 拷贝到 ubuntu 中并解压，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxjf alsa-lib-1.2.9.tar.bz2 </span><br></pre></td></tr></table></figure><p>解压完成以后就会得到一个名为“alsa-lib-1.2.9”的文件夹，这个就是 alsa-lib 的源码。进入alsa-lib-1.2.9 目录，然后配置并编译，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=arm-linux-gnueabihf --prefix=/home/moss/linux/tool/alsalib --with-configdir=/usr/share/arm-alsa </span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;配置注意， “–with-configdir”用于设置 alsa-lib 编译出来的配置文件存放位置，这里设置为前面创建的“&#x2F;usr&#x2F;share&#x2F;arm-alsa”目录。<br>配置完成以后就可以编译了，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make </span><br><span class="line">sudo make install </span><br></pre></td></tr></table></figure><p>可能会出现错误提示：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20132326.png"><br> libatopology.la 编译失败， 这是因为 sudo 会切换到 root 用户下，但是此时 root 用户下的环境变量中没有交叉编译器路径，因此会提示找不到“arm-linux-gnueabihf-gcc”，从而导致 libatopology.la 编译失败。解决方法就是先切换到 root 用户，重新执行一下&#x2F;etc&#x2F;profile<br>文件，然后直接 make install 即可，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo -s </span><br><span class="line">source /etc/profile </span><br><span class="line">make install </span><br><span class="line">su moss</span><br></pre></td></tr></table></figure><p>编译完成以后前面创建的“alsa-lib”目录就会保存相应的编译结果，如图 65.4.1.2 所示：<br>图 65.4.1.2 alsa-lib 编译结果<br>ubuntu 中&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下的内容如图 65.4.1.3 所示：<br>图 65.4.1.3 编译出来的配置文件。<br>将图 65.4.1.2 中 lib 目录下的所有文件拷贝到开发板根文件系统的&#x2F;usr&#x2F;lib 目录下，将图<br>65.4.1.3 中&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下的所有文件拷贝到开发板的&#x2F;usr&#x2F;share&#x2F;arm-alsa 目录下，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd alsa-lib //进入 alsa-lib</span><br><span class="line">sudo cp lib/* /home/moss/linux/nfs/rootfs/lib/ -af</span><br><span class="line">cd /usr/share/arm-alsa //进入 arm-alsa 目录，拷贝配置文件</span><br><span class="line">sudo cp * /home/moss/linux/nfs/rootfs/usr/share/arm-alsa/ -raf</span><br></pre></td></tr></table></figure><p><strong>alsa-utils 移植</strong><br>alsa-utils 是 ALSA 的一些小工具集合，我们可以通过这些小工具还测试我们的声卡。将 alsautils-1.2.2.tar.bz2 复制到 ubuntu 中并解压，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxjf alsa-utils-1.2.9.tar.bz2 </span><br></pre></td></tr></table></figure><p>解压成功以后会得到一个名为“alsa-utils-1.2.9”的文件夹，此文件夹就是 alsa-utils 源码。<br>重新创建一个名为“alsa-utils”的目录用于存放 alsa-utils-1.2.9 的编译结果。按照如下命令编译alsa-utils：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=arm-linux-gnueabihf --prefix=/home/moss/linux/tool/alsautils --with-alsa-inc-prefix=/home/moss/linux/tool/alsa-lib/include/ --with-alsaprefix=/home/moss/linux/tool/alsa-lib/lib/ --disable-alsamixer --disable-xmlto</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>编译完成以后就会在前面创建的“alsa-utils”目录下生成 bin、 sbin 和 share 三个文件夹，如<br><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20144427.png"><br><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-06%20144522.png"><br>将图 中 bin、 sbin 和 share 这三个目录中的所有文件分别拷贝到开发板根目录下的<br>&#x2F;bin、 &#x2F;sbin 和&#x2F;usr&#x2F;share&#x2F;alsa 目录下，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd alsa-utils</span><br><span class="line">sudo cp bin/* /home/zuozhongkai/linux/nfs/rootfs/bin/ -rfa</span><br><span class="line">sudo cp sbin/* /home/zuozhongkai/linux/nfs/rootfs/sbin/ -rfa</span><br><span class="line">sudo cp share/* /home/zuozhongkai/linux/nfs/rootfs/usr/share/ -rfa</span><br></pre></td></tr></table></figure><p>打开开发板根文件系统中的&#x2F;etc&#x2F;profile 文件，在里面加入如下所示内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALSA_CONFIG_PATH=/usr/share/arm-alsa/alsa.conf</span><br></pre></td></tr></table></figure><p>ALSA_CONFIG_PATH 用于指定 alsa 的配置文件，这个配置文件是 alsa-lib 编译出来的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音频驱动开发</title>
      <link href="/2023/08/05/2023-8-5-%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/08/05/2023-8-5-%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="音频解码"><a href="#音频解码" class="headerlink" title="音频解码"></a>音频解码</h2><p>处理器接收音频需要将声音通过ADC采集，将模拟信号转换成为数字信号，相反播放声音就需要将数字信号转换成为模拟信号使用DAC芯片。音频编解码芯片，英文名字就是 Audio CODEC 。</p><p>既然音频 CODEC 的本质是 ADC 和 DAC，那么采样率和采样位数就是衡量一款音频<br>CODEC 最重要的指标。比如常见音频采样率有 8K、 44.1K、 48K、 192K 甚至 384K 和 768K，采样位数常见的有 8 位、 16 位、 24 位、 32 位。采样率和采样位数越高，那么音频 CODEC 越能真实的还原声音，也就是大家说的 HIFI。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20140803.png"></p><p>①、此部分是 WM8960 提供的输入接口，作为立体声音频输入源，一共提供了三路，分别为 LINPUT1&#x2F;RINPUT1、 LINPUT2&#x2F;RINPUT2、 LINPUT3&#x2F;RINPUT3。麦克风或线路输入就连接到此接口上。<br>②、此部分是 WM8960 的输出接口，比如输出给耳机或喇叭， SPK_LP&#x2F;SPK_LN 用于连接左声道的喇叭，支持 1W 的 8Ω喇叭。  </p><p>③、此部分是数字音频接口，用于和主控制器连接，有 5 根线，用于主控制器和 WM8960之间进行数据“沟通”。主控制器向 WM8960 的 DAC 发送的数据，WM8960 的 ADC 向主控制传递的数据都是通过此音频接口来完成的。 </p><p>此接口支持 I2S 格式。此接口 5 根线的作用如下：<br>ADCDAT： ADC 数据输出引脚，采集到的音频数据转换为数字信号以后通过此引脚传输给主控制器。<br>ADCLRC： ADC 数据对齐时钟，也就是帧时钟(LRCK)，用于切换左右声道数据， 此信号的频率就是采样率。此引脚可以配置为 GPIO 功能，配置为 GPIO 以后 ADC 就会使用 DACLRC引脚作为帧时钟。<br>DACDAT： DAC 数据输入引脚，主控器通过此引脚将数字信号输入给 WM8960 的 DAC。<br>DACLRC： DAC 数据对齐时钟，功能和 ADCLRC 一样，都是帧时钟(LRCK)，用于切换左右声道数据，此信号的频率等于采样率。<br>BCLK： 位时钟，用于同步。<br>MCLK： 主时钟， WM8960 工作的时候还需要一路主时钟，此时钟由 I.MX6ULL 提供，MCLK 频率等于采样率的 256 或 384 倍。</p><p>④、此部分为控制接口，是一个标准的 I2C 接口， WM8960 要想工作必须对其进行配置，这个 I2C 接口就是用于配置 WM8960 的。 </p><h3 id="I2S总线"><a href="#I2S总线" class="headerlink" title="I2S总线"></a>I2S总线</h3><p>I2S 是飞利浦公司提出的一种用于数字音频设备之间进行音频数据传输的总线。I2S 总线用于主控制器和音频 CODEC 芯片之间传输音频数据。因此，要想使用 I2S 协议， 主控制器和音频 CODEC 都得支持 I2S 协议  。</p><p><strong>SCK</strong>： 串行时钟信号，也叫做位时钟(BCLK)，<strong>音频数据的每一位数据都对应一个 SCK</strong>，立体声都是双声道的，因此 <strong>SCK&#x3D;2×采样率×采样位数</strong>。比如采样率为 44.1KHz、 16 位的立体声音频，那么 SCK&#x3D;2× 44100×16&#x3D;1411200Hz&#x3D;1.4112MHz。<br><strong>WS</strong>： 字段(声道)选择信号，也叫做 LRCK，也叫做帧时钟，用于切换左右声道数据， WS 为“1”表示正在传输左声道的数据， WS 为“0”表示正在传输右声道的数据。 WS 的频率等于采样率，比如采样率为 44.1KHz 的音频， WS&#x3D;44.1KHz。<br><strong>SD</strong>： 串行数据信号，<strong>也就是我们实际的音频数据</strong>，如果要同时实现放音和录音，那么就需要 2 根数据线，比如 WM8960 的 ADCDAT 和 DACDAT，就是分别用于录音和放音。不管音频数据是多少位的，数据的最高位都是最先传输的。数据的最高位总是出现在一帧开始后(LRCK变化)的第 2 个 SCK 脉冲处。<br>另外，有时候为了使音频 CODEC 芯片与主控制器之间能够更好的同步，会引入另外一个叫做 MCLK 的信号，也叫做主时钟或系统时钟，一般是采样率的 256 倍或 384 倍。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20143955.png"></p><p>​一帧立体声时序图</p><p>SAI接口，全称为 Synchronous Audio Interface （同步音频接口）</p><p>SAI的主要特性是：</p><p>①、帧最大为32字</p><p>②、字最大可选择8bit和32bit</p><p>③、每个接收和发送通道拥有32x32bit的FIFO</p><p>④、FIFO错误以后支持平滑重启 。     <a href="https://blog.csdn.net/qq_46015011/article/details/107086812">FIFO是什么意思_飞鸟211的博客</a>)</p><p>使用音频芯片为wm8960芯片，在imx6ull上的硬件框图为</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20190900.png"></p><h3 id="音频驱动使能"><a href="#音频驱动使能" class="headerlink" title="音频驱动使能"></a>音频驱动使能</h3><p>nxp的官方写好了wm8960驱动，因此配置内核使能就行。</p><p>首先是添加设备树的节点，查看设备树关于此芯片的驱动手册，位置在Documentation&#x2F;devicetree&#x2F;bindings&#x2F;sound&#x2F;wm8960.txt</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-05%20190436.png"></p><p>可以看到需要两个必备特性，compatitble和reg，还有两个可选特性，wlf,shared-lrclk和wlf,capless。</p><p>由于硬件线路将配置接口接在了i2c2上，所以在i2c2上添加设备树的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">codec: wm8960@<span class="number">1</span>a &#123;</span><br><span class="line">compatible = <span class="string">&quot;wlf,wm8960&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x1a</span>&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;<span class="comment">//时钟源SAI2</span></span><br><span class="line">clock-names = <span class="string">&quot;mclk&quot;</span>;<span class="comment">//时钟名字，为了同步一般提供mclk的时钟</span></span><br><span class="line">wlf,shared-lrclk;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后是SAI的的节点代码，sound是在根节点下的一个代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">sound &#123;</span><br><span class="line">compatible = <span class="string">&quot;fsl,imx6ul-evk-wm8960&quot;</span>,</span><br><span class="line">   <span class="string">&quot;fsl,imx-audio-wm8960&quot;</span>;<span class="comment">//用于匹配驱动时使用</span></span><br><span class="line">model = <span class="string">&quot;wm8960-audio&quot;</span>;<span class="comment">//声卡的名字，相当于设备名字</span></span><br><span class="line">cpu-dai = &lt;&amp;sai2&gt;;<span class="comment">//CPU DAI（Digtial Audio Interface）句柄</span></span><br><span class="line">audio-codec = &lt;&amp;codec&gt;;<span class="comment">//音频解码芯片句柄</span></span><br><span class="line">asrc-controller = &lt;&amp;asrc&gt;;<span class="comment">//asrc控制器</span></span><br><span class="line">codec-master;</span><br><span class="line">gpr = &lt;&amp;gpr <span class="number">4</span> <span class="number">0x100000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * hp-det = &lt;hp-det-pin hp-det-polarity&gt;;</span></span><br><span class="line"><span class="comment"> * hp-det-pin: JD1 JD2  or JD3</span></span><br><span class="line"><span class="comment"> * hp-det-polarity = 0: hp detect high for headphone</span></span><br><span class="line"><span class="comment"> * hp-det-polarity = 1: hp detect high for speaker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hp-det = &lt;<span class="number">3</span> <span class="number">0</span>&gt;;<span class="comment">//耳机插入检测</span></span><br><span class="line"><span class="comment">/*hp-det-gpios = &lt;&amp;gpio5 4 0&gt;;</span></span><br><span class="line"><span class="comment">mic-det-gpios = &lt;&amp;gpio5 4 0&gt;;*/</span></span><br><span class="line">audio-routing =<span class="comment">//音频器件一系列的连接设置</span></span><br><span class="line"><span class="string">&quot;Headphone Jack&quot;</span>, <span class="string">&quot;HP_L&quot;</span>,</span><br><span class="line"><span class="string">&quot;Headphone Jack&quot;</span>, <span class="string">&quot;HP_R&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ext Spk&quot;</span>, <span class="string">&quot;SPK_LP&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ext Spk&quot;</span>, <span class="string">&quot;SPK_LN&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ext Spk&quot;</span>, <span class="string">&quot;SPK_RP&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ext Spk&quot;</span>, <span class="string">&quot;SPK_RN&quot;</span>,</span><br><span class="line"><span class="string">&quot;LINPUT2&quot;</span>, <span class="string">&quot;Mic Jack&quot;</span>,</span><br><span class="line"><span class="string">&quot;LINPUT3&quot;</span>, <span class="string">&quot;Mic Jack&quot;</span>,</span><br><span class="line"><span class="string">&quot;RINPUT1&quot;</span>, <span class="string">&quot;Main MIC&quot;</span>,</span><br><span class="line"><span class="string">&quot;RINPUT2&quot;</span>, <span class="string">&quot;Main MIC&quot;</span>,</span><br><span class="line"><span class="string">&quot;Mic Jack&quot;</span>, <span class="string">&quot;MICB&quot;</span>,</span><br><span class="line"><span class="string">&quot;Main MIC&quot;</span>, <span class="string">&quot;MICB&quot;</span>,</span><br><span class="line"><span class="string">&quot;CPU-Playback&quot;</span>, <span class="string">&quot;ASRC-Playback&quot;</span>,</span><br><span class="line"><span class="string">&quot;Playback&quot;</span>, <span class="string">&quot;CPU-Playback&quot;</span>,</span><br><span class="line"><span class="string">&quot;ASRC-Capture&quot;</span>, <span class="string">&quot;CPU-Capture&quot;</span>,</span><br><span class="line"><span class="string">&quot;CPU-Capture&quot;</span>, <span class="string">&quot;Capture&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果查看使用SAI引脚的设置，查看sai2的节点，首先看imx6ull.dtsi的设备节点，之后对自己的设备树文件进行追加修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;sai2 &#123;</span><br><span class="line"><span class="number">2</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">3</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_sai2</span><br><span class="line"><span class="number">4</span>                &amp;pinctrl_sai2_hp_det_b&gt;;</span><br><span class="line"><span class="number">5</span>assigned-clocks = &lt;&amp;clks IMX6UL_CLK_SAI2_SEL&gt;,</span><br><span class="line"><span class="number">6</span>                   &lt;&amp;clks IMX6UL_CLK_SAI2&gt;;</span><br><span class="line"><span class="number">7</span> assigned-clock-parents = &lt;&amp;clks IMX6UL_CLK_PLL4_AUDIO_DIV&gt;;</span><br><span class="line"><span class="number">8</span> assigned-clock-rates = &lt;<span class="number">0</span>&gt;, &lt;<span class="number">12288000</span>&gt;;</span><br><span class="line"><span class="number">9</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure><p>从 pinctrl-0 属性可以看出这里一共有两组 IO： pinctrl_sai2 和 pinctrl_sai2_hp_det_b，看这两个节点中引脚是否正确。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驱动程序编译进入内核</title>
      <link href="/2023/08/04/2023-8-4-%E9%A9%B1%E5%8A%A8%E7%BC%96%E8%AF%91%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8/"/>
      <url>/2023/08/04/2023-8-4-%E9%A9%B1%E5%8A%A8%E7%BC%96%E8%AF%91%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<p>通常都是将驱动源码编译为.ok文件，然后通过insmod 或者modprobe加载进系统中，而在脱离网络的设备中就需要将驱动编译进入内核。</p><h3 id="已知驱动类型操作步骤："><a href="#已知驱动类型操作步骤：" class="headerlink" title="已知驱动类型操作步骤："></a>已知驱动类型操作步骤：</h3><ol><li><p>查看自己编写驱动的所属类型，例如编写一个led的驱动，那么寻找内核drivers目录中的led驱动目录</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-04%20154249.png"></p></li><li><p>首先打开编写Kconfig文件</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-04%20154652.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tristate &quot;内容&quot;</span><br></pre></td></tr></table></figure><p>这行的内容是显示在menuconfig的目录中，相当于这个驱动的说明。</p></li><li><p>之后修改leds这个目录的Makefile</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-04%20150403.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">obj-$</span><span class="language-bash">(CONFIG_GPIOLED)+= gpioled.o</span></span><br></pre></td></tr></table></figure><p>$()的内容是CONFIG_后面加上Kconfig里添加的内容，+&#x3D;后面加上文件.o的名字</p></li><li><p>最后在内核中编译make menuconfig,可以在设备驱动的led驱动里面看到自己写的驱动。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-04%20153656.png"></p></li></ol><h3 id="未知驱动类型操作步骤："><a href="#未知驱动类型操作步骤：" class="headerlink" title="未知驱动类型操作步骤："></a>未知驱动类型操作步骤：</h3><ol><li><p>在drivers的目录下自行创建一个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir nxpops</span><br></pre></td></tr></table></figure></li><li><p>在此目录下创建Kconfig文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd nxpops</span><br><span class="line">vi Kconfig</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menuconfigNXPOPS</span><br><span class="line">bool &quot;nxpops driver&quot;</span><br><span class="line">help </span><br><span class="line">Put the driver the operation in nxp</span><br><span class="line">configMULTITOUCH</span><br><span class="line">tristate &quot;multitouch&quot;</span><br><span class="line">depends on NXPOPS</span><br><span class="line">help</span><br><span class="line">nxp multitouch</span><br></pre></td></tr></table></figure></li><li><p>编写Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_BEEP)</span>+= beep.o</span><br></pre></td></tr></table></figure></li><li><p>之后修改drivers目录中的Kconfig和Makefile文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &quot;drivers/nxpops/Kconfig&quot;</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-y+= nxpops/</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>触摸屏驱动</title>
      <link href="/2023/07/23/2023-7-23-%E8%A7%A6%E6%91%B8%E5%B1%8F/"/>
      <url>/2023/07/23/2023-7-23-%E8%A7%A6%E6%91%B8%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="触屏需要的知识点"><a href="#触屏需要的知识点" class="headerlink" title="触屏需要的知识点"></a>触屏需要的知识点</h2><p>首先触摸屏的驱动，也是使用之前使用input的知识点。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-22%20150749.png"></p><p>通过注册函数注册到内核，<img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-22%20150847.png"></p><p>触控屏幕，电容屏幕是控制 IC ，所以要使用到IIC的驱动，因为触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息 ，上报屏幕坐标等信息需要使用input的系统上报。</p><p>多点电容触摸的(Multi-touch，简称 MT)， MT 协议被分为两种类型， TypeA 和 TypeB，这两种类型的区别如下：<br>Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少！ )。<br>Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个触摸点的信息， FT5426 就属于此类型，一般的多点电容触摸屏 IC 都有此能力。 </p><p>触摸点的信息通过一系列的 ABS_MT 事件(有的资料也叫消息)上报给 linux 内核 ，ABS_MT 事件定义在文件 include&#x2F;uapi&#x2F;linux&#x2F;input.h中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_mt_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span><span class="comment">//A型隔离触摸点的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_mt_slot</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">int</span> slot)</span><span class="comment">//B型区分触摸点数据</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对于 Type A 类型的设备，发送触摸点信息的时序*/</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]<span class="comment">//通过 ABS_MT_POSITION_X 事件上报第一个触摸点的 X 坐标数据</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]<span class="comment">//通过 ABS_MT_POSITION_Y 事件上报第一个触摸点的 Y 坐标数据。</span></span><br><span class="line">SYN_MT_REPORT<span class="comment">//上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]<span class="comment">//通过 ABS_MT_POSITION_X 事件上报第二个触摸点的 X 坐标数据。</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]<span class="comment">//通过 ABS_MT_POSITION_Y 事件上报第二个触摸点的 Y 坐标数据。</span></span><br><span class="line">SYN_MT_REPORT<span class="comment">//上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。</span></span><br><span class="line">SYN_REPORT<span class="comment">//上报 SYN_REPORT 事件，通过调用 input_sync 函数实现。</span></span><br><span class="line">    <span class="comment">/*对于 Type B 类型的设备，发送触摸点信息的时序*/</span></span><br><span class="line">ABS_MT_SLOT <span class="number">0</span><span class="comment">//上报 ABS_MT_SLOT 事件，也就是触摸点对应的 SLOT。</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">45</span><span class="comment">/*根据 Type B 的要求，每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。*/</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]<span class="comment">//上报触摸点 0 的 X 轴坐标，使用函数 input_report_abs 来完成</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]<span class="comment">//上报触摸点 0 的 Y 轴坐标</span></span><br><span class="line">ABS_MT_SLOT <span class="number">1</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">46</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]</span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]</span><br><span class="line">SYN_REPORT<span class="comment">//当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件，使用 input_sync函数来完成。</span></span><br></pre></td></tr></table></figure><p>以上是TypeA和B 类型的时序，使用多点触摸驱动的时候就需要以上的时序上报坐标信息。 </p><h3 id="多点触摸所使用到的-API-函数"><a href="#多点触摸所使用到的-API-函数" class="headerlink" title="多点触摸所使用到的 API 函数"></a>多点触摸所使用到的 API 函数</h3><ol><li><p>input_mt_init_slots 函数用于初始化 MT 的输入 slots，编写 MT 驱动的时候必须先调用此函数初始化 slots。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span><span class="title function_">input_mt_init_slots</span><span class="params">( <span class="keyword">struct</span> input_dev *dev,<span class="comment">//MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev。</span></span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> num_slots,<span class="comment">//设备要使用的 SLOT 数量，也就是触摸点的数量。</span></span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> flags)</span><span class="comment">//其他一些 flags 信息，</span></span><br></pre></td></tr></table></figure></li><li><p>input_mt_slot 函数 此函数用于 Type B 类型，此函数用于产生 ABS_MT_SLOT 事件，告诉内核当前上报的是哪个触摸点的坐标数据 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_mt_slot</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,<span class="type">int</span> slot)</span></span><br></pre></td></tr></table></figure></li><li><p>input_mt_report_slot_state 函数此函数用于 Type B 类型，用于产生 ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE事 件 ， ABS_MT_TRACKING_ID 事 件 给 slot 关 联 一 个 ABS_MT_TRACKING_ID ，ABS_MT_TOOL_TYPE 事 件 指 定 触 摸 类 型 （ 是 笔 还 是 手 指 等 ）。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_mt_report_slot_state</span><span class="params">( <span class="keyword">struct</span> input_dev *dev,<span class="type">unsigned</span> <span class="type">int</span> tool_type,<span class="type">bool</span> active)</span></span><br><span class="line"><span class="comment">/*dev： MT 设备对应的 input_dev。</span></span><br><span class="line"><span class="comment">tool_type：触摸类型，可以选择 MT_TOOL_FINGER(手指)、 MT_TOOL_PEN(笔)或</span></span><br><span class="line"><span class="comment">MT_TOOL_PALM(手掌)，对于多点电容触摸屏来说一般都是手指。</span></span><br><span class="line"><span class="comment">active： true，连续触摸， input 子系统内核会自动分配一个 ABS_MT_TRACKING_ID 给 slot。</span></span><br><span class="line"><span class="comment">false，触摸点抬起，表示某个触摸点无效了， input 子系统内核会分配一个-1 给 slot，表示触摸</span></span><br><span class="line"><span class="comment">点溢出。*/</span></span><br></pre></td></tr></table></figure></li><li><p>input_report_abs 函数Type A 和 Type B 类型都使用此函数上报触摸点坐标信息，通过 ABS_MT_POSITION_X 和ABS_MT_POSITION_Y 事 件 实 现 X 和 Y 轴 坐 标 信 息 上 报 。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_report_abs</span><span class="params">( <span class="keyword">struct</span> input_dev *dev,<span class="type">unsigned</span> <span class="type">int</span> code,<span class="type">int</span> value)</span></span><br><span class="line"><span class="comment">/*dev： MT 设备对应的 input_dev。</span></span><br><span class="line"><span class="comment">code：要上报的是什么数据，可以设置为 ABS_MT_POSITION_X 或 ABS_MT_POSITION_Y，</span></span><br><span class="line"><span class="comment">也就是 X 轴或者 Y 轴坐标数据。</span></span><br><span class="line"><span class="comment">value： 具体的 X 轴或 Y 轴坐标数据值*/</span></span><br></pre></td></tr></table></figure></li><li><p>input_mt_report_pointer_emulation 如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量，然后调用 input_mt_report_pointer_emulation 函数将use_count 参数设置为 false。否则的话将use_count 参数设置为 true，表示当前的触摸点数量(函数会获取到具体的触摸点数量，不需要用户给出) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_mt_report_pointer_emulation</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,<span class="type">bool</span> use_count)</span></span><br><span class="line"><span class="comment">/*dev： MT 设备对应的 input_dev。</span></span><br><span class="line"><span class="comment">use_count： true，有效的触摸点数量； false，追踪到的触摸点数量多于当前上报的数量。*/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="多点电容触摸驱动框架"><a href="#多点电容触摸驱动框架" class="headerlink" title="多点电容触摸驱动框架"></a>多点电容触摸驱动框架</h3><p>①、多点电容触摸芯片的接口，一般都为 I2C 接口，因此驱动主框架肯定是 I2C。<br>②、 linux 里面一般都是通过中断来上报触摸点坐标信息，因此需要用到中断框架。<br>③、多点电容触摸属于 input 子系统，因此还要用到 input 子系统框架。<br>④、在中断处理程序中按照 linux 的 MT 协议上报坐标信息。 </p><h4 id="IIC驱动框架"><a href="#IIC驱动框架" class="headerlink" title="IIC驱动框架"></a>IIC驱动框架</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">/* 设备树匹配表 */</span></span><br><span class="line"><span class="number">2</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">xxx_ts_id</span>[] =</span> &#123;</span><br><span class="line"><span class="number">3</span> &#123; <span class="string">&quot;xxx&quot;</span>, <span class="number">0</span>, &#125;,</span><br><span class="line"><span class="number">4</span> &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line"><span class="number">5</span> &#125;;</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span><span class="comment">/* 设备树匹配表 */</span></span><br><span class="line"><span class="number">8</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">xxx_of_match</span>[] =</span> &#123;</span><br><span class="line"><span class="number">9</span> &#123; .compatible = <span class="string">&quot;xxx&quot;</span>, &#125;,</span><br><span class="line"><span class="number">10</span> &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line"><span class="number">11</span> &#125;;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="comment">/* i2c 驱动结构体 */</span></span><br><span class="line"><span class="number">14</span> <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ft5x06_ts_driver</span> =</span> &#123;</span><br><span class="line"><span class="number">15</span> .driver = &#123;</span><br><span class="line"><span class="number">16</span> .owner = THIS_MODULE,</span><br><span class="line"><span class="number">17</span> .name = <span class="string">&quot;edt_ft5x06&quot;</span>,</span><br><span class="line"><span class="number">18</span> .of_match_table =of_match_ptr(xxx_of_match),</span><br><span class="line"><span class="number">19</span> &#125;,</span><br><span class="line"><span class="number">20</span> .id_table = xxx_ts_id,</span><br><span class="line"><span class="number">21</span> .probe = xxx_ts_probe,</span><br><span class="line"><span class="number">22</span> .remove = xxx_ts_remove,</span><br><span class="line"><span class="number">23</span> &#125;;</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">26 * @description : 驱动入口函数</span></span><br><span class="line"><span class="comment">27 * @param : 无</span></span><br><span class="line"><span class="comment">28 * @return : 无</span></span><br><span class="line"><span class="comment">29 */</span></span><br><span class="line"><span class="number">30</span> <span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">31 &#123;</span><br><span class="line"><span class="number">32</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">34</span> ret = i2c_add_driver(&amp;xxx_ts_driver);</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">36</span> <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">37</span> &#125;</span><br><span class="line"><span class="number">38</span></span><br><span class="line"><span class="number">39</span> <span class="comment">/*</span></span><br><span class="line"><span class="comment">40 * @description : 驱动出口函数</span></span><br><span class="line"><span class="comment">41 * @param : 无</span></span><br><span class="line"><span class="comment">42 * @return : 无</span></span><br><span class="line"><span class="comment">43 */</span></span><br><span class="line"><span class="number">44</span> <span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">45 &#123;</span><br><span class="line"><span class="number">46</span> i2c_del_driver(&amp;ft5x06_ts_driver);</span><br><span class="line"><span class="number">47</span> &#125;</span><br><span class="line"><span class="number">48</span></span><br><span class="line"><span class="number">49</span> module_init(xxx_init);</span><br><span class="line"><span class="number">50</span> module_exit(xxx_exit);</span><br><span class="line"><span class="number">51</span> MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="number">52</span> MODULE_AUTHOR(<span class="string">&quot;zuozhongkai&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="初始化触摸-IC、中断和-input-子系统"><a href="#初始化触摸-IC、中断和-input-子系统" class="headerlink" title="初始化触摸 IC、中断和 input 子系统"></a>初始化触摸 IC、中断和 input 子系统</h4><p>在probe函数中完成初始化中断，input等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_ts_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="params">i2c_device_id *id)</span></span><br><span class="line">2 &#123;</span><br><span class="line"><span class="number">3</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span>;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="comment">/* 1、初始化 I2C */</span></span><br><span class="line"><span class="number">6</span> ......</span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="comment">/* 2，申请中断， */</span></span><br><span class="line"><span class="number">9</span> devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="literal">NULL</span>,</span><br><span class="line"><span class="number">10</span> xxx_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line"><span class="number">11</span> client-&gt;name, &amp;xxx);</span><br><span class="line"><span class="number">12</span> ......</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="comment">/* 3， input 设备申请与初始化 */</span></span><br><span class="line"><span class="number">15</span> input = devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> input-&gt;name = client-&gt;name;</span><br><span class="line"><span class="number">18</span> input-&gt;id.bustype = BUS_I2C;</span><br><span class="line"><span class="number">19</span> input-&gt;dev.parent = &amp;client-&gt;dev;</span><br><span class="line"><span class="number">20</span> ......</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="comment">/* 4，初始化 input 和 MT */</span></span><br><span class="line"><span class="number">23</span> __set_bit(EV_ABS, input-&gt;evbit);</span><br><span class="line"><span class="number">24</span> __set_bit(BTN_TOUCH, input-&gt;keybit);</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span> input_set_abs_params(input, ABS_X, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">27</span> input_set_abs_params(input, ABS_Y, <span class="number">0</span>, height, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">28</span> input_set_abs_params(input, ABS_MT_POSITION_X,<span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">29</span> input_set_abs_params(input, ABS_MT_POSITION_Y,<span class="number">0</span>, height, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="number">30</span> input_mt_init_slots(input, MAX_SUPPORT_POINTS, <span class="number">0</span>);</span><br><span class="line"><span class="number">31</span> ......</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span> <span class="comment">/* 5，注册 input_dev */</span></span><br><span class="line"><span class="number">34</span> input_register_device(input);</span><br><span class="line"><span class="number">35</span> ......</span><br><span class="line"><span class="number">36</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="上报坐标信息"><a href="#上报坐标信息" class="headerlink" title="上报坐标信息"></a>上报坐标信息</h4><p>typeB时序的设备多，按照typeB的时序来进行抒写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">xxx_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">2 &#123;</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="type">int</span> num; <span class="comment">/* 触摸点数量 */</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> x[n], y[n]; <span class="comment">/* 保存坐标值 */</span></span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span><span class="comment">/* 1、从触摸芯片获取各个触摸点坐标值 */</span></span><br><span class="line"><span class="number">8</span> ......</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* 2、上报每一个触摸点坐标 */</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="number">12</span> input_mt_slot(input, id);</span><br><span class="line"><span class="number">13</span> input_mt_report_slot_state(input, MT_TOOL_FINGER, <span class="literal">true</span>);</span><br><span class="line"><span class="number">14</span> input_report_abs(input, ABS_MT_POSITION_X, x[i]);</span><br><span class="line"><span class="number">15</span> input_report_abs(input, ABS_MT_POSITION_Y, y[i]);</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> ......</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span> input_sync(input);</span><br><span class="line"><span class="number">20</span> ......</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"><span class="number">23</span> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-01%20203604.png"></p><h3 id="移植tslib库"><a href="#移植tslib库" class="headerlink" title="移植tslib库"></a>移植tslib库</h3><p>tslib 是一个开源的第三方库，用于触摸屏性能调试，使用电阻屏的时候一般使用 tslib 进行校准。虽然电容屏不需要校准，但是由于电容屏加工的原因，有的时候其不一定精准，因此有时候也需要进行校准。最主要的是 tslib 提供了一些其他软件，我们可以通过这些软件来测试触摸屏工作是否正常。最新版本的 tslib 已经支持了多点电容触摸屏，因此可以通过 tslib 来直观的测试多点电容触摸屏驱动，这个要比观看 eventX 原始数据方便的多。<br>tslib 的移植很简单，步骤如下：<br><strong>1、获取 tslib 源码</strong><br>首先肯定是获取 tslib 的源码， git 地址为 <a href="https://github.com/kergoth/tslib%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AF1.21%E3%80%82">https://github.com/kergoth/tslib，目前最新的版本是1.21。</a><br><strong>2、修改 tslib 源码所属用户</strong><br>修改解压得到的 tslib-1.21 目录所属用户为当前用户，这一步一定要做！否则在稍后的编译<br>中会遇到各种问题。我当前 ubuntu 的登录用户名为“moss”，那么修改命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown moss:moss tslib-1.21 -R</span><br></pre></td></tr></table></figure><p><strong>3、 ubuntu 工具安装</strong><br>编译 tslib 的时候需要先在 ubuntu 中安装一些文件，防止编译 tslib 过程中出错，命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf</span><br><span class="line">sudo apt-get install automake</span><br><span class="line">sudo apt-get install libtool</span><br></pre></td></tr></table></figure><p><strong>4、编译 tslib</strong><br>首先在 ubuntu 中创建一个名为“tslib”的目录存放编译结果，比如我们创建的 tslib 目录路径为： &#x2F;home&#x2F;zuozhongkai&#x2F;linux&#x2F;IMX6ULL&#x2F;tool&#x2F;tslib。<br>接下来输入如下命令配置并编译 tslib：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd tslib-1.21/ //进入 tslib 源码目录</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure --host=arm-linux-gnueabihf --prefix=/home/moss/linux/tool/tslib</span><br><span class="line">make //编译</span><br><span class="line">make install //安装</span><br></pre></td></tr></table></figure><p>注意，在使用.&#x2F;configure 配置 tslib 的时候“–host”参数指定编译器，“–prefix”参数指定编译完成以后的 tslib 文件安装到哪里，这里肯定是安装到我们刚刚创建的“tslib”目录下。<br>bin 目录下是可执行文件，包括 tslib 的测试工具。 etc 目录下是 tslib 的配置文件， lib 目录下是相关的库文件。将lib的所有文件拷贝到开发板的根文件系统中，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp * -rf /home/zuozhongkai/linux/nfs/rootfs</span><br></pre></td></tr></table></figure><p>5、 配置 tslib<br>打开&#x2F;etc&#x2F;ts.conf 文件，找到下面这一行：module_raw input<br>如果上面这句前面有“#”的话就删除掉“#”。打开&#x2F;etc&#x2F;profile 文件，在里面加入如下内容：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> export TSLIB_TSDEVICE=/dev/input/event2</span><br><span class="line"><span class="number">2</span> export TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line"><span class="number">3</span> export TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line"><span class="number">4</span> export TSLIB_PLUGINDIR=/lib/ts</span><br><span class="line"><span class="number">5</span> export TSLIB_CONSOLEDEVICE=none</span><br><span class="line"><span class="number">6</span> export TSLIB_FBDEVICE=/dev/fb0</span><br></pre></td></tr></table></figure><p>第 1 行， TSLIB_TSDEVICE 表示触摸设备文件，这里设置为&#x2F;dev&#x2F;input&#x2F;event2，这个要根据具体情况设置，如果你的触摸设备文件为 event2 那么就应该设置为&#x2F;dev&#x2F;input&#x2F;event2，以此类推。<br>第 2 行， TSLIB_CALIBFILE 表示校准文件，如果进行屏幕校准的话校准结果就保存在这个文件中，这里设置校准文件为&#x2F;etc&#x2F;pointercal， 此文件可以不存在，校准的时候会自动生成。<br>第 3 行， TSLIB_CONFFILE 表示触摸配置文件，文件为&#x2F;etc&#x2F;ts.conf，此文件在移植 tslib 的时候会生成。<br>第 4 行， TSLIB_PLUGINDIR 表示 tslib 插件目录位置，目录为&#x2F;lib&#x2F;ts。<br>第 5 行， TSLIB_CONSOLEDEVICE 表示控制台设置，这里不设置，因此为 none。<br>第 6 行， TSLIB_FBDEVICE 表示 FB 设备，也就是屏幕，根据实际情况配置，我的屏幕文件为&#x2F;dev&#x2F;fb0，因此这里设置为&#x2F;dev&#x2F;fb0。全部配置好以后重启开发板，然后就可以进行测试了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串口驱动</title>
      <link href="/2023/07/20/2023-7-20-%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/20/2023-7-20-%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="串口驱动程序层次结构"><a href="#串口驱动程序层次结构" class="headerlink" title="串口驱动程序层次结构"></a>串口驱动程序层次结构</h2><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-20%20203055.png"></p><p>下层为串口驱动层，它直接与硬件相接触，需要填充一个 struct uart_ops 的结构体。上层为tty层，包括tty核心层及线路规程，它们各自都有一个 ops 结构体，用户空间可以通过tty注册的字符设备节点来访问串口设备。涉及到了4个 ops 结构体，层层进行跳转。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-20%20194425.png"></p><p>uart_driver包含了串口设备名、串口驱动名、主次设备号、串口控制台(可选)等信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">module</span>  *<span class="title">owner</span>;</span> <span class="comment">//拥有该uart_driver的模块,一般为THIS_MODULE </span></span><br><span class="line">   constchar *driver_name; <span class="comment">// 串口驱动名，串口设备文件名以驱动名为基础 </span></span><br><span class="line">   constchar *dev_name; <span class="comment">// 串口设备名 </span></span><br><span class="line">   <span class="type">int</span> major; <span class="comment">//主设备号 </span></span><br><span class="line">   <span class="type">int</span> minor; <span class="comment">//次设备号 </span></span><br><span class="line">   <span class="type">int</span> nr; <span class="comment">// 该uart_driver支持的串口个数(最大) </span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">console</span>  *<span class="title">cons</span>;</span><span class="comment">// 其对应的console.若该uart_driver支持serial console,否则为NULL </span></span><br><span class="line">    .............................</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span>  *<span class="title">state</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span>  *<span class="title">tty_driver</span>;</span>   <span class="comment">//uart_driver封装了tty_driver，使底层uart驱动不用关心ttr_driver。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(1)一个tty驱动程序必须注册&#x2F;注销tty_driver。</p><p>(2)一个uart驱动则变为注册&#x2F;注销uart_driver。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uart_register_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_unregister_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_register_driver</span><span class="params">(<span class="keyword">struct</span> tty_driver *drv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tty_unregister_driver</span><span class="params">(<span class="keyword">struct</span> tty_driver *drv)</span>;</span><br></pre></td></tr></table></figure><p><em>uart_port用于描述一个UART端口（直接对应于一个串口）的I&#x2F;O端口或I&#x2F;O内存地址、FIFO大小、端口类型等信息。</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;<span class="comment">/* 串口端口锁 */</span></span><br><span class="line">unsignedint iobase;<span class="comment">/* IO端口基地址 */</span></span><br><span class="line">unsignedchar __iomem *membase;<span class="comment">/* IO内存基地址,经映射(如ioremap)后的IO内存虚拟基地址 */</span></span><br><span class="line">unsignedint irq;<span class="comment">/* 中断号 */</span></span><br><span class="line">unsignedint uartclk;<span class="comment">/* 串口时钟 */</span></span><br><span class="line">unsignedint fifosize;<span class="comment">/* 串口FIFO缓冲大小 */</span></span><br><span class="line">unsignedchar x_char;<span class="comment">/* xon/xoff字符 */</span></span><br><span class="line">unsignedchar regshift;<span class="comment">/* 寄存器位移 */</span></span><br><span class="line">unsignedchar iotype;<span class="comment">/* IO访问方式 */</span></span><br><span class="line">unsignedchar unused1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_PORT (0)<span class="comment">/* IO端口 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_HUB6 (1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM (2)<span class="comment">/* IO内存 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM32 (3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_AU (4)<span class="comment">/* Au1x00 type IO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_TSI (5)<span class="comment">/* Tsi108/109 type IO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_DWAPB (6)<span class="comment">/* DesignWare APB UART */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_RM9000 (7)<span class="comment">/* RM9000 type IO */</span></span></span><br><span class="line"></span><br><span class="line">unsignedint read_status_mask;<span class="comment">/* 关心的Rx error status */</span></span><br><span class="line">unsignedint ignore_status_mask;<span class="comment">/* 忽略的Rx error status */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_info</span> *<span class="title">info</span>;</span>        <span class="comment">//重要，见下面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_icount</span>  <span class="title">icount</span>;</span>   <span class="comment">/* 计数器 uart_icount为串口信息计数器，包含了发送字符计数、接收字符计数等。在串口的发送中断处理函数和接收中断处理函数中，我们需要管理这些计数。*/</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">cons</span>;</span><span class="comment">/* console结构体 */</span></span><br><span class="line">#ifdefCONFIG_SERIAL_CORE_CONSOLE</span><br><span class="line">unsignedlong sysrq;<span class="comment">/* sysrq timeout */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">upf_t</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_FOURPORT ((__forceupf_t)(1 &lt;&lt; 1))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SAK ((__forceupf_t)(1 &lt;&lt; 2))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_MASK ((__forceupf_t)(0x1030))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_HI ((__forceupf_t)(0x0010))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_VHI ((__forceupf_t)(0x0020))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_CUST ((__forceupf_t)(0x0030))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_SHI ((__forceupf_t)(0x1000))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SPD_WARP ((__forceupf_t)(0x1010))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SKIP_TEST ((__forceupf_t)(1 &lt;&lt; 6))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_AUTO_IRQ ((__forceupf_t)(1 &lt;&lt; 7))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_HARDPPS_CD ((__forceupf_t)(1 &lt;&lt; 11))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_LOW_LATENCY ((__forceupf_t)(1 &lt;&lt; 13))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_BUGGY_UART ((__forceupf_t)(1 &lt;&lt; 14))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_MAGIC_MULTIPLIER((__force upf_t)(1 &lt;&lt; 16))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_CONS_FLOW ((__forceupf_t)(1 &lt;&lt; 23))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_SHARE_IRQ ((__forceupf_t)(1 &lt;&lt; 24))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_BOOT_AUTOCONF ((__forceupf_t)(1 &lt;&lt; 28))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_FIXED_PORT ((__forceupf_t)(1 &lt;&lt; 29))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_DEAD ((__forceupf_t)(1 &lt;&lt; 30))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_IOREMAP ((__forceupf_t)(1 &lt;&lt; 31))</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_CHANGE_MASK ((__forceupf_t)(0x17fff))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UPF_USR_MASK ((__forceupf_t)(UPF_SPD_MASK|UPF_LOW_LATENCY))</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mctrl;<span class="comment">/* 当前的moden设置 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> timeout;<span class="comment">/* character-based timeout */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> type;<span class="comment">/* 端口类型 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> *<span class="title">ops</span>;</span><span class="comment">/* 串口端口操作函数集 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> custom_divisor;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  line;<span class="comment">/* 端口索引 */</span></span><br><span class="line">    <span class="type">resource_size_t</span> mapbase;<span class="comment">/* IO内存物理基地址，可用于ioremap */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span><span class="comment">/* 父设备 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hub6;<span class="comment">/* this should be in the 8250 driver */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> suspended;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> unused[<span class="number">2</span>];</span><br><span class="line">    <span class="type">void</span>*private_data;<span class="comment">/* 端口私有数据,一般为platform数据指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPI驱动</title>
      <link href="/2023/07/18/2023-7-18-SPI%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/18/2023-7-18-SPI%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-18%20202734.png"></p><h3 id="SPI-控制器驱动程序"><a href="#SPI-控制器驱动程序" class="headerlink" title="SPI 控制器驱动程序"></a><strong>SPI 控制器驱动程序</strong></h3><p><strong>SPI 主机驱动就是 SOC 的 SPI 控制器驱动，</strong>SPI 控制器不用关心设备的具体功能，它只负责把上层协议驱动准备好的数据按 SPI 总线的时序要求发送给 SPI 设备，同时把从设备收到的数据返回给上层的协议驱动，因此，内核把 SPI 控制器的驱动程序独立出来。</p><p>SPI 控制器驱动负责控制具体的控制器硬件，诸如 DMA 和中断操作等等，因为多个上层的协议驱动可能会通过控制器请求数据传输操作，所以，SPI 控制器驱动同时也要负责对这些请求进行队列管理，保证先进先出的原则。</p><ol><li><p>申请必要的硬件资源，比如中断、DMA 通道、DMA 内存缓冲区等等</p></li><li><p>配置 SPI 控制器的工作模式和参数，使之可以和相应的设备进行正确的数据交换</p></li><li><p>向通用接口层提供接口，使得上层的协议驱动可以通过通用接口层访问控制器驱动</p></li><li><p>配合通用接口层，完成数据消息队列的排队和处理，直到消息队列变空为止</p></li></ol><p><strong>SPI 主机驱动的核心就是申请 spi_master，然后初始化 spi_master，最后向 Linux 内核注册spi_master。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spi_alloc_master 函数：申请 spi_master。</span><br><span class="line">spi_master_put 函数：释放 spi_master。</span><br><span class="line"></span><br><span class="line">spi_register_master函数：注册 spi_master。</span><br><span class="line">spi_unregister_master 函数：注销 spi_master。</span><br><span class="line"></span><br><span class="line">spi_bitbang_start函数：注册 spi_master。</span><br><span class="line">spi_bitbang_stop 函数：注销 spi_master</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-18%20201838.png"></p><h3 id="SPI-通用接口封装层"><a href="#SPI-通用接口封装层" class="headerlink" title="SPI 通用接口封装层"></a><strong>SPI 通用接口封装层</strong></h3><p>为了简化 SPI 驱动程序的编程工作，同时也为了降低【协议驱动程序】和【控制器驱动程序】的耦合程度，内核把控制器驱动和协议驱动的一些通用操作封装成标准的接口，加上一些通用的逻辑处理操作，组成了 SPI 通用接口封装层。</p><p>这样的好处是，对于控制器驱动程序，只要实现标准的接口回调 API，并把它注册到通用接口层即可，无需直接和协议层驱动程序进行交互。而对于协议层驱动来说，只需通过通用接口层提供的 API 即可完成设备和驱动的注册，并通过通用接口层的 API 完成数据的传输，无需关注 SPI 控制器驱动的实现细节。</p><ol><li><p>SPI 通用接口层把具体的 SPI 设备的协议驱动和 SPI 控制器驱动连接在一起。</p></li><li><p>负责 SPI 系统与 Linux 设备模型相关的初始化工作。</p></li><li><p>为协议驱动和控制器驱动提供一系列的标准接口 API 及其数据结构。</p></li><li><p>SPI 设备、SPI 协议驱动、SPI 控制器的数据抽象</p></li><li><p>协助数据传输而定义的数据结构</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重要数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>//描述一个 <span class="title">spi</span> 从机设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span>//描述一个 <span class="title">spi</span> 设备驱动</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_board_info</span>//描述一个 <span class="title">spi</span> 从机设备板级信息，无设备树时使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>/<span class="title">spi_master</span>//描述一个 <span class="title">spi</span> 主机设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>//描述 <span class="title">spi</span> 传输的具体数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span>//描述一次 <span class="title">spi</span> 传输的信息，是一次 <span class="title">SPI</span> 数据交换的原子操作</span></span><br><span class="line"><span class="class">//重要<span class="title">API</span></span></span><br><span class="line"><span class="class"><span class="title">spi_message_init</span></span></span><br><span class="line"><span class="class"><span class="title">spi_message_add_tail</span></span></span><br><span class="line"><span class="class"><span class="title">spi_sync</span></span></span><br><span class="line"><span class="class"><span class="title">spi_async</span></span></span><br><span class="line"><span class="class"><span class="title">spi_write</span></span></span><br><span class="line"><span class="class"><span class="title">spi_read</span></span></span><br></pre></td></tr></table></figure><h3 id="SPI-协议驱动程序"><a href="#SPI-协议驱动程序" class="headerlink" title="SPI 协议驱动程序"></a><strong>SPI 协议驱动程序</strong></h3><p>SPI 设备的具体功能是由 SPI 协议驱动程序完成的，SPI 协议驱动程序了解设备的功能和通信数据的协议格式。向下，协议驱动通过通用接口层和控制器交换数据，向上，协议驱动通常会根据设备具体的功能和内核的其它子系统进行交互。</p><p>例如，和 MTD 层交互以便把 SPI 接口的存储设备实现为某个文件系统，和 TTY 子系统交互把 SPI 设备实现为一个 TTY 设备，和网络子系统交互以便把一个 SPI 设备实现为一个网络设备。如果是一个专有的 SPI 设备，我们也可以按设备的协议要求，实现自己的专有协议驱动。</p><h3 id="SPI-通用设备驱动程序"><a href="#SPI-通用设备驱动程序" class="headerlink" title="SPI 通用设备驱动程序"></a><strong>SPI 通用设备驱动程序</strong></h3><p>考虑到连接在 SPI 控制器上的设备的可变性，在内核没有配备相应的协议驱动程序，对于这种情况，内核为我们准备了通用的 SPI 设备驱动程序，该通用设备驱动程序向用户空间提供了控制 SPI 控制的控制接口，具体的协议控制和数据传输工作交由用户空间根据具体的设备来完成，在这种方式中，只能采用同步的方式和 SPI 设备进行通信，所以通常用于一些数据量较少的简单 SPI 设备。</p><p>在Linux内核中spi的函数存放位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel<span class="number">-4.15</span>/drivers/spi/spi.c  Linux 提供的通用接口封装层驱动</span><br><span class="line">kernel<span class="number">-4.15</span>/drivers/spi/spidev.c  linux 提供的 SPI 通用设备驱动程序</span><br><span class="line">kernel<span class="number">-4.15</span>/include/linux/spi/spi.h  linux 提供的包含 SPI 的主要数据结构和函数</span><br></pre></td></tr></table></figure><p><strong>SPI 数据传输可以有两种方式：同步方式和异步方式。</strong></p><p>同步方式：数据传输的发起者必须等待本次传输的结束，期间不能做其它事情，用代码来解释就是，调用传输的函数后，直到数据传输完成，函数才会返回。</p><p>异步方式：数据传输的发起者无需等待传输的结束，数据传输期间还可以做其它事情，用代码来解释就是，调用传输的函数后，函数会立刻返回而不用等待数据传输完成，我们只需设置一个回调函数，传输完成后，该回调函数会被调用以通知发起者数据传送已经完成。</p><p>spi_async函数是发起一个异步传输的API，它会把spi_message结构挂在spi_master的queue字段下，然后启动专门为spi传输准备的内核工作线程，由该工作线程来实际处理message的传输工作，因为是异步操作，所以该函数会立刻返回，不会等待传输的完成，这时，协议驱动程序（可能是另一个协议驱动程序）可以再次调用该API，发起另一个message传输请求，结果就是，当工作线程被唤醒时，spi_master下面可能已经挂了多个待处理的spi_message结构，工作线程会按先进先出的原则来逐个处理这些message请求，每个message传送完成后，对应spi_message结构的complete回调函数就会被调用，以通知协议驱动程序准备下一帧数据。这就是spi_message的队列化。工作线程唤醒时，spi_master、spi_message和spi_transfer之间的关系可以用下图来描述：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-18%20200811.png"></p><h3 id="SPI驱动结构"><a href="#SPI驱动结构" class="headerlink" title="SPI驱动结构"></a>SPI驱动结构</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-18%20204137.png"></p><p>spi_driver 注册示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* probe 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 具体函数内容 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* remove 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 具体函数内容 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 传统匹配方式 ID 列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">xxx_id</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;xxx&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">xxx_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;xxx&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI 驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">xxx_driver</span> =</span> &#123;</span><br><span class="line">.probe = xxx_probe,</span><br><span class="line">.remove = xxx_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.name = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">.of_match_table = xxx_of_match,</span><br><span class="line">&#125;,</span><br><span class="line">.id_table = xxx_id,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> spi_register_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">spi_unregister_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure><h3 id="设备驱动的编写流程"><a href="#设备驱动的编写流程" class="headerlink" title="设备驱动的编写流程"></a>设备驱动的编写流程</h3><p>SPI使用的API函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">603</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span></span><br><span class="line"><span class="number">604</span> <span class="comment">/* it&#x27;s ok if tx_buf == rx_buf (right?)</span></span><br><span class="line"><span class="comment">605 * for MicroWire, one buffer must be null</span></span><br><span class="line"><span class="comment">606 * buffers must work with dma_*map_single() calls, unless</span></span><br><span class="line"><span class="comment">607 * spi_message.is_dma_mapped reports a pre-existing mapping</span></span><br><span class="line"><span class="comment">608 */</span></span><br><span class="line"><span class="number">609</span> <span class="type">const</span> <span class="type">void</span> *tx_buf;<span class="comment">//发送数据</span></span><br><span class="line"><span class="number">610</span> <span class="type">void</span> *rx_buf;<span class="comment">//接收数据</span></span><br><span class="line"><span class="number">611</span> <span class="type">unsigned</span> len;<span class="comment">//len 是要进行传输的数据长度</span></span><br><span class="line"><span class="number">612</span></span><br><span class="line"><span class="number">613</span> <span class="type">dma_addr_t</span> tx_dma;</span><br><span class="line"><span class="number">614</span> <span class="type">dma_addr_t</span> rx_dma;</span><br><span class="line"><span class="number">615</span> <span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">tx_sg</span>;</span></span><br><span class="line"><span class="number">616</span> <span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">rx_sg</span>;</span></span><br><span class="line"><span class="number">617</span></span><br><span class="line"><span class="number">618</span> <span class="type">unsigned</span> cs_change:<span class="number">1</span>;</span><br><span class="line"><span class="number">619</span> <span class="type">unsigned</span> tx_nbits:<span class="number">3</span>;</span><br><span class="line"><span class="number">620</span> <span class="type">unsigned</span> rx_nbits:<span class="number">3</span>;</span><br><span class="line"><span class="number">621</span> <span class="meta">#<span class="keyword">define</span> SPI_NBITS_SINGLE 0x01 <span class="comment">/* 1bit transfer */</span></span></span><br><span class="line"><span class="number">622</span> <span class="meta">#<span class="keyword">define</span> SPI_NBITS_DUAL 0x02 <span class="comment">/* 2bits transfer */</span></span></span><br><span class="line"><span class="number">623</span> <span class="meta">#<span class="keyword">define</span> SPI_NBITS_QUAD 0x04 <span class="comment">/* 4bits transfer */</span></span></span><br><span class="line"><span class="number">624</span> u8 bits_per_word;</span><br><span class="line"><span class="number">625</span> u16 delay_usecs;</span><br><span class="line"><span class="number">626</span> u32 speed_hz;</span><br><span class="line"><span class="number">627</span></span><br><span class="line"><span class="number">628</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfer_list</span>;</span></span><br><span class="line"><span class="number">629</span> &#125;;</span><br></pre></td></tr></table></figure><p>spi_transfer 需要组织成 spi_message， spi_message 也是一个结构体 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> &#123;</span></span><br><span class="line"><span class="number">661</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfers</span>;</span></span><br><span class="line"><span class="number">662</span></span><br><span class="line"><span class="number">663</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span>;</span></span><br><span class="line"><span class="number">664</span></span><br><span class="line"><span class="number">665</span> <span class="type">unsigned</span> is_dma_mapped:<span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">678</span> <span class="comment">/* completion is reported through a callback */</span></span><br><span class="line"><span class="number">679</span> <span class="type">void</span> (*complete)(<span class="type">void</span> *context);</span><br><span class="line"><span class="number">680</span> <span class="type">void</span> *context;</span><br><span class="line"><span class="number">681</span> <span class="type">unsigned</span> frame_length;</span><br><span class="line"><span class="number">682</span> <span class="type">unsigned</span> actual_length;</span><br><span class="line"><span class="number">683</span> <span class="type">int</span> status;</span><br><span class="line"><span class="number">684</span></span><br><span class="line"><span class="number">685</span> <span class="comment">/* for optional use by whatever driver currently owns the</span></span><br><span class="line"><span class="comment">686 * spi_message ... between calls to spi_async and then later</span></span><br><span class="line"><span class="comment">687 * complete(), that&#x27;s the spi_master controller driver.</span></span><br><span class="line"><span class="comment">688 */</span></span><br><span class="line"><span class="number">689</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>;</span></span><br><span class="line"><span class="number">690</span> <span class="type">void</span> *state;</span><br><span class="line"><span class="number">691</span> &#125;;</span><br></pre></td></tr></table></figure><p>在使用spi_message之前需要对其进行初始化， spi_message初始化函数为spi_message_init，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spi_message_init</span><span class="params">(<span class="keyword">struct</span> spi_message *m)</span></span><br><span class="line"><span class="comment">/*m： 要初始化的 spi_message。</span></span><br><span class="line"><span class="comment">返回值： 无。*/</span></span><br></pre></td></tr></table></figure><p>spi_message 初始化完成以后需要将 spi_transfer 添加到 spi_message 队列中，这里我们要用到 spi_message_add_tail 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spi_message_add_tail</span><span class="params">(<span class="keyword">struct</span> spi_transfer *t, <span class="keyword">struct</span> spi_message *m)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">t： 要添加到队列中的 spi_transfer。</span></span><br><span class="line"><span class="comment">m： spi_transfer 要加入的 spi_message。</span></span><br><span class="line"><span class="comment">返回值： 无。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>spi_message 准备好以后就可以进行数据传输了，数据传输分为同步传输和异步传输，<strong>同步传输会阻塞的等待 SPI 数据传输完成</strong>，同步传输函数为 spi_sync，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_sync</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *message)</span></span><br><span class="line"><span class="comment">/*spi： 要进行数据传输的 spi_device。</span></span><br><span class="line"><span class="comment">message：要传输的 spi_message。</span></span><br><span class="line"><span class="comment">返回值： 无。*/</span></span><br></pre></td></tr></table></figure><p><strong>异步传输不会阻塞的等到 SPI 数据传输完成</strong>，异步传输需要设置 spi_message 中的 complete成员变量， complete 是一个回调函数，当 SPI 异步传输完成以后此函数就会被调用。 SPI 异步传输函数为 spi_async。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_async</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *message)</span></span><br><span class="line"><span class="comment">/*spi： 要进行数据传输的 spi_device。</span></span><br><span class="line"><span class="comment">message：要传输的 spi_message。</span></span><br><span class="line"><span class="comment">返回值： 无。 */</span></span><br></pre></td></tr></table></figure><p>同步传输通过 SPI 进行 n 个字节的数据发送和接收的示例代码 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPI 多字节发送 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_send</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, u8 *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> <span class="title">t</span> =</span> &#123;</span><br><span class="line">.tx_buf = buf,</span><br><span class="line">.len = len,</span><br><span class="line">&#125;;</span><br><span class="line">spi_message_init(&amp;m); <span class="comment">/* 初始化 spi_message */</span></span><br><span class="line">spi_message_add_tail(t, &amp;m);<span class="comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span></span><br><span class="line">ret = spi_sync(spi, &amp;m); <span class="comment">/* 同步传输 */</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* SPI 多字节接收 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_receive</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, u8 *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> <span class="title">t</span> =</span> &#123;</span><br><span class="line">.rx_buf = buf,</span><br><span class="line">.len = len,</span><br><span class="line">&#125;;</span><br><span class="line">spi_message_init(&amp;m); <span class="comment">/* 初始化 spi_message */</span></span><br><span class="line">spi_message_add_tail(t, &amp;m);<span class="comment">/* 将 spi_transfer 添加到 spi_message 队列 */</span></span><br><span class="line">ret = spi_sync(spi, &amp;m); <span class="comment">/* 同步传输 */</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下的IIC</title>
      <link href="/2023/07/18/2023-7-18-linux%E4%B8%8B%E7%9A%84IIC/"/>
      <url>/2023/07/18/2023-7-18-linux%E4%B8%8B%E7%9A%84IIC/</url>
      
        <content type="html"><![CDATA[<h1 id="linux的IIC体系结构"><a href="#linux的IIC体系结构" class="headerlink" title="linux的IIC体系结构"></a>linux的IIC体系结构</h1><p>Linux的IIC体系结构分为3个组成部分，分别是IIC核心、IIC总线驱动和IIC设备驱动！</p><p>（1）IIC核心</p><p>提供了IIC总线驱动与IIC设备驱动的注册、注销方法和与具体IIC控制器无关的代码，该部分用来管理IIC总线驱动与IIC设备驱动。</p><p>（2）IIC总线驱动</p><p>IIC总线驱动是适配器（IIC控制器）的驱动程序，包含了适配器（IIC控制器）的数据描述结构i2c_adapter、通信方法数据结构i2c_algorithm、控制适配器产生通信时序的函数。</p><p>（3）IIC设备驱动</p><p>是具体IIC设备的驱动，因为不同的IIC设备可能有不同的读写时序要求，比如at24cxx读写需要发送16位地址，而tmp75只需要8位地址即可。IIC设备驱动通过i2c_algorithm通信方法驱动适配器驱动程序去访问具体的IIC设备。</p><p>体系结构</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-19%20205901.png"></p><h2 id="架构层次分类"><a href="#架构层次分类" class="headerlink" title="架构层次分类"></a>架构层次分类</h2><p>　　<strong>第一层</strong>：提供i2c adapter的硬件驱动，探测、初始化i2c adapter（如申请i2c的io地址和中断号），驱动soc控制的i2c adapter在硬件上产生信号（start、stop、ack）以及处理i2c中断。图中的硬件实现控制层。</p><p>　　<strong>第二层：</strong>提供i2c adapter的algorithm，用具体适配器的xxx_xfer()函数来填充i2c_algorithm的master_xfer函数指针，并把赋值后的i2c_algorithm再赋值给i2c_adapter的algo指针。图中的访问抽象层。</p><p>　　<strong>第三层：</strong>实现i2c设备驱动中的i2c_driver接口，用具体的i2c device设备的probe()、remove()方法赋值给i2c_driver的成员函数指针。实现设备device与总线（或者叫adapter）的匹配挂接。图中的driver驱动层。</p><p>　　<strong>第四层：</strong>实现i2c设备所对应的具体device的驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则是千差万别的，所以要实现具体设备device的write()、read()、ioctl()等方法，赋值给file_operations，然后注册字符设备（多数是字符设备）。也是图中的driver驱动层。</p><p>​       <strong>第一层和第二层属于i2c总线驱动(bus)（芯片厂商写），第三第四属于i2c设备驱动(device driver)（驱动工程师来写）。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC驱动</title>
      <link href="/2023/07/14/2023-7-14-IIC%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/14/2023-7-14-IIC%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="IIC驱动框架"><a href="#IIC驱动框架" class="headerlink" title="IIC驱动框架"></a>IIC驱动框架</h3><p>Linux内核将 I2C 驱动分为两部分：<br>①、 I2C 总线驱动， I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。<br>②、 I2C 设备驱动， I2C 设备驱动就是针对具体的 I2C 设备而编写的驱动。 </p><p>IIC驱动也是借用platform思想，将设备和总线进行分离，但是IIC有自己的总线，所以就不用使用虚拟总线。</p><p>I2C 总线驱动重点是 I2C 适配器(也就是 SOC 的 I2C 接口控制器)驱动，这里要用到两个重要的数据结构： i2c_adapter 和 i2c_algorithm， Linux 内核将 SOC 的 I2C 适配器(控制器)抽象成 i2c_adapter， i2c_adapter 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">498</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line"><span class="number">499</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="number">500</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span> <span class="comment">/* classes to allow probing for */</span></span><br><span class="line"><span class="number">501</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* 总线访问算法 */</span></span><br><span class="line"><span class="number">502</span> <span class="type">void</span> *algo_data;</span><br><span class="line"><span class="number">503</span></span><br><span class="line"><span class="number">504</span> <span class="comment">/* data fields that are valid for all devices */</span></span><br><span class="line"><span class="number">505</span> <span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line"><span class="number">506</span></span><br><span class="line"><span class="number">507</span> <span class="type">int</span> timeout; <span class="comment">/* in jiffies */</span></span><br><span class="line"><span class="number">508</span> <span class="type">int</span> retries;</span><br><span class="line"><span class="number">509</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span> <span class="comment">/* the adapter device */</span></span><br><span class="line"><span class="number">510</span></span><br><span class="line"><span class="number">511</span> <span class="type">int</span> nr;</span><br><span class="line"><span class="number">512</span> <span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line"><span class="number">513</span> <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"><span class="number">514</span></span><br><span class="line"><span class="number">515</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line"><span class="number">516</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line"><span class="number">517</span></span><br><span class="line"><span class="number">518</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line"><span class="number">519</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line"><span class="number">520</span> &#125;;</span><br></pre></td></tr></table></figure><p> i2c_algorithm 就是 I2C 适配器与 IIC 设备进行通信的方法。i2c_algorithm 结构体定义在 include&#x2F;linux&#x2F;i2c.h 文件中 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">391</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">......</span><br><span class="line"><span class="number">398</span> <span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap,<span class="keyword">struct</span> i2c_msg *msgs,<span class="type">int</span> num);</span><br><span class="line"><span class="number">399</span> <span class="comment">//master_xfer 就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之间的通信。</span></span><br><span class="line"><span class="number">400</span> <span class="type">int</span> (*smbus_xfer) (<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,<span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line"><span class="number">401</span> u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"><span class="number">402</span> <span class="comment">//smbus_xfer 就是 SMBUS 总线的传输函数</span></span><br><span class="line"><span class="number">403</span></span><br><span class="line"><span class="number">404</span> <span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line"><span class="number">405</span> u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line">......</span><br><span class="line"><span class="number">411</span> &#125;;</span><br></pre></td></tr></table></figure><p><strong>I2C 总线驱动，或者说 I2C 适配器驱动的主要工作就是初始化 i2c_adapter 结构体变量，然后设置 i2c_algorithm 中的 master_xfer 函数。完成以后通过 i2c_add_numbered_adapter或 i2c_add_adapter 这两个函数向系统注册设置好的 i2c_adapter</strong>，这两个函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span><span class="comment">//使用动态的总线号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_numbered_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span> <span class="comment">//使用静态的总线号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter * adap)</span><span class="comment">//删除 I2C 适配器</span></span><br></pre></td></tr></table></figure><h3 id="I2C-设备驱动"><a href="#I2C-设备驱动" class="headerlink" title="I2C 设备驱动"></a>I2C 设备驱动</h3><p>I2C 描写设备驱动，类似platform，分为描述设备的i2c_client和描述驱动内容的i2c_driver</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">217</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line"><span class="number">218</span> <span class="type">unsigned</span> <span class="type">short</span> flags; <span class="comment">/* 标志 */</span></span><br><span class="line"><span class="number">219</span> <span class="type">unsigned</span> <span class="type">short</span> addr; <span class="comment">/* 芯片地址， 7 位，存在低 7 位*/</span></span><br><span class="line">......</span><br><span class="line"><span class="number">222</span> <span class="type">char</span> name[I2C_NAME_SIZE]; <span class="comment">/* 名字 */</span></span><br><span class="line"><span class="number">223</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span> <span class="comment">/* 对应的 I2C 适配器 */</span></span><br><span class="line"><span class="number">224</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span> <span class="comment">/* 设备结构体 */</span></span><br><span class="line"><span class="number">225</span> <span class="type">int</span> irq; <span class="comment">/* 中断 */</span></span><br><span class="line"><span class="number">226</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="number">230</span> &#125;;</span><br><span class="line"><span class="comment">//一个设备对应一个 i2c_client，每检测到一个 I2C 设备就会给这个 I2C 设备分配一个i2c_client。</span></span><br><span class="line"></span><br><span class="line"><span class="number">161</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line"><span class="number">162</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"><span class="number">163</span></span><br><span class="line"><span class="number">164</span> <span class="comment">/* Notifies the driver that a new bus has appeared. You should</span></span><br><span class="line"><span class="comment">165 * avoid using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">166 */</span></span><br><span class="line"><span class="number">167</span> <span class="type">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;</span><br><span class="line"><span class="number">168</span></span><br><span class="line"><span class="number">169</span> <span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line"><span class="number">170</span> <span class="type">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *);<span class="comment">//当 I2C 设备和驱动匹配成功以后 probe 函数就会执行</span></span><br><span class="line"><span class="number">171</span> <span class="type">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"><span class="number">172</span></span><br><span class="line"><span class="number">173</span> <span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration */</span></span><br><span class="line"><span class="number">174</span> <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"><span class="number">175</span></span><br><span class="line"><span class="number">176</span> <span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">177 * The format and meaning of the data value depends on the</span></span><br><span class="line"><span class="comment">178 * protocol.For the SMBus alert protocol, there is a single bit</span></span><br><span class="line"><span class="comment">179 * of data passed as the alert response&#x27;s low bit (&quot;event</span></span><br><span class="line"><span class="comment">180 flag&quot;). */</span></span><br><span class="line"><span class="number">181</span> <span class="type">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="type">unsigned</span> <span class="type">int</span> data);</span><br><span class="line"><span class="number">182</span></span><br><span class="line"><span class="number">183</span> <span class="comment">/* a ioctl like command that can be used to perform specific</span></span><br><span class="line"><span class="comment">184 * functions with the device.</span></span><br><span class="line"><span class="comment">185 */</span></span><br><span class="line"><span class="number">186</span> <span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd,<span class="type">void</span> *arg);</span><br><span class="line"><span class="number">187</span></span><br><span class="line"><span class="number">188</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span><span class="comment">//使用设备树需要设置 device_driver 的of_match_table 成员变量</span></span><br><span class="line"><span class="number">189</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span><span class="comment">//id_table 是传统的、未使用设备树的设备匹配 ID 表</span></span><br><span class="line"><span class="number">190</span></span><br><span class="line"><span class="number">191</span> <span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line"><span class="number">192</span> <span class="type">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *);</span><br><span class="line"><span class="number">193</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list;</span><br><span class="line"><span class="number">194</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span></span><br><span class="line"><span class="number">195</span> &#125;;</span><br></pre></td></tr></table></figure><p>i2c_driver 的注册示例代码如下 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* i2c 驱动的 probe 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client,<span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 函数具体程序 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c 驱动的 remove 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 函数具体程序 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 传统匹配方式 ID 列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">xxx_id</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;xxx&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;&#125;<span class="comment">//空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">xxx_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;xxx&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c 驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">xxx_driver</span> =</span> &#123;</span><br><span class="line">.probe = xxx_probe,</span><br><span class="line">.remove = xxx_remove,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.name = <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">.of_match_table = xxx_of_match,</span><br><span class="line">&#125;,</span><br><span class="line"> .id_table = xxx_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = i2c_add_driver(&amp;xxx_driver);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 驱动出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">i2c_del_driver(&amp;xxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(xxx_init);</span><br><span class="line">module_exit(xxx_exit);</span><br></pre></td></tr></table></figure><h3 id="I2C-设备和驱动匹配过程"><a href="#I2C-设备和驱动匹配过程" class="headerlink" title="I2C 设备和驱动匹配过程"></a>I2C 设备和驱动匹配过程</h3><p>I2C 设备和驱动的匹配过程是由 I2C 核心来完成的， drivers&#x2F;i2c&#x2F;i2c-core.c 就是 I2C 的核心<br>部分， I2C 核心提供了一些与具体硬件无关的 API 函数，比如前面讲过的：</p><p>i2c_adapter 注册&#x2F;注销函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_numbered_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter * adap)</span></span><br></pre></td></tr></table></figure><p>i2c_driver 注册&#x2F;注销函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_register_driver</span><span class="params">(<span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_driver</span> <span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_driver</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span></span><br></pre></td></tr></table></figure><p>设备和驱动的匹配过程也是由 I2C 总线完成的， </p><p>I2C 总线的数据结构为 i2c_bus_type，定义在 drivers&#x2F;i2c&#x2F;i2c-core.c 文件， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">.name = <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">.match = i2c_device_match,</span><br><span class="line">.probe = i2c_device_probe,</span><br><span class="line">.remove = i2c_device_remove,</span><br><span class="line">.shutdown = i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>I2C 总线的设备和驱动匹配函数，在这里就是 i2c_device_match 这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">457</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">458 &#123;</span><br><span class="line"><span class="number">459</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line"><span class="number">460</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line"><span class="number">461</span></span><br><span class="line"><span class="number">462</span> <span class="keyword">if</span> (!client)</span><br><span class="line"><span class="number">463</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">464</span></span><br><span class="line"><span class="number">465</span> <span class="comment">/* Attempt an OF style match */</span></span><br><span class="line"><span class="number">466</span> <span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line"><span class="number">467</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">468</span></span><br><span class="line"><span class="number">469</span> <span class="comment">/* Then ACPI style match */</span></span><br><span class="line"><span class="number">470</span> <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line"><span class="number">471</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">472</span></span><br><span class="line"><span class="number">473</span> driver = to_i2c_driver(drv);</span><br><span class="line"><span class="number">474</span> <span class="comment">/* match on an id table if there is one */</span></span><br><span class="line"><span class="number">475</span> <span class="keyword">if</span> (driver-&gt;id_table)</span><br><span class="line"><span class="number">476</span> <span class="keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">477</span></span><br><span class="line"><span class="number">478</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">479</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="分析驱动流程"><a href="#分析驱动流程" class="headerlink" title="分析驱动流程"></a>分析驱动流程</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-14%20191536.png"></p><p>当设备和驱动匹配成功以后 i2c_imx_probe 函数就会执行 ，由此分析i2c_imx_probe的执行函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">971</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">972 &#123;</span><br><span class="line"><span class="number">973</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span> =</span></span><br><span class="line"><span class="number">974</span> of_match_device(i2c_imx_dt_ids, &amp;pdev-&gt;dev);</span><br><span class="line"><span class="number">975</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span>;</span></span><br><span class="line"><span class="number">976</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line"><span class="number">977</span> <span class="class"><span class="keyword">struct</span> <span class="title">imxi2c_platform_data</span> *<span class="title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);<span class="comment">//获取成员变量</span></span><br><span class="line"><span class="number">978</span> <span class="type">void</span> __iomem *base;</span><br><span class="line"><span class="number">979</span> <span class="type">int</span> irq, ret;</span><br><span class="line"><span class="number">980</span> <span class="type">dma_addr_t</span> phy_addr;</span><br><span class="line"><span class="number">981</span></span><br><span class="line"><span class="number">982</span> dev_dbg(&amp;pdev-&gt;dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"><span class="number">983</span></span><br><span class="line"><span class="number">984</span> irq = platform_get_irq(pdev, <span class="number">0</span>);<span class="comment">//获取中断号</span></span><br><span class="line">......</span><br><span class="line"><span class="number">990</span> res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);<span class="comment">//从设备树获取寄存器物理基地址</span></span><br><span class="line"><span class="number">991</span> base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line"><span class="number">992</span> <span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line"><span class="number">993</span> <span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line"><span class="number">994</span></span><br><span class="line"><span class="number">995</span> phy_addr = (<span class="type">dma_addr_t</span>)res-&gt;start;</span><br><span class="line"><span class="number">996</span> i2c_imx = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*i2c_imx),GFP_KERNEL);<span class="comment">//申请内存</span></span><br><span class="line"><span class="number">997</span> <span class="keyword">if</span> (!i2c_imx)</span><br><span class="line"><span class="number">998</span> <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="number">999</span></span><br><span class="line"><span class="number">1000</span> <span class="keyword">if</span> (of_id)</span><br><span class="line"><span class="number">1001</span> i2c_imx-&gt;hwdata = of_id-&gt;data;</span><br><span class="line"><span class="number">1002</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">1003</span> i2c_imx-&gt;hwdata = (<span class="keyword">struct</span> imx_i2c_hwdata *)platform_get_device_id(pdev)-&gt;driver_data;</span><br><span class="line"><span class="number">1004</span> </span><br><span class="line"><span class="number">1005</span></span><br><span class="line"><span class="number">1006</span> <span class="comment">/* Setup i2c_imx driver structure */</span></span><br><span class="line"><span class="number">1007</span> strlcpy(i2c_imx-&gt;adapter.name, pdev-&gt;name,<span class="keyword">sizeof</span>(i2c_imx-&gt;adapter.name));</span><br><span class="line"><span class="number">1008</span> i2c_imx-&gt;adapter.owner = THIS_MODULE;<span class="comment">//初始化i2c_adapter</span></span><br><span class="line"><span class="number">1009</span> i2c_imx-&gt;adapter.algo = &amp;i2c_imx_algo;</span><br><span class="line"><span class="number">1010</span> i2c_imx-&gt;adapter.dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line"><span class="number">1011</span> i2c_imx-&gt;adapter.nr = pdev-&gt;id;</span><br><span class="line"><span class="number">1012</span> i2c_imx-&gt;adapter.dev.of_node = pdev-&gt;dev.of_node;</span><br><span class="line"><span class="number">1013</span> i2c_imx-&gt;base = base;</span><br><span class="line"><span class="number">1014</span></span><br><span class="line"><span class="number">1015</span> <span class="comment">/* Get I2C clock */</span></span><br><span class="line"><span class="number">1016</span> i2c_imx-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">......</span><br><span class="line"><span class="number">1022</span> ret = clk_prepare_enable(i2c_imx-&gt;clk);</span><br><span class="line">......</span><br><span class="line"><span class="number">1027</span> <span class="comment">/* Request IRQ */</span></span><br><span class="line"><span class="number">1028</span> ret = devm_request_irq(&amp;pdev-&gt;dev, irq, i2c_imx_isr,IRQF_NO_SUSPEND, pdev-&gt;name, i2c_imx);<span class="comment">//注册控制器中断</span></span><br><span class="line"><span class="number">1029</span> </span><br><span class="line">......</span><br><span class="line"><span class="number">1035</span> <span class="comment">/* Init queue */</span></span><br><span class="line"><span class="number">1036</span> init_waitqueue_head(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line"><span class="number">1037</span></span><br><span class="line"><span class="number">1038</span> <span class="comment">/* Set up adapter data */</span></span><br><span class="line"><span class="number">1039</span> i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);</span><br><span class="line"><span class="number">1040</span></span><br><span class="line"><span class="number">1041</span> <span class="comment">/* Set up clock divider */</span></span><br><span class="line"><span class="number">1042</span> i2c_imx-&gt;bitrate = IMX_I2C_BIT_RATE;<span class="comment">//设置时钟频率</span></span><br><span class="line"><span class="number">1043</span> ret = of_property_read_u32(pdev-&gt;dev.of_node,<span class="string">&quot;clock-frequency&quot;</span>, &amp;i2c_imx-&gt;bitrate);</span><br><span class="line"><span class="number">1044</span> </span><br><span class="line"><span class="number">1045</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; pdata &amp;&amp; pdata-&gt;bitrate)</span><br><span class="line"><span class="number">1046</span> i2c_imx-&gt;bitrate = pdata-&gt;bitrate;</span><br><span class="line"><span class="number">1047</span></span><br><span class="line"><span class="number">1048</span> <span class="comment">/* Set up chip registers to defaults */</span></span><br><span class="line"><span class="number">1049</span> imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,i2c_imx, IMX_I2C_I2CR);</span><br><span class="line"><span class="number">1050</span> </span><br><span class="line"><span class="number">1051</span> imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, IMX_I2C_I2SR);</span><br><span class="line"><span class="number">1052</span><span class="comment">/*设置I2CR和SR寄存器*/</span></span><br><span class="line"><span class="number">1053</span> <span class="comment">/* Add I2C adapter */</span></span><br><span class="line"><span class="number">1054</span> ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);<span class="comment">//内核注册i2c_adapter</span></span><br><span class="line"><span class="number">1055</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">1056</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;registration failed\n&quot;</span>);</span><br><span class="line"><span class="number">1057</span> <span class="keyword">goto</span> clk_disable;</span><br><span class="line"><span class="number">1058</span> &#125;</span><br><span class="line"><span class="number">1059</span></span><br><span class="line"><span class="number">1060</span> <span class="comment">/* Set up platform driver data */</span></span><br><span class="line"><span class="number">1061</span> platform_set_drvdata(pdev, i2c_imx);</span><br><span class="line"><span class="number">1062</span> clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line">......</span><br><span class="line"><span class="number">1070</span> <span class="comment">/* Init DMA config if supported */</span></span><br><span class="line"><span class="number">1071</span> i2c_imx_dma_request(i2c_imx, phy_addr);<span class="comment">//设置了DMA</span></span><br><span class="line"><span class="number">1072</span></span><br><span class="line"><span class="number">1073</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Return OK */</span></span><br><span class="line"><span class="number">1074</span></span><br><span class="line"><span class="number">1075</span> clk_disable:</span><br><span class="line"><span class="number">1076</span> clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line"><span class="number">1077</span> <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">1078</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="设备添加驱动"><a href="#设备添加驱动" class="headerlink" title="设备添加驱动"></a>设备添加驱动</h3><p>以ap3216c设备为例子</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-17%20204441.png"></p><p>在节点i2c1中添加设备的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">ap3216c@<span class="number">1</span>e&#123;<span class="comment">//ap3216芯片设备添加的节点</span></span><br><span class="line">compatible = <span class="string">&quot;alientek,ap3216c&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编写ap3216c的设备驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ap3216creg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_CNT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_NAME    <span class="string">&quot;ap3216c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> devid;</span><br><span class="line">    <span class="type">int</span> major;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="type">void</span> *private_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ir,als,ps;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> <span class="title">ap3216cdev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_read_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line">    msg[<span class="number">0</span>].addr = client-&gt;addr; <span class="comment">//ap3216c地址</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;   <span class="comment">//标记为发送数据</span></span><br><span class="line">    msg[<span class="number">0</span>].buf = &amp;reg; <span class="comment">//读取首地址</span></span><br><span class="line">    msg[<span class="number">0</span>].len = <span class="number">1</span>;     <span class="comment">//数据长度</span></span><br><span class="line"></span><br><span class="line">    msg[<span class="number">1</span>].addr = client-&gt;addr;<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">    msg[<span class="number">1</span>].flags = I2C_M_RD;<span class="comment">/* 标记为读取数据*/</span></span><br><span class="line">    msg[<span class="number">1</span>].buf = val;<span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">    msg[<span class="number">1</span>].len = len;<span class="comment">/* 要读取的数据长度*/</span>    </span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        printk(<span class="string">&quot;i2c rd failed=%d reg = %06x led = %d\n&quot;</span>, ret, reg, len);</span><br><span class="line">        ret = -EREMOTEIO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">ap3216c_write_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 b[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *) dev-&gt; private_data;</span><br><span class="line">    b[<span class="number">0</span>] = reg ;    <span class="comment">//寄存器首地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>], buf, len);    <span class="comment">//写入的数据拷贝进入数组b里</span></span><br><span class="line">    msg.addr = client-&gt; addr;   <span class="comment">//ap3216c地址</span></span><br><span class="line">    msg.flags = <span class="number">0</span>;  <span class="comment">//  标记为写数据   </span></span><br><span class="line">    msg.len = len + <span class="number">1</span>; <span class="comment">//数据长度</span></span><br><span class="line">    msg.buf = b;<span class="comment">//写入数据缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ap3216c_read_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ap3216c_read_regs(dev, reg, &amp;data, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ap3216c_write_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 buf = <span class="number">0</span>;</span><br><span class="line">    buf = data;</span><br><span class="line">    ap3216c_write_regs(dev, reg, &amp;buf,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ap3216c_readdata</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 循环读取所有传感器数据 */</span></span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[i] = ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] &amp; <span class="number">0X80</span>) <span class="comment">/* IR_OF 位为 1,则数据无效 */</span></span><br><span class="line">        dev-&gt;ir = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 读取 IR 传感器的数据 */</span></span><br><span class="line">        dev-&gt;ir = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">1</span>] &lt;&lt; <span class="number">2</span>) | (buf[<span class="number">0</span>] &amp; <span class="number">0X03</span>);</span><br><span class="line"></span><br><span class="line">    dev-&gt;als = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">2</span>];<span class="comment">/* ALS 数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">4</span>] &amp; <span class="number">0x40</span>) <span class="comment">/* IR_OF 位为 1,则数据无效 */</span></span><br><span class="line">        dev-&gt;ps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 读取 PS 传感器的数据 */</span></span><br><span class="line">        dev-&gt;ps = ((<span class="type">unsigned</span> <span class="type">short</span>)(buf[<span class="number">5</span>] &amp; <span class="number">0X3F</span>) &lt;&lt; <span class="number">4</span>) | (buf[<span class="number">4</span>] &amp; <span class="number">0X0F</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    filp-&gt;private_data = &amp;ap3216cdev;</span><br><span class="line">    ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0x04</span>);</span><br><span class="line">    mdelay(<span class="number">50</span>);</span><br><span class="line">    ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0x03</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ap3216c_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt,<span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">short</span> data[<span class="number">3</span>];</span><br><span class="line">    <span class="type">long</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> ap3216c_dev *)filp-&gt;private_data;</span><br><span class="line">    ap3216c_readdata(dev);</span><br><span class="line"></span><br><span class="line">    data[<span class="number">0</span>] = dev-&gt;ir;</span><br><span class="line">    data[<span class="number">1</span>] = dev-&gt;als;</span><br><span class="line">    data[<span class="number">2</span>] = dev-&gt;ps;</span><br><span class="line">    err = copy_to_user(buf, data,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_release</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ap3216c_ops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .read = ap3216c_read,</span><br><span class="line">    .open = ap3216c_open,</span><br><span class="line">    .release = ap3216c_release,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 1、构建设备号 */</span></span><br><span class="line"><span class="keyword">if</span> (ap3216cdev.major) &#123;</span><br><span class="line">ap3216cdev.devid = MKDEV(ap3216cdev.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alloc_chrdev_region(&amp;ap3216cdev.devid, <span class="number">0</span>, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">ap3216cdev.major = MAJOR(ap3216cdev.devid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、注册设备 */</span></span><br><span class="line">cdev_init(&amp;ap3216cdev.cdev, &amp;ap3216c_ops);</span><br><span class="line">cdev_add(&amp;ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、创建类 */</span></span><br><span class="line">ap3216cdev.class = class_create(THIS_MODULE, AP3216C_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ap3216cdev.class)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ap3216cdev.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、创建设备 */</span></span><br><span class="line">ap3216cdev.device = device_create(ap3216cdev.class, <span class="literal">NULL</span>, ap3216cdev.devid, <span class="literal">NULL</span>, AP3216C_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ap3216cdev.device)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(ap3216cdev.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ap3216cdev.private_data = client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span></span><br><span class="line"><span class="comment"> * @param - client : i2c设备</span></span><br><span class="line"><span class="comment"> * @return          : 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 删除设备 */</span></span><br><span class="line">cdev_del(&amp;ap3216cdev.cdev);</span><br><span class="line">unregister_chrdev_region(ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销掉类和设备 */</span></span><br><span class="line">device_destroy(ap3216cdev.class, ap3216cdev.devid);</span><br><span class="line">class_destroy(ap3216cdev.class);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 传统匹配方式ID列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ap3216c_id</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="string">&quot;alientek,ap3216c&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ap3216c_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;alientek,ap3216c&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ap3216c_driver</span> =</span> &#123;</span><br><span class="line">.probe = ap3216c_probe,</span><br><span class="line">.remove = ap3216c_remove,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">   .name = <span class="string">&quot;ap3216c&quot;</span>,</span><br><span class="line">   .of_match_table = ap3216c_of_match, </span><br><span class="line">   &#125;,</span><br><span class="line">.id_table = ap3216c_id,</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动入口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ap3216c_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = i2c_add_driver(&amp;ap3216c_driver);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ap3216c_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">i2c_del_driver(&amp;ap3216c_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* module_i2c_driver(ap3216c_driver) */</span></span><br><span class="line"></span><br><span class="line">module_init(ap3216c_init);</span><br><span class="line">module_exit(ap3216c_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTC驱动</title>
      <link href="/2023/07/12/2023-7-12-RTC%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/12/2023-7-12-RTC%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-内核中-RTC-驱动调用流程"><a href="#Linux-内核中-RTC-驱动调用流程" class="headerlink" title="Linux 内核中 RTC 驱动调用流程"></a>Linux 内核中 RTC 驱动调用流程</h2><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-12%20154142.png"></p><p>Linux 内核将 RTC 设备抽象为 rtc_device 结构体，因此 RTC 设备驱动就是申请并初始化rtc_device，最后将 rtc_device 注册到 Linux 内核里面，这样 Linux 内核就有一个 RTC 设备了 。</p><p>当 rtc_class_ops 准备好以后需要将其注册到 Linux 内核中，这里我们可以使用rtc_device_register函数完成注册工作。此函数会申请一个rtc_device并且初始化这个rtc_device，最后向调用者返回这个 rtc_device，此函数原型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rtc_device *<span class="title function_">rtc_device_register</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,<span class="comment">//设备名字</span></span></span><br><span class="line"><span class="params">                                       <span class="keyword">struct</span> device *dev,<span class="comment">//设备</span></span></span><br><span class="line"><span class="params">                                       <span class="type">const</span> <span class="keyword">struct</span> rtc_class_ops *ops,<span class="comment">//RTC 底层驱动函数集</span></span></span><br><span class="line"><span class="params">                                       <span class="keyword">struct</span> module *owner)</span><span class="comment">//驱动模块拥有者</span></span><br><span class="line"><span class="comment">//注册成功的话就返回 rtc_device，错误的话会返回一个负值。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_device_unregister</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc)</span></span><br><span class="line"><span class="comment">//rtc：要删除的 rtc_device。返回值： 无。</span></span><br></pre></td></tr></table></figure><p>RTC 设备的操作肯定是用一个操作集合(结构体 )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">104</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span></span></span><br><span class="line"><span class="class">105 &#123;</span></span><br><span class="line"><span class="number">106</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span> <span class="comment">/* 设备 */</span></span><br><span class="line"><span class="number">107</span> <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="number">108</span></span><br><span class="line"><span class="number">109</span> <span class="type">int</span> id; <span class="comment">/* ID */</span></span><br><span class="line"><span class="number">110</span> <span class="type">char</span> name[RTC_DEVICE_NAME_SIZE]; <span class="comment">/* 名字 */</span></span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">112</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">ops</span>;</span> <span class="comment">/* RTC 设备底层操作函数 比较重要*/</span></span><br><span class="line"><span class="number">113</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">ops_lock</span>;</span></span><br><span class="line"><span class="number">114</span></span><br><span class="line"><span class="number">115</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">char_dev</span>;</span> <span class="comment">/* 字符设备 */</span></span><br><span class="line"><span class="number">116</span> <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="number">117</span></span><br><span class="line"><span class="number">118</span> <span class="type">unsigned</span> <span class="type">long</span> irq_data;</span><br><span class="line"><span class="number">119</span> <span class="type">spinlock_t</span> irq_lock;</span><br><span class="line"><span class="number">120</span> <span class="type">wait_queue_head_t</span> irq_queue;</span><br><span class="line"><span class="number">121</span> <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span></span><br><span class="line"><span class="number">122</span></span><br><span class="line"><span class="number">123</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_task</span> *<span class="title">irq_task</span>;</span></span><br><span class="line"><span class="number">124</span> <span class="type">spinlock_t</span> irq_task_lock;</span><br><span class="line"><span class="number">125</span> <span class="type">int</span> irq_freq;</span><br><span class="line"><span class="number">126</span> <span class="type">int</span> max_user_freq;</span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">128</span> <span class="class"><span class="keyword">struct</span> <span class="title">timerqueue_head</span> <span class="title">timerqueue</span>;</span></span><br><span class="line"><span class="number">129</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">aie_timer</span>;</span></span><br><span class="line"><span class="number">130</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">uie_rtctimer</span>;</span></span><br><span class="line"><span class="number">131</span> <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">pie_timer</span>;</span> <span class="comment">/* sub second exp, so needs hrtimer */</span></span><br><span class="line"><span class="number">132</span> <span class="type">int</span> pie_enabled;</span><br><span class="line"><span class="number">133</span> <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">irqwork</span>;</span></span><br><span class="line"><span class="number">134</span> <span class="comment">/* Some hardware can&#x27;t support UIE mode */</span></span><br><span class="line"><span class="number">135</span> <span class="type">int</span> uie_unsupported;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查看rtc_class_ops底层操作数集合，这个集合是最底层的 RTC 设备操作函数 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">71</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> &#123;</span></span><br><span class="line"><span class="number">72</span> <span class="type">int</span> (*open)(<span class="keyword">struct</span> device *);</span><br><span class="line"><span class="number">73</span> <span class="type">void</span> (*release)(<span class="keyword">struct</span> device *);</span><br><span class="line"><span class="number">74</span> <span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="number">75</span> <span class="type">int</span> (*read_time)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_time *);</span><br><span class="line"><span class="number">76</span> <span class="type">int</span> (*set_time)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_time *);</span><br><span class="line"><span class="number">77</span> <span class="type">int</span> (*read_alarm)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_wkalrm *);</span><br><span class="line"><span class="number">78</span> <span class="type">int</span> (*set_alarm)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_wkalrm *);</span><br><span class="line"><span class="number">79</span> <span class="type">int</span> (*proc)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> seq_file *);</span><br><span class="line"><span class="number">80</span> <span class="type">int</span> (*set_mmss64)(<span class="keyword">struct</span> device *, <span class="type">time64_t</span> secs);</span><br><span class="line"><span class="number">81</span> <span class="type">int</span> (*set_mmss)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">long</span> secs);</span><br><span class="line"><span class="number">82</span> <span class="type">int</span> (*read_callback)(<span class="keyword">struct</span> device *, <span class="type">int</span> data);</span><br><span class="line"><span class="number">83</span> <span class="type">int</span> (*alarm_irq_enable)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">int</span> enabled);</span><br><span class="line"><span class="number">84</span> &#125;;</span><br></pre></td></tr></table></figure><p>RTC 是字符设备（存在字符设备的 file_operations 函数操作集）， Linux 内核提供了一个 RTC 通用字符设备驱动文件，文件名为 drivers&#x2F;rtc&#x2F;rtc-dev.c， rtcdev.c 文件提供了所有 RTC 设备共用的 file_operations 函数操作集 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">448</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">rtc_dev_fops</span> =</span> &#123;</span><br><span class="line"><span class="number">449</span> .owner = THIS_MODULE,</span><br><span class="line"><span class="number">450</span> .llseek = no_llseek,</span><br><span class="line"><span class="number">451</span> .read = rtc_dev_read,</span><br><span class="line"><span class="number">452</span> .poll = rtc_dev_poll,</span><br><span class="line"><span class="number">453</span> .unlocked_ioctl = rtc_dev_ioctl,<span class="comment">/* rtc_class_ops 中的 read_time、 </span></span><br><span class="line"><span class="comment">set_time 等函数来对具体 RTC 设备的读写操作。*/</span></span><br><span class="line"><span class="number">454</span> .open = rtc_dev_open,</span><br><span class="line"><span class="number">455</span> .release = rtc_dev_release,</span><br><span class="line"><span class="number">456</span> .fasync = rtc_dev_fasync,</span><br><span class="line"><span class="number">457</span> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">218</span> <span class="type">static</span> <span class="type">long</span> <span class="title function_">rtc_dev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params"><span class="number">219</span> <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">220 &#123;</span><br><span class="line"><span class="number">221</span> <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"><span class="number">222</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span> =</span> file-&gt;private_data;</span><br><span class="line"><span class="number">223</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">ops</span> =</span> rtc-&gt;ops;</span><br><span class="line"><span class="number">224</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">tm</span>;</span></span><br><span class="line"><span class="number">225</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_wkalrm</span> <span class="title">alarm</span>;</span></span><br><span class="line"><span class="number">226</span> <span class="type">void</span> __user *uarg = (<span class="type">void</span> __user *) arg;</span><br><span class="line"><span class="number">227</span></span><br><span class="line"><span class="number">228</span> err = mutex_lock_interruptible(&amp;rtc-&gt;ops_lock);</span><br><span class="line"><span class="number">229</span> <span class="keyword">if</span> (err)</span><br><span class="line"><span class="number">230</span> <span class="keyword">return</span> err;</span><br><span class="line">......</span><br><span class="line"><span class="number">269</span> <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="number">333</span> <span class="keyword">case</span> RTC_RD_TIME: <span class="comment">/* 读取时间 */</span></span><br><span class="line"><span class="number">334</span> mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"><span class="number">335</span></span><br><span class="line"><span class="number">336</span> err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line"><span class="number">337</span> <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">338</span> <span class="keyword">return</span> err;</span><br><span class="line"><span class="number">339</span></span><br><span class="line"><span class="number">340</span> <span class="keyword">if</span> (copy_to_user(uarg, &amp;tm, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line"><span class="number">341</span> err = -EFAULT;</span><br><span class="line"><span class="number">342</span><span class="keyword">return</span> err;</span><br><span class="line"><span class="number">343</span></span><br><span class="line"><span class="number">344</span> <span class="keyword">case</span> RTC_SET_TIME: <span class="comment">/* 设置时间 */</span></span><br><span class="line"><span class="number">345</span> mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"><span class="number">346</span></span><br><span class="line"><span class="number">347</span> <span class="keyword">if</span> (copy_from_user(&amp;tm, uarg, <span class="keyword">sizeof</span>(tm)))</span><br><span class="line"><span class="number">348</span> <span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="number">349</span></span><br><span class="line"><span class="number">350</span> <span class="keyword">return</span> rtc_set_time(rtc, &amp;tm);</span><br><span class="line">......</span><br><span class="line"><span class="number">401</span> <span class="keyword">default</span>:</span><br><span class="line"><span class="number">402</span> <span class="comment">/* Finally try the driver&#x27;s ioctl interface */</span></span><br><span class="line"><span class="number">403</span> <span class="keyword">if</span> (ops-&gt;ioctl) &#123;</span><br><span class="line"><span class="number">404</span> err = ops-&gt;ioctl(rtc-&gt;dev.parent, cmd, arg);</span><br><span class="line"><span class="number">405</span> <span class="keyword">if</span> (err == -ENOIOCTLCMD)</span><br><span class="line"><span class="number">406</span> err = -ENOTTY;</span><br><span class="line"><span class="number">407</span> &#125; <span class="keyword">else</span></span><br><span class="line"><span class="number">408</span> err = -ENOTTY;</span><br><span class="line"><span class="number">409</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="number">410</span> &#125;</span><br><span class="line"><span class="number">411</span></span><br><span class="line"><span class="number">412</span> done:</span><br><span class="line"><span class="number">413</span> mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br><span class="line"><span class="number">414</span> <span class="keyword">return</span> err;</span><br><span class="line"><span class="number">415</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="1、时间-RTC-查看"><a href="#1、时间-RTC-查看" class="headerlink" title="1、时间 RTC 查看"></a>1、时间 RTC 查看</h4><p>如果要查看时间的话输入“date”命令即可 。</p><h4 id="2、设置-RTC-时间"><a href="#2、设置-RTC-时间" class="headerlink" title="2、设置 RTC 时间"></a>2、设置 RTC 时间</h4><p>RTC 时间设置也是使用的 date 命令，输入“date –help”命令即可查看 date 命令如何设置系统时间 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock -w //将当前系统时间写入到 RTC 里面</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lcd驱动</title>
      <link href="/2023/07/10/2023-7-10-lcd%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/10/2023-7-10-lcd%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Framebuffer"><a href="#Framebuffer" class="headerlink" title="Framebuffer"></a>Framebuffer</h2><p>在 Linux 中应用程序最终也是通过操作 RGB LCD 的显存来实现在 LCD 上显示字符、图片等信息。 因为虚拟内存的存在，驱动程序设置的显存和应用程序访问的显存要是同一片物理内存。</p><p>Framebuffer 诞生了， Framebuffer 翻译过来就是帧缓冲，简称 fb 。fb 是一种机制，将系统中所有跟显示有关的硬件以及软件集合起来，虚拟出一个 fb 设备。</p><p>fb 的 file_operations 操作集定义在drivers&#x2F;video&#x2F;fbdev&#x2F;core&#x2F;fbmem.c 文件中 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1495</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fb_fops</span> =</span> &#123;</span><br><span class="line"><span class="number">1496</span> .owner = THIS_MODULE,</span><br><span class="line"><span class="number">1497</span> .read = fb_read,</span><br><span class="line"><span class="number">1498</span> .write = fb_write,</span><br><span class="line"><span class="number">1499</span> .unlocked_ioctl = fb_ioctl,</span><br><span class="line"><span class="number">1500</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="number">1501</span> .compat_ioctl = fb_compat_ioctl,</span><br><span class="line"><span class="number">1502</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">1503</span> .mmap = fb_mmap,</span><br><span class="line"><span class="number">1504</span> .open = fb_open,</span><br><span class="line"><span class="number">1505</span> .release = fb_release,</span><br><span class="line"><span class="number">1506</span> <span class="meta">#<span class="keyword">ifdef</span> HAVE_ARCH_FB_UNMAPPED_AREA</span></span><br><span class="line"><span class="number">1507</span> .get_unmapped_area = get_fb_unmapped_area,</span><br><span class="line"><span class="number">1508</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">1509</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_FB_DEFERRED_IO</span></span><br><span class="line"><span class="number">1510</span> .fsync = fb_deferred_io_fsync,</span><br><span class="line"><span class="number">1511</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">1512</span> .llseek = default_llseek,</span><br><span class="line"><span class="number">1513</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="LCD设备节点"><a href="#LCD设备节点" class="headerlink" title="LCD设备节点"></a>LCD设备节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*imx6ull.dtsi 文件中 lcdif 节点内容*/</span></span><br><span class="line"><span class="number">1</span> lcdif: lcdif@<span class="number">021</span>c8000 &#123;</span><br><span class="line"><span class="number">2</span> compatible = <span class="string">&quot;fsl,imx6ul-lcdif&quot;</span>, <span class="string">&quot;fsl,imx28-lcdif&quot;</span>;</span><br><span class="line"><span class="number">3</span> reg = &lt;<span class="number">0x021c8000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line"><span class="number">4</span> interrupts = &lt;GIC_SPI <span class="number">5</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line"><span class="number">5</span> clocks = &lt;&amp;clks IMX6UL_CLK_LCDIF_PIX&gt;,</span><br><span class="line"><span class="number">6</span> &lt;&amp;clks IMX6UL_CLK_LCDIF_APB&gt;,</span><br><span class="line"><span class="number">7</span> &lt;&amp;clks IMX6UL_CLK_DUMMY&gt;;</span><br><span class="line"><span class="number">8</span> clock-names = <span class="string">&quot;pix&quot;</span>, <span class="string">&quot;axi&quot;</span>, <span class="string">&quot;disp_axi&quot;</span>;</span><br><span class="line"><span class="number">9</span> status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure><p>之后还要向 imx6ullalientek-emmc.dts 中的 lcdif 节点添加其他的属性信息。 </p><p>属性值为“fsl,imx6ul-lcdif”和“fsl,imx28-lcdif”，因此在 Linux 源码中搜索这两个字符串即可找到 I.MX6ULL 的 LCD 驱动文件，这个文件为 drivers&#x2F;video&#x2F;fbdev&#x2F;mxsfb.c，mxsfb.c就是 I.MX6ULL 的 LCD 驱动文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1362</span> <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mxsfb_dt_ids</span>[] =</span> &#123;</span><br><span class="line"><span class="number">1363</span> &#123; .compatible = <span class="string">&quot;fsl,imx23-lcdif&quot;</span>, .data = &amp;mxsfb_devtype[<span class="number">0</span>], &#125;,</span><br><span class="line"><span class="number">1364</span> &#123; .compatible = <span class="string">&quot;fsl,imx28-lcdif&quot;</span>, .data = &amp;mxsfb_devtype[<span class="number">1</span>], &#125;,</span><br><span class="line"><span class="number">1365</span> &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line"><span class="number">1366</span> &#125;;</span><br><span class="line">......</span><br><span class="line"><span class="number">1625</span> <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">mxsfb_driver</span> =</span> &#123;</span><br><span class="line"><span class="number">1626</span> .probe = mxsfb_probe,</span><br><span class="line"><span class="number">1627</span> .remove = mxsfb_remove,</span><br><span class="line"><span class="number">1628</span> .shutdown = mxsfb_shutdown,</span><br><span class="line"><span class="number">1629</span> .id_table = mxsfb_devtype,</span><br><span class="line"><span class="number">1630</span> .driver = &#123;</span><br><span class="line"><span class="number">1631</span> .name = DRIVER_NAME,</span><br><span class="line"><span class="number">1632</span> .of_match_table = mxsfb_dt_ids,</span><br><span class="line"><span class="number">1633</span> .pm = &amp;mxsfb_pm_ops,</span><br><span class="line"><span class="number">1634</span> &#125;,</span><br><span class="line"><span class="number">1635</span> &#125;;</span><br><span class="line"><span class="number">1636</span></span><br><span class="line"><span class="number">1637</span> module_platform_driver(mxsfb_driver);</span><br></pre></td></tr></table></figure><p>这是一个标准的 platform 驱动，当驱动和设备匹配以后mxsfb_probe 函数就会执行。 <strong>LCD 的驱动就是构建 fb_info，并且向系统注册 fb_info的过程。</strong> </p><p>fb_info 结构体定义在 include&#x2F;linux&#x2F;fb.h 文件里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">448</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> &#123;</span></span><br><span class="line"><span class="number">449</span> <span class="type">atomic_t</span> count;</span><br><span class="line"><span class="number">450</span> <span class="type">int</span> node;</span><br><span class="line"><span class="number">451</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="number">452</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* 互斥锁 */</span></span><br><span class="line"><span class="number">453</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mm_lock</span>;</span> <span class="comment">/* 互斥锁，用于 fb_mmap 和 smem_*域*/</span></span><br><span class="line"><span class="number">454</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span> <span class="comment">/* 当前可变参数 */</span></span><br><span class="line"><span class="number">455</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">fix</span>;</span> <span class="comment">/* 当前固定参数 */</span></span><br><span class="line"><span class="number">456</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_monspecs</span> <span class="title">monspecs</span>;</span> <span class="comment">/* 当前显示器特性 */</span></span><br><span class="line"><span class="number">457</span> <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">queue</span>;</span> <span class="comment">/* 帧缓冲事件队列 */</span></span><br><span class="line"><span class="number">458</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">pixmap</span>;</span> <span class="comment">/* 图像硬件映射 */</span></span><br><span class="line"><span class="number">459</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">sprite</span>;</span> <span class="comment">/* 光标硬件映射 */</span></span><br><span class="line"><span class="number">460</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_cmap</span> <span class="title">cmap</span>;</span> <span class="comment">/* 当前调色板 */</span></span><br><span class="line"><span class="number">461</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">modelist</span>;</span> <span class="comment">/* 当前模式列表 */</span></span><br><span class="line"><span class="number">462</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> *<span class="title">mode</span>;</span> <span class="comment">/* 当前视频模式 */</span></span><br><span class="line"><span class="number">463</span></span><br><span class="line"><span class="number">464</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_FB_BACKLIGHT <span class="comment">/* 如果 LCD 支持背光的话 */</span></span></span><br><span class="line"><span class="number">465</span> <span class="comment">/* assigned backlight device */</span></span><br><span class="line"><span class="number">466</span> <span class="comment">/* set before framebuffer registration,</span></span><br><span class="line"><span class="comment">467 remove after unregister */</span></span><br><span class="line"><span class="number">468</span> <span class="class"><span class="keyword">struct</span> <span class="title">backlight_device</span> *<span class="title">bl_dev</span>;</span> <span class="comment">/* 背光设备 */</span></span><br><span class="line"><span class="number">469</span></span><br><span class="line"><span class="number">470</span> <span class="comment">/* Backlight level curve */</span></span><br><span class="line"><span class="number">471</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bl_curve_mutex</span>;</span></span><br><span class="line"><span class="number">472</span> u8 bl_curve[FB_BACKLIGHT_LEVELS];原子哥在线教学:www.yuanzige.com 论坛:www.openedv.com</span><br><span class="line"><span class="number">1416</span></span><br><span class="line">I.MX6U 嵌入式 Linux 驱动开发指南</span><br><span class="line"><span class="number">473</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line"><span class="number">479</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> *<span class="title">fbops</span>;</span> <span class="comment">/* 帧缓冲操作函数集 */</span></span><br><span class="line"><span class="number">480</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">/* 父设备 */</span></span><br><span class="line"><span class="number">481</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span> <span class="comment">/* 当前 fb 设备 */</span></span><br><span class="line"><span class="number">482</span> <span class="type">int</span> class_flag; <span class="comment">/* 私有 sysfs 标志 */</span></span><br><span class="line">......</span><br><span class="line"><span class="number">486</span> <span class="type">char</span> __iomem *screen_base; <span class="comment">/* 虚拟内存基地址(屏幕显存) */</span></span><br><span class="line"><span class="number">487</span> <span class="type">unsigned</span> <span class="type">long</span> screen_size; <span class="comment">/* 虚拟内存大小(屏幕显存大小) */</span></span><br><span class="line"><span class="number">488</span> <span class="type">void</span> *pseudo_palette; <span class="comment">/* 伪 16 位调色板 */</span></span><br><span class="line">......</span><br><span class="line"><span class="number">507</span> &#125;;</span><br></pre></td></tr></table></figure><p><u><strong>mxsfb_probe 函数的主要工作内容为 ：</strong></u></p><p><strong>①、申请 fb_info。</strong><br><strong>②、初始化 fb_info 结构体中的各个成员变量。</strong><br><strong>③、初始化 eLCDIF 控制器。</strong><br><strong>④、使用 register_framebuffer 函数向 Linux 内核注册初始化好的 fb_info。</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mxsfb_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">1370 &#123;</span><br><span class="line"><span class="number">1371</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span> =</span></span><br><span class="line"><span class="number">1372</span> of_match_device(mxsfb_dt_ids, &amp;pdev-&gt;dev);</span><br><span class="line"><span class="number">1373</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line"><span class="number">1374</span> <span class="class"><span class="keyword">struct</span> <span class="title">mxsfb_info</span> *<span class="title">host</span>;</span><span class="comment">//IMX6uLL主控接口，mxsfb_info为NXP定义的fb设备结构体</span></span><br><span class="line"><span class="number">1375</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">fb_info</span>;</span></span><br><span class="line"><span class="number">1376</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span>;</span></span><br><span class="line"><span class="number">1377</span> <span class="type">int</span> irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line"><span class="number">1378</span> <span class="type">int</span> gpio, ret;</span><br><span class="line"><span class="number">1379</span></span><br><span class="line">......</span><br><span class="line"><span class="number">1394</span></span><br><span class="line"><span class="number">1395</span> res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);<span class="comment">//获取eLCDIF接口控制器的寄存器首地址</span></span><br><span class="line"><span class="number">1396</span> <span class="keyword">if</span> (!res) &#123;</span><br><span class="line"><span class="number">1397</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Cannot get memory IO resource\n&quot;</span>);</span><br><span class="line"><span class="number">1398</span> <span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="number">1399</span> &#125;</span><br><span class="line"><span class="number">1400</span></span><br><span class="line"><span class="number">1401</span> host = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mxsfb_info),GFP_KERNEL);<span class="comment">//给host申请内存</span></span><br><span class="line"><span class="number">1402</span> <span class="keyword">if</span> (!host) &#123;</span><br><span class="line"><span class="number">1403</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to allocate IO resource\n&quot;</span>);</span><br><span class="line"><span class="number">1404</span> <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="number">1405</span> &#125;</span><br><span class="line"><span class="number">1406</span></span><br><span class="line"><span class="number">1407</span> fb_info = framebuffer_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> fb_info), &amp;pdev-&gt;dev);<span class="comment">//给fb申请内存</span></span><br><span class="line"><span class="number">1408</span> <span class="keyword">if</span> (!fb_info) &#123;</span><br><span class="line"><span class="number">1409</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to allocate fbdev\n&quot;</span>);</span><br><span class="line"><span class="number">1410</span> devm_kfree(&amp;pdev-&gt;dev, host);</span><br><span class="line"><span class="number">1411</span> <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="number">1412</span> &#125;</span><br><span class="line"><span class="number">1413</span> host-&gt;fb_info = fb_info;</span><br><span class="line"><span class="number">1414</span> fb_info-&gt;par = host;<span class="comment">//将申请的host和fb_info联系到一起</span></span><br><span class="line"><span class="number">1415</span></span><br><span class="line"><span class="number">1416</span> ret = devm_request_irq(&amp;pdev-&gt;dev, irq, mxsfb_irq_handler, <span class="number">0</span>,dev_name(&amp;pdev-&gt;dev), host);</span><br><span class="line"><span class="number">1417</span> <span class="comment">//申请中断</span></span><br><span class="line"><span class="number">1418</span> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="number">1419</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;request_irq (%d) failed with</span></span><br><span class="line"><span class="string">1420 error %d\n&quot;</span>, irq, ret);</span><br><span class="line"><span class="number">1421</span> ret = -ENODEV;</span><br><span class="line"><span class="number">1422</span> <span class="keyword">goto</span> fb_release;</span><br><span class="line"><span class="number">1423</span> &#125;</span><br><span class="line"><span class="number">1424</span></span><br><span class="line"><span class="number">1425</span> host-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);<span class="comment">//对从设备树中获取寄存器首地址进行内存映射</span></span><br><span class="line">          <span class="comment">//   得到虚拟地址保存到host变量中</span></span><br><span class="line"><span class="number">1426</span> <span class="keyword">if</span> (IS_ERR(host-&gt;base)) &#123;</span><br><span class="line"><span class="number">1427</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;ioremap failed\n&quot;</span>);</span><br><span class="line"><span class="number">1428</span> ret = PTR_ERR(host-&gt;base);</span><br><span class="line"><span class="number">1429</span> <span class="keyword">goto</span> fb_release;</span><br><span class="line"><span class="number">1430</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">1461</span></span><br><span class="line"><span class="number">1462</span> fb_info-&gt;pseudo_palette = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(u32) * <span class="number">16</span>, GFP_KERNEL);<span class="comment">//申请内存</span></span><br><span class="line"><span class="number">1463</span> </span><br><span class="line"><span class="number">1464</span> <span class="keyword">if</span> (!fb_info-&gt;pseudo_palette) &#123;</span><br><span class="line"><span class="number">1465</span> ret = -ENOMEM;</span><br><span class="line"><span class="number">1466</span> <span class="keyword">goto</span> fb_release;</span><br><span class="line"><span class="number">1467</span> &#125;</span><br><span class="line"><span class="number">1468</span></span><br><span class="line"><span class="number">1469</span> INIT_LIST_HEAD(&amp;fb_info-&gt;modelist);</span><br><span class="line"><span class="number">1470</span></span><br><span class="line"><span class="number">1471</span> pm_runtime_enable(&amp;host-&gt;pdev-&gt;dev);</span><br><span class="line"><span class="number">1472</span></span><br><span class="line"><span class="number">1473</span> ret = mxsfb_init_fbinfo(host);<span class="comment">//初始化fb_info</span></span><br><span class="line"><span class="number">1474</span> <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line"><span class="number">1475</span> <span class="keyword">goto</span> fb_pm_runtime_disable;</span><br><span class="line"><span class="number">1476</span></span><br><span class="line"><span class="number">1477</span> mxsfb_dispdrv_init(pdev, fb_info);</span><br><span class="line"><span class="number">1478</span></span><br><span class="line"><span class="number">1479</span> <span class="keyword">if</span> (!host-&gt;dispdrv) &#123;</span><br><span class="line"><span class="number">1480</span> pinctrl = devm_pinctrl_get_select_default(&amp;pdev-&gt;dev);</span><br><span class="line"><span class="number">1481</span> <span class="keyword">if</span> (IS_ERR(pinctrl)) &#123;</span><br><span class="line"><span class="number">1482</span> ret = PTR_ERR(pinctrl);</span><br><span class="line"><span class="number">1483</span> <span class="keyword">goto</span> fb_pm_runtime_disable;</span><br><span class="line"><span class="number">1484</span> &#125;</span><br><span class="line"><span class="number">1485</span> &#125;</span><br><span class="line"><span class="number">1486</span></span><br><span class="line"><span class="number">1487</span> <span class="keyword">if</span> (!host-&gt;enabled) &#123;</span><br><span class="line"><span class="number">1488</span> writel(<span class="number">0</span>, host-&gt;base + LCDC_CTRL);</span><br><span class="line"><span class="number">1489</span> mxsfb_set_par(fb_info);<span class="comment">//设置eLCDIF控制器相应的寄存器</span></span><br><span class="line"><span class="number">1490</span> mxsfb_enable_controller(fb_info);</span><br><span class="line"><span class="number">1491</span> pm_runtime_get_sync(&amp;host-&gt;pdev-&gt;dev);</span><br><span class="line"><span class="number">1492</span> &#125;</span><br><span class="line"><span class="number">1493</span></span><br><span class="line"><span class="number">1494</span> ret = register_framebuffer(fb_info);<span class="comment">//内核注册fb_info</span></span><br><span class="line"><span class="number">1495</span> <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">1496</span> dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to register framebuffer\n&quot;</span>);</span><br><span class="line"><span class="number">1497</span> <span class="keyword">goto</span> fb_destroy;</span><br><span class="line"><span class="number">1498</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">1525</span> <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">1526</span> &#125;</span><br></pre></td></tr></table></figure><p>NXP 提供的 fbops 为mxsfb_ops</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">987</span> <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> <span class="title">mxsfb_ops</span> =</span> &#123;</span><br><span class="line"><span class="number">988</span> .owner = THIS_MODULE,</span><br><span class="line"><span class="number">989</span> .fb_check_var = mxsfb_check_var,</span><br><span class="line"><span class="number">990</span> .fb_set_par = mxsfb_set_par,</span><br><span class="line"><span class="number">991</span> .fb_setcolreg = mxsfb_setcolreg,</span><br><span class="line"><span class="number">992</span> .fb_ioctl = mxsfb_ioctl,</span><br><span class="line"><span class="number">993</span> .fb_blank = mxsfb_blank,</span><br><span class="line"><span class="number">994</span> .fb_pan_display = mxsfb_pan_display,</span><br><span class="line"><span class="number">995</span> .fb_mmap = mxsfb_mmap,</span><br><span class="line"><span class="number">996</span> .fb_fillrect = cfb_fillrect,</span><br><span class="line"><span class="number">997</span> .fb_copyarea = cfb_copyarea,</span><br><span class="line"><span class="number">998</span> .fb_imageblit = cfb_imageblit,</span><br><span class="line"><span class="number">999</span> &#125;;</span><br></pre></td></tr></table></figure><p>mxsfb_init_fbinfo 函数通过调用 mxsfb_init_fbinfo_dt 函数从设备树中获取到 LCD 的各个参数信息。最后， mxsfb_init_fbinfo<br>函数会调用 mxsfb_map_videomem 函数申请 LCD 的帧缓冲内存(也就是显存)。 </p><h2 id="驱动编写"><a href="#驱动编写" class="headerlink" title="驱动编写"></a>驱动编写</h2><p>重点要注意三个地方：<br><strong>①、 LCD 所使用的 IO 配置。</strong><br><strong>②、 LCD 屏幕节点修改，修改相应的属性值，所使用的 LCD 屏幕参数。</strong><br><strong>③、 LCD 背光节点信息修改，要根据实际所使用的背光 IO 来修改相应的设备节点信息。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设备树 LCD IO 配置</span></span><br><span class="line"><span class="number">1</span> pinctrl_lcdif_dat: lcdifdatgrp &#123;</span><br><span class="line"><span class="number">2</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">3</span> MX6UL_PAD_LCD_DATA00__LCDIF_DATA00 <span class="number">0x79</span></span><br><span class="line"><span class="number">4</span> MX6UL_PAD_LCD_DATA01__LCDIF_DATA01 <span class="number">0x79</span></span><br><span class="line"><span class="number">5</span> MX6UL_PAD_LCD_DATA02__LCDIF_DATA02 <span class="number">0x79</span></span><br><span class="line"><span class="number">6</span> MX6UL_PAD_LCD_DATA03__LCDIF_DATA03 <span class="number">0x79</span></span><br><span class="line"><span class="number">7</span> MX6UL_PAD_LCD_DATA04__LCDIF_DATA04 <span class="number">0x79</span></span><br><span class="line"><span class="number">8</span> MX6UL_PAD_LCD_DATA05__LCDIF_DATA05 <span class="number">0x79</span></span><br><span class="line"><span class="number">9</span> MX6UL_PAD_LCD_DATA06__LCDIF_DATA06 <span class="number">0x79</span></span><br><span class="line"><span class="number">10</span> MX6UL_PAD_LCD_DATA07__LCDIF_DATA07 <span class="number">0x79</span></span><br><span class="line"><span class="number">11</span> MX6UL_PAD_LCD_DATA08__LCDIF_DATA08 <span class="number">0x79</span></span><br><span class="line"><span class="number">12</span> MX6UL_PAD_LCD_DATA09__LCDIF_DATA09 <span class="number">0x79</span></span><br><span class="line"><span class="number">13</span> MX6UL_PAD_LCD_DATA10__LCDIF_DATA10 <span class="number">0x79</span></span><br><span class="line"><span class="number">14</span> MX6UL_PAD_LCD_DATA11__LCDIF_DATA11 <span class="number">0x79</span></span><br><span class="line"><span class="number">15</span> MX6UL_PAD_LCD_DATA12__LCDIF_DATA12 <span class="number">0x79</span></span><br><span class="line"><span class="number">16</span> MX6UL_PAD_LCD_DATA13__LCDIF_DATA13 <span class="number">0x79</span></span><br><span class="line"><span class="number">17</span> MX6UL_PAD_LCD_DATA14__LCDIF_DATA14 <span class="number">0x79</span></span><br><span class="line"><span class="number">18</span> MX6UL_PAD_LCD_DATA15__LCDIF_DATA15 <span class="number">0x79</span></span><br><span class="line"><span class="number">19</span> MX6UL_PAD_LCD_DATA16__LCDIF_DATA16 <span class="number">0x79</span></span><br><span class="line"><span class="number">20</span> MX6UL_PAD_LCD_DATA17__LCDIF_DATA17 <span class="number">0x79</span></span><br><span class="line"><span class="number">21</span> MX6UL_PAD_LCD_DATA18__LCDIF_DATA18 <span class="number">0x79</span></span><br><span class="line"><span class="number">22</span> MX6UL_PAD_LCD_DATA19__LCDIF_DATA19 <span class="number">0x79</span></span><br><span class="line"><span class="number">23</span> MX6UL_PAD_LCD_DATA20__LCDIF_DATA20 <span class="number">0x79</span></span><br><span class="line"><span class="number">24</span> MX6UL_PAD_LCD_DATA21__LCDIF_DATA21 <span class="number">0x79</span></span><br><span class="line"><span class="number">25</span> MX6UL_PAD_LCD_DATA22__LCDIF_DATA22 <span class="number">0x79</span></span><br><span class="line"><span class="number">26</span> MX6UL_PAD_LCD_DATA23__LCDIF_DATA23 <span class="number">0x79</span></span><br><span class="line"><span class="number">27</span> &gt;;<span class="comment">//为RGBLCD的27根数据线配置项</span></span><br><span class="line"><span class="number">28</span> &#125;;</span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span> pinctrl_lcdif_ctrl: lcdifctrlgrp &#123;</span><br><span class="line"><span class="number">31</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">32</span> MX6UL_PAD_LCD_CLK__LCDIF_CLK <span class="number">0x79</span></span><br><span class="line"><span class="number">33</span> MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE <span class="number">0x79</span></span><br><span class="line"><span class="number">34</span> MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC <span class="number">0x79</span></span><br><span class="line"><span class="number">35</span> MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC <span class="number">0x79</span></span><br><span class="line"><span class="number">36</span> &gt;;<span class="comment">//RGB LCD 的 4 根控制线配置项，包括 CLK、ENABLE、 VSYNC(场同步信号)和 HSYNC(行同步信号)。</span></span><br><span class="line"><span class="number">37</span> pinctrl_pwm1: pwm1grp &#123;</span><br><span class="line"><span class="number">38</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">39</span> MX6UL_PAD_GPIO1_IO08__PWM1_OUT <span class="number">0x110b0</span></span><br><span class="line"><span class="number">40</span> &gt;;<span class="comment">//LCD 背光 PWM 引脚配置项。这个引脚要根据实际情况设置，</span></span><br><span class="line"><span class="number">41</span> &#125;;</span><br></pre></td></tr></table></figure><p>之后修改lcdif节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;lcdif&#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_lcdif_dat</span><br><span class="line">    &amp;pinctrl_lcdif_ctrl</span><br><span class="line">    <span class="comment">/*&amp;pinctrl_lcdif_reset*/</span>&gt;;<span class="comment">//本显示lcd没有复位引脚所以删掉</span></span><br><span class="line">    display = &lt;&amp;display0&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    display0: display &#123; <span class="comment">/* LCD 属性信息 */</span></span><br><span class="line">bits-per-pixel = &lt;<span class="number">24</span>&gt;; <span class="comment">/* 一个像素占用几个 bit ，RGB888 8+8+8 =24bit*/</span></span><br><span class="line">bus-width = &lt;<span class="number">24</span>&gt;; <span class="comment">/* 总线宽度 */</span></span><br><span class="line"></span><br><span class="line">        display-timings &#123;</span><br><span class="line">        native-mode = &lt;&amp;timing0&gt;; <span class="comment">/* 时序信息 */</span></span><br><span class="line">        timing0: timing0 &#123;</span><br><span class="line">            clock-frequency = &lt;<span class="number">33300000</span>&gt;; <span class="comment">/* LCD 像素时钟，单位 Hz */</span></span><br><span class="line">            hactive = &lt;<span class="number">800</span>&gt;; <span class="comment">/* LCD X 轴像素个数 */</span></span><br><span class="line">            vactive = &lt;<span class="number">480</span>&gt;; <span class="comment">/* LCD Y 轴像素个数 */</span></span><br><span class="line">            hfront-porch = &lt;<span class="number">210</span>&gt;; <span class="comment">/* LCD hfp 参数 */</span></span><br><span class="line">            hback-porch = &lt;<span class="number">46</span>&gt;; <span class="comment">/* LCD hbp 参数 */</span></span><br><span class="line">            hsync-len = &lt;<span class="number">1</span>&gt;; <span class="comment">/* LCD hspw 参数 */</span></span><br><span class="line">            vback-porch = &lt;<span class="number">23</span>&gt;; <span class="comment">/* LCD vbp 参数 */</span></span><br><span class="line">            vfront-porch = &lt;<span class="number">22</span>&gt;; <span class="comment">/* LCD vfp 参数 */</span></span><br><span class="line">            vsync-len = &lt;<span class="number">1</span>&gt;; <span class="comment">/* LCD vspw 参数 */</span></span><br><span class="line"></span><br><span class="line">            hsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* hsync 数据线极性 */</span></span><br><span class="line">            vsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* vsync 数据线极性 */</span></span><br><span class="line">            de-active = &lt;<span class="number">1</span>&gt;; <span class="comment">/* de 数据线极性 */</span></span><br><span class="line">            pixelclk-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* clk 数据线先极性 */</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>背光节点信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> pinctrl_pwm1: pwm1grp &#123;</span><br><span class="line"><span class="number">2</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">3</span> MX6UL_PAD_GPIO1_IO08__PWM1_OUT <span class="number">0x110b0</span></span><br><span class="line"><span class="number">4</span> &gt;;</span><br><span class="line"><span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>LCD 背光要用到 PWM1，因此也要设置 PWM1 节点，在 imx6ull.dtsi 文件中找到如下内容： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> pwm1: pwm@<span class="number">02080000</span> &#123;</span><br><span class="line"><span class="number">2</span> compatible = <span class="string">&quot;fsl,imx6ul-pwm&quot;</span>, <span class="string">&quot;fsl,imx27-pwm&quot;</span>;</span><br><span class="line"><span class="number">3</span> reg = &lt;<span class="number">0x02080000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line"><span class="number">4</span> interrupts = &lt;GIC_SPI <span class="number">83</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line"><span class="number">5</span> clocks = &lt;&amp;clks IMX6UL_CLK_PWM1&gt;,</span><br><span class="line"><span class="number">6</span> &lt;&amp;clks IMX6UL_CLK_PWM1&gt;;</span><br><span class="line"><span class="number">7</span> clock-names = <span class="string">&quot;ipg&quot;</span>, <span class="string">&quot;per&quot;</span>;</span><br><span class="line"><span class="number">8</span> <span class="meta">#pwm-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line"><span class="number">9</span> &#125;;</span><br></pre></td></tr></table></figure><p>在整个 Linux 源码文件中搜索 compatible 属性的这两个值即可找到 imx6ull 的 pwm 驱动文件。</p><p>继续在 imx6ull-alientek-emmc.dts 文件中找到向 pwm1追加的内容，如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;pwm1 &#123;</span><br><span class="line"><span class="number">2</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">3</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_pwm1&gt;;<span class="comment">//之前定义的GPIO1_08</span></span><br><span class="line"><span class="number">4</span> status = <span class="string">&quot;okay&quot;</span>;<span class="comment">//设置okay</span></span><br><span class="line"><span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure><p>要让Linux知道PWM1_OUT是控制背光的，需要一个节点来将 LCD 背光和 PWM1_OUT连 接 起 来 。 这 个 节 点 就 是 backlight ， backlight 节 点 描 述 可 以 参 考Documentation&#x2F;devicetree&#x2F;indings&#x2F;video&#x2F;backlight&#x2F;pwm-backlight.txt 这个文档，此文档详细讲解了<br>backlight 节点该如何去创建，这里大概总结一下： </p><ol><li>节点名称要为“backlight”。</li><li>节点的 compatible 属性值要为“pwm-backlight”，因此可以通过在 Linux 内核中搜索“ pwm-backlight ” 来 查 找 PWM 背 光 控 制 驱 动 程 序 ， 这 个 驱 动 程 序 文 件 为drivers&#x2F;video&#x2F;backlight&#x2F;pwm_bl.c，感兴趣的可以去看一下这个驱动程序。</li><li>pwms属性用于描述背光所使用的PWM以及PWM频率，比如本章我们要使用的pwm1，pwm 频率设置为 200Hz(NXP 官方推荐设置)。</li><li>brightness-levels 属性描述亮度级别，范围为 0~255， 0 表示 PWM 占空比为 0%，也就是亮度最低， 255 表示 100%占空比，也就是亮度最高 </li><li>default-brightness-level 属性为默认亮度级别。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">backlight &#123;</span><br><span class="line">compatible = <span class="string">&quot;pwm-backlight&quot;</span>;</span><br><span class="line">pwms = &lt;&amp;pwm1 <span class="number">0</span> <span class="number">5000000</span>&gt;;<span class="comment">//设置背光使用 pwm1， PWM 频率为 200Hz。</span></span><br><span class="line">brightness-levels = &lt;<span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span> <span class="number">64</span> <span class="number">128</span> <span class="number">255</span>&gt;;<span class="comment">/*设置背 8 级背光(0~7)，分别为 0、 4、 8、 16、 32、 64、 128、 255，对应占空比为0%、 1.57%、 3.13%、 6.27%、 12.55%、 25.1%、 50.19%、 100%*/</span></span><br><span class="line"><span class="keyword">default</span>-brightness-level = &lt;<span class="number">6</span>&gt;;<span class="comment">//设置默认背光等级为 6，也就是 50.19%的亮度</span></span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make dtbs//编译设备树</span><br></pre></td></tr></table></figure><p>使能 Linux logo 显示 ，make menuconfig打开 Linux内核图形化配置界面，按下路径找到对应的配置项： </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-10%20195842.png"></p><p>重新编译 Linux 内核，编译完成以后使用新编译出来的 imx6ull-alientek-emmc.dtb 和 zImage 镜像启动系统 ，如果显示正常的话，LCD左上角会出现一个彩色的小企鹅logo</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-10%20200126.png"></p><h4 id="设置-LCD-作为终端控制台"><a href="#设置-LCD-作为终端控制台" class="headerlink" title="设置 LCD 作为终端控制台"></a>设置 LCD 作为终端控制台</h4><ol><li><p><strong>设置uboot中的bootargs</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=tty1 console=ttymxc0,115200 root=/dev/nfs rw nfsroot=192.168.1.250:</span><br><span class="line">/home/moss/linux/nfs/rootfs ip=192.168.0.128:192.168.1.250:192.168.0.1:255.255.255.0::eth0:off&#x27;</span><br></pre></td></tr></table></figure><p>设置了两遍 console，第一次设置 console&#x3D;tty1，也就是设置 LCD 屏幕为控制台，第二遍又设置 console&#x3D;ttymxc0,115200，也就是设置串口也作为控制台。相当于我们打开了两个 console，一个是 LCD，一个是串口，大家重启开发板就会发现 LCD 和串口都会显示 Linux 启动 log 信息。 </p></li><li><p><strong>修改&#x2F;etc&#x2F;inittab 文件</strong></p></li></ol><p>打开开发板根文件系统中的&#x2F;etc&#x2F;inittab 文件，在里面加入下面这一行： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tty1::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure><p>添加完成以后的&#x2F;etc&#x2F;inittab 文件内容如图 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-10%20200633.png">·····</p><p>修改完成以后保存&#x2F;etc&#x2F;inittab 并退出，然后重启开发板，重启以后开发板 LCD 屏幕最后一行会显示下面一行语句： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please press Enter to activate this console.</span><br></pre></td></tr></table></figure><p>至此，我们就拥有了两套终端，一个是基于串口的 SecureCRT，一个就是我们开发板的 LCD屏幕，但是为了方便调试，我们以后还是以 SecureCRT 为主。我们可以通过下面这一行命令向LCD 屏幕输出“hello linux！”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello linux &gt; /dev/tty1 </span><br></pre></td></tr></table></figure><p>通过设置背光等级来实现 LCD 背光亮度的调节，进入如下目录：&#x2F;sys&#x2F;devices&#x2F;platform&#x2F;backlight&#x2F;backlight&#x2F;backlight </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-10%20202557.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 7 &gt; brightness//设置背光等级为7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>input驱动</title>
      <link href="/2023/07/09/2023-7-9-input%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/09/2023-7-9-input%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Input子系统"><a href="#Input子系统" class="headerlink" title="Input子系统"></a>Input子系统</h2><p>input 就是输入的意思，因此 input 子系统就是管理输入的子系统，和 pinctrl、 gpio 子系统一样，都是 Linux 内核针对某一类设备而创建的框架。比如按键输入、键盘、鼠标、触摸屏等等这些都属于输入设备，为此 input 子系统分为 input 驱动层、 input 核心层、 input 事件处理层，最终给用户空间提供可访问的设备节点。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-08%20114135.png"></p><h3 id="驱动部分包含三个部分：驱动层，核心层，事件层"><a href="#驱动部分包含三个部分：驱动层，核心层，事件层" class="headerlink" title="驱动部分包含三个部分：驱动层，核心层，事件层"></a>驱动部分包含三个部分：驱动层，核心层，事件层</h3><p>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。<br>核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。<br>事件层：主要和用户空间进行交互。 </p><h3 id="注册input-dev"><a href="#注册input-dev" class="headerlink" title="注册input_dev"></a>注册input_dev</h3><p>在使用 input 子系统的时候我们只需要注册一个 input 设备即可， input_dev 结构体表示 input设备 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">121</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line"><span class="number">122</span> <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="number">123</span> <span class="type">const</span> <span class="type">char</span> *phys;</span><br><span class="line"><span class="number">124</span> <span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line"><span class="number">125</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span></span><br><span class="line"><span class="number">126</span></span><br><span class="line"><span class="number">127</span> <span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"><span class="number">128</span></span><br><span class="line"><span class="number">129</span> <span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">/* 事件类型的位图 */</span></span><br><span class="line"><span class="number">130</span> <span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="comment">/* 按键值的位图 */</span></span><br><span class="line"><span class="number">131</span> <span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="comment">/* 相对坐标的位图 */</span></span><br><span class="line"><span class="number">132</span> <span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="comment">/* 绝对坐标的位图 */</span></span><br><span class="line"><span class="number">133</span> <span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; <span class="comment">/* 杂项事件的位图 */</span></span><br><span class="line"><span class="number">134</span> <span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; <span class="comment">/*LED 相关的位图 */</span></span><br><span class="line"><span class="number">135</span> <span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="comment">/* sound 有关的位图 */</span></span><br><span class="line"><span class="number">136</span> <span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; <span class="comment">/* 压力反馈的位图 */</span></span><br><span class="line"><span class="number">137</span> <span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; <span class="comment">/*开关状态的位图 */</span></span><br><span class="line">......</span><br><span class="line"><span class="number">189</span> <span class="type">bool</span> devres_managed;</span><br><span class="line"><span class="number">190</span> &#125;;</span><br></pre></td></tr></table></figure><p>evbit 表示输入事件类型，可选的事件类型定义在 include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，事件类型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SYN 0x00 <span class="comment">/* 同步事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_KEY 0x01 <span class="comment">/* 按键事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REL 0x02 <span class="comment">/* 相对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ABS 0x03 <span class="comment">/* 绝对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_MSC 0x04 <span class="comment">/* 杂项(其他)事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SW 0x05 <span class="comment">/* 开关事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_LED 0x11 <span class="comment">/* LED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SND 0x12 <span class="comment">/* sound(声音) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REP 0x14 <span class="comment">/* 重复事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF 0x15 <span class="comment">/* 压力事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PWR 0x16 <span class="comment">/* 电源事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF_STATUS 0x17 <span class="comment">/* 压力状态事件 */</span></span></span><br></pre></td></tr></table></figure><p>Linux 内核定义了很多按键值，这些按键值定义在 include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，按键值如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">215</span> <span class="meta">#<span class="keyword">define</span> KEY_RESERVED 0</span></span><br><span class="line"><span class="number">216</span> <span class="meta">#<span class="keyword">define</span> KEY_ESC 1</span></span><br><span class="line"><span class="number">217</span> <span class="meta">#<span class="keyword">define</span> KEY_1 2</span></span><br><span class="line"><span class="number">218</span> <span class="meta">#<span class="keyword">define</span> KEY_2 3</span></span><br><span class="line"><span class="number">219</span> <span class="meta">#<span class="keyword">define</span> KEY_3 4</span></span><br><span class="line"><span class="number">220</span> <span class="meta">#<span class="keyword">define</span> KEY_4 5</span></span><br><span class="line"><span class="number">221</span> <span class="meta">#<span class="keyword">define</span> KEY_5 6</span></span><br><span class="line"><span class="number">222</span> <span class="meta">#<span class="keyword">define</span> KEY_6 7</span></span><br><span class="line"><span class="number">223</span> <span class="meta">#<span class="keyword">define</span> KEY_7 8</span></span><br><span class="line"><span class="number">224</span> <span class="meta">#<span class="keyword">define</span> KEY_8 9</span></span><br><span class="line"><span class="number">225</span> <span class="meta">#<span class="keyword">define</span> KEY_9 10</span></span><br><span class="line"><span class="number">226</span> <span class="meta">#<span class="keyword">define</span> KEY_0 11</span></span><br><span class="line">......</span><br><span class="line"><span class="number">794</span> <span class="meta">#<span class="keyword">define</span> BTN_TRIGGER_HAPPY39 0x2e6</span></span><br><span class="line"><span class="number">795</span> <span class="meta">#<span class="keyword">define</span> BTN_TRIGGER_HAPPY40 0x2e7</span></span><br></pre></td></tr></table></figure><p>在编写 input 设备驱动的时候我们需要先申请一个 input_dev 结构体变量，使用input_allocate_device 函数来申请一个 input_dev， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> input_dev *<span class="title function_">input_allocate_device</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure><p>如果要注销的 input 设备的话需要使用 input_free_device 函数来释放掉前面申请到的input_dev， i</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_free_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure><p>申请好一个 input_dev 以后就需要初始化这个 input_dev，需要初始化的内容主要为事件类型(evbit)和事件值(keybit)这两种。 input_dev 初始化完成以后就需要向 Linux 内核注册 input_dev了，需要用到 input_register_device 函数 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure><h3 id="input-dev-注册过程如下："><a href="#input-dev-注册过程如下：" class="headerlink" title="input_dev 注册过程如下："></a>input_dev 注册过程如下：</h3><p>①、使用 input_allocate_device 函数申请一个 input_dev。<br>②、初始化 input_dev 的事件类型以及事件值。<br>③、使用 input_register_device 函数向 Linux 系统注册前面初始化好的 input_dev。<br>④、卸载input驱动的时候需要先使用input_unregister_device 函数注销掉注册的input_dev，然后使用 input_free_device 函数释放掉前面申请的 input_dev。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">inputdev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    inputdev = input_allocate_device();<span class="comment">//申请input_dev</span></span><br><span class="line">    inputdev -&gt; name = <span class="string">&quot;test_inputdev&quot;</span>;<span class="comment">//设置名字</span></span><br><span class="line">    <span class="comment">//第一种设置事件和键值</span></span><br><span class="line">    __set_bit(EV_KEY, inputdev-&gt;evbit);<span class="comment">//设置产生按键事件</span></span><br><span class="line">__set_bit(EV_REP, inputdev-&gt;evbit);<span class="comment">//重复事件</span></span><br><span class="line">    __set_bit(KEY_0, inputdev-&gt;keyit);<span class="comment">//设置产生哪些按键值</span></span><br><span class="line"><span class="comment">//第二种设置事件和键值</span></span><br><span class="line">    keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY)|BIT_MASK(EV_REP);</span><br><span class="line">    keyinputdev.inputdev-&gt;keyit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);</span><br><span class="line">    <span class="comment">//第三种设置事件和键值</span></span><br><span class="line">    keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">    input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">    </span><br><span class="line">    input_register_device(inputdev);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    input_unregister_device(inputdev);</span><br><span class="line">    input_free_device(inputdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上报输入事件"><a href="#上报输入事件" class="headerlink" title="上报输入事件"></a>上报输入事件</h3><p> Linux 内核注册好 input_dev 不能顺利的使用input设备， input 设备都是具有输入功能的，但是具体是什么样的输入值 Linux 内核是不知道的，需要获取到具体的输入值，或者说是输入事件，然后将输入事件上报给 Linux 内核。比如按键，我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。不同的事件，其上报事件的 API 函数不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于上报指定事件以及对应的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="comment">//dev需要上报inputdev</span></span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> <span class="type">int</span> type,<span class="comment">//上报的事件类型如EV_KEY</span></span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> <span class="type">int</span> code,<span class="comment">//事件码也就是注册的键值</span></span></span><br><span class="line"><span class="params">                 <span class="type">int</span> value)</span><span class="comment">//事件值</span></span><br></pre></td></tr></table></figure><p>nput_event 函数可以上报所有的事件类型和事件值， Linux 内核也提供了其他的针对具体事件的上报函数，这些函数其实都用到了 input_event 函数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">input_report_key</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的还有一些其他的事件上报函数，这些函数如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_report_rel</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_abs</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_ff_status</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_switch</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_mt_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure><p>上报事件以后还需要使用 input_sync 函数来告诉 Linux 内核 input 子系统上报结束，input_sync 函数本质是上报一个同步事件， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span><span class="comment">//dev需要上报的同步事件的input_dev</span></span><br></pre></td></tr></table></figure><p>eg：按键的上报事件代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于按键消抖的定时器服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line"> </span><br><span class="line">value = gpio_get_value(keydesc-&gt;gpio); <span class="comment">/* 读取 IO 值 */</span></span><br><span class="line"><span class="keyword">if</span>(value == <span class="number">0</span>)&#123; <span class="comment">/* 按下按键 */</span></span><br><span class="line"><span class="comment">/* 上报按键值 */</span></span><br><span class="line">    input_report_key(inputdev, KEY_0, <span class="number">1</span>); <span class="comment">/* 最后一个参数 1， 按下 */</span></span><br><span class="line">        input_sync(inputdev); <span class="comment">/* 同步事件 */</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 按键松开 */</span></span><br><span class="line">input_report_key(inputdev, KEY_0, <span class="number">0</span>); <span class="comment">/* 最后一个参数 0， 松开 */</span></span><br><span class="line">input_sync(inputdev); <span class="comment">/* 同步事件 */</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux 内核使用 input_event 这个结构体来表示所有的输入事件， input_envent 结构体定义在include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，结构体内容如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span><span class="comment">//此事件发生的时间</span></span><br><span class="line">__u16 type;<span class="comment">//事件类型</span></span><br><span class="line">__u16 code;<span class="comment">//事件码</span></span><br><span class="line">__s32 value;<span class="comment">//按键值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于时间timeval的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="type">long</span><span class="type">__kernel_long_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__kernel_long_t</span><span class="type">__kernel_time_t</span>;</span><br><span class="line"><span class="keyword">typedef</span><span class="type">__kernel_long_t</span><span class="type">__kernel_suseconds_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">  <span class="type">__kernel_time_t</span>tv_sec;<span class="comment">//秒  </span></span><br><span class="line"><span class="type">__kernel_suseconds_t</span>tv_usec;<span class="comment">//微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Linux-自带按键驱动程序的使用"><a href="#Linux-自带按键驱动程序的使用" class="headerlink" title="Linux 自带按键驱动程序的使用"></a>Linux 自带按键驱动程序的使用</h3><p>编译内核make menuconfig</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-08%20160716.png"></p><p>使 用 Linux 内 核 自 带 的 按 键 驱 动 程 序 添加设备节点。</p><p>①、节点名字为“gpio-keys”。<br>②、 gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。<br>③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述自己：<br>gpios： KEY 所连接的 GPIO 信息。<br>interrupts： KEY 所使用 GPIO 中断信息，不是必须的，可以不写。<br>label： KEY 名字<br>linux,code： KEY 要模拟的按键，也就是示例代码 58.1.2.4 中的这些按键。<br>④、如果按键要支持连按的话要加入 autorepeat。<br> <strong>gpio-keys 节点内容</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gpio-keys &#123;</span><br><span class="line">compatible = <span class="string">&quot;gpio-keys&quot;</span>;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">autorepeat;</span><br><span class="line">key0 &#123;</span><br><span class="line">label = <span class="string">&quot;GPIO Key Enter&quot;</span>;</span><br><span class="line">linux,code = &lt;KEY_ENTER&gt;;</span><br><span class="line">gpios = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MISC设备驱动</title>
      <link href="/2023/07/07/2023-7-7-MISC%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/07/2023-7-7-MISC%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="MISC驱动"><a href="#MISC驱动" class="headerlink" title="MISC驱动"></a>MISC驱动</h2><p>所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。 MISC 设备会自动创建 cdev，不需要像手动创建，因此采用 MISC 设备驱动可以简化字符设备驱动的编写。 需要向 Linux 注册一个 miscdevice 设备 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> &#123;</span></span><br><span class="line"><span class="type">int</span> minor; <span class="comment">/* 子设备号 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/* 设备名字 */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span> <span class="comment">/* 设备操作集 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *nodename;</span><br><span class="line"><span class="type">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Linux 系统已经预定义了一些 MISC 设备的子设备号，这些预定义的子设备号定义在include&#x2F;linux&#x2F;miscdevice.h 文件中，如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span> <span class="meta">#<span class="keyword">define</span> PSMOUSE_MINOR 1</span></span><br><span class="line"><span class="number">14</span> <span class="meta">#<span class="keyword">define</span> MS_BUSMOUSE_MINOR 2 <span class="comment">/* unused */</span></span></span><br><span class="line"><span class="number">15</span> <span class="meta">#<span class="keyword">define</span> ATIXL_BUSMOUSE_MINOR 3 <span class="comment">/* unused */</span></span></span><br><span class="line"><span class="number">16</span> <span class="comment">/*#define AMIGAMOUSE_MINOR 4 FIXME OBSOLETE */</span></span><br><span class="line"><span class="number">17</span> <span class="meta">#<span class="keyword">define</span> ATARIMOUSE_MINOR 5 <span class="comment">/* unused */</span></span></span><br><span class="line"><span class="number">18</span> <span class="meta">#<span class="keyword">define</span> SUN_MOUSE_MINOR 6 <span class="comment">/* unused */</span></span></span><br><span class="line">......</span><br><span class="line"><span class="number">52</span> <span class="meta">#<span class="keyword">define</span> MISC_DYNAMIC_MINOR 255</span></span><br></pre></td></tr></table></figure><p>注册和删除设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">misc_register</span><span class="params">(<span class="keyword">struct</span> miscdevice * misc)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">misc_deregister</span><span class="params">(<span class="keyword">struct</span> miscdevice *misc)</span></span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misc_beepname <span class="string">&quot;miscbeep&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>beep_minor144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>BEEPON1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>BEEPOFF0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscbeep_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"><span class="type">int</span> beep_gpio;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscbeep_dev</span> <span class="title">miscbeep</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">misc_beep_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp -&gt; private_data = &amp;miscbeep;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">misc_beep_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt,<span class="type">loff_t</span> *offt )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscbeep_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t find user&#x27;s data\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">state = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(state == BEEPON)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;beep_gpio, <span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == BEEPOFF)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;beep_gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">misc_beep_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = misc_beep_open,</span><br><span class="line">.write = misc_beep_write,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">beep_miscdev</span> =</span> &#123;</span><br><span class="line">.minor = beep_minor,</span><br><span class="line">.name = misc_beepname,</span><br><span class="line">.fops = &amp;misc_beep_fops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">miscbeep_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">&quot;beep driver and device have matched\r\n&quot;</span>);</span><br><span class="line">miscbeep.nd = of_find_node_by_path(<span class="string">&quot;/beep&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(miscbeep.nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;beep node can&#x27;t find\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">miscbeep.beep_gpio = of_get_named_gpio(miscbeep.nd, <span class="string">&quot;beep-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(miscbeep.beep_gpio &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t get beep-gpio\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">ret = gpio_direction_output(miscbeep.beep_gpio, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;misc device register failed!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">ret = misc_register(&amp;beep_miscdev);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;misc device register failed\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">miscbeep_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(miscbeep.beep_gpio, <span class="number">1</span>);</span><br><span class="line">gpio_free(miscbeep.beep_gpio);<span class="comment">//将硬件资源还给linux内核</span></span><br><span class="line">misc_deregister(&amp;beep_miscdev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">beep_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123;.compatible = <span class="string">&quot;atkalpha-beep&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="comment">/*empty*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">beep_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">&quot;imx6ul-beep&quot;</span>,</span><br><span class="line">.of_match_table = beep_of_match,</span><br><span class="line">&#125;,</span><br><span class="line">.probe = miscbeep_probe,</span><br><span class="line">.remove = miscbeep_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">miscbeep_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> platform_driver_register(&amp;beep_driver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">miscbeep_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;beep_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(miscbeep_init);</span><br><span class="line">module_exit(miscbeep_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树下的platform设备驱动</title>
      <link href="/2023/07/06/2023-7-6-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8B%E7%9A%84platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/06/2023-7-6-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8B%E7%9A%84platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="设备树下的platform驱动"><a href="#设备树下的platform驱动" class="headerlink" title="设备树下的platform驱动"></a>设备树下的platform驱动</h2><p>在使用设备树的时候，设备的描述被放到了设备树中，因此 platform_device 就不需要我们去编写了，我们只需要实现 platform_driver 即可 。</p><h3 id="1-创建设备树中设备节点"><a href="#1-创建设备树中设备节点" class="headerlink" title="1.创建设备树中设备节点"></a>1.创建设备树中设备节点</h3><p>platform 总线需要通过设备节点的 compatible 属性值来匹配驱动！ 以led设备为例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gpioled&#123;</span><br><span class="line">   <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    compatible = <span class="string">&quot;atkalpha-gpioled&quot;</span>;<span class="comment">//匹配的属性</span></span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_led&gt;;</span><br><span class="line">    led-gpio = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h3 id="2-编写platform驱动时候要注意兼容属性"><a href="#2-编写platform驱动时候要注意兼容属性" class="headerlink" title="2.编写platform驱动时候要注意兼容属性"></a>2.编写platform驱动时候要注意兼容属性</h3><p>在使用设备树的时候 platform 驱动会通过 of_match_table 来保存兼容性值，也就是表明此驱动兼容哪些设备。所以， of_match_table 将会尤为重要，比如本例程的 platform 驱动中 platform_driver 就可以按照如下所示设置： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">leds_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;atkalpha-gpioled&quot;</span> &#125;, <span class="comment">/* 兼容属性 */</span></span><br><span class="line">&#123; <span class="comment">/* Sentinel */</span> &#125;<span class="comment">//在编写 of_device_id 的时候最后一个元素一定要为空！</span></span><br><span class="line">&#125;;<span class="comment">/*of_device_id 表，也就是驱动的兼容表，是一个数组，每个数组元素为 of_device_id类型。每个数组元素都是一个兼容属性，表示兼容的设备，一个驱动可以跟多个设备匹配。*/</span></span><br><span class="line">MODULE_DEVICE_TABLE(of, leds_of_match);<span class="comment">// 声明一下 leds_of_match 这个设备匹配表。</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">leds_platform_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">&quot;imx6ul-led&quot;</span>,</span><br><span class="line">    .of_match_table = leds_of_match,<span class="comment">//设置为上面的匹配表</span></span><br><span class="line">&#125;,</span><br><span class="line">    .probe = leds_probe,</span><br><span class="line">.remove = leds_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDDEV_CNT1<span class="comment">/* 设备号长度 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDDEV_NAME<span class="string">&quot;dtsplatled&quot;</span><span class="comment">/* 设备名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 1</span></span><br><span class="line"><span class="comment">/* leddev设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leddev_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备*/</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span>;</span><span class="comment">/* LED设备节点 */</span></span><br><span class="line"><span class="type">int</span> led0;<span class="comment">/* LED灯GPIO标号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leddev_dev</span> <span class="title">leddev</span>;</span> <span class="comment">/* led设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: LED打开/关闭</span></span><br><span class="line"><span class="comment"> * @param - sta : LEDON(0) 打开LED，LEDOFF(1) 关闭LED</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led0_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sta == LEDON )</span><br><span class="line">gpio_set_value(leddev.led0, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sta == LEDOFF)</span><br><span class="line">gpio_set_value(leddev.led0, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode : 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> *   一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;leddev; <span class="comment">/* 设置私有数据  */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 向设备写数据 </span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，表示打开的文件描述符</span></span><br><span class="line"><span class="comment"> * @param - buf : 要写给设备写入的数据</span></span><br><span class="line"><span class="comment"> * @param - cnt : 要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">2</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line"></span><br><span class="line">retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ledstat = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (ledstat == LEDON) &#123;</span><br><span class="line">led0_switch(LEDON);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ledstat == LEDOFF) &#123;</span><br><span class="line">led0_switch(LEDOFF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_open,</span><br><span class="line">.write = led_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: flatform驱动的probe函数，当驱动与</span></span><br><span class="line"><span class="comment"> *   设备匹配以后此函数就会执行</span></span><br><span class="line"><span class="comment"> * @param - dev : platform设备</span></span><br><span class="line"><span class="comment"> * @return : 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;led driver and device was matched!\r\n&quot;</span>);</span><br><span class="line"><span class="comment">/* 1、设置设备号 */</span></span><br><span class="line"><span class="keyword">if</span> (leddev.major) &#123;</span><br><span class="line">leddev.devid = MKDEV(leddev.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(leddev.devid, LEDDEV_CNT, LEDDEV_NAME);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alloc_chrdev_region(&amp;leddev.devid, <span class="number">0</span>, LEDDEV_CNT, LEDDEV_NAME);</span><br><span class="line">leddev.major = MAJOR(leddev.devid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、注册设备      */</span></span><br><span class="line">cdev_init(&amp;leddev.cdev, &amp;led_fops);</span><br><span class="line">cdev_add(&amp;leddev.cdev, leddev.devid, LEDDEV_CNT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、创建类      */</span></span><br><span class="line">leddev.class = class_create(THIS_MODULE, LEDDEV_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(leddev.class)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(leddev.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、创建设备 */</span></span><br><span class="line">leddev.device = device_create(leddev.class, <span class="literal">NULL</span>, leddev.devid, <span class="literal">NULL</span>, LEDDEV_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(leddev.device)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(leddev.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、初始化IO */</span></span><br><span class="line">leddev.node = of_find_node_by_path(<span class="string">&quot;/gpioled&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (leddev.node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">printk(<span class="string">&quot;gpioled node nost find!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">leddev.led0 = of_get_named_gpio(leddev.node, <span class="string">&quot;led-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (leddev.led0 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t get led-gpio\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gpio_request(leddev.led0, <span class="string">&quot;led0&quot;</span>);</span><br><span class="line">gpio_direction_output(leddev.led0, <span class="number">1</span>); <span class="comment">/* led0 IO设置为输出，默认高电平*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: platform驱动的remove函数，移除platform驱动的时候此函数会执行</span></span><br><span class="line"><span class="comment"> * @param - dev : platform设备</span></span><br><span class="line"><span class="comment"> * @return : 0，成功;其他负值,失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(leddev.led0, <span class="number">1</span>); <span class="comment">/* 卸载驱动的时候关闭LED */</span></span><br><span class="line">gpio_free(leddev.led0);<span class="comment">/* 释放IO */</span></span><br><span class="line"></span><br><span class="line">cdev_del(&amp;leddev.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">unregister_chrdev_region(leddev.devid, LEDDEV_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line">device_destroy(leddev.class, leddev.devid);</span><br><span class="line">class_destroy(leddev.class);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">led_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;atkalpha-gpioled&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* platform驱动结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">led_driver</span> =</span> &#123;</span><br><span class="line">.driver= &#123;</span><br><span class="line">.name= <span class="string">&quot;imx6ul-led&quot;</span>,<span class="comment">/* 驱动名字，用于和设备匹配 */</span></span><br><span class="line">.of_match_table= led_of_match, <span class="comment">/* 设备树匹配表  */</span></span><br><span class="line">&#125;,</span><br><span class="line">.probe= led_probe,</span><br><span class="line">.remove= led_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动模块加载函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">leddriver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> platform_driver_register(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动模块卸载函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">leddriver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;led_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(leddriver_init);</span><br><span class="line">module_exit(leddriver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;zuozhongkai&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>platform设备驱动</title>
      <link href="/2023/07/03/2023-7-3-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/07/03/2023-7-3-platform%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="驱动框架"><a href="#驱动框架" class="headerlink" title="驱动框架"></a>驱动框架</h2><h4 id="传统驱动框架"><a href="#传统驱动框架" class="headerlink" title="传统驱动框架"></a>传统驱动框架</h4><p>假如现在有三个平台 A、 B 和 C，这三个平台(这里的平台说的是 SOC)上都有 MPU6050 这个 I2C接口的六轴传感器 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-03%20144925.png"></p><p>每种平台下都有一个主机驱动和设备驱动，主机驱动肯定是必须要的，毕竟不同的平台其 I2C 控制器不同。但是右侧的设备驱动就没必要每个平台都写一个，因为不管对于那个 SOC 来说， MPU6050 都是一样，通过 I2C 接口读写数据就行了，只需要一个 MPU6050 的驱动程序即可。 </p><h3 id="分离后的驱动框架"><a href="#分离后的驱动框架" class="headerlink" title="分离后的驱动框架"></a>分离后的驱动框架</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-03%20145117.png"></p><p>相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息)，然后根据获取到的设备信息来初始化设备。 这样就相当于驱动只负责驱动，设备只负责设备，想办法将两者进行匹配即可。这个就是 Linux 中的总线(bus)、驱动(driver)和设备(device)模型，也就是常说的驱动分离。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-03%20145316.png"></p><h2 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h2><h3 id="platform总线"><a href="#platform总线" class="headerlink" title="platform总线"></a>platform总线</h3><p>paltform是一种虚拟的总线，用于管理外设资源<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>资源中断资源。在硬件上有USB-BUS总线，PCI-BUS总线，这是在物理设备上实际存在的总线。USB-BUS管理USB设备，PCI总线管理PCI设备。但是在实际中，一些设备不属于这些总线，一些SOC上面的控制器或者设备。使用platform统一管理这些设备。</p><p>Linux系统内核使用bus_type结构体表示总线</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/* 总线名字 */</span></span><br><span class="line"><span class="number">3</span> <span class="type">const</span> <span class="type">char</span> *dev_name;</span><br><span class="line"><span class="number">4</span> <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev_root</span>;</span></span><br><span class="line"><span class="number">5</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attrs</span>;</span></span><br><span class="line"><span class="number">6</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span> <span class="comment">/* 总线属性 */</span></span><br><span class="line"><span class="number">7</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span> <span class="comment">/* 设备属性 */</span></span><br><span class="line"><span class="number">8</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span> <span class="comment">/* 驱动属性 */</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">int</span> (*match)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv);<span class="comment">//完成设备和驱动之间的匹配</span></span><br><span class="line"><span class="number">11</span> <span class="type">int</span> (*uevent)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> kobj_uevent_env *env);</span><br><span class="line"><span class="number">12</span> <span class="type">int</span> (*probe)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">13</span> <span class="type">int</span> (*remove)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">14</span> <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="type">int</span> (*online)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> (*offline)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">18</span> <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state);</span><br><span class="line"><span class="number">19</span> <span class="type">int</span> (*resume)(<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="number">20</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"><span class="number">21</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"><span class="number">22</span> <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="number">23</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line"><span class="number">24</span> &#125;;</span><br></pre></td></tr></table></figure><p>总线就是使用 match 函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备，因此每一条总线都必须实现此函数。 match 函数有两个参数： dev 和 drv，这两个参数分别为 device 和 device_driver 类型，也就是设备和驱动。 </p><p>platform 总线 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">platform_bus_type</span> =</span> &#123;</span><br><span class="line"><span class="number">2</span> .name = <span class="string">&quot;platform&quot;</span>,</span><br><span class="line"><span class="number">3</span> .dev_groups = platform_dev_groups,</span><br><span class="line"><span class="number">4</span> .match = platform_match,</span><br><span class="line"><span class="number">5</span> .uevent = platform_uevent,</span><br><span class="line"><span class="number">6</span> .pm = &amp;platform_dev_pm_ops,</span><br><span class="line"><span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure><p>platform_bus_type 就是 platform 平台总线，其中 platform_match 就是匹配函数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">platform_match</span><span class="params">(<span class="keyword">struct</span> device *dev,<span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">2 &#123;</span><br><span class="line"><span class="number">3</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line"><span class="number">4</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">6</span><span class="comment">/*When driver_override is set,only bind to the matching driver*/</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">if</span> (of_driver_match_device(dev, drv))<span class="comment">//of设备树的匹配模式比较每个设备节点compatible属性和of_match_table</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="comment">/* Then try ACPI style match */</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))<span class="comment">//ACPI的匹配模式</span></span><br><span class="line"><span class="number">16</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/* Then try to match against the id table */</span></span><br><span class="line"><span class="number">19</span> <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line"><span class="number">20</span> <span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;<span class="comment">//id_table匹配</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line"><span class="number">23</span> <span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);<span class="comment">//如果id匹配的 id_table 不存在的话就比较驱动和设备的 name 字段</span></span><br><span class="line"><span class="number">24</span> &#125;</span><br></pre></td></tr></table></figure><p>对于支持设备树的 Linux 版本号，一般设备驱动为了兼容性都支持设备树和无设备树两种匹配方式。<strong>也就是第一种匹配方式一般都会存在，第三种和第四种只要存在一种就可以</strong>，一般用的最多的还是第四种，也就是直接比较驱动和设备的 name 字段，毕竟这种方式最简单了。 </p><p>platform驱动</p><p> platform_driver 结 构 体 表 示 platform  驱 动 ， 此 结 构 体 定 义 在 文 件 include&#x2F;linux&#x2F;platform_device.h 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"><span class="number">3</span> <span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"><span class="number">4</span> <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);</span><br><span class="line"><span class="number">6</span> <span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line"><span class="number">7</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line"><span class="number">8</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line"><span class="number">9</span> <span class="type">bool</span> prevent_deferred_probe;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure><p>第 2 行， probe 函数，当驱动与设备匹配成功以后 probe 函数就会执行，非常重要的函数！！<br>一般驱动的提供者会编写，如果自己要编写一个全新的驱动，那么 probe 就需要自行实现。<br>第 7 行， driver 成员，为 device_driver 结构体变量， Linux 内核里面大量使用到了面向对象的思维， device_driver 相当于基类，提供了最基础的驱动框架。 plaform_driver 继承了这个基类，然后在此基础上又添加了一些特有的成员变量。</p><p>第 8 行， id_table 表，也就是platform 总线匹配驱动和设备的时候采用的第三种方法， id_table 是个表( 也就是数组) ，每个元素的类型为 platform_device_id。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">char</span> name[PLATFORM_NAME_SIZE];</span><br><span class="line"><span class="number">3</span> <span class="type">kernel_ulong_t</span> driver_data;</span><br><span class="line"><span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *mod_name; <span class="comment">/* used for built-in modules */</span></span><br><span class="line"><span class="type">bool</span> suppress_bind_attrs; <span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_match_table</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span> *<span class="title">acpi_match_table</span>;</span></span><br><span class="line">    <span class="type">int</span> (*probe) (<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="type">int</span> (*remove) (<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="type">void</span> (*shutdown) (<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="type">int</span> (*suspend) (<span class="keyword">struct</span> device *dev, <span class="type">pm_message_t</span> state);</span><br><span class="line"><span class="type">int</span> (*resume) (<span class="keyword">struct</span> device *dev);</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>of_match_table 就是采用设备树的时候驱动使用的匹配表，同样是数组，每个匹配项都为 of_device_id 结构体类型 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> type[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> compatible[<span class="number">128</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="platform设备"><a href="#platform设备" class="headerlink" title="platform设备"></a>platform设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//设备名字</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">bool</span> id_auto;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">u32 num_resources;<span class="comment">//资源数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resource</span>;</span><span class="comment">//资源大小</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_entry</span>;</span></span><br><span class="line"><span class="type">char</span> *driver_override; <span class="comment">/* Driver name to force a match */</span></span><br><span class="line"><span class="comment">/* MFD cell pointer */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"><span class="comment">/* arch specific additions */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span> <span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line"><span class="type">resource_size_t</span> start;</span><br><span class="line"><span class="type">resource_size_t</span> end;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址， name 表示资源名字， flags 表示资源类型。</p><h2 id="platform框架"><a href="#platform框架" class="headerlink" title="platform框架"></a>platform框架</h2><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/1688375549528.jpg"></p><h2 id="platform总结"><a href="#platform总结" class="headerlink" title="platform总结"></a>platform总结</h2><p>1）定义一个 platform_driver 结构体变量。</p><p>2）实现probe函数。</p><p>3）实现remove函数。</p><p>4）实现of_match_table。</p><p>5）调用platform_driver_register 函数向 Linux 内核注册一个 platform 驱动。</p><p>6）调用platform_driver_unregister 函数卸载 platform 驱动。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典滤波算法</title>
      <link href="/2023/06/15/2023-6-15-%E7%BB%8F%E5%85%B8%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2023/06/15/2023-6-15-%E7%BB%8F%E5%85%B8%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-限幅滤波法（程序判断滤波法）"><a href="#1-限幅滤波法（程序判断滤波法）" class="headerlink" title="1.限幅滤波法（程序判断滤波法）"></a>1.限幅滤波法（程序判断滤波法）</h2><p>方法：确定两次采样允许的最大偏差值，如果本次值与上次值之差&lt;&#x3D;A,则本次有效，反之&gt;A,则本次值无效，放弃本次值，上次代替本次值。</p><p>优点：克服偶然误差造成的干扰</p><p>缺点：无法抑制周期性干扰，平滑度差</p><p>核心内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A 10</span></span><br><span class="line"><span class="type">char</span> value;</span><br><span class="line"><span class="type">char</span> <span class="title function_">filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> new_value;</span><br><span class="line">new_value = get_ad();</span><br><span class="line"><span class="keyword">if</span> ( ( new_value - value &gt; A ) || ( value - new_value &gt; A )</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A 4</span></span><br><span class="line"><span class="type">float</span> data_number[] = &#123;<span class="number">1.2</span> , <span class="number">1.3</span>, <span class="number">3.1</span>, <span class="number">2.1</span>, <span class="number">32</span>, <span class="number">2.4</span>, <span class="number">2.3</span>, <span class="number">4.1</span>&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">input</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">filter</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> sum[<span class="number">7</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">   sum[i] = filter();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%f\r\n&quot;</span>, sum[i]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">input</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> data1;</span><br><span class="line"></span><br><span class="line">j++;</span><br><span class="line">data1 = data_number[j];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> data1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">filter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> new_value;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">value = data_number[<span class="number">0</span>];    </span><br><span class="line">n = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">value = new_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_value = input();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n=%f v=%f\r\n&quot;</span>,new_value, value);</span><br><span class="line"><span class="keyword">if</span>((new_value-value &gt; A))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> new_value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-中位值滤波法"><a href="#2-中位值滤波法" class="headerlink" title="2.中位值滤波法"></a>2.中位值滤波法</h2><p>方法：连续采样 N 次（ N 取奇数）把 N 次采样值按大小排列取中间值为本次有效值。<br>优点：能有效克服因偶然因素引起的波动干扰，对温度、液位的变化缓慢的被测参数有良好的滤波效果。<br>缺点：对流量、速度等快速变化的参数不宜 。</p><p>一般处理椒盐噪声（脉冲噪声），噪声来自于ADC采样，传感器等。</p><p>核心：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 11</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> value_buf[N];</span><br><span class="line"><span class="type">char</span> count,i,j,temp;</span><br><span class="line"><span class="keyword">for</span> ( count = <span class="number">0</span>;count &lt; N; count++） </span><br><span class="line">    &#123;</span><br><span class="line">value_buf[count] = get_ad();</span><br><span class="line">delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;N<span class="number">-1</span>;j++) <span class="comment">//冒泡法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>-j;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( value_buf[i]&gt;value_buf[i+<span class="number">1</span>] )</span><br><span class="line">&#123;</span><br><span class="line">temp = value_buf[i];</span><br><span class="line">value_buf [i]= value_buf[i+<span class="number">1</span>];</span><br><span class="line">value_buf[i+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value_buf[(N<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="type">int</span> num[N] = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">filter</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">input</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> med;</span><br><span class="line">med = filter();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;med = %d&quot;</span>, med);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">input</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> j = <span class="number">0</span> ;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">data = num[j];</span><br><span class="line">j++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">filter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> value_buf[N];</span><br><span class="line"><span class="type">int</span> count, i, j, temp;</span><br><span class="line">temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(count = <span class="number">0</span>; count &lt; N; count++)</span><br><span class="line">&#123;</span><br><span class="line">value_buf[count] = input();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N<span class="number">-1</span> ; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N<span class="number">-1</span>-j; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(value_buf[i]&gt;value_buf[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp = value_buf[i];</span><br><span class="line">value_buf[i] = value_buf[i+<span class="number">1</span>];</span><br><span class="line">value_buf[i+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value_buf[(N<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把滤波区间的数据从小到大进行排序，然后取中值，（如果是奇数个数据，那么中值就只有一个了，如果偶数个数据，中值有两个，可以对两个数据再求平均,</p><p><strong>是把要处理的数据用中值代替，不是全部放成中值。</strong></p><h2 id="3-算术平均滤波"><a href="#3-算术平均滤波" class="headerlink" title="3.算术平均滤波"></a>3.算术平均滤波</h2><p>方法：连续取 N 个采样值进行算术平均运算，N 值较大时：信号平滑度较高，但灵敏度较低N 值较小时：信号平滑度较低，但灵敏度较高，N 值的选取：一般流量， N&#x3D;12；压力： N&#x3D;4。<br>优点：<br>适用于对一般具有随机干扰的信号进行滤波，这样信号的特点是有一个平均值，信号在某一数值范围附近上下波动。<br>缺点：<br>对于测量速度较慢或要求数据计算速度较快的实时控制不适用，比较浪费 RAM 。</p><p>一般处理高斯噪声，噪声来源于热产生，是随机噪声，服从高斯分布。</p><p>核心：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 12</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( count=<span class="number">0</span>;count&lt;N;count++)</span><br><span class="line">&#123;</span><br><span class="line">sum + = get_ad();</span><br><span class="line">delay();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">char</span>)(sum/N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是缺点明显，但是u低于偶然异常，对于某次的采样明显偏大，经过平均计算后导致最终值存在较大偏差，针对这种极大值或者极小值，可以在算数平均前进行剔除。</p><p>改进的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">filter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SAMPLE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vBat[i] &lt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = vBat[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vBat[i] &lt; min)</span><br><span class="line">        &#123;</span><br><span class="line">            min = vBat[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += vBat[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum - min - max;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum/SAMPL_NAM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、递推平均滤波法（又称滑动平均滤波法）"><a href="#4、递推平均滤波法（又称滑动平均滤波法）" class="headerlink" title="4、递推平均滤波法（又称滑动平均滤波法）"></a>4、递推平均滤波法（又称滑动平均滤波法）</h2><p>方法：<br>把连续取 N 个采样值看成一个队列,队列的长度固定为 N,每次采样到一个新数据放入队尾,并扔掉原来队首的一次数据.(先进先出原则)<br>把队列中的 N 个数据进行算术平均运算,就可获得新的滤波结果,N 值的选取：流量， N&#x3D;12；压力： N&#x3D;4；液面， N&#x3D;4<del>12；温度， N&#x3D;1</del>4<br>优点：<br>对周期性干扰有良好的抑制作用，平滑度高,适用于高频振荡的系统<br>缺点：<br>灵敏度低,对偶然出现的脉冲性干扰的抑制作用较差,不易消除由于脉冲干扰所引起的采样值偏差,不适用于脉冲干扰比较严重的场合,<br>比较浪费 RAM </p><p>核心：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 12</span></span><br><span class="line"><span class="type">char</span> value_buf[N];</span><br><span class="line"><span class="type">char</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">filter</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> count;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">value_buf[i++] = get_ad();</span><br><span class="line"><span class="keyword">if</span> ( i == N ) i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( count=<span class="number">0</span>;count&lt;N;count++) sum = value_buf[count];</span><br><span class="line"><span class="keyword">return</span> (<span class="type">char</span>)(sum/N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C知识点</title>
      <link href="/2023/06/09/2023-06-09-%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/06/09/2023-06-09-%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h4 id="一-用预处理指令-define-声明一个常数，用以表明1年中有多少秒（忽略闰年问题）"><a href="#一-用预处理指令-define-声明一个常数，用以表明1年中有多少秒（忽略闰年问题）" class="headerlink" title="一. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）"></a>一. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a_year (365*24*60*60)UL</span></span><br><span class="line"><span class="comment">//UL无符号整形</span></span><br></pre></td></tr></table></figure><h4 id="二-写一个”标准”宏MIN-，这个宏输入两个参数并返回较小的一个"><a href="#二-写一个”标准”宏MIN-，这个宏输入两个参数并返回较小的一个" class="headerlink" title="二. 写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个"></a>二. 写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>MIN( a, b)((a&lt;=b)?(a):(b))</span></span><br></pre></td></tr></table></figure><h4 id="三-嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？"><a href="#三-嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？" class="headerlink" title="三. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？"></a>三. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;&#125;</span><br><span class="line">loop:...</span><br><span class="line"><span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure><h4 id="四-用变量a给出下面的定义"><a href="#四-用变量a给出下面的定义" class="headerlink" title="四. 用变量a给出下面的定义"></a>四. 用变量a给出下面的定义</h4><ul><li>a) 一个整型数（An integer）</li><li>b)一个指向整型数的指针（ A pointer to an integer）</li><li>c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）</li><li>d)一个有10个整型数的数组（ An array of 10 integers）</li><li>e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）</li><li>f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）</li><li>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）</li><li>h)  一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数 （ An array of ten pointers to functions that take an integer argument and return an integer ）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> **p;</span><br><span class="line"><span class="type">int</span> sum[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *sum[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*sum)[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *<span class="title function_">prie</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line"><span class="title function_">int</span> <span class="params">(*prie[<span class="number">10</span>](<span class="type">int</span>))</span></span><br></pre></td></tr></table></figure><h4 id="五-关键字static的作用是什么？"><a href="#五-关键字static的作用是什么？" class="headerlink" title="五. 关键字static的作用是什么？"></a>五. 关键字static的作用是什么？</h4><p>首先，是static修饰了变量，延长了变量生命周期，直到程序运行结束后才释放。</p><p>之后是static修饰一个函数则这个函数<strong>只能在本文件中调用，不能被其他文件调用</strong>，Static修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为0；</p><p>static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。</p><h4 id="六-关键字const有什么含意？"><a href="#六-关键字const有什么含意？" class="headerlink" title="六. 关键字const有什么含意？"></a>六. 关键字const有什么含意？</h4><p>要一个变量前用const来修饰，就意味着该变量里的数据只能被访问，而不能被修改，也就是意味着const“只读”（readonly）。</p><h4 id="七-关键字volatile有什么含意？并给出三个不同的例子"><a href="#七-关键字volatile有什么含意？并给出三个不同的例子" class="headerlink" title="七. 关键字volatile有什么含意？并给出三个不同的例子"></a>七. 关键字volatile有什么含意？并给出三个不同的例子</h4><p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p><ul><li>并行设备的硬件寄存器（如：状态寄存器）</li><li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</li><li>多线程应用中被几个任务共享的变量</li></ul><h4 id="八-嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit-3，第二个清除a-的bit-3。在以上两个操作中，要保持其它位不变。"><a href="#八-嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit-3，第二个清除a-的bit-3。在以上两个操作中，要保持其它位不变。" class="headerlink" title="八. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。"></a>八. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    </span><br><span class="line">    a |= (a &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    a &amp;= ~( a &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="九-下面的代码输出是什么，为什么？"><a href="#九-下面的代码输出是什么，为什么？" class="headerlink" title="九. 下面的代码输出是什么，为什么？"></a>九. 下面的代码输出是什么，为什么？</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">-20</span>;</span><br><span class="line">    (a+b &gt; <span class="number">6</span>) ? <span class="built_in">puts</span>(<span class="string">&quot;&gt;6&quot;</span>) : (<span class="string">&quot;&lt;=6&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管如何，这无符号整型问题的答案是输出是 “&gt;6”。原因 是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。</p><p>因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研电赛</title>
      <link href="/2023/05/31/2023-4-22-%E7%A0%94%E7%94%B5%E8%B5%9B/"/>
      <url>/2023/05/31/2023-4-22-%E7%A0%94%E7%94%B5%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：超声接近感知系统"><a href="#题目：超声接近感知系统" class="headerlink" title="题目：超声接近感知系统"></a>题目：超声接近感知系统</h2><p>（1）赛题主要考察接近感知系统的实现，可使用指示灯的亮灭来表征接近态和远离态</p><p>（2）以超声波技术为基础实现接近感知。可辅助使用加速度、陀螺仪或等其他传感器，来提高准确率（如提取接听电话动作中的距离、姿态、运动轨迹…等信息的变化）。</p><h4 id="设计stm32pcb"><a href="#设计stm32pcb" class="headerlink" title="设计stm32pcb"></a>设计stm32pcb</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-31%20141653.png"></p><h4 id="设计姿态传感器pcb"><a href="#设计姿态传感器pcb" class="headerlink" title="设计姿态传感器pcb"></a>设计姿态传感器pcb</h4><p>由磁力计IST8310和陀螺仪BMI088组成。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-21%20214647.png"></p><p>由于先设计的硬件，并没确定使用的IO口，所以分为了两个板子，为了符合题目要求，pcb上打上通孔，便于使用螺丝连接。</p><p>使用MCU是stm32f407VGT6的型号，在使用usart进行串口通信的时候发现会出现，乱码的问题，最后发现问题的原因出在了，晶振的频率源头上，</p><p>#define HSE_VALUE 25000000 把25改为8.</p><p>使用两个超声波模块，使用spi和iic通信来读取姿态传感器的数据。</p><p>关于SPI的通信使用为了节省CPU的占有率，使用了串口DMA的通信方式，DMA传输将数据从一个地址空间复制到另一个地址空间， 提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。</p><p>关于这种pcb的贴片焊接，是建议用<strong>开一个钢网，之后刷锡膏，放器件，回炉加热</strong>就可以了。对于芯片来讲还是要开钢网的，由于此次没开钢网，导致有个别的引脚焊接在一起。</p><p>关于此次的pcb还有一个问题就是外部晶振坏了，所以导致定时器工作不稳定，数据出问题，所以当确定程序无误时候，查一下硬件，毕竟是自己做的，可能是出现了问题，所以时钟源使用的是RC的内部震荡。</p><p>之后超声波的使用是使用定时器来进行输入捕获，来实现高电平的脉宽时间读取，之后才能计算超声波的距离。</p><p>为了控制陀螺仪温度，控制零飘，所以使用了pid来控制温度。复习了一下pid的知识点</p><h4 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-31%20142627.png"></p><h4 id="姿态解算任务"><a href="#姿态解算任务" class="headerlink" title="姿态解算任务"></a>姿态解算任务</h4><p>姿态是反应物体相对于参考坐标系的指向。常使用欧拉角代表物体的姿态，描述物体姿态需要三个角度，分别是 yaw(偏航角), pitch(俯仰角),roll(横滚角)。Yaw(偏航角)是绕 z 轴的角度，pitch 是绕 y 轴的角度，roll 是绕 x 轴的角度。</p><p>mahony 算法是常见的姿态融合算法，将加速度计，磁力计，陀螺仪共九轴数据，融合解算出载体四元数</p><p><a href="https://x-io.co.uk/open-source-imu-and-ahrs-algorithms/%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E3%80%82%E6%94%BE%E5%88%B0%E5%B7%A5%E7%A8%8B%E9%87%8C%E8%BF%9B%E8%A1%8C%E7%A7%BB%E6%A4%8D%E3%80%82">https://x-io.co.uk/open-source-imu-and-ahrs-algorithms/下载网址。放到工程里进行移植。</a></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E7%BD%91%E9%A1%B5%E6%8D%95%E8%8E%B7_31-5-2023_143843_.jpeg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux异步通知</title>
      <link href="/2023/05/18/2023-5-18-linux%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/"/>
      <url>/2023/05/18/2023-5-18-linux%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h2><p><strong>异步通知：一旦设备准备就绪，则主动通知应用程序，这样引用程序根本不需要查询设备状态</strong>，由此引入了信号的概念，信号是在软件层次上的对中断机制的一种模拟，驱动可以通过主动向应用程序发送信号的方式来报告自己可以访问了，应用程序获取到信号以后就可以从驱动设备中读取或者写入数据了。整个过程就相当于应用程序收到了驱动发送过来了的一个中断，然后应用程序去响应这个中断，。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/eatfrqag.png"></p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>Linux中用异步信号来实现进程通信（IPC）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34</span> <span class="meta">#<span class="keyword">define</span> SIGHUP 1 <span class="comment">/* 终端挂起或控制进程终止 */</span></span></span><br><span class="line"><span class="number">35</span> <span class="meta">#<span class="keyword">define</span> SIGINT 2 <span class="comment">/* 终端中断(Ctrl+C 组合键) */</span></span></span><br><span class="line"><span class="number">36</span> <span class="meta">#<span class="keyword">define</span> SIGQUIT 3 <span class="comment">/* 终端退出(Ctrl+\组合键) */</span></span></span><br><span class="line"><span class="number">37</span> <span class="meta">#<span class="keyword">define</span> SIGILL 4 <span class="comment">/* 非法指令 */</span></span></span><br><span class="line"><span class="number">38</span> <span class="meta">#<span class="keyword">define</span> SIGTRAP 5 <span class="comment">/* debug 使用，有断点指令产生 */</span></span></span><br><span class="line"><span class="number">39</span> <span class="meta">#<span class="keyword">define</span> SIGABRT 6 <span class="comment">/* 由 abort(3)发出的退出指令 */</span></span></span><br><span class="line"><span class="number">40</span> <span class="meta">#<span class="keyword">define</span> SIGIOT 6 <span class="comment">/* IOT 指令 */</span></span></span><br><span class="line"><span class="number">41</span> <span class="meta">#<span class="keyword">define</span> SIGBUS 7 <span class="comment">/* 总线错误 */</span></span></span><br><span class="line"><span class="number">42</span> <span class="meta">#<span class="keyword">define</span> SIGFPE 8 <span class="comment">/* 浮点运算错误 */</span></span></span><br><span class="line"><span class="number">43</span> <span class="meta">#<span class="keyword">define</span> SIGKILL 9 <span class="comment">/* 杀死、终止进程 */</span></span></span><br><span class="line"><span class="number">44</span> <span class="meta">#<span class="keyword">define</span> SIGUSR1 10 <span class="comment">/* 用户自定义信号 1 */</span></span></span><br><span class="line"><span class="number">45</span> <span class="meta">#<span class="keyword">define</span> SIGSEGV 11 <span class="comment">/* 段违例(无效的内存段) */</span></span></span><br><span class="line"><span class="number">46</span> <span class="meta">#<span class="keyword">define</span> SIGUSR2 12 <span class="comment">/* 用户自定义信号 2 */</span></span></span><br><span class="line"><span class="number">47</span> <span class="meta">#<span class="keyword">define</span> SIGPIPE 13 <span class="comment">/* 向非读管道写入数据 */</span></span></span><br><span class="line"><span class="number">48</span> <span class="meta">#<span class="keyword">define</span> SIGALRM 14 <span class="comment">/* 闹钟 */</span></span></span><br><span class="line"><span class="number">49</span> <span class="meta">#<span class="keyword">define</span> SIGTERM 15 <span class="comment">/* 软件终止 */</span></span></span><br><span class="line"><span class="number">50</span> <span class="meta">#<span class="keyword">define</span> SIGSTKFLT 16 <span class="comment">/* 栈异常 */</span></span></span><br><span class="line"><span class="number">51</span> <span class="meta">#<span class="keyword">define</span> SIGCHLD 17 <span class="comment">/* 子进程结束 */</span></span></span><br><span class="line"><span class="number">52</span> <span class="meta">#<span class="keyword">define</span> SIGCONT 18 <span class="comment">/* 进程继续 */</span></span></span><br><span class="line"><span class="number">53</span> <span class="meta">#<span class="keyword">define</span> SIGSTOP 19 <span class="comment">/* 停止进程的执行，只是暂停 */</span></span></span><br><span class="line"><span class="number">54</span> <span class="meta">#<span class="keyword">define</span> SIGTSTP 20 <span class="comment">/* 停止进程的运行(Ctrl+Z 组合键) */</span></span></span><br><span class="line"><span class="number">55</span> <span class="meta">#<span class="keyword">define</span> SIGTTIN 21 <span class="comment">/* 后台进程需要从终端读取数据 */</span></span></span><br><span class="line"><span class="number">56</span> <span class="meta">#<span class="keyword">define</span> SIGTTOU 22 <span class="comment">/* 后台进程需要向终端写数据 */</span></span></span><br><span class="line"><span class="number">57</span> <span class="meta">#<span class="keyword">define</span> SIGURG 23 <span class="comment">/* 有&quot;紧急&quot;数据 */</span></span></span><br><span class="line"><span class="number">58</span> <span class="meta">#<span class="keyword">define</span> SIGXCPU 24 <span class="comment">/* 超过 CPU 资源限制 */</span></span></span><br><span class="line"><span class="number">59</span> <span class="meta">#<span class="keyword">define</span> SIGXFSZ 25 <span class="comment">/* 文件大小超额 */</span></span></span><br><span class="line"><span class="number">60</span> <span class="meta">#<span class="keyword">define</span> SIGVTALRM 26 <span class="comment">/* 虚拟时钟信号 */</span></span></span><br><span class="line"><span class="number">61</span> <span class="meta">#<span class="keyword">define</span> SIGPROF 27 <span class="comment">/* 时钟信号描述 */</span></span></span><br><span class="line"><span class="number">62</span> <span class="meta">#<span class="keyword">define</span> SIGWINCH 28 <span class="comment">/* 窗口大小改变 */</span></span></span><br><span class="line"><span class="number">63</span> <span class="meta">#<span class="keyword">define</span> SIGIO 29 <span class="comment">/* 可以进行输入/输出操作 */</span></span></span><br><span class="line"><span class="number">64</span> <span class="meta">#<span class="keyword">define</span> SIGPOLL SIGIO</span></span><br><span class="line"><span class="number">65</span> <span class="comment">/* #define SIGLOS 29 */</span></span><br><span class="line"><span class="number">66</span> <span class="meta">#<span class="keyword">define</span> SIGPWR 30 <span class="comment">/* 断点重启 */</span></span></span><br><span class="line"><span class="number">67</span> <span class="meta">#<span class="keyword">define</span> SIGSYS 31 <span class="comment">/* 非法的系统调用 */</span></span></span><br><span class="line"><span class="number">68</span> <span class="meta">#<span class="keyword">define</span> SIGUNUSED 31 <span class="comment">/* 未使用信号 */</span></span></span><br></pre></td></tr></table></figure><h4 id="信号的接收"><a href="#信号的接收" class="headerlink" title="信号的接收"></a>信号的接收</h4><p><strong>在应用程序中使用 signal 函数来设置指定信号的处理函数</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span><br><span class="line"><span class="comment">/*第一个参数处理的信号，第二个参数指定指针对前面信号值的处理函数，调用成功返回最后一次为信号signum绑定handler值，失败返回SIG_ERR*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span><br></pre></td></tr></table></figure><p><strong>为文件描述符的设置属主</strong></p><p>通过 fcntl() 的 F_SETOWN 操作来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(fd, F_SETOWN, pid)</span><br></pre></td></tr></table></figure><p>属主是当文件描述符上可执行 I&#x2F;O 时，会接收到通知信号的进程或进程组。</p><p>pid 为正整数时，代表了进程 ID 号。</p><p>pid 为负整数时，它的绝对值就代表了进程组 ID 号。</p><p><strong><u>使用信号异步通知的应用程序</u></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 100</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_handler</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data[MAX_LEN];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    len = read(STDIN_FILENO, &amp;data, MAX_LEN)；</span><br><span class="line">    data[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input available :%s\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> oflags;</span><br><span class="line">    signal(SIGIO, input_handler);</span><br><span class="line">    fcntl(STDIN_FILENO, F_SETOWN, getpid());<span class="comment">//fcntl函数对描述符提供控制</span></span><br><span class="line">    oflags = fcntl(STDIN_FILENO,F_GETFL);</span><br><span class="line">    fcntl(STDIN_FILENO, F_SETFL, oflags|FASYNC);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);<span class="comment">//为了保证进程不终止。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看到，为了在用户空间中能处理一个设备释放的信号，必须完成三项工作：</p><ol><li>通过F_SETOWN IO控制命令设置设备文件的拥有者为本进程，这样从设备驱动发出的信号才能被本进程接收到；</li><li>通过F_SETFL IO控制命令设置设备文件支持FASYNC，即异步通知；</li><li>通过signal函数连结信号和信号处理函数。</li></ol><h4 id="信号的释放"><a href="#信号的释放" class="headerlink" title="信号的释放"></a>信号的释放</h4><p>在设备驱动和应用程序的异步通知交互中，仅仅在应用程序端捕获信号是不够的，因为信号没有的源头在设备驱动端，因此，应该在合适的时机让设备驱动释放信号， 在设备驱动程序中加信号释放的代码。</p><p>为支持异步通知机制，驱动程序中涉及以下三项工作。</p><p>支持F_SETOWN命令。能在这个控制命令处理中设置filp-&gt;f_owner为对应进程ID。不过此项工作已由内核完成，设备驱动无需处理。</p><p>支持S_SETFL命令处理，每当FASYNC标志改变时，驱动程序中的fasync()函数将执行。</p><p>在设备可获得时候，调用kill_fasync()函数激发相应的信号</p><p>异步通知中用户空间和设备驱动之间的交互：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/Screenshot_20230518_204435.jpg"></p><p>设备驱动中要用到一项数据结构和两个函数：</p><p>在驱动程序中定义一个 fasync_struct 结构体指针变量 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> fa_lock;</span><br><span class="line"><span class="type">int</span> magic;</span><br><span class="line"><span class="type">int</span> fa_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fa_next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fa_file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">fa_rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一般将 fasync_struct 结构体指针变量定义到设备结构体中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span> <span class="comment">/* 异步相关结构体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要使用异步通知，需要在设备驱动中实现 file_operations 操作集中的 fasync 函数 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> on)</span><br></pre></td></tr></table></figure><p>fasync 函数里面一般通过调用 fasync_helper 函数来初始化前面定义的 fasync_struct 结构体指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fasync_helper</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file * filp, <span class="type">int</span> on, <span class="keyword">struct</span> fasync_struct **fapp)</span></span><br></pre></td></tr></table></figure><p>  <strong>当应用程序通过“fcntl(fd, F_SETFL, flags | FASYNC)”改变fasync 标记的时候，驱动程序 file_operations 操作集中的 fasync 函数就会执行。</strong></p><p>驱动中fasync参考实例： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span>&#123;</span></span><br><span class="line">  .......  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *filp, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">dev</span> =</span> (xxx_dev *)filp -&gt; privata_data;</span><br><span class="line">    <span class="keyword">if</span>(fasync_helper(fd, filp, on ,&amp;dev-&gt;async_queue) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">xxx_release</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> xxx_fasync( <span class="number">-1</span>, filp, <span class="number">0</span>);<span class="comment">//调用函数完成fasync_struct 的释放工作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">xxx_ops</span> =</span> &#123;</span><br><span class="line">  ....</span><br><span class="line">  .fasync = xxx_fasync,</span><br><span class="line">  .release = xxx_release,</span><br><span class="line">  ....  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>kill_fasync 函数</strong> </p><p>当设备可以访问的时候，驱动程序需要向应用程序发出信号，相当于产生“中断”。 kill_fasync函数负责发送指定的信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kill_fasync</span><span class="params">(<span class="keyword">struct</span> fasync_struct **fp, <span class="type">int</span> sig, <span class="type">int</span> band)</span></span><br></pre></td></tr></table></figure><p>fp：要操作的 fasync_struct。<br>sig： 要发送的信号。<br>band： 可读时设置为 POLL_IN，可写时设置为 POLL_OUT。<br>返回值： 无。 </p><h4 id="应用程序对异步通知的处理"><a href="#应用程序对异步通知的处理" class="headerlink" title="应用程序对异步通知的处理"></a>应用程序对异步通知的处理</h4><p>应用程序对异步通知的处理包括以下三步：</p><ol><li>注册信号处理函数（使用signal函数）</li><li>将本应用程序的进程号告诉给内核（使用 fcntl(fd, F_SETOWN, getpid())将本应用程序的进程号告诉给内核 ）</li><li>开启异步通知</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flags = fcntl(fd, F_GETFL); <span class="comment">/* 获取当前的进程状态 */</span></span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC); <span class="comment">/* 开启当前进程异步通知功能 */</span></span><br></pre></td></tr></table></figure><h3 id="备注fcntl函数用法"><a href="#备注fcntl函数用法" class="headerlink" title="备注fcntl函数用法"></a>备注fcntl函数用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span>;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd ,<span class="keyword">struct</span> flock* lock)</span>;  </span><br></pre></td></tr></table></figure><p>cmd的值不同有对应功能如下：</p><table><thead><tr><th>命令名</th><th>描述</th></tr></thead><tbody><tr><td>F_DUPFD</td><td>复制文件描述符</td></tr><tr><td>F_GETFD</td><td>获取文件描述符标志</td></tr><tr><td>F_SETFD</td><td>设置文件描述符标志</td></tr><tr><td>F_GETFL</td><td>获取文件状态标志</td></tr><tr><td>F_SETFL</td><td>设置文件状态标志</td></tr><tr><td>F_GETLK</td><td>获取文件锁</td></tr><tr><td>F_SETLK</td><td>设置文件锁</td></tr><tr><td>F_SETOWN</td><td>设置当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td></tr><tr><td>F_SETLKW</td><td>类似F_SETLK,但等待返回</td></tr><tr><td>F_GETOWN</td><td>获取当前接收SIGIO和SIGURG信号的进程ID和进程组ID</td></tr></tbody></table><h4 id="应用程序对异步通知的处理-1"><a href="#应用程序对异步通知的处理-1" class="headerlink" title="应用程序对异步通知的处理"></a>应用程序对异步通知的处理</h4><p><strong>1、注册信号处理函数</strong><br>应用程序根据驱动程序所使用的信号来设置信号的处理函数，应用程序使用 signal 函数来设置信号的处理函数。<br><strong>2、将本应用程序的进程号告诉给内核</strong><br>使用 fcntl(fd, F_SETOWN, getpid())将本应用程序的进程号告诉给内核。<br><strong>3、开启异步通知</strong><br>使用如下两行程序开启异步通知：<br>flags &#x3D; fcntl(fd, F_GETFL); &#x2F;* 获取当前的进程状态 <em>&#x2F;<br>fcntl(fd, F_SETFL, flags | FASYNC); &#x2F;</em> 开启当前进程异步通知功能 *&#x2F;<br>重点就是通过 fcntl 函数设置进程状态为 FASYNC，经过这一步，驱动程序中的 fasync 函数就会执行 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux阻塞与非阻塞</title>
      <link href="/2023/05/10/2023-5-10-linux%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
      <url>/2023/05/10/2023-5-10-linux%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞和非阻塞IO"><a href="#阻塞和非阻塞IO" class="headerlink" title="阻塞和非阻塞IO"></a>阻塞和非阻塞IO</h2><p>阻塞式</p><p>当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 IO 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-10%20115842.png"></p><p>非阻塞式</p><p>对于非阻塞 IO，应用程序对应的线程不会挂<br>起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-10%20115857.png"></p><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><h4 id="等待队列头"><a href="#等待队列头" class="headerlink" title="等待队列头"></a>等待队列头</h4><p>阻塞式的好处就是，当无法获取资源的时候进程进入休眠状态，让出cpu来干别的事情，可以操作的时候再进行唤醒（<strong>一般在中断里唤醒</strong>）。</p><p>Linux内核提供了等待队列来实现阻塞进程的唤醒工作，首先要创建并初始化一个等待队列头，等待队列头使用结构体wait_queue_head_t表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span>&#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">task_list</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br><span class="line"><span class="comment">//使用init_waitqueue_head初始化等待队列头</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_waitqueue_head</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span><span class="comment">//q为初始化的等待队列头</span></span><br></pre></td></tr></table></figure><h4 id="等待队列项"><a href="#等待队列项" class="headerlink" title="等待队列项"></a>等待队列项</h4><p>每个访问设备的进程都是一个队列项，当设备不可用的时候就要将这些进程对应的等待队列项添加到等待队列里面。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>flags;</span><br><span class="line">    <span class="type">void</span>*private;</span><br><span class="line">    <span class="type">wait_queue_func_t</span>func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">task_list</span>;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br><span class="line"><span class="comment">//使用宏DECLARE_WAITQUEUE定义初始化一个等待队列项</span></span><br><span class="line">DECLARE_WAITQUEUE(name, tsk)<span class="comment">//name等待队列项的名字，tsk表示等待队列项属于哪个进程</span></span><br></pre></td></tr></table></figure><h4 id="添加或移除等待队列头"><a href="#添加或移除等待队列头" class="headerlink" title="添加或移除等待队列头"></a>添加或移除等待队列头</h4><p>当设备不可访问的时候就需要将进程对应的等待队列项添加到前面创建的等待队列头中，只有添加到等待队列头中以后进程才能进入休眠态。当设备可以访问以后再将进程对应的等待队列项从等待队列头中移除即可 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span>*wait)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_wait_queue</span><span class="params">(<span class="type">wait_queue_head_t</span> *q, <span class="type">wait_queue_t</span> *wait)</span></span><br></pre></td></tr></table></figure><h4 id="等待唤醒"><a href="#等待唤醒" class="headerlink" title="等待唤醒"></a>等待唤醒</h4><p>当设备可以使用的时候就要唤醒进入休眠态的进程 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up_interruptible</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span></span><br></pre></td></tr></table></figure><p>两个函数会将这个等待队列头中的所有进程都唤醒。wake_up 函数可以唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 状态的进程，而 wake_up_interruptible 函数只能唤醒处于 TASK_INTERRUPTIBLE 状态的进程。 </p><h4 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h4><p>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程 </p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>wait_event(wq, condition)</td><td>等待以 wq 为等待队列头的等待队列被唤醒，前提是 condition 条件必须满足(为真)，否则一直阻塞 此 函 数 会 将 进 程 设 置 为TASK_UNINTERRUPTIBLE 状态</td></tr><tr><td>wait_event_timeout(wq,condition,timeout)</td><td>功能和 wait_event 类似，但是此函数可以添加超时时间，以 jiffies 为单位。此函数有返回值，如果返回 0 的话表示超时时间到，而且 condition为假。为 1 的话表示 condition 为真，也就是条件满足了。</td></tr><tr><td>wait_event_interruptible(wq, condition)</td><td>与 wait_event 函数类似，但是此函数将进程设置为 TASK_INTERRUPTIBLE，就是可以被信号打断。</td></tr><tr><td>wait_event_interruptible_timeout(wq,condition, timeout)</td><td>与 wait_event_timeout 函数类似，此函数也将进程设置为 TASK_INTERRUPTIBLE，可以被信号打断</td></tr></tbody></table><p><img src="https://gitee.com/hanfengdyh/image/raw/master/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-19%20184010.png"></p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>如果用户应用程序以非阻塞的方式访问设备，设备驱动程序就要提供非阻塞的处理方式，也就是轮询。 poll、 epoll 和 select 可以用于处理轮询，应用程序通过 select、 epoll 或 poll 函数来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。 </p><p><strong>select函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">           fd_set *readfds,</span></span><br><span class="line"><span class="params">           fd_set *writefds,</span></span><br><span class="line"><span class="params">           fd_set *exceptfds,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> timeval *timeout)</span></span><br></pre></td></tr></table></figure><p>nfds:所要监视的这三类文件描述集合中， 最大文件描述符加 1。 </p><p>readfds、 writefds 和 exceptfds ：readfds 用于监视指定描述符集的读变化，也就是监视这些文件是否可以读取，只要这些集合里面有一个文件可以读取那么 seclect 就会返回一个大于 0 的值表示文件可以读取。如果没有文件可以读取，那么就会根据 timeout 参数来判断是否超时。可以将 readfs设置为 NULL，表示不关心任何文件的读变化。 </p><p>exceptfds 用于监视这些文件的异常 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span><span class="comment">//所有位清零</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span><span class="comment">//将某个位置1，也就是向 fd_set 添加一个文件描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span><span class="comment">//将某个位清0，也就是将一个文件描述符从 fd_set 中删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span><span class="comment">//用于测试一个文件是否属于某个集合</span></span><br></pre></td></tr></table></figure><p>timeout:超时时间，调用select等待某些文件描述符可以设置超时时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">timeval</span>&#123;</span></span><br><span class="line">   <span class="type">long</span>tv_sec ;<span class="comment">//秒</span></span><br><span class="line">   <span class="type">long</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>返回值： 0，表示的话就表示超时发生，但是没有任何文件描述符可以进行操作； -1，发生错误；其他值，可以进行操作的文件描述符个数。 </p><h4 id="select系统阻塞状态判断"><a href="#select系统阻塞状态判断" class="headerlink" title="select系统阻塞状态判断"></a>select系统阻塞状态判断</h4><p>1、timeout传入NULL，则select为阻塞状态，即需要等到监视文件描述符集合中某个文件描述符发生变化才会返回；相当于无穷大的时间，一直等<br>2、timeout置为0秒、0微秒，则select为非阻塞状态，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；<br>3、timeout置为大于0的值，即等待的超时时间，select在timeout时间内阻塞，超时时间之内有事件到来就返回，否则在超时后不管怎样一定返回，返回值同上述。 </p><p><u>使用 select 函数对某个设备驱动文件进行读非阻塞访问的操作</u> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret,fd;</span><br><span class="line">    fd_set readfd;</span><br><span class="line">    </span><br><span class="line">    fd = open(<span class="string">&quot;dev_xx&quot;</span>, O_RDWR|)_NONBLOCK);<span class="comment">//非阻塞打开</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file\r\n&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">FD_ZERO(readfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Poll函数"><a href="#Poll函数" class="headerlink" title="Poll函数"></a>Poll函数</h4><p>在单个线程中，select 函数能够监视的文件描述符数量有最大的限制，一般为 1024，但是 poll 函数没有最大文件描述符限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds,</span></span><br><span class="line"><span class="params"><span class="type">nfds_t</span> nfds,</span></span><br><span class="line"><span class="params"><span class="type">int</span> timeout)</span></span><br></pre></td></tr></table></figure><p>fds： 要监视的文件描述符集合以及要监视的事件,为一个数组，数组元素都是结构体 pollfd类型的， pollfd 结构体如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="type">int</span> fd; <span class="comment">/* 文件描述符 */</span></span><br><span class="line"><span class="type">short</span> events; <span class="comment">/* 请求的事件 */</span></span><br><span class="line"><span class="type">short</span> revents; <span class="comment">/* 返回的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>fd 是要监视的文件描述符，如果 fd 无效的话那么 events 监视事件也就无效，并且 revents返回 0。 events 是要监视的事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可监视事件</span><br><span class="line">POLLIN 有数据可以读取。</span><br><span class="line">POLLPRI 有紧急的数据需要读取。</span><br><span class="line">POLLOUT 可以写数据。</span><br><span class="line">POLLERR 指定的文件描述符发生错误。</span><br><span class="line">POLLHUP 指定的文件描述符挂起。</span><br><span class="line">POLLNVAL 无效的请求。</span><br><span class="line">POLLRDNORM 等同于 POLLIN</span><br></pre></td></tr></table></figure><p>revents 是返回参数，也就是返回的事件， 由 Linux 内核设置具体的返回事件 </p><p>nfds： poll 函数要监视的文件描述符数量。<br>timeout： 超时时间，单位为 ms。 </p><p>返回值：返回 revents 域中不为 0 的 pollfd 结构体个数，也就是发生事件或错误的文件描述符数量； 0，超时； -1，发生错误，并且设置 errno 为错误类型。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">int</span> fd; <span class="comment">/* 要监视的文件描述符 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>;</span></span><br><span class="line"></span><br><span class="line">fd = open(filename, O_RDWR | O_NONBLOCK); <span class="comment">/* 非阻塞式访问 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造结构体 */</span></span><br><span class="line">fds.fd = fd;</span><br><span class="line">fds.events = POLLIN; <span class="comment">/* 监视数据是否可以读取 */</span></span><br><span class="line">ret = poll(&amp;fds, <span class="number">1</span>, <span class="number">500</span>); <span class="comment">/* 轮询文件是否可操作，超时 500ms */</span></span><br><span class="line"><span class="keyword">if</span> (ret) &#123; <span class="comment">/* 数据有效 */</span></span><br><span class="line"> ......</span><br><span class="line"><span class="comment">/* 读取数据 */</span></span><br><span class="line"> ......</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123; <span class="comment">/* 超时 */</span></span><br><span class="line"> ......</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">/* 错误 */</span></span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h4><p>epoll 就是为处理大并发而准备的，一般常常在网络编程中使用 epoll 函数。应用程序需要先使用 epoll_create 函数创建一个 epoll 句柄 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure><p>size： 从 Linux2.6.8 开始此参数已经没有意义了，随便填写一个大于 0 的值就可以。<br>返回值： epoll 句柄，如果为-1 的话表示创建失败。 </p><p>epoll 句柄创建成功以后使用 epoll_ctl 函数向其中添加要监视的文件描述符以及监视的事件 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> op,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> epoll_event *event)</span></span><br></pre></td></tr></table></figure><p>epfd： 要操作的 epoll 句柄，也就是使用 epoll_create 函数创建的 epoll 句柄。<br>op： 表示要对 epfd(epoll 句柄)进行的操作，可以设置为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CTL_ADD 向 epfd 添加文件参数 fd 表示的描述符。</span><br><span class="line">EPOLL_CTL_MOD 修改参数 fd 的 event 事件。</span><br><span class="line">EPOLL_CTL_DEL 从 epfd 中删除 fd 描述符。</span><br></pre></td></tr></table></figure><p>fd：要监视的文件描述符。<br>event： 要监视的事件类型，为 epoll_event 结构体类型指针 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> events; <span class="comment">/* epoll 事件 */</span></span><br><span class="line"><span class="type">epoll_data_t</span> data; <span class="comment">/* 用户数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体 epoll_event 的 events 成员变量表示要监视的事件 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EPOLLIN 有数据可以读取。</span><br><span class="line">EPOLLOUT 可以写数据。</span><br><span class="line">EPOLLPRI 有紧急的数据需要读取。</span><br><span class="line">EPOLLERR 指定的文件描述符发生错误。</span><br><span class="line">EPOLLHUP 指定的文件描述符挂起。</span><br><span class="line">EPOLLET 设置 epoll 为边沿触发，默认触发模式为水平触发。</span><br><span class="line">EPOLLONESHOT 一次性的监视，当监视完成以后还需要再次监视某个 fd，那么就需要将</span><br><span class="line">fd 重新添加到 epoll 里面。</span><br></pre></td></tr></table></figure><p>上面这些事件可以进行“或”操作，也就是说可以设置监视多个事件。 </p><p>返回值： 0，成功； -1，失败，并且设置 errno 的值为相应的错误码。 </p><p>一切都设置好以后应用程序就可以通过 epoll_wait 函数来等待事件的发生，类似 select 函数。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd,</span><br><span class="line">   struct epoll_event *events,</span><br><span class="line">               int maxevents,</span><br><span class="line">               int timeout)</span><br></pre></td></tr></table></figure><p>epfd： 要等待的 epoll。 </p><p>events： 指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调<br>用者可以根据 events 判断发生了哪些事件。<br>maxevents： events 数组大小，必须大于 0。<br>timeout： 超时时间，单位为 ms。<br>返回值： 0，超时； -1，错误；其他值，准备就绪的文件描述符数量。 </p><h4 id="Linux-驱动下的-poll-操作函数"><a href="#Linux-驱动下的-poll-操作函数" class="headerlink" title="Linux 驱动下的 poll 操作函数"></a>Linux 驱动下的 poll 操作函数</h4><p>当应用程序调用 select 或 poll 函数来对驱动程序进行非阻塞访问的时候，驱动程序file_operations 操作集中的 poll 函数就会执行。所以驱动程序的编写者需要提供对应的 poll 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//poll函数原型</span></span><br><span class="line"><span class="type">unsigned</span><span class="title function_">int</span><span class="params">(*poll)</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> poll_table_struct *wait)</span></span><br><span class="line"><span class="comment">//filp要打开的设备文件</span></span><br><span class="line"><span class="comment">//wait结构体 poll_table_struct 类型指针， 由应用程序传递进来的。一般将此参数传递给poll_wait 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">poll_wait</span><span class="params">(<span class="keyword">struct</span> file * filp, <span class="type">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span><br><span class="line"> <span class="comment">//poll_wait 函数不会引起阻塞，只是将应用程序添加到 poll_table 中</span></span><br><span class="line"> <span class="comment">//参数 wait_address 是要添加到 poll_table 中的等待队列头，参数 p 就是 poll_table</span></span><br></pre></td></tr></table></figure><p>poll函数的返回值：向应用程序返回设备或者资源状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POLLIN 有数据可以读取。</span><br><span class="line">POLLPRI 有紧急的数据需要读取。</span><br><span class="line">POLLOUT 可以写数据。</span><br><span class="line">POLLERR 指定的文件描述符发生错误。</span><br><span class="line">POLLHUP 指定的文件描述符挂起。</span><br><span class="line">POLLNVAL 无效的请求。</span><br><span class="line">POLLRDNORM 等同于 POLLIN，普通数据可读</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中断</title>
      <link href="/2023/05/04/2023-5-4-linux%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/05/04/2023-5-4-linux%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="linux中断"><a href="#linux中断" class="headerlink" title="linux中断"></a>linux中断</h2><p>中断是指CPU在执行程序执行中，出现了突发事件，CPU必须暂停当前程序的执行，处理突发事件，处理完后又返回程序到中断的位置继续进行。</p><p>根据中断入口跳转方法不同，分为向量中断和非向量中断，采用向量中断的CPU通常为不同的中断分配不同的中断号，当检测到某中断到来后，自动跳转到该中断号对应的地址执行。不同中断号的中断有不同的入口地址。非向量中断的多个中断共享一个入口地址，进入该入口地址后，再通过软件判断中断标志来标识，具体哪个中断。</p><h4 id="申请和释放中断"><a href="#申请和释放中断" class="headerlink" title="申请和释放中断"></a>申请和释放中断</h4><p>request_irq 函数用于申请中断， request_irq函数可能会导致睡眠，因此不能在中断上下文或者其他禁止睡眠的代码段中使用 request_irq 函数。 request_irq 函数会激活(使能)中断，所以不需要我们手动去使能中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params"><span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure><p>irq：要申请中断的中断号。</p><p>每个中断都有一个中断号，通过中断号即可区分不同的中断 。</p><p>handler：中断处理函数，当中断发生以后就会执行此中断处理函数。<br>flags：中断标志，可以在文件 include&#x2F;linux&#x2F;interrupt.h 里面查看所有的中断标志 </p><p>name：中断名字，设置以后可以在&#x2F;proc&#x2F;interrupts 文件中看到对应的中断名字。<br>dev： 如果将 flags 设置为 IRQF_SHARED 的话， dev 用来区分不同的中断，一般情况下将<br>dev 设置为设备结构体， dev 会传递给中断处理函数 irq_handler_t 的第二个参数。<br>返回值： 0 中断申请成功，其他负值 中断申请失败，如果返回-EBUSY 的话表示中断已经被申请了。 </p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>IRQF_SHARED</td><td>多个设备共享一个中断线，共享的所有中断都必须指定此标志。如果使用共享中断的话， request_irq 函数的 dev 参数就是唯一区分的标志</td></tr><tr><td>IRQF_ONESHOT</td><td>单次中断，中断执行一次就结束。</td></tr><tr><td>IRQF_TRIGGER_NONE</td><td>无触发</td></tr><tr><td>IRQF_TRIGGER_RISING</td><td>上升沿触发</td></tr><tr><td>IRQF_TRIGGER_FALLING</td><td>下降沿触发</td></tr><tr><td>IRQF_TRIGGER_HIGH</td><td>高电平触发</td></tr><tr><td>IRQF_TRIGGER_LOW</td><td>低电平触发</td></tr></tbody></table><h4 id="free-irq-函数"><a href="#free-irq-函数" class="headerlink" title="free_irq 函数"></a>free_irq 函数</h4><p>通过 free_irq 函数释放掉相应的中断。 如果中断不是共享的，那么 free_irq 会删除中断处理函数并且禁止中断。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure><p>第一个参数是要中断处理函数要相应的中断号。第二个参数是一个指向 void 的指针，也就是个通用指针，需要与 request_irq 函数的 dev 参数保持一致。用于区分共享中断的不同设备，dev 也可以指向设备数据结构。 </p><p>中断处理函数的返回值为 irqreturn_t 类型， irqreturn_t 类型定义如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> &#123;</span></span><br><span class="line">IRQ_NONE = (<span class="number">0</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">IRQ_HANDLED = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line">IRQ_WAKE_THREAD = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">irqreturn</span> <span class="title">irqreturn_t</span>;</span></span><br></pre></td></tr></table></figure><p>可以看出 irqreturn_t 是个枚举类型，一共有三种返回值。一般中断服务函数返回值使用如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED) </span><br></pre></td></tr></table></figure><h4 id="中断使能与禁止函数"><a href="#中断使能与禁止函数" class="headerlink" title="中断使能与禁止函数"></a>中断使能与禁止函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span><span class="comment">//使能中断irq为中断号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span><span class="comment">//禁止中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span><span class="comment">//需要保证不会产生新的中断，并且确保所有已经开始执行的中断处理程序已经全部退出,调用以后立即返回，不会等待当前中断处理程序执行完毕</span></span><br><span class="line"><span class="title function_">local_irq_enable</span><span class="params">()</span><span class="comment">//使能当前处理器中断系统</span></span><br><span class="line"><span class="title function_">local_irq_disable</span><span class="params">()</span><span class="comment">//禁止当前中断系统</span></span><br><span class="line"><span class="title function_">local_irq_save</span><span class="params">(flags)</span><span class="comment">//用于禁止中断，并且将中断状态保存在 flags 中</span></span><br><span class="line"><span class="title function_">local_irq_restore</span><span class="params">(flags)</span><span class="comment">//用于恢复中断，将中断到 flags 状态</span></span><br></pre></td></tr></table></figure><h4 id="中断上下部"><a href="#中断上下部" class="headerlink" title="中断上下部"></a>中断上下部</h4><p>中断处理过程就分为了两部分：<br>上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。<br>下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。 </p><p>对于网卡的中断处理，上半部会执行通知硬件、拷贝网络数据报到内存并继续读取新数据包，这些重要、紧急且与硬件相关的工作，因为网卡接收的网络数据包的缓存大小通常是固定的、有限的，一旦被延迟可能造成缓存溢出。而数据包的处理等操作，则由下半部来完成。</p><p>Linux 内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，那些对时间敏感、执行速度快的操作可以放到中断处理函数中，也就是上半部。剩下的所有工作都可以放到下半部去执行，比如在上半部将数据拷贝到内存中，关于数据的具体处理就可以放到下半部去执行。至于哪些代码属于上半部，哪些代码属于下半部并没有明确的规定 。</p><ol><li>如果要处理的内容不希望被其他中断打断，那么可以放到上半部。</li><li>如果要处理的任务对时间敏感，可以放到上半部。</li><li>如果要处理的任务与硬件有关，可以放到上半部</li><li>除了上述三点以外的其他任务，优先考虑放到下半部。</li></ol><h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><p>2.5版本以前使用BH(bottom half)实现下半部分，之后都是使用软中断核tasklet代替BH机制。Linux内核使用结构体softirq_action表示软中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span>(*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在kernel&#x2F;softirq.c文件中一共定义了10个软中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>];</span></span><br></pre></td></tr></table></figure><p>NR_SOFTIRQS是枚举类型，定义在文件include&#x2F;linux&#x2F;interrupt.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">HI_SOFTIRQ=<span class="number">0</span>, <span class="comment">/* 高优先级软中断 */</span></span><br><span class="line">TIMER_SOFTIRQ, <span class="comment">/* 定时器软中断 */</span></span><br><span class="line">NET_TX_SOFTIRQ, <span class="comment">/* 网络数据发送软中断 */</span></span><br><span class="line">NET_RX_SOFTIRQ, <span class="comment">/* 网络数据接收软中断 */</span></span><br><span class="line">BLOCK_SOFTIRQ,</span><br><span class="line">BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">TASKLET_SOFTIRQ, <span class="comment">/* tasklet 软中断 */</span></span><br><span class="line">SCHED_SOFTIRQ, <span class="comment">/* 调度软中断 */</span></span><br><span class="line">HRTIMER_SOFTIRQ, <span class="comment">/* 高精度定时器软中断 */</span></span><br><span class="line">RCU_SOFTIRQ, <span class="comment">/* RCU 软中断 */</span></span><br><span class="line">NR_SOFTIRQS</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>softirq_action 结构体中的 action 成员变量就是软中断的服务函数，数组 softirq_vec 是个全局数组，因此所有的 CPU(对于 SMP 系统而言)都可以访问到，每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。 </p><p>要使用软中断，必须先使用 open_softirq 函数注册对应的软中断处理函数 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span><br><span class="line"><span class="comment">//nr：要开启的软中断，</span></span><br><span class="line"><span class="comment">//action：软中断对应的处理函数。</span></span><br><span class="line"><span class="comment">//返回值： 没有返回值。</span></span><br></pre></td></tr></table></figure><p>注册好软中断以后需要通过 raise_softirq 函数触发 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line"><span class="comment">//nr：要触发的软中断</span></span><br><span class="line"><span class="comment">//返回值： 没有返回值。</span></span><br></pre></td></tr></table></figure><p>软中断必须在编译的时候静态注册！ Linux 内核使用 softirq_init 函数初始化软中断，softirq_init 函数定义在 kernel&#x2F;softirq.c 文件里面， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">softirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line">per_cpu(tasklet_vec, cpu).tail =&amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">per_cpu(tasklet_hi_vec, cpu).tail =&amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tasklet 是利用软中断来实现的另外一种下半部机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span>//结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span> <span class="comment">/* 下一个 tasklet */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> state; <span class="comment">/* tasklet 状态 */</span></span><br><span class="line"><span class="type">atomic_t</span> count; <span class="comment">/* 计数器，记录对 tasklet 的引用数 */</span></span><br><span class="line"><span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">/* tasklet 执行的函数 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> data; <span class="comment">/* 函数 func 的参数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t, <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line"><span class="comment">//t：要初始化的 tasklet</span></span><br><span class="line"><span class="comment">//func： tasklet 的处理函数。</span></span><br><span class="line"><span class="comment">//data： 要传递给 func 函数的参数</span></span><br><span class="line"><span class="comment">//返回值： 没有返回值。</span></span><br></pre></td></tr></table></figure><p>在上半部，也就是中断处理函数中调用 tasklet_schedule 函数就能使 tasklet 在合适的时间运行 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line"><span class="comment">//t：要调度的 tasklet，也就是 DECLARE_TASKLET 宏里面的 name。</span></span><br></pre></td></tr></table></figure><p>tasklet的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义 taselet */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">testtasklet</span>;</span></span><br><span class="line"><span class="comment">/* tasklet 处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testtasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* tasklet 具体处理内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 调度 tasklet */</span></span><br><span class="line">tasklet_schedule(&amp;testtasklet);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 初始化 tasklet */</span></span><br><span class="line">tasklet_init(&amp;testtasklet, testtasklet_func, data);</span><br><span class="line"><span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">request_irq(xxx_irq, test_handler, <span class="number">0</span>, <span class="string">&quot;xxx&quot;</span>, &amp;xxx_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>工作队列是另外一种下半部执行方式，工作队列在进程上下文执行，工作队列将要推后的工作交给一个内核线程去执行，因为工作队列工作在进程上下文，因此工作队列允许睡眠或重新调度。因此如果你要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 tasklet。 </p><p>工作队列结构体workqueue_struct结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">int</span> work_color;</span><br><span class="line"><span class="type">int</span> flush_color;</span><br><span class="line"><span class="type">atomic_t</span> nr_pwqs_to_flush;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span> *<span class="title">first_flusher</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flusher_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flusher_overflow</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">maydays</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">rescuer</span>;</span></span><br><span class="line"><span class="type">int</span> nr_drainers;</span><br><span class="line"><span class="type">int</span> saved_max_active;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">unbound_attrs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">dfl_pwq</span>;</span></span><br><span class="line"><span class="type">char</span> name[WQ_NAME_LEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags ____cacheline_aligned;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">percpu</span> *<span class="title">cpu_pwqs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">rcu</span> *<span class="title">numa_pwq_tbl</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内核使用工作者线程(worker thread)来处理工作队列的各个工作，Linux使用worker结构体表示工作者线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hentry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_work</span>;</span></span><br><span class="line"><span class="type">work_func_t</span> current_func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">current_pwq</span>;</span></span><br><span class="line"><span class="type">bool</span> desc_valid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">scheduled</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> last_active;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> desc[WORKER_DESC_LEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">rescue_wq</span>;</span><span class="comment">//工作队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单创建工作很简单，直接定义一个 work_struct 结构体变量即可，然后使用 INIT_WORK 宏来初始化工作， INIT_WORK 宏定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_WORK(_work, _func)</span></span><br><span class="line"><span class="comment">//work 表示要初始化的工作， _func 是工作对应的处理函数。</span></span><br></pre></td></tr></table></figure><p>也可以使用 DECLARE_WORK 宏一次性完成工作的创建和初始化，宏定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WORK(n, f)</span></span><br><span class="line"><span class="comment">//n 表示定义的工作(work_struct)， f 表示工作对应的处理函数。</span></span><br></pre></td></tr></table></figure><p>和 tasklet 一样，工作也是需要调度才能运行的，工作的调度函数为 schedule_work，函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line"><span class="comment">//work： 要调度的工作。</span></span><br><span class="line"><span class="comment">//返回值： 0 成功，其他值 失败。 </span></span><br></pre></td></tr></table></figure><p>工作队列的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义工作(work) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">testwork</span>;</span></span><br><span class="line"><span class="comment">/* work 处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testwork_func_t</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* work 具体处理内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 调度 work */</span></span><br><span class="line">schedule_work(&amp;testwork);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 初始化 work */</span></span><br><span class="line">INIT_WORK(&amp;testwork, <span class="type">testwork_func_t</span>);</span><br><span class="line"><span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">request_irq(xxx_irq, test_handler, <span class="number">0</span>, <span class="string">&quot;xxx&quot;</span>, &amp;xxx_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-05-06%20143233.png"></p><h4 id="补充杂项"><a href="#补充杂项" class="headerlink" title="补充杂项"></a>补充杂项</h4><h5 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h5><p>Volatile意思是“易变的”，<strong>直接从变量地址中读取数据</strong>。“易变”是因为外在因素引起的，像多线程，中断等。</p><p>volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。</p><p>如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</p><p><strong>使用场景</strong></p><ol><li>并行设备的硬件寄存器（如：状态寄存器） 存储器映射的硬件寄存器通常也要加 voliate，因为每次对它的读写都可能有不同意义。</li><li><strong>中断服务程序中修改的供其它程序检测的变量，需要加volatile；</strong></li><li>多任务环境下各个任务间的共享标志，应该加volatile</li><li>存储器映射的硬件寄存器通常叶家volatile说明，因为每次对它的读写都可能有不同的意义。</li></ol><h5 id="volatile-问题和总结"><a href="#volatile-问题和总结" class="headerlink" title="volatile 问题和总结"></a>volatile 问题和总结</h5><ol><li><p>一个参数既可以是const还可以是volatile吗？</p><p>可以的，例如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p></li><li><p>一个指针可以是volatile吗？</p><p>可以，当一个中服务子程序修改一个指向buffer的指针时。</p></li></ol><p>volatile long可以保证其可见性。（多线程安全三大特性：可见性，原子性，有序性）</p><p>通常来说，Volatile这个关键字的作用仅保证数据的可见性，并不保证原子性，而对于double和long的读写，Volatile还额外保证了读写的原子性。Volatile对于double、long的读写原子性仅指单次读或单次写，如果一个操作同时具有读写。</p><p><strong>原子性：</strong>操作是不可分的。其表现在于对于共享变量的某些操作，应该是不可分的，必须连续完成。</p><p><strong>可见性：</strong>可见性是指一个线程对共享变量的修改，另外一个线程能够立刻看到；</p><p><strong>有序性：</strong>指程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。</p><p>那为什么会出现不一致的情况呢？<br>这是由于重排序的缘故。</p><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序；重排序不会影响单线程的执行结果，但是在并发情况下，可能会出现诡异的BUG。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内核定时器</title>
      <link href="/2023/04/25/2023-4-25-linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2023/04/25/2023-4-25-linux%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="时间管理和内核定时器"><a href="#时间管理和内核定时器" class="headerlink" title="时间管理和内核定时器"></a>时间管理和内核定时器</h2><p>Linux 内核中有大量的函数需要时间管理，比如周期性的调度程序、延时程序、对于我们驱动编写者来说最常用的定时器。硬件定时器提供时钟源，时钟源的频率可以设置， 设置好以后就周期性的产生定时中断，系统使用定时中断来计时。中断周期性产生的频率就是系统频率，也叫做节拍率(tick rate)(有的资料也叫系统频率)。</p><p>可以在编译 Linux 内核的时候可以通过图形化界面设置系统节拍率， </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Kernel Features</span><br><span class="line">-&gt; Timer frequency (&lt;choice&gt; [=y])</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-24%20205453.png"></p><p>高节拍率和低节拍率的优缺点： </p><p>①、高节拍率会提高系统时间精度，如果采用 100Hz 的节拍率，时间精度就是 10ms，采用1000Hz 的话时间精度就是 1ms，精度提高了 10 倍。高精度时钟的好处有很多，对于那些对时间要求严格的函数来说，能够以更高的精度运行，时间测量也更加准确。<br>②、高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担， 1000Hz 和 100Hz的系统节拍率相比，系统要花费 10 倍的“精力”去处理中断。中断服务函数占用处理器的时间增加，但是现在的处理器性能都很强大，所以采用 1000Hz 的系统节拍率并不会增加太大的负载压力。根据自己的实际情况，选择合适的系统节拍率。</p><p>Linux 内核使用全局变量 jiffies 来记录系统从启动以来的系统节拍数，系统启动的时候会将 jiffies 初始化为 0， jiffies 定义在文件 include&#x2F;linux&#x2F;jiffies.h 中，定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> u64 __jiffy_data jiffies_64;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> __jiffy_data jiffies;</span><br></pre></td></tr></table></figure><p>jiffies_64 和 jiffies 其实是同一个东西， jiffies_64 用于 64 位系统，而 jiffies 用于 32 位系统。为了兼容不同的硬件， jiffies 其实就是 jiffies_64 的低 32 位 。</p><p>当我们访问 jiffies 的时候其实访问的是 jiffies_64 的低 32 位，使用 get_jiffies_64 这个函数可以获取 jiffies_64 的值。在 32 位的系统上读取 jiffies 的值，在 64 位的系统上 jiffes 和 jiffies_64表示同一个变量，因此也可以直接读取 jiffies 的值。所以不管是 32 位的系统还是 64 位系统，都可以使用 jiffies。 </p><p>HZ 表示每秒的节拍数 ，jiffies 表示系统运行的 jiffies 节拍数，所以 jiffies&#x2F;HZ 就是系统运行时间，单位为秒。 </p><p>不管是 32 位还是 64 位的 jiffies，都有溢出的风险，溢出以后会重新从 0 开始计数，相当于绕回来了，因此有些资料也将这个现象也叫做绕回。 Linux 内核提供了如表所示的几个 API 函数来处理绕回 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-24%20210737.png"></p><p>Linux 内核提供了几个 jiffies 和 ms、 us、 ns 之间的转换函数 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-24%20211000.png"></p><h3 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h3><p>定时器是一个很常用的功能，需要周期性处理的工作都要用到定时器。 Linux 内核定时器采用系统时钟来实现，并不是我们在裸机篇中讲解的 PIT 等硬件定时器。 Linux 内核定时器使用很简单，只需要提供超时时间(相当于定时值)和定时处理函数即可，当超时时间到了以后设置的定时处理函数就会执行，和我们使用硬件定时器的套路一样，只是使用内核定时器不需要做一大堆的寄存器初始化工作。在使用内核定时器的时候要注意一点，内核定时器并不是周期性运行的，超时以后就会自动关闭，因此如果想要实现周期性定时，那么就需要在定时处理函数中重新开启定时器。 </p><p>Linux 内核使用 timer_list 结构体表示内核定时器 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">/* 定时器超时时间，单位是节拍数 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line"><span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">/* 定时处理函数 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> data; <span class="comment">/* 要传递给 function 函数的参数 */</span></span><br><span class="line"><span class="type">int</span> slack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="定时器API函数"><a href="#定时器API函数" class="headerlink" title="定时器API函数"></a>定时器API函数</h4><p>init_timer 函数负责初始化 timer_list 类型变量 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line"><span class="comment">//timer要初始化定时器，没有返回值</span></span><br></pre></td></tr></table></figure><p>add_timer函数用于向linux内核注册定时器，使用add_timer函数注册定时器以后，定时器运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line"><span class="comment">//timer:要注册的定时器，没有返回值</span></span><br></pre></td></tr></table></figure><p>del_timer函数用于删除一个定时器，不管定时器是否被激活，都能删除。在多处理器系统上，定时器可能会在其他的处理器上运行，因此在调用 del_timer 函数删除定时器之前要先等待其他处理器的定时处理器函数退出。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line"><span class="comment">//timer:要删除的定时器</span></span><br><span class="line"><span class="comment">//返回值: 0 定时器还没被激活，1定时器已经激活</span></span><br></pre></td></tr></table></figure><p>del_timer_sync 函数是 del_timer 函数的同步版，会等待其他处理器使用完定时器再删除，del_timer_sync 不能使用在中断上下文中。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer_sync</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br><span class="line"><span class="comment">//timer：要删除的定时器。</span></span><br><span class="line"><span class="comment">//返回值： 0，定时器还没被激活； 1，定时器已经激活。  </span></span><br></pre></td></tr></table></figure><p>mod_timer 函数用于修改定时值，如果定时器还没有激活的话， mod_timer 函数会激活定时器！ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mod_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">unsigned</span> <span class="type">long</span> expires)</span></span><br><span class="line"><span class="comment">//timer:要修改超时时间（定时值）的定时器</span></span><br><span class="line"><span class="comment">//expires:修改后的超时时间</span></span><br><span class="line"><span class="comment">//返回值： 0，调用 mod_timer 函数前定时器未被激活； 1，调用 mod_timer 函数前定时器已被激活。</span></span><br></pre></td></tr></table></figure><h4 id="ioctl函数（设备控制接口函数）"><a href="#ioctl函数（设备控制接口函数）" class="headerlink" title="ioctl函数（设备控制接口函数）"></a>ioctl函数（设备控制接口函数）</h4><p>octl是设备驱动程序中对设备的I&#x2F;O通道进行管理的函数。所谓对I&#x2F;O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。它的调用个数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ioctl(int fd, ind cmd, …)；</span><br></pre></td></tr></table></figure><p>其中fd就是用户程序打开设备时使用open函数返回的文件标示符，cmd就是用户程序对设备的控制命令，至于后面的省略号，那是一些补充参数，一般最多一个，有或没有是和cmd的意义相关的。<br>ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数控制设备的I&#x2F;O通道。 </p><p><strong>应用程序调用 ioctl函数向驱动发送控制信息，此函数响应并执行。</strong> </p><h4 id="内核定时器一般的使用流程"><a href="#内核定时器一般的使用流程" class="headerlink" title="内核定时器一般的使用流程"></a>内核定时器一般的使用流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span> <span class="comment">/* 定义定时器 */</span></span><br><span class="line"><span class="comment">/* 定时器回调函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定时器处理代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 如果需要定时器周期性运行的话就使用 mod_timer</span></span><br><span class="line"><span class="comment"> * 函数重新设置超时值并且启动定时器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mod_timer(&amp;dev-&gt;timertest, jiffies + msecs_to_jiffies(<span class="number">2000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">init_timer(&amp;timer); <span class="comment">/* 初始化定时器 */</span></span><br><span class="line">timer.function = function; <span class="comment">/* 设置定时处理函数 */</span></span><br><span class="line">timer.expires=jffies + msecs_to_jiffies(<span class="number">2000</span>);<span class="comment">/* 超时时间 2 秒 */</span></span><br><span class="line">timer.data = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;dev; <span class="comment">/* 将设备结构体作为参数 */</span></span><br><span class="line">add_timer(&amp;timer); <span class="comment">/* 启动定时器 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 退出函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">del_timer(&amp;timer); <span class="comment">/* 删除定时器 */</span></span><br><span class="line"> <span class="comment">/* 或者使用 */</span></span><br><span class="line">del_timer_sync(&amp;timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-26%20110943.png"></p><h4 id="Linux-内核短延时函数"><a href="#Linux-内核短延时函数" class="headerlink" title="Linux 内核短延时函数"></a>Linux 内核短延时函数</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-25%20205843.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>globalmem设备驱动</title>
      <link href="/2023/04/23/2023-4-25-globalmem%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/04/23/2023-4-25-globalmem%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="globalmem驱动"><a href="#globalmem驱动" class="headerlink" title="globalmem驱动"></a>globalmem驱动</h2><p>globalmem为“全局内存”的意思，在globalmem字符设备中会分配一片大小为GLOBALMEM_SIZE的内存空间，并在驱动中提供对这片内存的读写、控制和定位函数，供用户空间的进程能通过Linux系统调用获取和设置这片内存。</p><h4 id="头文件、宏定义以及结构体"><a href="#头文件、宏定义以及结构体" class="headerlink" title="头文件、宏定义以及结构体"></a>头文件、宏定义以及结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_SIZE  0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR  0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_MAJOR  230</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> globalmem_major = GLOBALMEM_MAJOR;</span><br><span class="line">module_param(globalmem_major, <span class="type">int</span>, S_IRUGO);<span class="comment">//模块传递参数，在加载模块的时候可以自己传递</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mem[GLOBALMEM_SIZE];<span class="comment">//使用内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> *<span class="title">globalmem_devp</span>;</span></span><br></pre></td></tr></table></figure><h4 id="内核模块传入参数"><a href="#内核模块传入参数" class="headerlink" title="内核模块传入参数"></a>内核模块传入参数</h4><p>内核模块中没有main函数，所以向模块内部传入参数可以通过module_param这个宏定义来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXU 00700    <span class="comment">// 用户读写可执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR 00400    <span class="comment">// 用户读权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWUSR 00200    <span class="comment">// 用户写权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXUSR 00100    <span class="comment">// 用户可执行权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXG 00070    <span class="comment">// 用户组读写可执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRGRP 00040    <span class="comment">// 用户组读权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWGRP 00020    <span class="comment">// 用户组写权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXGRP 00010    <span class="comment">// 用户组可执行权限</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRWXO 00007    <span class="comment">// 其他人可读写执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IROTH 00004    <span class="comment">// 其他人可读权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWOTH 00002    <span class="comment">// 其他人可写权限</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXOTH 00001    <span class="comment">// 其他人可执行权限</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="kzalloc函数与kfree函数"><a href="#kzalloc函数与kfree函数" class="headerlink" title="kzalloc函数与kfree函数"></a>kzalloc函数与kfree函数</h4><p>用kzalloc申请内存的时候， 效果等同于先是用 <em>kmalloc()</em> 申请空间 <em>,</em> 然后用 <em>memset()</em> 来初始化 *,*所有申请的元素都被初始化为 <em>0.</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure><p>给 kmalloc 的第一个参数是要分配的块的大小. 第 2 个参数, 分配标志, 非常有趣, 因为它以几个方式控制 kmalloc 的行为.</p><p>最一般使用的标志, GFP_KERNEL, 代表运行在内核空间的进程而进行的. 这意味着调用函数是代表一个进程在执行一个系统调用. 使用 GFP_KENRL 意味着 kmalloc 能够使当前进程在少内存的情况下睡眠来等待一页. 一个使用 GFP_KERNEL 来分配内存的函数必须, 因此, 是可重入的并且不能在原子上下文中运行. 当当前进程睡眠, 内核采取正确的动作来定位一些空闲内存, 或者通过刷新缓存到磁盘或者交换出去一个用户进程的内存。</p><p>GFP_KERNEL 不一直是使用的正确分配标志; 有时 kmalloc 从一个进程的上下文的外部调用. 例如, 这类的调用可能发生在中断处理, tasklet, 和内核定时器中. 在这个情况下, 当前进程不应当被置为睡眠, 并且驱动应当使用一个GFP_ATOMIC 标志来代替. 内核正常地试图保持一些空闲页以便来满足原子的分配. 当使用 GFP_ATOMIC 时,kmalloc 能够使用甚至最后一个空闲页. 如果这最后一个空闲页不存在, 但是, 分配失败。</p><p>其他用来代替或者增添 GFP_KERNEL 和 GFP_ATOMIC 的标志, 尽管它们 2 个涵盖大部分设备驱动的需要. 所有的标志定义在 &lt;linux&#x2F;gfp.h&gt;, 并且每个标志用一个双下划线做前缀, 例如 __GFP_DMA. 另外, 有符号代表常常使用的标志组合; 这些缺乏前缀并且有时被称为分配优先级。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span></span><br><span class="line"><span class="comment">//objp：内存地址，通常是kmalloc( )函数的返回值，即是指向分配的内存块起始地址的地址指针。</span></span><br></pre></td></tr></table></figure><h4 id="seek函数"><a href="#seek函数" class="headerlink" title="seek函数"></a>seek函数</h4><p>文件重定位函数，改变文件的读写偏移量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">globalmem_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> orig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">loff_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (orig) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)offset &gt; GLOBALMEM_SIZE) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">filp-&gt;f_pos = (<span class="type">unsigned</span> <span class="type">int</span>)offset;</span><br><span class="line">ret = filp-&gt;f_pos;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((filp-&gt;f_pos + offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">filp-&gt;f_pos += offset;</span><br><span class="line">ret = filp-&gt;f_pos;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件重定位的起始地址有三种情况:同时该函数具有检测定位的合法性<br>        ①0:从文件开头进行定位<br>        ②1:从文件当前位置进行定位<br>        ③2:定位到文件末尾</p><h4 id="ioctl函数"><a href="#ioctl函数" class="headerlink" title="ioctl函数"></a>ioctl函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">globalmem_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line"><span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, GLOBALMEM_SIZE);</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;globalmem is set to zero\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ioctl()函数可以接收用户空间的MEM_CLEAR命令实现对内存的数据清0. </p><p>驱动代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linxu/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_SIZE0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CLEAR 0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBALMEM_MAJOR230</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmemdev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">  <span class="type">int</span> major;</span><br><span class="line">  <span class="type">int</span> minor;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> mem[GLOBALMEM_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmemdev</span> *<span class="title">globalmem_devp</span>;</span></span><br><span class="line">module_param(globalmem_devp-&gt;major, <span class="type">int</span> , S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalmem_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = globalmem_devp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">globalmem_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">globalmem_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmemdev</span> *<span class="title">dev</span> =</span> filp -&gt; private_data;</span><br><span class="line">  <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line">      <span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, GLOBALMEM_SIZE);</span><br><span class="line">      printk(KERN_INFO <span class="string">&quot;globalmem is set to zero \n&quot;</span>);<span class="comment">//KERN_INFO提示信息</span></span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalmem_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> p = *offt;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> count = cnt;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">globalmemdev</span> *<span class="title">dev</span> =</span> filp -&gt; private_data;</span><br><span class="line">  <span class="keyword">if</span>(p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count &gt; GLOBALMEM_SIZE - p)</span><br><span class="line">    count = GLOBALMEM_SIZE-p;</span><br><span class="line">  <span class="keyword">if</span>(copy_to_user(buf, dev-&gt;mem + p, count))</span><br><span class="line">    ret = -EFAULT；</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">  *ppos += count;</span><br><span class="line">    ret = count;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;read %u bytes(s) from %lu\n&quot;</span>, count , p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">globalmem_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> p = *offt;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> count  = cnt ;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">globalmemdev</span> *<span class="title">dev</span> =</span> filp -&gt; private_data;</span><br><span class="line">  <span class="keyword">if</span>(p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(count &gt; GLOBALMEM_SIZE - p)</span><br><span class="line">    count = GLOBALMEM_SIZE - p;</span><br><span class="line">  <span class="keyword">if</span>(copy_from_user(dev-&gt;mem + p, buf, count))</span><br><span class="line">    ret = -EFAULT;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">  *offt += count;</span><br><span class="line">    ret = count;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;written %u bytes(s) from %lu\n&quot;</span>, count, p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">loff_t</span> <span class="title function_">globalmem_llseek</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">loff_t</span> offset, <span class="type">int</span> orig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">loff_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (orig) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">int</span>)offset &gt; GLOBALMEM_SIZE) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">filp-&gt;f_pos = (<span class="type">unsigned</span> <span class="type">int</span>)offset;</span><br><span class="line">ret = filp-&gt;f_pos;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span> ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((filp-&gt;f_pos + offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">filp-&gt;f_pos += offset;</span><br><span class="line">ret = filp-&gt;f_pos;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">globalmem_ops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">  .llseek = globalmem_llseek,</span><br><span class="line">  .read = globalmem_read,</span><br><span class="line">  .write = globalmem_write,</span><br><span class="line">  .unlocked_ioctl = globalmem_ioctl,</span><br><span class="line">  .open = globalmem_open,</span><br><span class="line">  .release = globalmem_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">globalmem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(globalmem_devp.major)</span><br><span class="line">  &#123;</span><br><span class="line">  globalmem_devp.devid = MKDEV(globalmem_devp.major, <span class="number">0</span>);</span><br><span class="line">    register_chrdev_region(globalmem_devp.devid, <span class="number">1</span>, <span class="string">&quot;globalmem&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  alloc_chrdev_region(&amp;globalmem_devp.devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;globalmem&quot;</span>);</span><br><span class="line">    globalmem_devp.major = MAJOR(globalmem_devp.devid);</span><br><span class="line">    globalmem_devp.minor = MINOR(globalmem_devp.devid);</span><br><span class="line">  &#125;</span><br><span class="line">  cdev_init(&amp;globalmem_devp.cdev, &amp;globalmem_ops);</span><br><span class="line">  dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">  cdev_add(&amp;globalmem_dep.cdev, globalmem_devp.devid, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  globalmem_devp = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> globalmem_dev), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!globalmem_devp) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> fail_malloc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> fail_malloc:</span><br><span class="line">unregister_chrdev_region(devno, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">globalmem_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">cdev_del(&amp;globalmem_devp-&gt;cdev);</span><br><span class="line">  kfree(globalmem_devp)</span><br><span class="line">  unregister_chrdev_region(globalmem_devp.devid, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">module_init(globalmem_init);</span><br><span class="line">module_exit(globalmem_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux并发与竞争</title>
      <link href="/2023/04/20/2023-4-21-linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/"/>
      <url>/2023/04/20/2023-4-21-linux%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%AB%9E%E4%BA%89/</url>
      
        <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>若我们谈及计算机系统中的并发，则是指同一个系统中，多个独立活动同时进行，而非依次进行。起初的计算机并发只是一种制造并发的假象，因为只有一个处理器，在同一时刻实质只能处理一个任务，不过是一秒钟内进行多个任务的切换。看起来是同时进行的，因此叫做任务交换。</p><p>多年来，配备了多处理器的计算机一直被用作服务器，它要承担高性能的计算任务；现今，基于一芯多核处理器（简称多核处理器）的计算机日渐普及，多核处理器也用在台式计算机上。</p><p>无论是装配多个处理器，还是单个多核处理器，或是多个多核处理器，这些计算机都能真正并行运作多个任务，我们称之为硬件并发（hardware concurrency）。</p><h3 id="并发方式"><a href="#并发方式" class="headerlink" title="并发方式"></a>并发方式</h3><h4 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h4><p>在应用软件内部，一种并发方式是，将一个应用软件拆分成多个独立进程同时运行，它们都只含单一线程，非常类似于同时运行浏览器和文字处理软件。这些独立进程可以通过所有常规的进程间通信途径相互传递信息（信号、套接字、文件、管道等）。</p><h4 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h4><p>另一种并发方式是在单一进程内运行多线程。线程非常像轻量级进程，每个线程都独立运行，并能各自执行不同的指令序列。</p><p>不过，同一进程内的所有线程都共用相同的地址空间，且所有线程都能直接访问大部分数据。全局变量依然全局可见，指向对象或数据的指针和引用能在线程间传递。</p><p>尽管进程间共享内存通常可行，但这种做法设置复杂，往往难以驾驭，原因是同一数据的地址在不同进程中不一定相同。</p><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><ul><li>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。</li><li>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。</li></ul><h3 id="并发产生的原因"><a href="#并发产生的原因" class="headerlink" title="并发产生的原因"></a>并发产生的原因</h3><p>现在的 Linux 系统并发产生的原因很复杂，总结一下有下面几个主要原<br>因：<br>①、多线程并发访问， Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。<br>②、抢占式并发访问，从 2.6 版本内核开始， Linux 内核支持抢占，也就是说调度程序可以在任意时刻抢占正在运行的线程，从而运行其他的线程。<br>③、中断程序并发访问。<br>④、 SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并发访问 </p><p>并发访问带来的问题就是竞争，对于临界区必须保证一次只有一个线程访问，也就是要保证临界区是原子访问的，原子访问就表示这一个访问是一个步骤，不能再进行拆分。 </p><p>任意时刻，单处理器系统都只能执行一个进程的代码，当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文转换，即保存当前进程的上下文，回复进程的上下文，然后将控制权传递到新进程，新进程就会从它上次停止的地方开始。</p><p>从一个进程到另一个进程的转换是由操作系统内核管理的，内核是操作系统代码常驻主存的部分。</p><h4 id="临界资源和临界区"><a href="#临界资源和临界区" class="headerlink" title="临界资源和临界区"></a>临界资源和临界区</h4><p>1.临界资源<br>  临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式，实现共享的资源称作临界资源。属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。</p><p>2.临界区：<br>  每个进程中访问临界资源的那段代码称为临界区（criticalsection），每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。</p><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><h4 id="原子整形操作API函数"><a href="#原子整形操作API函数" class="headerlink" title="原子整形操作API函数"></a>原子整形操作API函数</h4><p>Linux 内核定义了叫做 atomic_t 的结构体来完成整形数据的原子操作，在使用中用原子变量来代替整形变量，此结构体定义在 include&#x2F;linux&#x2F;types.h 文件中，定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">175</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="number">176</span> <span class="type">int</span> counter;</span><br><span class="line"><span class="number">177</span> &#125; <span class="type">atomic_t</span>;</span><br></pre></td></tr></table></figure><p>如果要使用原子操作 API 函数，首先要先定义一个 atomic_t 的变量 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> a;<span class="comment">//定义a</span></span><br><span class="line"><span class="type">atomic_t</span> b = ATOMIC_INIT(<span class="number">0</span>);<span class="comment">//定义原子变量b并赋值0；使用的是ATOMIC_INIT宏</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-19%20153803.png"></p><p>如果使用 64 位的 SOC 的话，就要用到 64 位的原子变量， Linux 内核也定义了 64 位原子结构体，如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;</span><br></pre></td></tr></table></figure><p>相应的也提供了 64 位原子变量的操作 API 函数，这里我们就不详细讲解了，和表 47.2.1.1中的 API 函数有用法一样，只是将“atomic_”前缀换为“atomic64_”，将 int 换为 long long。如果使用的是 64 位的 SOC，那么就要使用 64 位的原子操作函数。 </p><h4 id="原子位操作-API-函数"><a href="#原子位操作-API-函数" class="headerlink" title="原子位操作 API 函数"></a>原子位操作 API 函数</h4><p>Linux 内核也提供了一系列的原子位操作 API 函数，只不过原子位操作不像原子整形变量那样有个 atomic_t 的数据结构，原子位操作是直接对内存进行操作 .</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void set_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位置 1</td></tr><tr><td align="center">void clear_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位清零。</td></tr><tr><td align="center">void change_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位进行翻转</td></tr><tr><td align="center">int test_bit(int nr, void *p)</td><td align="center">获取 p 地址的第 nr 位的值。</td></tr><tr><td align="center">int test_and_set_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值</td></tr><tr><td align="center">int test_and_clear_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位清零，并且返回 nr 位原来的值</td></tr><tr><td align="center">int test_and_change_bit(int nr, void *p)</td><td align="center">将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值</td></tr></tbody></table><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>当一个线程要访问某个共享资源的时候首先要先获取相应的锁， 锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线程就不能获取此锁。对于自旋锁而言，如果自旋锁正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线程 B 不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁可用。 </p><p>自旋锁的一个缺点：那就等待自旋锁的线程会一直处于自旋状态，这样会浪费处理器时间，降低系统性能，所以自旋锁的持有时间不能太长。所以自旋锁适用于短时期的轻量级加锁，如果遇到需要长时间持有锁的场景那就需要换其他的方法了， </p><p>Linux 内核使用结构体 spinlock_t 表示自旋锁 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line"><span class="number">65</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="number">66</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"><span class="number">67</span></span><br><span class="line"><span class="number">68</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="number">69</span> <span class="meta"># <span class="keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line"><span class="number">70</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="number">71</span> u8 __padding[LOCK_PADSIZE];</span><br><span class="line"><span class="number">72</span> <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="number">73</span> &#125;;</span><br><span class="line"><span class="number">74</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">75</span> &#125;;</span><br><span class="line"><span class="number">76</span> &#125; <span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">spinlock_t</span> lock;<span class="comment">//定义自旋锁</span></span><br></pre></td></tr></table></figure><h3 id="自旋锁API函数"><a href="#自旋锁API函数" class="headerlink" title="自旋锁API函数"></a>自旋锁API函数</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-19%20162257.png"></p><p>表中的自旋锁API 函数适用于SMP或支持抢占的单CPU下线程之间的并发访问，也就是用于线程与线程之间，被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API 函数，否则的话会可能会导致死锁现象的发生。自旋锁会自动禁止抢占，也就说当线程 A得到锁以后会暂时禁止内核抢占。如果线程 A 在持有锁期间进入了休眠状态，那么线程 A 会自动放弃 CPU 使用权。线程 B 开始运行，线程 B 也想要获取锁，但是此时锁被 A 线程持有，而<br>且内核抢占还被禁止了！线程 B 无法被调度出去，那么线程 A 就无法运行，锁也就无法释放，好了，死锁发生了！ </p><p>表 中的 API 函数用于线程之间的并发访问，如果此时中断也要插一脚，中断也想访问共享资源，那该怎么办呢？首先可以肯定的是，中断里面可以使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要先禁止本地中断(也就是本 CPU 中断，对于多核 SOC来说会有多个 CPU 核)，否则可能导致锁死现象的发生。</p><p>线程 A 先运行，并且获取到了 lock 这个锁，当线程 A 运行 functionA 函数的时候中断发生了，中断抢走了 CPU 使用权。右边的中断服务函数也要获取 lock 这个锁，但是这个锁被线程 A 占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程 A 是不可能执行的，线程 A 说“你先放手”，中断说“你先放手”，场面就这么僵持着，死锁发生！</p><p>最好的解决方法就是获取锁之前关闭本地中断， Linux 内核提供了相应的 API 函数 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-20%20162230.png"></p><p>建议使用 spin_lock_irqsave&#x2F; spin_unlock_irqrestore，因为这一组函<br>数会保存中断状态，在释放锁的时候会恢复中断状态。一般在线程中使用 spin_lock_irqsave&#x2F;spin_unlock_irqrestore，在中断中使用spin_lock&#x2F;spin_unlock， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> DEFINE_SPINLOCK(lock) <span class="comment">/* 定义并初始化一个锁 */</span></span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span><span class="comment">/* 线程 A */</span></span><br><span class="line"><span class="number">4</span> <span class="type">void</span> <span class="title function_">functionA</span> <span class="params">()</span>&#123;</span><br><span class="line"><span class="number">5</span> <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* 中断状态 */</span></span><br><span class="line"><span class="number">6</span> spin_lock_irqsave(&amp;lock, flags) <span class="comment">/* 获取锁 */</span></span><br><span class="line"><span class="number">7</span> <span class="comment">/* 临界区 */</span></span><br><span class="line"><span class="number">8</span> spin_unlock_irqrestore(&amp;lock, flags) <span class="comment">/* 释放锁 */</span></span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="comment">/* 中断服务函数 */</span></span><br><span class="line"><span class="number">12</span> <span class="type">void</span> <span class="title function_">irq</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">13</span> spin_lock(&amp;lock) <span class="comment">/* 获取锁 */</span></span><br><span class="line"><span class="number">14</span> <span class="comment">/* 临界区 */</span></span><br><span class="line"><span class="number">15</span> spin_unlock(&amp;lock) <span class="comment">/* 释放锁 */</span></span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="自旋锁使用注意事项"><a href="#自旋锁使用注意事项" class="headerlink" title="自旋锁使用注意事项"></a>自旋锁使用注意事项</h4><p>①、因为在等待自旋锁的时候处于“自旋”状态，因此锁的持有时间不能太长，一定要短，否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处理方式，比如稍后要讲的信号量和互斥体。<br>②、自旋锁保护的临界区内不能调用任何可能导致线程休眠的 API 函数，否则的话可能导致死锁。<br>③、不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了！<br>④、在编写驱动程序的时候我们必须考虑到驱动的可移植性，因此不管你用的是单核的还是多核的 SOC，都将其当做多核 SOC 来编写驱动程序。 </p><h4 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h4><p><u><strong>使用自旋锁来实现对实现设备的互斥访问 ，其实是使用定义的自旋锁来保护设备状态的变量，在改变设备状态的变量前后使用上锁和解锁的操作，主要是通过判断自旋锁的设备状态变量实现设备的互斥访问。</strong></u></p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量（<a href="https://so.csdn.net/so/search?q=semaphore&spm=1001.2101.3001.7020">semaphore</a>）是操作系统用来解决并发中的互斥和同步问题的一种方法。<br>信号量是一个与队列有关的整型变量，你可以把它想象成一个数后面拖着一条排队的队列。</p><p>那信号量上面值n代表什么意思呢？<br>n&gt;0：当前有可用资源，可用资源数量为n<br>n&#x3D;0：资源都被占用，可用资源数量为0<br>n&lt;0：资源都被占用，并且还有n个进程正在排队<br>那信号量拖着的那个队列就是用来放正在排队想要使用这一资源的进程。</p><p>信号量的特点：<br>①、因为信号量可以使等待资源线程进入休眠状态，因此适用于那些占用资源比较久的场合。<br>②、因此信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。<br>③、如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势。 </p><p>信号量API函数</p><p>Linux 内核使用 semaphore 结构体表示信号量 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line"><span class="type">raw_spinlock_t</span> lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-20%20185124.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span> <span class="comment">/* 定义信号量 */</span></span><br><span class="line">sema_init(&amp;sem, <span class="number">1</span>); <span class="comment">/* 初始化信号量 */</span></span><br><span class="line">down(&amp;sem); <span class="comment">/* 申请信号量 */</span></span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">up(&amp;sem); <span class="comment">/* 释放信号量 */</span></span><br></pre></td></tr></table></figure><h3 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h3><p>将信号量的值设置为 1 就可以使用信号量进行互斥访问了，虽然可以通过信号量实现互斥，但是 Linux 提供了一个比信号量更专业的机制来进行互斥，它就是互斥体—mutex。互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥体。在我们编写 Linux 驱动的时候遇到需要互斥访问的地方建议使用 mutex。  </p><p>linux内核使用mutex结构体表示互斥体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line"><span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line"><span class="type">atomic_t</span> count;</span><br><span class="line"><span class="type">spinlock_t</span> wait_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在使用 mutex 之前要先定义一个 mutex 变量。在使用 mutex 的时候要注意如下几点：<br>①、 mutex 可以导致休眠，因此不能在中断中使用 mutex，中断中只能使用自旋锁。<br>②、和信号量一样， mutex 保护的临界区可以调用引起阻塞的 API 函数。<br>③、因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁 </p><p><strong>API函数</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-20%20190738.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* 定义一个互斥体 */</span></span><br><span class="line"><span class="number">2</span> mutex_init(&amp;lock); <span class="comment">/* 初始化互斥体 */</span></span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> mutex_lock(&amp;lock); <span class="comment">/* 上锁 */</span></span><br><span class="line"><span class="number">5</span> <span class="comment">/* 临界区 */</span></span><br><span class="line"><span class="number">6</span> mutex_unlock(&amp;lock); <span class="comment">/* 解锁 */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gpio子系统</title>
      <link href="/2023/04/14/2023-4-14-pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/04/14/2023-4-14-pinctrl%E5%92%8Cgpio%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="GPIO子系统"><a href="#GPIO子系统" class="headerlink" title="GPIO子系统"></a>GPIO子系统</h3><h4 id="GPIO子系统API函数"><a href="#GPIO子系统API函数" class="headerlink" title="GPIO子系统API函数"></a>GPIO子系统API函数</h4><p>对于驱动开发人员，<strong>设置好设备树以后就可以使用 gpio 子系统提供的 API 函数来操作指定的 GPIO， gpio 子系统向驱动开发人员屏蔽了具体的读写寄存器过程。</strong>这就是驱动分层与分离的好处，大家各司其职，做好自己的本职工作即可。 gpio 子系统提供的常用的 API 函数有下面几个： </p><ol><li><p>gpio_request函数，用于申请一个 GPIO 管脚 </p><p>在使用一个 GPIO 之前一定要使用 gpio_request进行申请 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span> *label)</span></span><br></pre></td></tr></table></figure><p>gpio:要申请的gpio号，使用of_get_named_gpio函数从设备树获取指定gpio属性</p><p>label: gpio的名字</p><p>返回值：0申请成功，其他值失败</p></li><li><p>gpio_free函数， 释放gpio</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_free</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br></pre></td></tr></table></figure><p>gpio: 释放的gpio</p><p>返回值无</p></li><li><p>gpio_direction_input函数 ， 设置gpio为输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_direction_input</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br></pre></td></tr></table></figure><p>gpio:要设置的gpio</p><p>返回值：设置成功，负值设置失败</p></li><li><p>gpio_direction_output函数 ，设置某个 GPIO 为输出 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure><p>gpio：要设置为输出的 GPIO 标号。<br>value： GPIO 默认输出值。<br>返回值： 0，设置成功；负值，设置失败。 </p></li><li><p>gpio_get_value函数， 于获取某个 GPIO 的值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> gpio_get_value __gpio_get_value</span></span><br><span class="line"><span class="type">int</span> __gpio_get_value(<span class="type">unsigned</span> gpio)</span><br></pre></td></tr></table></figure><p>gpio：要获取的 GPIO 标号。<br>返回值： 非负值，得到的 GPIO 值；负值，获取失败。 </p></li><li><p>gpio_set_value函数， 设置某个 GPIO 的值</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> gpio_set_value __gpio_set_value</span></span><br><span class="line"><span class="type">void</span> __gpio_set_value(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span><br></pre></td></tr></table></figure><p>​gpio：要设置的 GPIO 标号。<br>​value： 要设置的值。<br>​返回值： 无 </p><h3 id="设备树中添加GPIO节点模板"><a href="#设备树中添加GPIO节点模板" class="headerlink" title="设备树中添加GPIO节点模板"></a>设备树中添加GPIO节点模板</h3><ul><li>创建设备节点</li><li>添加pinctrl信息</li><li>添加GPIO属性信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">gpio&#123;<span class="comment">/*把gpio节点添加到根节点下*/</span></span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;<span class="comment">/*添加 pinctrl-names 属性*/</span></span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_gpio&gt;;<span class="comment">/*添加 pinctrl-0 节点，使用的 PIN 信息保存在 pinctrl_gpio 节点中*/</span></span><br><span class="line">gpio = &lt;&amp;gpio1 <span class="number">0</span> GPIO_ACTIVE_LOW&gt;;<span class="comment">/*设备用的gpio*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gpio-相关的-OF-函数"><a href="#gpio-相关的-OF-函数" class="headerlink" title="gpio 相关的 OF 函数"></a>gpio 相关的 OF 函数</h4><p>在驱动程序中需要读取 gpio 属性内容， Linux 内核提供了几个与 GPIO 有关的 OF 函数，常用的几个 OF 函数如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_gpio_named_count</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname)</span><span class="comment">//获取设备树某个属性定义了几个gpio信息</span></span><br></pre></td></tr></table></figure><p>np：设备节点。<br>propname：要统计的 GPIO 属性。<br>返回值： 正值，统计到的 GPIO 数量；负值，失败。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_gpio_count</span><span class="params">(<span class="keyword">struct</span> device_node *np)</span><span class="comment">//统计的是“gpios”这个属性的 GPIO 数量</span></span><br></pre></td></tr></table></figure><p>np：设备节点。<br>返回值： 正值，统计到的 GPIO 数量；负值，失败。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_get_named_gpio</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params"><span class="type">int</span> index)</span><span class="comment">//此函数会将设备树中类似&lt;&amp;gpio5 7 GPIO_ACTIVE_LOW&gt;的属性信息转换为对应的 GPIO 编</span></span><br><span class="line">号</span><br></pre></td></tr></table></figure><p>np：设备节点。</p><p>propname：包含要获取 GPIO 信息的属性名。</p><p>index： GPIO 索引，因为一个属性里面可能包含多个 GPIO，此参数指定要获取哪个 GPIO的编号，如果只有一个 GPIO 信息的话此参数为 0。<br>返回值： 正值，获取到的 GPIO ；负值，失败。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> off0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> on1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="type">int</span> major;</span><br><span class="line"><span class="type">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"><span class="type">int</span> led_gpio;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> <span class="title">gpioled</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_open</span><span class="params">(<span class="keyword">struct</span> inode *inode ,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;gpioled;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_release</span><span class="params">(<span class="keyword">struct</span> inode *inode , <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">val = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(val &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kernl write failed \r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">state = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(state == on)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, <span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == off)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpioled_ops</span> =</span>&#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = gpio_open,</span><br><span class="line">.read = gpio_read,</span><br><span class="line">.write = gpio_write,</span><br><span class="line">.release = gpio_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">gpioled.nd = of_find_node_by_path(<span class="string">&quot;/gpioled&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(gpioled.nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;gpioled node can not found\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">printk(<span class="string">&quot;gpioled node found\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">&quot;led-gpio&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(gpioled.led_gpio &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;can not led-gpio\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">ret = gpio_direction_output(gpioled.led_gpio, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t see gpio\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(gpioled.major)</span><br><span class="line">&#123;</span><br><span class="line">gpioled.devid = MKDEV(gpioled.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(gpioled.devid, <span class="number">1</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">alloc_chrdev_region(&amp;gpioled.devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">gpioled.major = MAJOR(gpioled.devid);</span><br><span class="line">gpioled.minor = MINOR(gpioled.devid);</span><br><span class="line">&#125;</span><br><span class="line">gpioled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;gpioled.cdev, &amp;gpioled_ops);</span><br><span class="line">cdev_add(&amp;gpioled.cdev, gpioled.devid, <span class="number">1</span>);</span><br><span class="line">gpioled.class = class_create(THIS_MODULE, <span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(gpioled.class))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(gpioled.class);</span><br><span class="line">&#125;</span><br><span class="line">gpioled.device = device_create(gpioled.class, <span class="literal">NULL</span>,gpioled.devid, <span class="literal">NULL</span>,<span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(gpioled.device))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(gpioled.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">cdev_del(&amp;gpioled.cdev);</span><br><span class="line">unregister_chrdev_region(gpioled.devid, <span class="number">1</span>);</span><br><span class="line">device_destroy(gpioled.class, gpioled.devid);</span><br><span class="line">class_destroy(gpioled.class);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_init);</span><br><span class="line">module_exit(gpio_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树上的驱动开发</title>
      <link href="/2023/04/11/2023-4-11-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8A%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/04/11/2023-4-11-%E8%AE%BE%E5%A4%87%E6%A0%91%E4%B8%8A%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="设备树驱动编写框架"><a href="#设备树驱动编写框架" class="headerlink" title="设备树驱动编写框架"></a>设备树驱动编写框架</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-11%20180457.png"></p><h3 id="编写设备树节点"><a href="#编写设备树节点" class="headerlink" title="编写设备树节点"></a>编写设备树节点</h3><p>首先是将节点编写在使用的开发板的dts文件中，比如编写led的节点。首先将节点编写在根节点下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">alphaled<span class="comment">//节点名字&#123;</span></span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">  compatible = <span class="string">&quot;atkalpha-led&quot;</span>;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">reg = &#123;</span><br><span class="line">  <span class="number">0X020C406C</span> <span class="number">0X04</span> <span class="comment">//CCM_CCGR1_BASE</span></span><br><span class="line">        <span class="number">0X020E0068</span> <span class="number">0X04</span> <span class="comment">//SW_MUX_GPIO103_BASE</span></span><br><span class="line">        <span class="number">0X020E02F4</span> <span class="number">0X04</span> <span class="comment">//SW_PAD_GPIO103_BASE</span></span><br><span class="line">        <span class="number">0X0209C000</span> <span class="number">0X04</span> <span class="comment">//GPIO1_DR_BASE</span></span><br><span class="line">  <span class="number">0X0209C004</span> <span class="number">0X04</span> <span class="comment">//GPIO1_GDIR_BASE      </span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在节点中已经写入物理地址，所以驱动程序进行获取就行不用写了，设备树修改完重新编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make dtbs</span><br></pre></td></tr></table></figure><h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> on 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> off 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">led_switch</span><span class="params">(u8 state)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 val;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line"><span class="keyword">if</span>(state == on)</span><br><span class="line">&#123;</span><br><span class="line">val |= (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == off)</span><br><span class="line">&#123;</span><br><span class="line">val |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devtree</span> &#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="type">int</span> major;</span><br><span class="line"><span class="type">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devtree</span> <span class="title">chrled</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode , <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;chrled;<span class="comment">//设置私有数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line"></span><br><span class="line">val = copy_from_user(databuf, buf, cnt);</span><br><span class="line">state = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(state == on)</span><br><span class="line">&#123;</span><br><span class="line">led_switch(on);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == off)</span><br><span class="line">&#123;</span><br><span class="line">led_switch(off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">chrops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_open,</span><br><span class="line">.read = led_read,</span><br><span class="line">.write = led_write,</span><br><span class="line">.release = led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrled_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">proper</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line">u32 regdata[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line">chrled.nd = of_find_node_by_path(<span class="string">&quot;/alphaled&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(chrled.nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;error: node don&#x27;t find \r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">proper = of_find_property(chrled.nd, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(proper == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;compatible property find failed\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ret = of_property_read_string(chrled.nd, <span class="string">&quot;status&quot;</span>, &amp;str);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;status read failed\r\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">printk(<span class="string">&quot;status = %s\r\n&quot;</span>,str);</span><br><span class="line">&#125;</span><br><span class="line">ret = of_property_read_u32_array(chrled.nd , <span class="string">&quot;reg&quot;</span>, regdata, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;reg property read failed!\r\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">u8 i = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">&quot;reg data: \r\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)</span><br><span class="line">printk(<span class="string">&quot;%#X &quot;</span>, regdata[i]);</span><br><span class="line">printk(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">CCM_CCGR1 = of_iomap(chrled.nd, <span class="number">0</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = of_iomap(chrled.nd, <span class="number">1</span>);</span><br><span class="line">SW_PAD_GPIO1_IO03 = of_iomap(chrled.nd, <span class="number">2</span>);</span><br><span class="line">GPIO1_DR = of_iomap(chrled.nd, <span class="number">3</span>);</span><br><span class="line">GPIO1_GDIR = of_iomap(chrled.nd, <span class="number">4</span>);</span><br><span class="line"><span class="comment">/*设备驱动*/</span></span><br><span class="line">val = readl(CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">val |= (<span class="number">3</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">writel(val, CCM_CCGR1);</span><br><span class="line">writel(<span class="number">5</span>, SW_MUX_GPIO1_IO03);</span><br><span class="line">writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">val |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_GDIR);</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(chrled.major)</span><br><span class="line">&#123;</span><br><span class="line">chrled.devid = MKDEV(chrled.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(chrled.devid, <span class="number">1</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">alloc_chrdev_region(&amp;chrled.devid, <span class="number">0</span>, <span class="number">1</span>,<span class="string">&quot;led&quot;</span>);</span><br><span class="line">chrled.major = MAJOR(chrled.devid);</span><br><span class="line">chrled.minor = MINOR(chrled.devid);</span><br><span class="line">&#125;</span><br><span class="line">cdev_init(&amp;chrled.cdev, &amp;chrops);</span><br><span class="line">chrled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_add(&amp;chrled.cdev, chrled.devid, <span class="number">1</span>);</span><br><span class="line">chrled.class = class_create(THIS_MODULE, <span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(chrled.class))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chrled.class);</span><br><span class="line">&#125;</span><br><span class="line">chrled.device = device_create(chrled.class, <span class="literal">NULL</span>,chrled.devid, <span class="literal">NULL</span>,<span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(chrled.device))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(chrled.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrled_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">iounmap(CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line"></span><br><span class="line">cdev_del(&amp;chrled.cdev);</span><br><span class="line">unregister_chrdev_region(chrled.devid, <span class="number">1</span>);</span><br><span class="line">device_destroy(chrled.class, chrled.devid);</span><br><span class="line">class_destroy(chrled.class);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">module_init(chrled_init);</span><br><span class="line">module_exit(chrled_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nfs挂载设备树失败</title>
      <link href="/2023/04/10/2023-4-10-nfs%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87%E6%A0%91%E5%A4%B1%E8%B4%A5/"/>
      <url>/2023/04/10/2023-4-10-nfs%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87%E6%A0%91%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="VFS-Cannot-open-root-device-“nfs”-or-unknown-block-2-0"><a href="#VFS-Cannot-open-root-device-“nfs”-or-unknown-block-2-0" class="headerlink" title="VFS: Cannot open root device “nfs” or unknown-block(2,0)"></a>VFS: Cannot open root device “nfs” or unknown-block(2,0)</h3><p>首先说明一下问题，之前根文件系统一直正常使用，突然今天进行了以上报错，首先是搜索了一下问题，说是开发板内核和Ubuntu的nfs版本不匹配，之前遇到过，系统换成Ubuntu16版本的了，应该可以排除，但是也试了一下不好使。</p><p>感觉是ip地址的变化将bootargs变量里的服务器ip地址的数值进行了相应的改变，但是还是没有变化。</p><p>查了相关的问题搜索发现，没有解决方案，我先是进行了开发板的固化系统，使用了emmc中的根文件系统，发现没有问题，但是使用网络nfs挂载还是出现了问题，最后通过装载了第二个系统进行挂载发现了问题所在。</p><p>问题是：板子的ip地址和别的设备的ip地址冲突了（虽然之前也dhcp了但当时没好使），加上了服务器ip地址的变化导致的。</p><p>所以为了一劳永逸，将Ubuntu的动态分配ip地址进行了更改，改为静态分配ip地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipaddr</span><br></pre></td></tr></table></figure><p>可以查看发现网卡的名字。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-10%20210629.png"></p><p>网卡名字叫做ens33</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/network/interfaces</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line"> </span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line">auto ens33</span><br><span class="line"> </span><br><span class="line">iface ens33 inet static</span><br><span class="line">address  192.168.1.128</span><br><span class="line">netmask  255.255.255.0</span><br><span class="line">gateway  192.168.1.1</span><br></pre></td></tr></table></figure><p>之后进行重启网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/networking start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树常用的of操作树</title>
      <link href="/2023/04/09/2023-4-9-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%B8%B8%E7%94%A8%E7%9A%84of%E6%93%8D%E4%BD%9C%E6%A0%91/"/>
      <url>/2023/04/09/2023-4-9-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%B8%B8%E7%94%A8%E7%9A%84of%E6%93%8D%E4%BD%9C%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="设备树常用-OF-操作函数"><a href="#设备树常用-OF-操作函数" class="headerlink" title="设备树常用 OF 操作函数"></a>设备树常用 OF 操作函数</h3><p>设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，在编写驱动的时候需要获取到这些信息。比如设备树使用 reg 属性描述了某个外设的寄存器地址为 0X02005482，长度为 0X400，我们在编写驱动的时候需要获取到 reg 属性0X02005482和 0X400 这两个值，然后初始化外设。 </p><p>Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 include&#x2F;linux&#x2F;of.h 文件中。</p><p>linux内核使用device_code结构体来描述一个节点，此结构体定义在include&#x2F;linux&#x2F;of.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name; <span class="comment">/* 节点名字 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *type; <span class="comment">/* 设备类型 */</span></span><br><span class="line">phandle phandle;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *full_name; <span class="comment">/* 节点全名 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">properties</span>;</span> <span class="comment">/* 属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">deadprops</span>;</span> <span class="comment">/* removed 属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span> <span class="comment">/* 父节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span> <span class="comment">/* 子节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line"><span class="type">void</span> *data;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *path_component_name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="查找节点of函数"><a href="#查找节点of函数" class="headerlink" title="查找节点of函数"></a>查找节点of函数</h3><p>1、通过节点名字查找指定节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_name</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line"><span class="comment">//from开始查找的节点 </span></span><br><span class="line"><span class="comment">//name要查找的节点名字返回找到的节点，NULL表示失败</span></span><br></pre></td></tr></table></figure><p>2、通过device_type属性查找指定的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_type</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type)</span></span><br><span class="line"><span class="comment">//from开始查找的节点，NULL表示从根节点查找整个设备树 </span></span><br><span class="line"><span class="comment">//type要查找的节点对应的type字符串，</span></span><br><span class="line"><span class="comment">//返回值为找到的节点，NULL失败</span></span><br></pre></td></tr></table></figure><p>3、根据device_type和compatible两个属性查找指定的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_compatible_node</span><span class="params">(<span class="keyword">struct</span> device_node *from,<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *compatible)</span></span><br><span class="line"><span class="comment">//from 开始查找的节点NULL表示从根节点查找整个设备树</span></span><br><span class="line"><span class="comment">//type 要查找的节点对应的type字符串（device_type属性值），NULL表示忽略device_type属性</span></span><br><span class="line"><span class="comment">//compatible 要查找的节点所对应的compatible属性列表</span></span><br><span class="line"><span class="comment">//返回值： 找到的节点，如果为 NULL 表示查找失败</span></span><br></pre></td></tr></table></figure><p>4、通过of_device_id匹配表来查找节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_matching_node_and_match</span><span class="params">(<span class="keyword">struct</span> device_node *from, </span></span><br><span class="line"><span class="params">                                                    <span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">                                                    <span class="type">const</span> <span class="keyword">struct</span> of_device_id **match)</span></span><br><span class="line"><span class="comment">//from开始查找的节点，NULL代表从根节点查找整个设备树</span></span><br><span class="line"><span class="comment">//matches of_device_id匹配表，在匹配表里查找节点</span></span><br><span class="line"><span class="comment">//match 找到的匹配的of_device_id</span></span><br><span class="line"><span class="comment">//返回值：找到的节点，NULL表示失败，</span></span><br></pre></td></tr></table></figure><p>5、通过路径来查找指定的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span><br><span class="line"><span class="comment">//path:带有全路径的节点名</span></span><br><span class="line"><span class="comment">//返回值找到的节点，NULL表示失败</span></span><br></pre></td></tr></table></figure><h4 id="查找父-x2F-子节点的of函数"><a href="#查找父-x2F-子节点的of函数" class="headerlink" title="查找父&#x2F;子节点的of函数"></a>查找父&#x2F;子节点的of函数</h4><p>1、获取指定节点的父节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_parent</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node)</span></span><br><span class="line"><span class="comment">//node：要查找的父节点的节点。</span></span><br><span class="line"><span class="comment">//返回值： 找到的父节点。</span></span><br></pre></td></tr></table></figure><p>2、用迭代方式查找子节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_child</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node , <span class="keyword">struct</span> device_node *prev)</span></span><br><span class="line"><span class="comment">//node父节点</span></span><br><span class="line"><span class="comment">//prev前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始。</span></span><br><span class="line"><span class="comment">//返回值： 找到的下一个子节点。</span></span><br></pre></td></tr></table></figure><h3 id="提取属性值的of函数"><a href="#提取属性值的of函数" class="headerlink" title="提取属性值的of函数"></a>提取属性值的of函数</h3><p>节点的属性信息里面保存了驱动所需要的内容，因此对于属性值的提取非常重要， Linux 内核中使用结构体 property 表示属性，此结构体同样定义在文件 include&#x2F;linux&#x2F;of.h 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *name; <span class="comment">/* 属性名字 */</span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">/* 属性长度 */</span></span><br><span class="line"><span class="type">void</span> *value; <span class="comment">/* 属性值 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">next</span>;</span> <span class="comment">/* 下一个属性 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1、用于查找指定的属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">property *<span class="title function_">of_find_property</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> *lenp)</span></span><br><span class="line"><span class="comment">//np 设备节点</span></span><br><span class="line"><span class="comment">//name 属性名字</span></span><br><span class="line"><span class="comment">//lenp 属性值的字节树</span></span><br><span class="line"><span class="comment">//返回值找到的属性</span></span><br></pre></td></tr></table></figure><p>2、用于获取属性中元素的数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_count_elems_of_size</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,<span class="type">const</span> <span class="type">char</span> *propname，<span class="type">int</span> elem_size)</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//proname： 需要统计元素数量的属性名字。</span></span><br><span class="line"><span class="comment">//elem_size：元素长度。</span></span><br><span class="line"><span class="comment">//返回值： 得到的属性元素数量</span></span><br></pre></td></tr></table></figure><p>3、用于从属性中获取指定标号的 u32 类型数据值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u32_index</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">                               u32 index,</span></span><br><span class="line"><span class="params">                               u32 *out_value               )</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//proname： 要读取的属性名字。</span></span><br><span class="line"><span class="comment">//index：要读取的值标号。</span></span><br><span class="line"><span class="comment">//out_value：读取到的值</span></span><br><span class="line"><span class="comment">//返回值： 0 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</span></span><br></pre></td></tr></table></figure><p>4、读取属性中 u8、 u16、 u32 和 u64 类型的数组数据 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u8_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">u8 *out_values,</span></span><br><span class="line"><span class="params"><span class="type">size_t</span> sz)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u16_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">  u16 *out_values,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> sz)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u32_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params"> u32 *out_values,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> sz)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u64_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params"> u64 *out_values,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> sz)</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//proname： 要读取的属性名字。</span></span><br><span class="line"><span class="comment">//out_value：读取到的数组值，分别为 u8、 u16、 u32 和 u64。</span></span><br><span class="line"><span class="comment">//sz： 要读取的数组元素数量。</span></span><br><span class="line"><span class="comment">//返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</span></span><br></pre></td></tr></table></figure><p>5、用于读取这种只有一个整形值的属性，分别用于读取 u8、 u16、 u32 和 u64 类型属性值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u8</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">u8 *out_value)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u16</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">u16 *out_value)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u32</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">  u32 *out_value)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_u64</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params"> u64 *out_value)</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//proname： 要读取的属性名字。</span></span><br><span class="line"><span class="comment">//out_value：读取到的数组值。</span></span><br><span class="line"><span class="comment">//返回值： 0，读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有要读取的数据， -EOVERFLOW 表示属性值列表太小。</span></span><br></pre></td></tr></table></figure><p>6、用于读取属性中字符串值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_string</span><span class="params">(<span class="keyword">struct</span> device_node *np,<span class="type">const</span> <span class="type">char</span> *propname,<span class="type">const</span> <span class="type">char</span> **out_string)</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//proname： 要读取的属性名字。</span></span><br><span class="line"><span class="comment">//out_string：读取到的字符串值。</span></span><br><span class="line"><span class="comment">//返回值： 0，读取成功，负值，读取失败。</span></span><br></pre></td></tr></table></figure><p>7、用于获取#address-cells 属性值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_n_addr_cells</span><span class="params">(<span class="keyword">struct</span> device_node *np)</span></span><br><span class="line"><span class="comment">//np：设备节点。</span></span><br><span class="line"><span class="comment">//返回值： 获取到的#address-cells 属性值。</span></span><br></pre></td></tr></table></figure><p>8、用于获取#size-cells 属性值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_n_size_cells</span><span class="params">(<span class="keyword">struct</span> device_node *np)</span></span><br><span class="line"><span class="comment">//np 设备节点</span></span><br><span class="line"><span class="comment">//获取到的size-cells</span></span><br></pre></td></tr></table></figure><h4 id="其他常用的-OF-函数"><a href="#其他常用的-OF-函数" class="headerlink" title="其他常用的 OF 函数"></a>其他常用的 OF 函数</h4><p>1、查看节点的compatible属性是否包含compat指定的字符串，也就是检查设备节点的兼容性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_device_is_compatible</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *device,<span class="type">const</span> <span class="type">char</span> *compat)</span></span><br><span class="line"><span class="comment">//device：设备节点</span></span><br><span class="line"><span class="comment">//compat：要查看的字符串</span></span><br><span class="line"><span class="comment">//返回值： 0，节点的 compatible 属性中不包含 compat 指定的字符串； 正数，节点的 compatible属性中包含 compat 指定的字符串。</span></span><br></pre></td></tr></table></figure><p>2、用于获取地址相关属性，主要是reg和assigned-address属性值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> __be32 *<span class="title function_">of_get_address</span><span class="params">(<span class="keyword">struct</span> device_node *dev,<span class="type">int</span> index,u64 *size,<span class="type">unsigned</span> <span class="type">int</span> *flags)</span></span><br><span class="line"><span class="comment">//dev设备节点</span></span><br><span class="line"><span class="comment">//index：要读取的地址标号。</span></span><br><span class="line"><span class="comment">//size：地址长度。</span></span><br><span class="line"><span class="comment">//flags：参数，比如 IORESOURCE_IO、 IORESOURCE_MEM 等</span></span><br><span class="line"><span class="comment">//返回值： 读取到的地址数据首地址，为 NULL 的话表示读取失败。</span></span><br></pre></td></tr></table></figure><p>3、负责将从设备树读取到的地址转换为物理地址 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u64 <span class="title function_">of_translate_address</span><span class="params">(<span class="keyword">struct</span> device_node *dev，const__be32*in_addr)</span></span><br><span class="line"><span class="comment">//dev：设备节点。</span></span><br><span class="line"><span class="comment">//in_addr：要转换的地址。</span></span><br><span class="line"><span class="comment">//返回值： 得到的物理地址，如果为 OF_BAD_ADDR 的话表示转换失败</span></span><br></pre></td></tr></table></figure><p>4、IIC、 SPI、 GPIO 等这些外设都有对应的寄存器，这些寄存器其实就是一组内存空间， Linux内核使用 resource 结构体来描述一段内存空间，“resource”翻译出来就是“资源”，因此用 resource结构体描述的都是设备资源信息， resource 结构体定义在文件 include&#x2F;linux&#x2F;ioport.h 中，定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line"><span class="type">resource_size_t</span> start;</span><br><span class="line"><span class="type">resource_size_t</span> end;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 32 位的 SOC 来说， resource_size_t 是 u32 类型的。其中 start 表示开始地址， end 表示结束地址， name 是这个资源的名字， flags 是资源标志位，一般表示资源类型，可选的资源标志定义在文件 include&#x2F;linux&#x2F;ioport.h 中 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_BITS 0x000000ff</span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_TYPE_BITS 0x00001f00</span></span><br><span class="line"><span class="number">3</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_IO 0x00000100</span></span><br><span class="line"><span class="number">4</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM 0x00000200</span></span><br><span class="line"><span class="number">5</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_REG 0x00000300</span></span><br><span class="line"><span class="number">6</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_IRQ 0x00000400</span></span><br><span class="line"><span class="number">7</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_DMA 0x00000800</span></span><br><span class="line"><span class="number">8</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_BUS 0x00001000</span></span><br><span class="line"><span class="number">9</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_PREFETCH 0x00002000</span></span><br><span class="line"><span class="number">10</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_READONLY 0x00004000</span></span><br><span class="line"><span class="number">11</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_CACHEABLE 0x00008000</span></span><br><span class="line"><span class="number">12</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_RANGELENGTH 0x00010000</span></span><br><span class="line"><span class="number">13</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_SHADOWABLE 0x00020000</span></span><br><span class="line"><span class="number">14</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_SIZEALIGN 0x00040000</span></span><br><span class="line"><span class="number">15</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_STARTALIGN 0x00080000</span></span><br><span class="line"><span class="number">16</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM_64 0x00100000</span></span><br><span class="line"><span class="number">17</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_WINDOW 0x00200000</span></span><br><span class="line"><span class="number">18</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_MUXED 0x00400000</span></span><br><span class="line"><span class="number">19</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_EXCLUSIVE 0x08000000</span></span><br><span class="line"><span class="number">20</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_DISABLED 0x10000000</span></span><br><span class="line"><span class="number">21</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_UNSET 0x20000000</span></span><br><span class="line"><span class="number">22</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_AUTO 0x40000000</span></span><br><span class="line"><span class="number">23</span> <span class="meta">#<span class="keyword">define</span> IORESOURCE_BUSY 0x80000000</span></span><br></pre></td></tr></table></figure><p>将 reg 属性值，然后将其转换为 resource 结构体类型， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev,<span class="type">int</span> index,<span class="keyword">struct</span> resource *r)</span></span><br><span class="line"><span class="comment">//dev：设备节点。</span></span><br><span class="line"><span class="comment">//index：地址资源标号。</span></span><br><span class="line"><span class="comment">//r：得到的 resource 类型的资源值。</span></span><br><span class="line"><span class="comment">//返回值： 0，成功；负值，失败</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux设备树</title>
      <link href="/2023/04/08/2023-4-8-linux%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
      <url>/2023/04/08/2023-4-8-linux%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="设备树定义"><a href="#设备树定义" class="headerlink" title="设备树定义"></a>设备树定义</h3><p>设备树（Device tree），描述设备树的文件叫做DTS（Tree Source），这个DTS采用树形结构描述板级设备（开发板上的设备信息）。树的主干就是系统总线， IIC 控制器、 GPIO 控制器、 SPI 控制器等都是接到系统主线上的分支。 </p><p>设备树源文件扩展名为.dts， DTS 是设备树源码文件， DTB 是将DTS 编译以后得到的二进制文件。将.c 文件编译为.o 需要用到 gcc 编译器，那么将.dts 编译为.dtb需要什么工具呢？需要用到 DTC 工具！ </p><h3 id="DTS语法"><a href="#DTS语法" class="headerlink" title="DTS语法"></a>DTS语法</h3><p>设备树也支持头文件，设备树的头文件扩展名为.dtsi。例如：在imx6ull-14x14-evk.dts中有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ulll-14x14-evk.dsti&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="设备点"><a href="#设备点" class="headerlink" title="设备点"></a>设备点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">示例代码 <span class="number">43.3</span><span class="number">.2</span><span class="number">.1</span> 设备树模板</span><br><span class="line"><span class="number">1</span> / &#123;</span><br><span class="line"><span class="number">2</span> aliases &#123;</span><br><span class="line"><span class="number">3</span> can0 = &amp;flexcan1;</span><br><span class="line"><span class="number">4</span> &#125;;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> cpus &#123;</span><br><span class="line"><span class="number">7</span> <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="number">8</span> <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> cpu0: cpu@<span class="number">0</span> &#123;</span><br><span class="line"><span class="number">11</span> compatible = <span class="string">&quot;arm,cortex-a7&quot;</span>;</span><br><span class="line"><span class="number">12</span> device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line"><span class="number">13</span> reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line"><span class="number">14</span> &#125;;</span><br><span class="line"><span class="number">15</span> &#125;;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> intc: interrupt-controller@<span class="number">00</span>a01000 &#123;</span><br><span class="line"><span class="number">18</span> compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>;</span><br><span class="line"><span class="number">19</span> <span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;</span></span><br><span class="line"><span class="number">20</span> interrupt-controller;</span><br><span class="line"><span class="number">21</span> reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line"><span class="number">22</span> &lt;<span class="number">0x00a02000</span> <span class="number">0x100</span>&gt;;</span><br><span class="line"><span class="number">23</span> &#125;;</span><br><span class="line"><span class="number">24</span> &#125;</span><br></pre></td></tr></table></figure><p>第 2、6 和 17 行，aliases、cpus 和 intc 是三个子节点，在设备树中节点命名格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node-name@unit-address</span><br></pre></td></tr></table></figure><p>其中“node-name”是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如“uart1”就表示这个节点是 UART1 外设。“unit-address”一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话“unit-address”可以不要，比如“cpu@0”、“interrupt-controller@00a01000”。</p><p>但是我们在示例代码 43.3.2.1 中我们看到的节点命名却如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu0:cpu@0</span><br></pre></td></tr></table></figure><p>上述命令并不是“node-name@unit-address”这样的格式，而是用“：”隔开成了两部分，“：”<br>前面的是节点标签(label)，“：”后面的才是节点名字，格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label: node-name@unit-address</span><br></pre></td></tr></table></figure><h4 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-07%20201941.png"></p><p>设备树源码中常用的几种数据形式如下所示：</p><p>①、字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = &quot;arm,cortex-a7&quot;;</span><br></pre></td></tr></table></figure><p>上述代码设置 compatible 属性的值为字符串“arm,cortex-a7”。<br>②、32 位无符号整数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg = &lt;0&gt;;</span><br></pre></td></tr></table></figure><p>上述代码设置 reg 属性的值为 0，reg 的值也可以设置为一组值，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg = &lt;0 0x123456 100&gt;;</span><br></pre></td></tr></table></figure><p>③、字符串列表<br>属性值也可以为字符串列表，字符串和字符串之间采用“,”隔开，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = &quot;fsl,imx6ull-gpmi-nand&quot;, &quot;fsl, imx6ul-gpmi-nand&quot;;</span><br></pre></td></tr></table></figure><h4 id="标准属性"><a href="#标准属性" class="headerlink" title="标准属性"></a>标准属性</h4><p>节点是由一堆的属性组成，节点都是具体的设备，不同的设备需要的属性不同，用户可以自定义属性。除了用户自定义属性，有很多属性是标准属性， Linux 下的很多外设驱动都会使用这些标准属性。</p><p><strong>1、compatible属性</strong></p><p>compatible 属性也叫做“兼容性”属性，这是非常重要的一个属性！ compatible 属性的值是一个字符串列表， compatible 属性用于将设备和驱动绑定起来。字符串列表用于选择设备所要使用的驱动程序， compatible 属性的值格式如下所示： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;manufacturer,model&quot;</span><br></pre></td></tr></table></figure><p>其中 manufacturer 表示厂商， model 一般是模块对应的驱动名字。 </p><p>I.MX6U-ALPHA 开发板上的音频芯片采用的欧胜(WOLFSON)出品的 WM8960， sound 节点的 compatible 属性值如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = &quot;fsl,imx6ul-evk-wm8960&quot;,&quot;fsl,imx-audio-wm8960&quot;;</span><br></pre></td></tr></table></figure><p>属性值有两个，分别为“fsl,imx6ul-evk-wm8960”和“fsl,imx-audio-wm8960” ,sound这个设备首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。 </p><p><strong><u>一般驱动程序文件都会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。</u></strong> </p><p><strong>2、model属性</strong></p><p>model属性值也是一个字符串，一般model属性描述设备模块信息，比如名字，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = &quot;wm8960-audio&quot;;</span><br></pre></td></tr></table></figure><p><strong>3、status属性</strong></p><p>status 属性看名字就知道是和设备状态有关的， status 属性值也是字符串，字符串是设备的状态信息，可选的状态如表 :</p><table><thead><tr><th align="center">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">”okey“</td><td align="left">表明设备是可操作的。</td></tr><tr><td align="center">”disabled“</td><td align="left">表明设备当前是不可操作的，但是在未来可以变为可操作的，比如热插拔设备插入以后。具体含义看设备绑定的文档。</td></tr><tr><td align="center">”fail“</td><td align="left">表明设备不可操作，设备检测到了一系列的错误，而且设备也不大可能变得操作。</td></tr><tr><td align="center">”fail-sss“</td><td align="left">含义和“fail”相同，后面的 sss 部分是检测到的错误内容。</td></tr></tbody></table><p><strong>4、#address-cells和#size-cells属性</strong></p><p>这两个属性的值都是无符号 32 位整形， #address-cells 和#size-cells 这两个属性可以用在任何拥有子节点的设备中，用于描述子节点的地址信息。 #address-cells 属性值决定了子节点 reg 属性中地址信息所占用的字长(32 位)， </p><p>#size-cells 属性值决定了子节点 reg 属性中长度信息所占的字长(32 位)。 #address-cells 和#size-cells 表明了子节点应该如何编写 reg 属性值，一般 reg 属性都是和地址有关的内容，和地址相关的信息有两种：起始地址和地址长度。reg格式一般为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg = &lt;address1 length1 address2 length2 address3 length3……&gt;</span><br></pre></td></tr></table></figure><p>每个“address length”组合表示一个地址范围，其中 address 是起始地址， length 是地址长度， #address-cells 表明 address 这个数据所占用的字长， #size-cells 表明 length 这个数据所占用的字长 </p><p><strong>5、reg属性</strong></p><p>reg 属性的值一般是(address， length)对。 reg 属性一般用于描述设备地址空间资源信息，一般都是某个外设的寄存器地址范围信息。</p><p><strong>6、 ranges 属性</strong><br>ranges属性值可以为空或者按照(child-bus-address,parent-bus-address,length)格式编写的数字矩阵， ranges 是一个地址映射&#x2F;转换表， ranges 属性每个项目由子地址、父地址和地址空间长度。<br>这三部分组成：<br>    child-bus-address：子总线地址空间的物理地址，由父节点的#address-cells 确定此物理地址所占用的字长。<br>    parent-bus-address： 父总线地址空间的物理地址，同样由父节点的#address-cells 确定此物理地址所占用的字长。<br>    length： 子地址空间的长度，由父节点的#size-cells 确定此地址长度所占用的字长 </p><p><strong>7、 name 属性</strong><br>name 属性值为字符串， name 属性用于记录节点名字， name 属性已经被弃用，不推荐使用name 属性，一些老的设备树文件可能会使用此属性。<br><strong>8、 device_type 属性</strong><br>device_type 属性值为字符串， IEEE 1275 会用到此属性，用于描述设备的 FCode，但是设备树没有 FCode，所以此属性也被抛弃了。<u>此属性只能用于 cpu 节点或者 memory 节点</u>。imx6ull.dtsi 的 cpu0 节点用到了此属性 。</p><h4 id="根节点-compatible-属性"><a href="#根节点-compatible-属性" class="headerlink" title="根节点 compatible 属性"></a>根节点 compatible 属性</h4><p>设备节点的 compatible 属性值是为了匹配 Linux 内核中的驱动程序，通过根节点的 compatible 属性可以知道我们所使用的设备，一般第<br>一个值描述了所使用的硬件设备名字，第二个值描述了设备所使用的 SOC。 <u>Linux 内核会通过根节点的 compoatible 属性查看是否支持此设备，如果支持的话设备就会启动 Linux 内核。</u> </p><p><strong>1、使用设备树之前的设备匹配方法</strong></p><p>在没有使用设备树以前， uboot 会向 Linux 内核传递一个叫做 machine id 的值， machine id也就是设备 ID，告诉 Linux 内核自己是个什么设备，看看 Linux 内核是否支持。 </p><p>uboot 会给 Linux 内核传递 machine id 这个参数， Linux 内核会检查这个 machine id，其实就是将 machine id 与MACH_TYPE_XXX 宏进行对比，看看有没有相等的，如果相等的话就表示 Linux 内核支持这个设备，如果不支持的话那么这个设备就没法启动 Linux 内核。 </p><p><strong>2、使用设备树以后的设备匹配方法</strong></p><p>当 Linux 内 核 引 入 设 备 树 以 后 就 不 再 使 用 MACHINE_START 了 ， 而 是 换 为 了DT_MACHINE_START。 DT_MACHINE_START 也定义在文件 arch&#x2F;arm&#x2F;include&#x2F;asm&#x2F;mach&#x2F;arch.h里面，定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DT_MACHINE_START(_name, _namestr) \</span></span><br><span class="line"><span class="meta">static const struct machine_desc __mach_desc_##_name \</span></span><br><span class="line"><span class="meta">__used \</span></span><br><span class="line"><span class="meta">__attribute__((__section__(<span class="string">&quot;.arch.info.init&quot;</span>))) = &#123; \</span></span><br><span class="line"><span class="meta">.nr = ~0, \</span></span><br><span class="line"><span class="meta">.name = _namestr,</span></span><br></pre></td></tr></table></figure><p>可以看出， DT_MACHINE_START 和 MACHINE_START 基本相同，只是.nr 的设置不同，在 DT_MACHINE_START 里面直接将.nr 设置为~0。说明引入设备树以后不会再根据 machineid 来检查 Linux 内核是否支持某个设备了。 </p><p>打开文件 arch&#x2F;arm&#x2F;mach-imx&#x2F;mach-imx6ul.c，有如下所示内容： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">208</span> <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *imx6ul_dt_compat[] __initconst = &#123;</span><br><span class="line"><span class="number">209</span> <span class="string">&quot;fsl,imx6ul&quot;</span>,</span><br><span class="line"><span class="number">210</span> <span class="string">&quot;fsl,imx6ull&quot;</span>,</span><br><span class="line"><span class="number">211</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="number">212</span> &#125;;</span><br><span class="line"><span class="number">213</span></span><br><span class="line"><span class="number">214</span> DT_MACHINE_START(IMX6UL, <span class="string">&quot;Freescale i.MX6 Ultralite (Device Tree)&quot;</span>)</span><br><span class="line"><span class="number">215</span> .map_io = imx6ul_map_io,</span><br><span class="line"><span class="number">216</span> .init_irq = imx6ul_init_irq,</span><br><span class="line"><span class="number">217</span> .init_machine = imx6ul_init_machine,</span><br><span class="line"><span class="number">218</span> .init_late = imx6ul_init_late,</span><br><span class="line"><span class="number">219</span> .dt_compat = imx6ul_dt_compat,</span><br><span class="line"><span class="number">220</span> MACHINE_END</span><br></pre></td></tr></table></figure><p>machine_desc 结构体中有个.dt_compat 成员变量，此成员变量保存着本设备兼容属性，设置.dt_compat &#x3D; imx6ul_dt_compat， imx6ul_dt_compat 表里面有”fsl,imx6ul”和”fsl,imx6ull”这两个兼容值。只要某个设备(板子)根节点“ &#x2F;”的 compatible 属性值与imx6ul_dt_compat 表中的任何一个值相等，那么就表示 Linux 内核支持此设备。 </p><p>imx6ull-alientekemmc.dts 中根节点的 compatible 属性值如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="string">&quot;fsl,imx6ull&quot;</span>;</span><br></pre></td></tr></table></figure><p>其中“fsl,imx6ull”与 imx6ul_dt_compat 中的“fsl,imx6ull”匹配，因此 I.MX6U-ALPHA 开发板可以正常启动 Linux 内核。 </p><p>Linux 内核调用 start_kernel 函数来启动内核， start_kernel 函数会调用setup_arch 函数来匹配 machine_desc， setup_arch 函数定义在文件 arch&#x2F;arm&#x2F;kernel&#x2F;setup.c 中 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">913</span> <span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">914 &#123;</span><br><span class="line"><span class="number">915</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">mdesc</span>;</span></span><br><span class="line"><span class="number">916</span></span><br><span class="line"><span class="number">917</span> setup_processor();</span><br><span class="line"><span class="number">918</span> mdesc = setup_machine_fdt(__atags_pointer);</span><br><span class="line"><span class="number">919</span> <span class="keyword">if</span> (!mdesc)</span><br><span class="line"><span class="number">920</span> mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type);</span><br><span class="line"><span class="number">921</span> machine_desc = mdesc;</span><br><span class="line"><span class="number">922</span> machine_name = mdesc-&gt;name;</span><br><span class="line">......</span><br><span class="line"><span class="number">986</span> &#125;</span><br></pre></td></tr></table></figure><p>第 918 行，调用 setup_machine_fdt 函数来获取匹配的 machine_desc，参数就是 atags 的首地址，也就是 uboot 传递给 Linux 内核的 dtb 文件首地址， setup_machine_fdt 函数的返回值就是找到的最匹配的 machine_desc。 </p><p>函数 setup_machine_fdt 定义在文件 arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c 中，内容如下 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">204</span> <span class="type">const</span> <span class="keyword">struct</span> machine_desc * __init <span class="title function_">setup_machine_fdt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> dt_phys)</span></span><br><span class="line">205 &#123;</span><br><span class="line"><span class="number">206</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">mdesc</span>, *<span class="title">mdesc_best</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">214</span></span><br><span class="line"><span class="number">215</span> <span class="keyword">if</span> (!dt_phys || !early_init_dt_verify(phys_to_virt(dt_phys)))</span><br><span class="line"><span class="number">216</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">217</span></span><br><span class="line"><span class="number">218</span> mdesc = of_flat_dt_match_machine(mdesc_best,arch_get_next_mach);</span><br><span class="line"><span class="number">219</span></span><br><span class="line">......</span><br><span class="line"><span class="number">247</span> __machine_arch_type = mdesc-&gt;nr;</span><br><span class="line"><span class="number">248</span></span><br><span class="line"><span class="number">249</span> <span class="keyword">return</span> mdesc;</span><br><span class="line"><span class="number">250</span> &#125;</span><br></pre></td></tr></table></figure><p>第 218 行，调用函数 of_flat_dt_match_machine 来获取匹配的 machine_desc，参数 mdesc_best是 默 认 的 machine_desc ， 参 数 arch_get_next_mach 是 个 函 数 ， 此 函 数 定 义 在 定 义 在arch&#x2F;arm&#x2F;kernel&#x2F;devtree.c 文件中。找到匹配的 machine_desc 的过程就是用设备树根节点的compatible 属性值和 Linux 内核中 machine_desc 下.dt_compat 的值比较，看看那个相等，如果相等的话就表示找到匹配的 machine_desc， arch_get_next_mach 函数的工作就是获取 Linux 内核中下一个 machine_desc 结构体。 </p><p>最后再来看一下 of_flat_dt_match_machine 函数，此函数定义在文件 drivers&#x2F;of&#x2F;fdt.c 中 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">705</span> <span class="type">const</span> <span class="type">void</span> * __init <span class="title function_">of_flat_dt_match_machine</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *default_match,</span></span><br><span class="line"><span class="params"><span class="number">706</span> <span class="type">const</span> <span class="type">void</span> * (*get_next_compat)(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span>**))</span></span><br><span class="line">707 &#123;</span><br><span class="line"><span class="number">708</span> <span class="type">const</span> <span class="type">void</span> *data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">709</span> <span class="type">const</span> <span class="type">void</span> *best_data = default_match;</span><br><span class="line"><span class="number">710</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> *compat;</span><br><span class="line"><span class="number">711</span> <span class="type">unsigned</span> <span class="type">long</span> dt_root;</span><br><span class="line"><span class="number">712</span> <span class="type">unsigned</span> <span class="type">int</span> best_score = ~<span class="number">1</span>, score = <span class="number">0</span>;</span><br><span class="line"><span class="number">713</span></span><br><span class="line"><span class="number">714</span> dt_root = of_get_flat_dt_root();</span><br><span class="line"><span class="number">715</span> <span class="keyword">while</span> ((data = get_next_compat(&amp;compat))) &#123;</span><br><span class="line"><span class="number">716</span> score = of_flat_dt_match(dt_root, compat);</span><br><span class="line"><span class="number">717</span> <span class="keyword">if</span> (score &gt; <span class="number">0</span> &amp;&amp; score &lt; best_score) &#123;</span><br><span class="line"><span class="number">718</span> best_data = data;</span><br><span class="line"><span class="number">719</span> best_score = score;</span><br><span class="line"><span class="number">720</span> &#125;</span><br><span class="line"><span class="number">721</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">739</span></span><br><span class="line"><span class="number">740</span> pr_info(<span class="string">&quot;Machine model: %s\n&quot;</span>, of_flat_dt_get_machine_name());</span><br><span class="line"><span class="number">741</span></span><br><span class="line"><span class="number">742</span> <span class="keyword">return</span> best_data;</span><br><span class="line"><span class="number">743</span> &#125;</span><br></pre></td></tr></table></figure><p>第 714 行，通过函数 of_get_flat_dt_root 获取设备树根节点。<br>第 715~720 行，此循环就是查找匹配的 machine_desc 过程，第 716 行的 of_flat_dt_match 函数会将根节点 compatible 属性的值和每个 machine_desc 结构体中. dt_compat 的值进行比较，直至找到匹配的那个 machine_desc。 </p><p>Linux 内核通过根节点 compatible 属性找到对应的设备的函数调用过程 如下：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-08%20105607.png"></p><h4 id="向节点追加或修改内容"><a href="#向节点追加或修改内容" class="headerlink" title="向节点追加或修改内容"></a>向节点追加或修改内容</h4><p>打开imx6ull.dtsi文件进行追加内容，因为imx6ull.dtsi是设备头文件，所有使用IMX6ULL这个soc的板子都会引用这个文件，向文件中添加一个设备节点，相当于所有的板子都会添加这个设备，所以要在自己板子的.dts文件进行数据追加内容。</p><p>比如要向I2C1节点追加一个fxls8471的子节点，需要在imx6ull-alientek-emmc.dts 文件中完成数据追加的内容，方式如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;i2c1 &#123;</span><br><span class="line"><span class="number">2</span> <span class="comment">/* 要追加或修改的内容 */</span></span><br><span class="line"><span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p>第 1 行， &amp;i2c1 表示要访问 i2c1 这个 label 所对应的节点，也就是 imx6ull.dtsi 中的“i2c1:i2c@021a0000”。<br>第 2 行，花括号内就是要向 i2c1 这个节点添加的内容，包括修改某些属性的值。 </p><p>打开 imx6ull-alientek-emmc.dts，找到如下所示内容： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">224</span> &amp;i2c1 &#123;</span><br><span class="line"><span class="number">225</span> clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line"><span class="number">226</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">227</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line"><span class="number">228</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">229</span></span><br><span class="line"><span class="number">230</span> mag3110@<span class="number">0</span>e &#123;</span><br><span class="line"><span class="number">231</span> compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line"><span class="number">232</span> reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line"><span class="number">233</span> position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line"><span class="number">234</span> &#125;;</span><br><span class="line"><span class="number">235</span></span><br><span class="line"><span class="number">236</span> fxls8471@<span class="number">1</span>e &#123;</span><br><span class="line"><span class="number">237</span> compatible = <span class="string">&quot;fsl,fxls8471&quot;</span>;</span><br><span class="line"><span class="number">238</span> reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line"><span class="number">239</span> position = &lt;<span class="number">0</span>&gt;;</span><br><span class="line"><span class="number">240</span> interrupt-parent = &lt;&amp;gpio5&gt;;</span><br><span class="line"><span class="number">241</span> interrupts = &lt;<span class="number">0</span> <span class="number">8</span>&gt;;</span><br><span class="line"><span class="number">242</span> &#125;;</span><br><span class="line"><span class="number">243</span>&#125;</span><br></pre></td></tr></table></figure><p>本代码就是向 i2c1 节点添加&#x2F;修改数据，比如第 225 行的属性“clock-frequency”就表示 i2c1 时钟为 100KHz。“clock-frequency”就是新添加的属性。<br>第 228 行，将 status 属性的值由原来的 disabled 改为 okay。<br>第 230<del>234 行， i2c1 子节点 mag3110，因为 NXP 官方开发板在 I2C1 上接了一个磁力计芯片 mag3110，正点原子的 I.MX6U-ALPHA 开发板并没有使用 mag3110。<br>第 236</del>242 行， i2c1 子节点 fxls8471，同样是因为 NXP 官方开发板在 I2C1 上接了 fxls8471这颗六轴芯片 。</p><h3 id="创建小型模板设备树"><a href="#创建小型模板设备树" class="headerlink" title="创建小型模板设备树"></a>创建小型模板设备树</h3><p>以 I.MX6ULL 这个 SOC 为例，我们需要在设备树里面描述的内容如下：<br>①、 I.MX6ULL 这个 Cortex-A7 架构的 32 位 CPU。<br>②、 I.MX6ULL 内部 ocram，起始地址 0x00900000，大小为 128KB(0x20000)。<br>③、 I.MX6ULL 内部 aips1 域下的 ecspi1 外设控制器，寄存器起始地址为 0x02008000，大小为 0x4000。<br>④、 I.MX6ULL 内部 aips2 域下的 usbotg1 外设控制器，寄存器起始地址为 0x02184000，大小为 0x4000。<br>⑤、 I.MX6ULL 内部 aips3 域下的 rngb 外设控制器，寄存器起始地址为 0x02284000，大小为 0x4000。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-09%20151328.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">compatible = <span class="string">&quot;fsl, imx6ull-alientek-evk&quot;</span>, <span class="string">&quot;fsl, imx6ull&quot;</span>;</span><br><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;<span class="comment">//基地址、片选号等绝对起始地址所占字长</span></span></span><br><span class="line">      <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;<span class="comment">//长度所占字长</span></span></span><br><span class="line">    cpu0 : cpu@<span class="number">0</span>&#123;</span><br><span class="line">      compatible = <span class="string">&quot;arm ,cortex-a7&quot;</span>;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  soc &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">      <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">      compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">      ranges;</span><br><span class="line">      ocram: sram@<span class="number">00900000</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;fsl, lpm-sram&quot;</span>;</span><br><span class="line">      reg = &lt;<span class="number">0x00900000</span> <span class="number">0x20000</span>&gt;;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      apis1: aips-bus@<span class="number">02000000</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;fsl, aip-bus&quot;</span>, <span class="string">&quot;simble-bus&quot;</span>;</span><br><span class="line">        <span class="meta">#address-cells  = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        reg = &lt;<span class="number">0x2000000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line">        ranges;</span><br><span class="line">      </span><br><span class="line">        ecspi1: ecspi@<span class="number">02008000</span> &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">          <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">          compatible = <span class="string">&quot;fsl, imx6ul-ecspi&quot;</span>, <span class="string">&quot;fsl, imx5-ecspi&quot;</span>;</span><br><span class="line">          reg = &lt;<span class="number">0x02008000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">          status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      apis2: aips-bus@<span class="number">02100000</span> &#123;</span><br><span class="line">      compatible = <span class="string">&quot;fsl, apis-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        reg = &lt;<span class="number">0x02100000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line">        ranges;</span><br><span class="line">        </span><br><span class="line">        usbotg1: usb@<span class="number">02184000</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;fsl, imx6ul-usb&quot;</span> , <span class="string">&quot;fsl, imx27-usb&quot;</span>;</span><br><span class="line">          reg = &lt;<span class="number">0x02184000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">          status  = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      aips3: aips-bus@<span class="number">02200000</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">reg = &lt;<span class="number">0x02200000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line">ranges;</span><br><span class="line"></span><br><span class="line">rngb: rngb@<span class="number">02284000</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;fsl,imx6sl-rng&quot;</span>, <span class="string">&quot;fsl,imx-rng&quot;</span>, <span class="string">&quot;imxrng&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x02284000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设备树在系统中的体现"><a href="#设备树在系统中的体现" class="headerlink" title="设备树在系统中的体现"></a>设备树在系统中的体现</h3><p>Linux 内核启动的时候会解析设备树中各个节点的信息，并且在根文件系统的&#x2F;proc&#x2F;devicetree 目录下根据节点名字创建不同文件夹， 可以使用cat命令来查看model和compatible文件信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd proc/devicetree</span><br><span class="line">cat model</span><br><span class="line">cat compatible</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;device-tree 目录就是设备树在根文件系统中的体现，同样是按照树形结构组织的，进入&#x2F;proc&#x2F;device-tree&#x2F;soc 目录中就可以看到 soc 节点的所有子节点 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd soc</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><h3 id="Linux内核解析DTB文件"><a href="#Linux内核解析DTB文件" class="headerlink" title="Linux内核解析DTB文件"></a>Linux内核解析DTB文件</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-09%20154941.png"></p><h3 id="如何添加节点"><a href="#如何添加节点" class="headerlink" title="如何添加节点"></a>如何添加节点</h3><p>可以查看Linux的源码下的&#x2F;Documentation&#x2F;devicetree&#x2F;bindings，添加哪个就看哪个文件。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-09%20155142.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新字符设备驱动开发</title>
      <link href="/2023/04/06/2023-4-7-%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/04/06/2023-4-7-%E6%96%B0%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h3><p>Linux的设备管理是和文件系统紧密结合的，各种设备都以文件的形式存放在&#x2F;dev目录下，称为设备文件。应用程序可以打开、关闭和读写这些设备文件，完成对设备的操作，就像操作普通的数据文件一样。为了管理这些设备，系统为设备编了号，每个设备号又分为主设备号和次设备号。<strong>主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。</strong>对于常用设备，Linux有约定俗成的编号，如硬盘的主设备号是3。</p><p>一个字符设备或者块设备都有一个主设备号和次设备号。主设备号和次设备号统称为设备号。主设备号用来表示一个特定的驱动程序。次设备号用来表示使用该驱动程序的各设备。例如一个嵌入式系统，有两个LED指示灯，LED灯需要独立的打开或者关闭。那么，可以写一个LED灯的字符设备驱动程序，可以将其主设备号注册成5号设备，次设备号分别为1和2。这里，次设备号就分别表示两个LED灯。</p><p> 函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysmacros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line">MKDEV(<span class="type">int</span> major,<span class="type">int</span> minor) <span class="comment">//major为主设备号 minor为次设备号。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(major,minor) (((major) &lt;&lt; MINORBITS) | (minor))。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">major</span><span class="params">(<span class="type">dev_t</span> dev)</span>;<span class="comment">//获取主设备号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">minor</span><span class="params">(<span class="type">dev_t</span> dev)</span>;<span class="comment">//获取次设备号</span></span><br></pre></td></tr></table></figure><p>在程序中用宏MAJOR(dev_t  dev)可以解析出主设备号，用宏MINOR(dev_t dev)可以解析出次设备号</p><h4 id="申请设备号"><a href="#申请设备号" class="headerlink" title="申请设备号"></a>申请设备号</h4><p>动态申请设备号，没有指定设备号用以下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure><p>dev :alloc_chrdev_region函数向内核申请下来的设备号</p><p>baseminor :次设备号的起始</p><p>count: 申请次设备号的个数</p><p>name :执行 cat &#x2F;proc&#x2F;devices显示的名称</p><p>静态申请设备号，给定了设备的主设备号和次设备号就使用如下所示函数来注册设备号即可： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure><p>from:起始设备号</p><p>count：数量设备</p><p>name：设备名字</p><p>注 销 字 符 设 备 之 后 要 释 放 掉 设 备 号 ， 不 管 是 通 过 alloc_chrdev_region 函 数 还 是register_chrdev_region 函数申请的设备号，统一使用如下释放函数： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count)</span></span><br></pre></td></tr></table></figure><p>新字符设备驱动下，设备号分配如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> major; <span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="type">int</span> minor; <span class="comment">/* 次设备号 */</span></span><br><span class="line"><span class="type">dev_t</span> devid; <span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="keyword">if</span> (major) </span><br><span class="line">&#123; <span class="comment">/* 定义了主设备号 */</span></span><br><span class="line">  devid = MKDEV(major, <span class="number">0</span>); <span class="comment">/* 大部分驱动次设备号都选择 0*/</span></span><br><span class="line">register_chrdev_region(devid, <span class="number">1</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">alloc_chrdev_region(&amp;devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">/* 申请设备号 */</span></span><br><span class="line">major = MAJOR(devid); <span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">minor = MINOR(devid); <span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符设备结构"><a href="#字符设备结构" class="headerlink" title="字符设备结构"></a>字符设备结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span><span class="comment">//是一个嵌入在该结构中的内核对象。它用于该数据结构的一般管理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">//owner指向提供驱动程序的模块</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span><span class="comment">//ops是一组文件操作，实现了与硬件通信的具体操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">//list用来实现一个链表，其中包含所有表示该设备的设备特殊文件的inode</span></span><br><span class="line"><span class="type">dev_t</span> dev;<span class="comment">//dev指定了设备号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;<span class="comment">//表示与该设备关联的从设备的数目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>cdev两种定义初始化方式：<a href="https://blog.csdn.net/daocaokafei/article/details/119720422"> Linux驱动|cdev_init、cdev_alloc区别_一口Linux的博客-CSDN博客</a></p><p><strong>静态初始化：cdev_init函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span> </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">my_cdev</span>;</span></span><br><span class="line">cdev_init(&amp;my_cdev, &amp;fops);</span><br><span class="line">my_cdev.owner = THIS_MODULE;</span><br><span class="line">my_cdev.ops = &amp;fops;</span><br></pre></td></tr></table></figure><p><strong>动态初始化：cdev_alloc函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">my_cdev</span> =</span> cdev_alloc();</span><br><span class="line">my_cdev-&gt;ops = &amp;fops;</span><br><span class="line">my_cdev-&gt;owner = THIS_MODULE;</span><br></pre></td></tr></table></figure><p>将cdev添加到系统中去 <strong>cdev_add函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">testcdev</span>;</span></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">test_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line"> <span class="comment">/* 其他具体的初始项 */</span></span><br><span class="line">&#125;;</span><br><span class="line">testcdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;testcdev, &amp;test_fops); <span class="comment">/* 初始化 cdev 结构体变量 */</span></span><br><span class="line">cdev_add(&amp;testcdev, devid, <span class="number">1</span>); <span class="comment">/* 添加字符设备 */</span></span><br></pre></td></tr></table></figure><p><strong>cdev_del 函数</strong> </p><p>卸载驱动的时候一定要使用 cdev_del 函数从 Linux 内核中删除相应的字符设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span></span><br></pre></td></tr></table></figure><p>参数 p 就是要删除的字符设备。如果要删除字符设备，参考如下代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdev_del(&amp;testcdev); <span class="comment">/* 删除 cdev */</span></span><br></pre></td></tr></table></figure><p>cdev_del 和 unregister_chrdev_region 这两个函数合起来的功能相当于 unregister_chrdev 函数。 </p><h3 id="自动创建设备节点"><a href="#自动创建设备节点" class="headerlink" title="自动创建设备节点"></a>自动创建设备节点</h3><p>早期的Linux内核（版本2.4之前）并没有实现一个统一的设备模型，设备节点的创建一般是mknod命令手动创建或利用devfs文件系统创建。早期的Linux发行版一般会采用手动创建的方式预先把通常用到的节点都创建出来，而嵌入式系统则会采用devfs的方式。起初Linux2.6 内核还支持devfs，但从2.6.18开始，内核完全移除了devfs系统而采用的udev的方式动态的创建设备节点。因此，新的Linux发行版都采用udev的方式管理设备节点文件。<br>class可以自动创建设备节点，不需要udev，而udev自动创建节点需要用到class。</p><h4 id="创建和删除类"><a href="#创建和删除类" class="headerlink" title="创建和删除类"></a>创建和删除类</h4><p>自动创建设备节点的工作是在驱动程序的入口函数中完成的，一般在 cdev_add 函数后面添加自动创建设备节点相关代码。首先要创建一个 class 类， class 是个结构体，定义在文件include&#x2F;linux&#x2F;device.h 里面。 class_create 是类创建函数， class_create 是个宏定义。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> class_create(owner, name) \</span></span><br><span class="line"><span class="meta">(&#123; \</span></span><br><span class="line"><span class="meta">static struct lock_class_key __key; \</span></span><br><span class="line"><span class="meta">__class_create(owner, name, &amp;__key); \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *__<span class="title">class_create</span>(<span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>,<span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>)</span></span><br></pre></td></tr></table></figure><p>根据上述代码，将宏 class_create 展开以后内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class *<span class="title function_">class_create</span> <span class="params">(<span class="keyword">struct</span> module *owner, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure><p>class_create 一共有两个参数，参数 owner 一般为 THIS_MODULE，参数 name 是类名字。<br>返回值是个指向结构体 class 的指针，也就是创建的类。<br>卸载驱动程序的时候需要删除掉类，类删除函数为 class_destroy，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">class_destroy</span><span class="params">(<span class="keyword">struct</span> class *cls)</span>;</span><br></pre></td></tr></table></figure><p>参数 cls 就是要删除的类。 </p><h4 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h4><p>使用 device_create 函数在类下面创建设备， device_create 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="keyword">struct</span> class *class,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> device *parent,</span></span><br><span class="line"><span class="params">                                <span class="type">dev_t</span> devt,</span></span><br><span class="line"><span class="params">                                <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br></pre></td></tr></table></figure><p>device_create 是个可变参数函数，参数 class 就是设备要创建哪个类下面；参数 parent 是父设备，一般为 NULL，也就是没有父设备；参数 devt 是设备号；参数 drvdata 是设备可能会使用的一些数据，一般为 NULL；参数 fmt 是设备名字，如果设置 fmt&#x3D;xxx 的话，就会生成&#x2F;dev&#x2F;xxx这个设备文件。返回值就是创建好的设备。<br>同样的，卸载驱动的时候需要删除掉创建的设备，设备删除函数为 device_destroy，函数原型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">device_destroy</span><span class="params">(<span class="keyword">struct</span> class *class, <span class="type">dev_t</span> devt)</span></span><br></pre></td></tr></table></figure><p>参数 class 是要删除的设备所处的类，参数 devt 是要删除的设备号。</p><h3 id="设置文件私有数据"><a href="#设置文件私有数据" class="headerlink" title="设置文件私有数据"></a>设置文件私有数据</h3><p>每个硬件设备都有一些属性，比如主设备号(dev_t)，类(class)、设备(device)、开关状态(state)等等，在编写驱动的时候你可以将这些属性全部写成变量的形式 ，一般以设备的所有属性来作为一个结构体。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid; <span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span> <span class="comment">/* cdev */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span> <span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">/* 设备 */</span></span><br><span class="line"><span class="type">int</span> major; <span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="type">int</span> minor; <span class="comment">/* 次设备号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_dev</span> <span class="title">testdev</span>;</span></span><br><span class="line"><span class="comment">/* open 函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;testdev; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 open 函数里面设置好私有数据以后，在 write、 read、 close 等函数中直接读取 private_data即可得到设备结构体。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-07%20100106.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>NEWCHRLED_CNT1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>NEWCHRLED_NAME<span class="string">&quot;newchrled&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_MAJOR200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>LED_NAME<span class="string">&quot;led&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>CCM_CCGR1_BASE(0X020C406C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_DR_BASE(0X0209C000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_GDIR_BASE(0X0209C004)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> on1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>off0</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"><span class="comment">//设备属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newchrled_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span><span class="title">cdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="type">int</span> major;</span><br><span class="line"><span class="type">int</span> minor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newchrled_dev</span> <span class="title">newchrled</span>;</span><span class="comment">//led 设备</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 num;</span><br><span class="line"><span class="keyword">if</span>(sta == on)</span><br><span class="line">&#123;</span><br><span class="line">num =readl(GPIO1_DR);</span><br><span class="line">num &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( num, GPIO1_DR);</span><br><span class="line">printk(<span class="string">&quot;on\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sta == off)</span><br><span class="line">&#123;</span><br><span class="line">num = readl(GPIO1_DR);</span><br><span class="line">num |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( num, GPIO1_DR);</span><br><span class="line">printk(<span class="string">&quot;off\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_dev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;newchrled;<span class="comment">//设置私有数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_dev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_dev_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_dev_write</span><span class="params">(<span class="keyword">struct</span> file *filp,<span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state ;</span><br><span class="line"></span><br><span class="line">val = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(val &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kernl write failed \r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">state = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(state == on)</span><br><span class="line">led_switch(on);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state == off)</span><br><span class="line">led_switch(off);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_dev_open,</span><br><span class="line">.read = led_dev_read,</span><br><span class="line">.write = led_dev_write,</span><br><span class="line">.release = led_dev_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//int value = 0;</span></span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line">CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="number">4</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="number">4</span>); </span><br><span class="line">GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">val = readl(CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);<span class="comment">//CCM_CCGR1的第27和26位控制GPIO1 clock的使能</span></span><br><span class="line">val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">writel(val, CCM_CCGR1);</span><br><span class="line"><span class="comment">//GPIO复位</span></span><br><span class="line">writel(<span class="number">5</span>,SW_MUX_GPIO1_IO03);</span><br><span class="line"><span class="comment">//配置电器属性 </span></span><br><span class="line">writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line"><span class="comment">//配置输出模式</span></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_GDIR);</span><br><span class="line">    <span class="comment">//默认关闭led</span></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( val , GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册设备驱动</span></span><br><span class="line"><span class="keyword">if</span>(newchrled.major)</span><br><span class="line">&#123;</span><br><span class="line">newchrled.devid = MKDEV(newchrled.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(newchrled.devid, <span class="number">1</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">alloc_chrdev_region(&amp;newchrled.devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">newchrled.major = MAJOR(newchrled.devid);</span><br><span class="line">newchrled.minor = MINOR(newchrled.devid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">cdev_init(&amp;newchrled.cdev, &amp;led_fops);</span><br><span class="line">newchrled.cdev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加到系统中</span></span><br><span class="line">cdev_add(&amp;newchrled.cdev, newchrled.devid, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//创建类</span></span><br><span class="line">newchrled.class = class_create(THIS_MODULE , <span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(newchrled.class))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建设备</span></span><br><span class="line">newchrled.device = device_create(newchrled.class, <span class="literal">NULL</span>, newchrled.devid, <span class="literal">NULL</span>, <span class="string">&quot;led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(IS_ERR(newchrled.device))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">iounmap(CCM_CCGR1);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line"><span class="comment">//注销led设备</span></span><br><span class="line">cdev_del(&amp;newchrled.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">unregister_chrdev_region(newchrled.devid, NEWCHRLED_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">device_destroy(newchrled.class, newchrled.devid);</span><br><span class="line">class_destroy(newchrled.class);</span><br><span class="line">printk(<span class="string">&quot;led exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LED驱动开发</title>
      <link href="/2023/04/04/2023-4-4-LED%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/04/04/2023-4-4-LED%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><p>MMU(Memory Manage Unit)为内存管理单元，Linux内核2.6以前必须要有MMU，之后支持无MMU的处理器。MMU的功能有：</p><p>①完成虚拟空间到物理空间的映射。②内存保护，设置存储器的访问权限，设置虚拟存储空间的缓冲特性。Linux 内核启动的时候会初始化 MMU，设置好内存映射，设置好以后 CPU 访问的都是虚拟 地 址 。 比 如 I.MX6ULL 的GPIO1_IO03 引 脚 的 复 用 寄 存 器IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 的地址为 0X020E0068。如果没有开启MMU 的话直接向 0X020E0068 这个寄存器地址写入数据就可以配置 GPIO1_IO03 的复用功能。现在开启了 MMU，并且设置了内存映射，因此就不能直接向 0X020E0068 这个地址写入数据了。我们必须得到 0X020E0068 这个物理地址在 Linux 系统里面对应的虚拟地址，这里就涉及到了物理内存和虚拟内存之间的转换，需要用到两个函数： ioremap 和 iounmap。 </p><h4 id="ioremap函数"><a href="#ioremap函数" class="headerlink" title="ioremap函数"></a>ioremap函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ioremap(cookie,size) __arm_ioremap((cookie), (size),MT_DEVICE)</span></span><br><span class="line"><span class="type">void</span> __iomem * __arm_ioremap(<span class="type">phys_addr_t</span> phys_addr, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> mtype)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> arch_ioremap_caller(phys_addr, size,mtype,__builtin_return_address(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>phys_addr：要映射的物理起始地址。<br>size：要映射的内存空间大小。<br>mtype： ioremap 的类型，可以选择 MT_DEVICE、MT_DEVICE_NONSHARED、MT_DEVICE_CACHED 和 MT_DEVICE_WC， ioremap 函数选择 MT_DEVICE。<br>返回值： __iomem 类型的指针，指向映射后的虚拟空间首地址。 </p><p>假如我们要获取 I.MX6ULL 的 IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 寄存器对应的虚拟地址，使用如下代码即可： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SW_MUX_GPIO1_IO03_BASE (0X020E0068)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem* SW_MUX_GPIO1_IO03;</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>宏 SW_MUX_GPIO1_IO03_BASE 是寄存器物理地址， SW_MUX_GPIO1_IO03 是映射后的虚拟地址。对于 I.MX6ULL 来说一个寄存器是 4 字节(32 位)的，因此映射的内存长度为 4。映射完成以后直接对 SW_MUX_GPIO1_IO03 进行读写操作即可。 </p><h4 id="iounmap函数"><a href="#iounmap函数" class="headerlink" title="iounmap函数"></a>iounmap函数</h4><p>卸载驱动的时候需要使用 iounmap 函数释放掉 ioremap 函数所做的映射， iounmap 函数原型如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iounmap</span> <span class="params">(<span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br></pre></td></tr></table></figure><p>iounmap 只有一个参数 addr，此参数就是要取消映射的虚拟地址空间首地址。 </p><h3 id="I-x2F-O内存访问"><a href="#I-x2F-O内存访问" class="headerlink" title="I&#x2F;O内存访问"></a>I&#x2F;O内存访问</h3><p><strong>当外部寄存器或内存映射到 IO 空间时，称为 I&#x2F;O 端口。</strong><br><strong>当外部寄存器或内存映射到内存空间时，称为 I&#x2F;O 内存。</strong> </p><p><u>但是对于 ARM 来说没有 I&#x2F;O 空间这个概念，因此 ARM 体系下只有 I&#x2F;O 内存(可以直接理解为内存)。</u> </p><h4 id="读操作函数"><a href="#读操作函数" class="headerlink" title="读操作函数"></a>读操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">readb</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">u16 <span class="title function_">readw</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line">u32 <span class="title function_">readl</span><span class="params">(<span class="type">const</span> <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br></pre></td></tr></table></figure><p>参数 addr 就是要读取写内存地址，返回值就是读取到的数据。 </p><h4 id="写操作函数"><a href="#写操作函数" class="headerlink" title="写操作函数"></a>写操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">writeb</span><span class="params">(u8 value, <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writew</span><span class="params">(u16 value, <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writel</span><span class="params">(u32 value, <span class="keyword">volatile</span> <span class="type">void</span> __iomem *addr)</span></span><br></pre></td></tr></table></figure><p>参数 value 是要写入的数值， addr 是要写入的地址。 </p><h3 id="写LED驱动程序"><a href="#写LED驱动程序" class="headerlink" title="写LED驱动程序"></a>写LED驱动程序</h3><p>首先在汇编点亮LED的程序里面使能了imx6ull的外设时钟，使能GPIO1_03,配置了IO口的属性，之后进行了初始化，DR寄存器置位点灯。</p><p>LED的驱动开发首先要查出所要用到的寄存器的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CCGR1的地址</span></span><br><span class="line">CCM_CCGR1<span class="number">20</span>C_406Ch</span><br><span class="line"><span class="comment">//GPIO1_03的地址</span></span><br><span class="line">IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03<span class="number">20</span>E_02F4h</span><br><span class="line">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03<span class="number">20</span>E_0068h</span><br><span class="line">GPIO1_DR<span class="number">209</span>_C000h</span><br><span class="line">GPIO1_GDIR<span class="number">20</span>A_0004h</span><br></pre></td></tr></table></figure><p>GPIO1_DR和GPIO1_GPIR的地址实在GPIO memory map（GPIO的地址映射）中寻找。</p><p><strong>DR（data register）</strong>，即数据寄存器，它是32位的，一个GPIO组最大只有32个IO，因此DR寄存器中的每个位都对应一个 GPIO。</p><ul><li>当GPIO被配置为<strong>输出模式</strong>后，向指定的位写入数据那么相应的IO就会输出相应的高低电平，例如，要设置GPIO5_IO03输出低电平，那么就应该设置 GPIO5.DR&#x3D;0x08。</li><li>当 GPIO被配置为<strong>输入模式</strong>后，此寄存器就保存着对应IO的电平值，每个位对对应一个GPIO，例如，当GPIO5_IO03这个引脚接地的话，那么 GPIO5.DR 的bit3就是0。</li></ul><p><strong>GDIR（GPIO direction register）</strong>，即方向寄存器，也是32位的，用来设置某个GPIO的工作方向的，即输入&#x2F;输出。</p><p>同样的，每个IO对应一个位，如果要设置GPIO为输入，就设置相应的位为0，如果要设置为输出，就设置为 1。</p><h3 id="程序以及搭建思路"><a href="#程序以及搭建思路" class="headerlink" title="程序以及搭建思路"></a>程序以及搭建思路</h3><h4 id="led驱动步骤："><a href="#led驱动步骤：" class="headerlink" title="led驱动步骤："></a>led驱动步骤：</h4><p>①、书写字符设备驱动框架，添加头文件，定义file_operations，以及相关函数框架。<br>②、添加地址宏定义创建指针，以及在入口函数中实现虚拟地址的映射，注册设备。<br>③、在出接口地址中取消虚拟地址的映射，注销设备。<br>④、在open函数中实现GPIO的使能，以及IO引脚的配置。<br>⑤、在write函数中从应用层获取数据，来根据数据来进行GPIO的输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_MAJOR200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>LED_NAME<span class="string">&quot;led&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>CCM_CCGR1_BASE(0X020C406C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_DR_BASE(0X0209C000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_GDIR_BASE(0X0209C004)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> on1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>off0</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 num;</span><br><span class="line"><span class="keyword">if</span>(sta == on)</span><br><span class="line">&#123;</span><br><span class="line">num =readl(GPIO1_DR);</span><br><span class="line">num &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( num, GPIO1_DR);</span><br><span class="line">printk(<span class="string">&quot;on\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sta == off)</span><br><span class="line">&#123;</span><br><span class="line">num = readl(GPIO1_DR);</span><br><span class="line">num |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( num, GPIO1_DR);</span><br><span class="line">printk(<span class="string">&quot;off\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_dev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_dev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_dev_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_dev_write</span><span class="params">(<span class="keyword">struct</span> file *filp,<span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> state ;</span><br><span class="line"></span><br><span class="line">val = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(val &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;kernl write failed \r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">state = databuf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(state == on)</span><br><span class="line">led_switch(on);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state == off)</span><br><span class="line">led_switch(off);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_dev_open,</span><br><span class="line">.read = led_dev_read,</span><br><span class="line">.write = led_dev_write,</span><br><span class="line">.release = led_dev_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line">CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="number">4</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="number">4</span>); </span><br><span class="line">GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="number">4</span>);    </span><br><span class="line">val = readl(CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);<span class="comment">//CCM_CCGR1的第27和26位控制GPIO1 clock的使能</span></span><br><span class="line">val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">writel(val, CCM_CCGR1);</span><br><span class="line"><span class="comment">//GPIO复位</span></span><br><span class="line">writel(<span class="number">5</span>,SW_MUX_GPIO1_IO03);</span><br><span class="line"><span class="comment">//配置电器属性 </span></span><br><span class="line">writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line"><span class="comment">//配置输出模式</span></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_GDIR);</span><br><span class="line">    <span class="comment">//默认关闭led</span></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel( val , GPIO1_DR);</span><br><span class="line">value = register_chrdev(LED_MAJOR, LED_NAME, &amp;led_fops);</span><br><span class="line"><span class="keyword">if</span>(value &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;led register failed\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">iounmap(CCM_CCGR1);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line"><span class="comment">//注销led设备</span></span><br><span class="line">unregister_chrdev(LED_MAJOR, LED_NAME);</span><br><span class="line">printk(<span class="string">&quot;led exit\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="应用层程序"><a href="#应用层程序" class="headerlink" title="应用层程序"></a>应用层程序</h4><p>搭建思路：</p><p>①、获取命令行的数据<br>②、打开设备<br>③、写入指令<br>④、关闭设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  value;</span><br><span class="line">    FILE *fp == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *filename</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">    filename = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(filename, <span class="string">&quot;w+&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(<span class="string">&quot;fopen error:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功!\n&quot;</span>);</span><br><span class="line">    databuf[<span class="number">0</span>] = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">sizeof</span>(buf) &gt; fwrite(databuf, <span class="number">1</span>, <span class="keyword">sizeof</span>(databuf), fp))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fwrite error\n&quot;</span>);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据写入成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Makefile文件编写，跟之前一样。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">KERNELDIR := /home/moss/linux/imx-kernel/linux-fslc-4.9-2.0.x-imx</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line">obj-m := led.o</span><br><span class="line"></span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符设备驱动开发</title>
      <link href="/2023/04/01/2023-4-1-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/04/01/2023-4-1-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="字符设备驱动简介"><a href="#字符设备驱动简介" class="headerlink" title="字符设备驱动简介"></a>字符设备驱动简介</h3><p>字符设备是Linux驱动基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的；数据是实时传输的，没有缓存，字符设备是没有文件系统的。</p><p>绝大部分设备驱动是字符设备：LED、按键、声卡、IIC、SPI、LCD、摄像头等都是字符设备。这些设备的驱动都是字符设备驱动。</p><p>在 Linux 中一切皆为文件，驱动加载成功以后会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx” (xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。 </p><p>应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间。当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开&#x2F;dev&#x2F;led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入” 到内核空间，这样才能实现对底层驱动的操作。 </p><h3 id="驱动模块加载和卸载"><a href="#驱动模块加载和卸载" class="headerlink" title="驱动模块加载和卸载"></a>驱动模块加载和卸载</h3><p>Linux 驱动有两种运行方式，第一种就是将驱动编译进 Linux 内核中，这样当 Linux 内核启动的时候就会自动运行驱动程序。第二种就是将驱动编译成模块(Linux 下模块扩展名为.ko)，在Linux 内核启动以后使用“insmod”命令加载驱动模块。 </p><p>模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和卸载注册函数如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(xxx_init); <span class="comment">//注册模块加载函数</span></span><br><span class="line">module_exit(xxx_exit); <span class="comment">//注册模块卸载函数</span></span><br></pre></td></tr></table></figure><p>module_init 函数用来向 Linux 内核注册一个模块加载函数，参数 xxx_init 就是需要注册的具体函数，当使用“insmod”命令加载驱动的时候， xxx_init 这个函数就会被调用。 module_exit()函数用来向 Linux 内核注册一个模块卸载函数，参数 xxx_exit 就是需要注册的具体函数，当使用“rmmod”命令卸载具体驱动的时候 xxx_exit 函数就会被调用。 </p><p>编写一个chrdevbase的驱动</p><p>首先根据加载模板写出chrdevabase.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdevbase_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动字符入口函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdevbase_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">module_init(chrdevbase_init);</span><br><span class="line">module_exit(chrdevbase_exit);</span><br></pre></td></tr></table></figure><p>编写Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">KERNELDIR := /home/moss/linux/imx-kernel/linux-fslc-4.9-2.0.x-imx</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">obj-m := chrdevbase.o</span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure><p>第 1 行， KERNELDIR 表示开发板所使用的 Linux 内核源码目录，使用绝对路径，大家根据自己的实际情况填写即可。<br>第 2 行， CURRENT_PATH 表示当前路径，直接通过运行“pwd”命令来获取当前所处路径。<br>第 3 行， obj-m 表示将 chrdevbase.c 这个文件编译为 chrdevbase.ko 模块。<br>第 86行，具体的编译命令，后面的 modules 表示编译模块， -C 表示将当前的工作目录切换到指定目录中，也就是 KERNERLDIR 目录。 M 表示模块源码目录，“make modules”命令中加入 M&#x3D;dir 以后程序会自动到指定的 dir 目录中读取模块的源码并将其编译为.ko 文件。 </p><p>之后在根文件系统中使用modprobe加载模块命令来看缺失的文件，之后都创立好，将编译好的.ko文件复制到下面，之后可使用modprobe命令加载设备，或者使用rmmod卸载设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe chrdevbase.ko</span><br><span class="line">rmmod chrdevbase.ko</span><br></pre></td></tr></table></figure><p>在板子的命令段使用。</p><h3 id="字符设备注册与注销"><a href="#字符设备注册与注销" class="headerlink" title="字符设备注册与注销"></a>字符设备注册与注销</h3><p>对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备。字符设备的注册和注销函数原型如下所示: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name,<span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">unregister_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure><p>major： 主设备号， Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分，关于设备号后面会详细讲解。<br>name：设备名字，指向一串字符串。查看设备中的设备号可以使用“<strong>cat &#x2F;proc&#x2F;devices</strong> ”来查看。<br>fops： 结构体 file_operations 类型指针，指向设备的操作函数集合变量。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">                                        <span class="comment">/*file_operations结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">int</span> (*mremap)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line"><span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, unsignedlong)</span>;</span><br><span class="line"><span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line"><span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,<span class="type">loff_t</span> len);</span><br><span class="line"><span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line"><span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="字符设备驱动框架"><a href="#字符设备驱动框架" class="headerlink" title="字符设备驱动框架"></a>字符设备驱动框架</h3><p>设备的具体操作函数就是通过file_operations结构体来进行设置，首先初始化之前要进行分析需求，也就是对chrtest这个设备进行哪些操作，才知道要实现哪些操作函数。此设置是假设对字符设备进行打开和关闭操作（基本设备都要打开关闭），对字符设备进行读写（假设  这个设备控制着一段缓冲区(内存)，应用程序需要通过 read 和 write 这两个函数对 chrtest 的缓冲区进行读写操作 ）。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-03%20172521.png"></p><p>所以进行修改chrdevbase.c文件内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrtest_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrtest_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrtest_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf , <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrtest_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">test_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">    .open = chrtest_open,</span><br><span class="line">    .read = chrtest_read,</span><br><span class="line">    .write = chrtest_write,</span><br><span class="line">    .release = chrtest_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdevbase_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动字符入口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    value = register_chrdev(<span class="number">200</span>, <span class="string">&quot;chrtest&quot;</span>, &amp;test_fops);</span><br><span class="line">    <span class="keyword">if</span>(value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    printk(<span class="string">&quot;注册失败\n&quot;</span>);<span class="comment">//内核空间的printf</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdevbase_exit</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//驱动出口函数</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev(<span class="number">200</span>, <span class="string">&quot;chrtest&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(chrdevbase_init);</span><br><span class="line">module_exit(chrdevbase_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//防止加载模块警告</span></span><br></pre></td></tr></table></figure><h3 id="关于设备号码"><a href="#关于设备号码" class="headerlink" title="关于设备号码"></a>关于设备号码</h3><h4 id="静态分配设备号"><a href="#静态分配设备号" class="headerlink" title="静态分配设备号"></a>静态分配设备号</h4><p>注册字符设备的时候需要给设备指定一个设备号，这个设备号可以是驱动开发者静态的指定一个设备号，比如选择 200 这个主设备号。有一些常用的设备号已经被 Linux 内核开发者给分配掉了，具体分配的内容可以查看文档 Documentation&#x2F;devices.txt。并不是说内核开发者已经分配掉的主设备号我们就不能用了，具体能不能用还得看我们的硬件平台运行过程中有没有使用这个主设备号，。</p><h4 id="动态分配设备号"><a href="#动态分配设备号" class="headerlink" title="动态分配设备号"></a>动态分配设备号</h4><p>静态分配设备号需要我们检查当前系统中所有被使用了的设备号，然后挑选一个没有使用的。而且静态分配设备号很容易带来冲突问题， Linux 社区推荐使用动态分配设备号，在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。卸载驱动的时候释放掉这个设备号即可， </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span><span class="comment">//申请函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count)</span><span class="comment">//释放函数</span></span><br></pre></td></tr></table></figure><p>申请设备函数有 4 个参数：<br>dev：保存申请到的设备号。<br>baseminor： 次设备号起始地址， alloc_chrdev_region 可以申请一段连续的多个设备号，这些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递增。一般 baseminor 为 0，也就是说次设备号从 0 开始。<br>count： 要申请的设备号数量。<br>name：设备名字。<br>释放函数有两个参数：<br>from：要释放的设备号。<br>count： 表示从 from 开始，要释放的设备号数量。 </p><h3 id="实现例程"><a href="#实现例程" class="headerlink" title="实现例程"></a>实现例程</h3><p>应用程序调用 open 函数打开 chrdevbase 这个设备，打开以后可以使用 write 函数向chrdevbase 的写缓冲区 writebuf 中写入数据(不超过 100 个字节)，也可以使用 read 函数读取读缓冲区 readbuf 中的数据操作，操作完成以后应用程序使用 close 函数关闭 chrdevbase 设备。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="type">static</span><span class="type">char</span> readbuf[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span><span class="type">char</span>writebuf[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span><span class="type">char</span>kerneldata[] = &#123;<span class="string">&quot;kernel data&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;open devices\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;release devices\n&quot;</span>)；</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//向用户空间发送信息</span></span><br><span class="line">    <span class="built_in">memcpy</span>(readbuf, kerneldata, <span class="keyword">sizeof</span>(kerneldata));<span class="comment">//将kerneldata的sizeof个数据复制readbuf</span></span><br><span class="line">value = copy_to_user(buf, readbuf, cnt);</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="number">0</span>)</span><br><span class="line">        printk(<span class="string">&quot;kernel senddata ok\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(<span class="string">&quot;kernel senddata failed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdev_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retvalue = <span class="number">0</span>;</span><br><span class="line">    retvalue  = copy_from_user(writebuf, buf, cnt);</span><br><span class="line">    <span class="keyword">if</span>(retvalue == <span class="number">0</span>)</span><br><span class="line">        printk(<span class="string">&quot;kernel recedata :%s ok\n&quot;</span>, writebuf);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(<span class="string">&quot;kernel recedata failed\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">chrdevbase_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = chrdev_open,</span><br><span class="line">    .read = chrdev_read,</span><br><span class="line">    .write = chrdev_write,</span><br><span class="line">    .release = chrdev_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdevbase_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line">retvalue = register_chrdev(<span class="number">200</span>, <span class="string">&quot;chrdevbase&quot;</span>, &amp;chrdevbase_fops);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)&#123;</span><br><span class="line">printk(<span class="string">&quot;chrdevbase driver register failed\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdevbase_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//卸载驱动</span></span><br><span class="line">    unregister_chrdev(<span class="number">200</span>, <span class="string">&quot;chrdevbase&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">module_init(chrdevbase_init);</span><br><span class="line">module_exit(chrdevbase_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="copy-to-user-x2F-copy-from-user函数解析"><a href="#copy-to-user-x2F-copy-from-user函数解析" class="headerlink" title="copy_to_user&#x2F;copy_from_user函数解析"></a>copy_to_user&#x2F;copy_from_user函数解析</h4><p>copy_to_user和copy_from_user是在进行驱动相关程序设计的时候，要经常遇到的函数。<strong>由于内核空间与用户空间的内存不能直接互访，因此借助函数copy_to_user()完成内核空间到用户空间的复制，函数copy_from_user()完成用户空间到内核空间的复制。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_to_user</span> <span class="params">(<span class="type">void</span> __user * to, <span class="type">const</span> <span class="type">void</span> * from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line">to目标地址，这个地址是用户空间的地址</span><br><span class="line">from源地址  ，这个地址是内核空间的地址</span><br><span class="line">n要拷贝数据的字节数</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_from_user</span> <span class="params">(<span class="type">void</span> * to, <span class="type">const</span> <span class="type">void</span> __user * from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line">to目标地址，这个地址是用户空间的地址</span><br><span class="line">from源地址  ，这个地址是内核空间的地址</span><br><span class="line">n要拷贝数据的字节数</span><br></pre></td></tr></table></figure><h3 id="编写测试APP"><a href="#编写测试APP" class="headerlink" title="编写测试APP"></a>编写测试APP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> usrdata[] = &#123;<span class="string">&quot;usr data!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : main 主程序</span></span><br><span class="line"><span class="comment"> * @param - argc : argv 数组元素个数</span></span><br><span class="line"><span class="comment"> * @param - argv : 具体参数</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd, retvalue;</span><br><span class="line"><span class="type">char</span> *filename;</span><br><span class="line"><span class="type">char</span> readbuf[<span class="number">100</span>], writebuf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filename = argv[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* 打开驱动文件 */</span></span><br><span class="line">fd = open(filename, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(atoi(argv[<span class="number">2</span>]) == <span class="number">1</span>)&#123; <span class="comment">/* 从驱动文件读取数据 */</span></span><br><span class="line">retvalue = read(fd, readbuf, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read file %s failed!\r\n&quot;</span>, filename);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="comment">/* 读取成功，打印出读取成功的数据 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read data:%s\r\n&quot;</span>,readbuf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(atoi(argv[<span class="number">2</span>]) == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">/* 向设备驱动写数据 */</span></span><br><span class="line"><span class="built_in">memcpy</span>(writebuf, usrdata, <span class="keyword">sizeof</span>(usrdata));</span><br><span class="line">retvalue = write(fd, writebuf, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;write file %s failed!\r\n&quot;</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/* 关闭设备 */</span></span><br><span class="line">    retvalue = close(fd);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t close file %s\r\n&quot;</span>, filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用交叉编译器进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc chrdevbaseApp.c -o chrdevbaseApp</span><br></pre></td></tr></table></figure><p>把chrdevbaseApp也复制到那个文件夹中。</p><p><strong>创建设备设备节点</strong></p><p>驱动加载成功需要在&#x2F;dev 目录下创建一个与之对应的设备节点文件，应用程序就是通过操这个设备节点文件来完成对具体设备的操作。输入如下命令创建&#x2F;dev&#x2F;chrdevbase 这个设备节点文件 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mknod /dev/chrdevbase c 200 0</span><br><span class="line">ls /dev/chrdevbase -l</span><br><span class="line">/chrdevbaseApp /dev/chrdevbase 1 //进行测试</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驱动开发流程</title>
      <link href="/2023/03/31/2023-3-31-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/03/31/2023-3-31-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="嵌入式linux驱动开发流程"><a href="#嵌入式linux驱动开发流程" class="headerlink" title="嵌入式linux驱动开发流程"></a>嵌入式linux驱动开发流程</h3><p>嵌入式系统中，操作系统是通过各种驱动程序来驾驭硬件设备的。设备驱动程序是操作系统内核和硬件设备之间的接口，它为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件，可以像操作普通文件一样对硬件设备进行操作。设备驱动程序是内核的一部分，完成以下功能：<br>◇ 驱动程序的注册和注销。<br>◇ 设备的打开和释放。<br>◇ 设备的读写操作。<br>◇ 设备的控制操作。<br>◇ 设备的中断和轮询处理。</p><p>在 Linux 中一切皆为文件，驱动加载成功以后会在“&#x2F;dev”目录下生成一个相应的文件，应用程序通过对这个名为“&#x2F;dev&#x2F;xxx” (xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。 </p><p><strong>应用程序对驱动程序的调用为：应用程序-&gt;库-&gt;内核-&gt;驱动程序-&gt;硬件</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/e588edd3300840379caa5357296b7c58.png"></p><p>Linux主要将设备分为三类：字符设备、块设备和网络设备。字符设备是指发送和接收数据以字符的形式进行，没有缓冲区的设备；块设备是指发送和接收数据以整个数据缓冲区的形式进行的设备；网络设备是指网络设备访问的BSD socket 接口。</p><p><strong>基于操作系统的驱动就是在无操作系统下的硬件接口函数加上操作系统外套</strong></p><p>实现一个嵌入式Linux设备驱动程序的大致流程如下:<br>(l)查看原理图，理解设备的工作原理。<br>(2)定义主设备号。设备由一个主设备号和一个次设备号来标识。主设备号唯一标识了设备类型，即设备驱动程序类型，它是块设备表或字符设备表中设备表项的索引。次设备号仅由设备驱动程序解释，区分被一个设备驱动控制下的某个独立的设备。<br>(3)实现初始化函数。在驱动程序中实现驱动的注册和卸载。<br>(4)设计所要实现的文件操作，定义file–operations结构。<br>(5)实现所需的文件操作调用，如read，write等。<br>(6)实现中断服务，并用request–irq向内核注册，中断并不是每个设备驱动所必需的。<br>(7)编译该驱动程序到内核中，或者用insmod命令加载模块。<br>(8)测试该设备，编写应用程序，对驱动程序进行测试。</p><h4 id="驱动开发套路"><a href="#驱动开发套路" class="headerlink" title="驱动开发套路"></a>驱动开发套路</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/20200227155905995.png"></p><h3 id="linux内存管理"><a href="#linux内存管理" class="headerlink" title="linux内存管理"></a>linux内存管理</h3><p><a href="https://blog.csdn.net/yusiguyuan/article/details/12045255?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168023029416800186520924%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168023029416800186520924&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-12045255-null-null.142%5Ev80%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4&spm=1018.2226.3001.4187">linux内存管理–用户空间和内核空间_鱼思故渊的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根文件系统构建</title>
      <link href="/2023/03/30/2023-3-30-%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/03/30/2023-3-30-%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="根文件系统定义"><a href="#根文件系统定义" class="headerlink" title="根文件系统定义"></a>根文件系统定义</h3><p>根文件系统首先是内核启动时所 mount(挂载)的第一个文件系统，内核代码映像文件保存在根文件系统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。 </p><p>根文件系统是 Linux 内核启动以后挂载(mount)的第一个文件系统，然后从根文件系统中读取初始化脚本，比如 rcS， inittab 等。根文件系统和 Linux 内核是分开的，单独的 Linux 内核是没法正常工作的，必须要搭配根文件系统。 </p><h4 id="常用子目录"><a href="#常用子目录" class="headerlink" title="常用子目录"></a>常用子目录</h4><table><thead><tr><th align="left">目录</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">&#x2F;bin</td><td align="center">存放可执行文件一般都是命令</td></tr><tr><td align="left">&#x2F;dev</td><td align="center">设备文件</td></tr><tr><td align="left">&#x2F;etc</td><td align="center">各种配置文件</td></tr><tr><td align="left">&#x2F;lib</td><td align="center">linux所需的必备库文件（共享库）</td></tr><tr><td align="left">&#x2F;mnt</td><td align="center">临时挂载目录（一般为空）</td></tr><tr><td align="left">&#x2F;proc</td><td align="center">作为 proc 文件系统的挂载点（文件是临时存在的，一般存储系统运行信息文件）</td></tr><tr><td align="left">&#x2F;usr</td><td align="center">Unix 操作系统软件资源目录</td></tr><tr><td align="left">&#x2F;var</td><td align="center">存放一些可以改变的数据</td></tr><tr><td align="left">&#x2F;sbin</td><td align="center">此目录页用户存放一些可执行文件</td></tr><tr><td align="left">&#x2F;sys</td><td align="center">此目录作为 sysfs 文件系统的挂载点</td></tr><tr><td align="left">&#x2F;opt</td><td align="center">可选的文件、软件存放区（用户选择放哪些）</td></tr></tbody></table><h3 id="BusyBox构建根文件系统"><a href="#BusyBox构建根文件系统" class="headerlink" title="BusyBox构建根文件系统"></a>BusyBox构建根文件系统</h3><h4 id="顶层Makefile修改"><a href="#顶层Makefile修改" class="headerlink" title="顶层Makefile修改"></a>顶层Makefile修改</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">164 CROSS_COMPILE ?= /usr/local/arm/gcc/bin/arm-linux-gnueabihf-</span><br><span class="line">......</span><br><span class="line">190 ARCH ?= arm</span><br></pre></td></tr></table></figure><h4 id="修改busybox支持中文字符"><a href="#修改busybox支持中文字符" class="headerlink" title="修改busybox支持中文字符"></a>修改busybox支持中文字符</h4><p>打开&#x2F;libbb&#x2F;printable_string.c </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> <span class="type">const</span> <span class="type">char</span>* FAST_FUNC <span class="title function_">printable_string</span><span class="params">(<span class="type">uni_stat_t</span> *stats, <span class="type">const</span> <span class="type">char</span></span></span><br><span class="line"><span class="params">*str)</span></span><br><span class="line">13 &#123;</span><br><span class="line"><span class="number">14</span> <span class="type">char</span> *dst;</span><br><span class="line"><span class="number">15</span> <span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> s = str;</span><br><span class="line"><span class="number">18</span> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="number">30</span> <span class="keyword">if</span> (c &lt; <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">31</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="number">32</span> <span class="comment">/* 注释掉下面这个两行代码 */</span></span><br><span class="line"><span class="number">33</span> <span class="comment">/* if (c &gt;= 0x7f)</span></span><br><span class="line"><span class="comment">34 break; */</span></span><br><span class="line"><span class="number">35</span> s++;</span><br><span class="line"><span class="number">36</span> &#125;</span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">38</span> <span class="meta">#<span class="keyword">if</span> ENABLE_UNICODE_SUPPORT</span></span><br><span class="line"><span class="number">39</span> dst = unicode_conv_to_printable(stats, str);</span><br><span class="line"><span class="number">40</span> <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="number">41</span> &#123;</span><br><span class="line"><span class="number">42</span> <span class="type">char</span> *d = dst = xstrdup(str);</span><br><span class="line"><span class="number">43</span> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="number">44</span> <span class="type">unsigned</span> <span class="type">char</span> c = *d;</span><br><span class="line"><span class="number">45</span> <span class="keyword">if</span> (c == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="number">46</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="number">47</span> <span class="comment">/* 修改下面代码 */</span></span><br><span class="line"><span class="number">48</span> <span class="comment">/* if (c &lt; &#x27; &#x27; || c &gt;= 0x7f) */</span></span><br><span class="line"><span class="number">49</span> <span class="keyword">if</span>( c &lt; <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">50</span> *d = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="number">51</span> d++;</span><br><span class="line"><span class="number">52</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">59</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">60</span> <span class="keyword">return</span> auto_string(dst);</span><br><span class="line"><span class="number">61</span> &#125;</span><br></pre></td></tr></table></figure><p>接着打开文件 busybox-1.29.0&#x2F;libbb&#x2F;unicode.c </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1003</span> <span class="type">static</span> <span class="type">char</span>* FAST_FUNC <span class="title function_">unicode_conv_to_printable2</span><span class="params">(<span class="type">uni_stat_t</span> *stats, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">unsigned</span> width, <span class="type">int</span> flags)</span></span><br><span class="line">1004 &#123;</span><br><span class="line"><span class="number">1005</span> <span class="type">char</span> *dst;</span><br><span class="line"><span class="number">1006</span> <span class="type">unsigned</span> dst_len;</span><br><span class="line"><span class="number">1007</span> <span class="type">unsigned</span> uni_count;</span><br><span class="line"><span class="number">1008</span> <span class="type">unsigned</span> uni_width;</span><br><span class="line"><span class="number">1009</span></span><br><span class="line"><span class="number">1010</span> <span class="keyword">if</span> (unicode_status != UNICODE_ON) &#123;</span><br><span class="line"><span class="number">1011</span> <span class="type">char</span> *d;</span><br><span class="line"><span class="number">1012</span> <span class="keyword">if</span> (flags &amp; UNI_FLAG_PAD) &#123;</span><br><span class="line"><span class="number">1013</span> d = dst = xmalloc(width + <span class="number">1</span>);</span><br><span class="line">......</span><br><span class="line"><span class="number">1022</span> <span class="comment">/* 修改下面一行代码 */</span></span><br><span class="line"><span class="number">1023</span> <span class="comment">/* *d++ = (c &gt;= &#x27; &#x27; &amp;&amp; c &lt; 0x7f) ? c : &#x27;?&#x27;; */</span></span><br><span class="line"><span class="number">1024</span> *d++ = (c &gt;= <span class="string">&#x27; &#x27;</span>) ? c : <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="number">1025</span> src++;</span><br><span class="line"><span class="number">1026</span> &#125;</span><br><span class="line"><span class="number">1027</span> *d = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="number">1028</span> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1029</span> d = dst = xstrndup(src, width);</span><br><span class="line"><span class="number">1030</span> <span class="keyword">while</span> (*d) &#123;</span><br><span class="line"><span class="number">1031</span> <span class="type">unsigned</span> <span class="type">char</span> c = *d;</span><br><span class="line"><span class="number">1032</span> <span class="comment">/* 修改下面一行代码 */</span></span><br><span class="line"><span class="number">1033</span> <span class="comment">/* if (c &lt; &#x27; &#x27; || c &gt;= 0x7f) */</span></span><br><span class="line"><span class="number">1034</span> <span class="keyword">if</span>(c &lt; <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">1035</span> *d = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"><span class="number">1036</span> d++;</span><br><span class="line"><span class="number">1037</span> &#125;</span><br><span class="line"><span class="number">1038</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">1044</span> <span class="keyword">return</span> dst;</span><br><span class="line"><span class="number">1045</span> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="number">1047</span></span><br><span class="line"><span class="number">1048</span> <span class="keyword">return</span> dst;</span><br><span class="line"><span class="number">1049</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="配置busybox"><a href="#配置busybox" class="headerlink" title="配置busybox"></a>配置busybox</h4><p>要先对 busybox 进行默认的配置，有以下几种配置选项： </p><p>①defconfig，缺省配置，也就是默认配置选项。<br>②allyesconfig，全选配置，也就是选中 busybox 的所有功能。<br>③allnoconfig，最小配置。 </p><p>也可以图形化配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>配置路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line">-&gt; Settings</span><br><span class="line">-&gt; Build static binary (no shared libs)</span><br></pre></td></tr></table></figure><p><strong>这个选项不选。</strong></p><p>选项“Build static binary (no shared libs)”用来决定是静态编译 busybox 还是动态编译，静态编译的话就不需要库文件，但是编译出来的库会很大。动态编译的话要求根文件系统中有库文件，但是编译出来的 busybox 会小很多。不能采用静态编译！因为采用静态编译的话 DNS 会出问题！无法进行域名解析 。</p><p>继续配置，选上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line">-&gt; Settings</span><br><span class="line">-&gt; vi-style line editing commands</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line">-&gt; Linux Module Utilities</span><br><span class="line">-&gt; Simplified modutils</span><br></pre></td></tr></table></figure><p>不选simplified modutils</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line">-&gt; Linux System Utilities</span><br><span class="line">-&gt; mdev (16 kb) //确保下面的全部选中，默认都是选中的</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-28%20212143.png"></p><p>最后使能busybox的unicode编码支持中文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line">-&gt; Settings</span><br><span class="line">-&gt; Support Unicode //选中</span><br><span class="line">-&gt; Check $LC_ALL, $LC_CTYPE and $LANG environment variables //选中</span><br></pre></td></tr></table></figure><h4 id="编译busybox"><a href="#编译busybox" class="headerlink" title="编译busybox"></a>编译busybox</h4><p>要将编译结果存放到前面创建的 rootfs 目录中 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install CONFIG_PREFIX=/home/moss/linux/nfs/rootfs</span><br></pre></td></tr></table></figure><p>busybox 的工作就完成了，但是此时的根文件系统还不能使用，还需要一些其他的文件，我们继续来完善 rootfs。 </p><h4 id="向根文件系统添加-lib-库"><a href="#向根文件系统添加-lib-库" class="headerlink" title="向根文件系统添加 lib 库"></a>向根文件系统添加 lib 库</h4><p>Linux 中的应用程序一般都是需要动态库的 。所以在rootfs中创建一个lib文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir lib</span><br></pre></td></tr></table></figure><p>库文件从哪里来呢？ lib 库文件从交叉编译器中获取，前面我们搭建交叉编译环境的时候将交叉编译器存放到了“&#x2F;usr&#x2F;local&#x2F;arm&#x2F;”目录中。 </p><p>进入对应路径的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd/usr/local/arm/gcc/arm-linux-gnueabihf/libc/lib</span><br></pre></td></tr></table></figure><p>此目录下有很多的* <strong>so</strong>*(*<em>是通配符)和.a 文件，这些就是库文件，将此目录下所有的</em>so*和.a文件都拷贝到 rootfs&#x2F;lib 目录中，拷贝命令如下： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp *so* *.a /home/moss/linux/nfs/rootfs/lib/ -d</span><br></pre></td></tr></table></figure><p>后面的“-d”表示拷贝符号链接，这里有个比较特殊的库文件： ld-linux-armhf.so.3，此库文件也是个符号链接，</p><p>要把它变成本身的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm ld-linux-armhf.so.3</span><br></pre></td></tr></table></figure><p>然 后 重  进 入 到 &#x2F;usr&#x2F;local&#x2F;arm&#x2F;gcc&#x2F;armlinux-gnueabihf&#x2F;libc&#x2F;lib 目录中，重新拷贝 ld-linux-armhf.so.3，命令： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ld-linux-armhf.so.3 /home/moss/linux/nfs/rootfs/lib/</span><br></pre></td></tr></table></figure><p>继续进入如下目录中： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd/usr/local/arm/gcc/arm-linux-gnueabihf/libc/lib</span><br><span class="line">cp *so* *.a /home/moss/linux/nfs/rootfs/lib/ -d</span><br></pre></td></tr></table></figure><p><strong>向rootfs的usr&#x2F;lib目录添加库文件</strong></p><p>在 rootfs 的 usr 目录下创建一个名为 lib 的目录 ，之前arm-linux-gnueabihf&#x2F;usr&#x2F;lib的so和.a库文件复制到rootfs&#x2F;usr&#x2F;lib目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp *so* *.a /home/moss/linux/nfs/rootfs/usr/lib/ -d</span><br><span class="line">cd /home/moss/linux/nfs/rootfs//进入根文件系统目录</span><br><span class="line">du ./lib ./usr/lib/ -sh//查看 lib 和 usr/lib 这两个目录的大小</span><br></pre></td></tr></table></figure><p>在根文件系统中创建其他文件夹，如 dev、 proc、 mnt、 sys、 tmp 和 root 等 .</p><h3 id="初步测试根文件系统"><a href="#初步测试根文件系统" class="headerlink" title="初步测试根文件系统"></a>初步测试根文件系统</h3><p>首先使用nfs挂载根文件系统，首先熟悉bootargs环境变量的root值的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root=/dev/nfs nfsroot=[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gwip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;:&lt;dns0-ip&gt;:&lt;dns1-ip&gt;</span><br></pre></td></tr></table></figure><p><server-ip>：服务器IP地址。（也就是Ubuntu的IP）</p><p><root-dir>：根文件系统存放路径，也就是rootfs的绝对路径，可用pwd命令查询。</p><p><nfs-options>：NFS的其他选项一般不用。</p><p><client-ip>：开发板IP地址</p><p><server-ip>：服务器IP</p><p><gw-ip>：网关地址，我的是192.168.1.1</p><p><netmask>：子网掩码，255.255.255.0</p><p><hostname>：客户机名字，一般不用</p><p><device>：网卡名字：一般eth0,eht1,之类的</p><p><autoconf>：自动配置，一般为off</p><p><dns0-ip>：DNS0服务器IP地址，不使用</p><p><dns1-ip>：DNS1服务器IP地址，不使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.115:</span><br><span class="line">/home/moss/linux/nfs/rootfs,proto=tcp rw ip=192.168.1.114:192.168.1.115:192.168.1.1:</span><br><span class="line">255.255.255.0::eth0:off&#x27; </span><br></pre></td></tr></table></figure><h3 id="完善根文件系统"><a href="#完善根文件系统" class="headerlink" title="完善根文件系统"></a>完善根文件系统</h3><p>Linux 内核启动以后需要启动一些服务，<u>而 rcS 就是规定启动哪些文件的脚本文件</u>。在 rootfs 中创建&#x2F;etc&#x2F;init.d&#x2F;rcS 文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 #!/bin/sh</span><br><span class="line">2 </span><br><span class="line">3 PATH=/sbin:/bin:/usr/sbin:/usr/bin:$PATH</span><br><span class="line">4 LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/lib</span><br><span class="line">5 export PATH LD_LIBRARY_PATH</span><br><span class="line">6</span><br><span class="line">7 mount -a</span><br><span class="line">8 mkdir /dev/pts</span><br><span class="line">9 mount -t devpts devpts /dev/pts</span><br><span class="line">10</span><br><span class="line">11 echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">12 mdev -s</span><br></pre></td></tr></table></figure><p>第 1 行，表示这是一个 shell 脚本。<br>第 3 行， PATH 环境变量保存着可执行文件可能存在的目录，这样我们在执行一些命令或者可执行文件的时候就不会提示找不到文件这样的错误。<br>第 4 行， LD_LIBRARY_PATH 环境变量保存着库文件所在的目录。<br>第 5 行，使用 export 来导出上面这些环境变量，相当于声明一些“全局变量”。<br>第 7 行，使用 mount 命令来挂载所有的文件系统，这些文件系统由文件&#x2F;etc&#x2F;fstab 来指定，所以我们一会还要创建&#x2F;etc&#x2F;fstab 文件。<br>第 8 和 9 行，创建目录&#x2F;dev&#x2F;pts，然后将 devpts 挂载到&#x2F;dev&#x2F;pts 目录中。<br>第 11 和 12 行，使用 mdev 来管理热插拔设备，通过这两行， Linux 内核就可以在&#x2F;dev 目录下自动创建设备节点。 </p><p>使用chmod给予&#x2F;ec&#x2F;init.d&#x2F;rcS 可执行权限</p><h4 id="创建-x2F-etc-x2F-fstab-文件"><a href="#创建-x2F-etc-x2F-fstab-文件" class="headerlink" title="创建&#x2F;etc&#x2F;fstab 文件"></a>创建&#x2F;etc&#x2F;fstab 文件</h4><p><u>fstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区</u>，格式如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br></pre></td></tr></table></figure><p><file system>：要挂载的特殊的设备，也可以是块设备，比如&#x2F;dev&#x2F;sda </p><p><mount point>：挂载点。</p><p><type>：文件系统类型，比如 ext2、 ext3、 proc、 romfs、 tmpfs 等等。</p><p><options>：挂载选项，在 Ubuntu 中输入“man mount”命令可以查看具体的选项。一般使用 defaults，也就是默认选项， </p><p>defaults 包含了 rw、 suid、 dev、 exec、 auto、 nouser 和 async。</p><p><dump>：为 1 的话表示允许备份，为 0 不备份，一般不备份，因此设置为 0。</p><p><pass>：磁盘检查设置，为 0 表示不检查。根目录‘&#x2F;’设置为 1，其他的都不能设置为 1，其他的分区从 2 开始。一般不在 </p><p>fstab 中挂载根目录，因此这里一般设置为 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br><span class="line">proc /proc  proc defaults  0  0</span><br><span class="line">tmpfs /tmp  tmpfs defaults  0  0</span><br><span class="line">sysfs /sys  sysfs defaults  0  0</span><br></pre></td></tr></table></figure><h4 id="创建-x2F-etc-x2F-inittab-文件"><a href="#创建-x2F-etc-x2F-inittab-文件" class="headerlink" title="创建&#x2F;etc&#x2F;inittab 文件"></a>创建&#x2F;etc&#x2F;inittab 文件</h4><p>init 程序会读取&#x2F;etc&#x2F;inittab这个文件， inittab 由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的 4 个段组成，格式如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br></pre></td></tr></table></figure><p><id>：每个指令的标识符，不能重复。但是对于 busybox 的 init 来说， <id>有着特殊意义。对于 busybox 而言<id>用来指定启动进程的控制 tty，一般我们将串口或者 LCD 屏幕设置为控制 tty。</p><p><runlevels>： 对 busybox 来说此项完全没用，所以空着。</p><p><action>：动作，用于指定<process>可能用到的动作。 <process>： 具体的动作，比如程序、脚本或命令等。动作表如下：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-29%20211432.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例代码 38.4.3.1 /etc/inittab 文件</span><br><span class="line">1 #etc/inittab</span><br><span class="line">2 ::sysinit:/etc/init.d/rcS</span><br><span class="line">3 console::askfirst:-/bin/sh</span><br><span class="line">4 ::restart:/sbin/init</span><br><span class="line">5 ::ctrlaltdel:/sbin/reboot</span><br><span class="line">6 ::shutdown:/bin/umount -a -r</span><br><span class="line">7 ::shutdown:/sbin/swapoff -a</span><br></pre></td></tr></table></figure><p>第 2 行，系统启动以后运行&#x2F;etc&#x2F;init.d&#x2F;rcS 这个脚本文件。<br>第 3 行，将 console 作为控制台终端，也就是 ttymxc0。<br>第 4 行，重启的话运行&#x2F;sbin&#x2F;init。<br>第 5 行，按下 ctrl+alt+del 组合键的话就运行&#x2F;sbin&#x2F;reboot，看来 ctrl+alt+del 组合键用于重启系统。<br>第 6 行，关机的时候执行&#x2F;bin&#x2F;umount，也就是卸载各个文件系统。<br>第 7 行，关机的时候执行&#x2F;sbin&#x2F;swapoff，也就是关闭交换分区。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核移植</title>
      <link href="/2023/03/28/2023-3-28-%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D/"/>
      <url>/2023/03/28/2023-3-28-%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="内核移植"><a href="#内核移植" class="headerlink" title="内核移植"></a>内核移植</h3><p>首先是要将官方的板载内核进行下载，在其之上进行改动来支持自己的板子。</p><p>例如可以下载nxp关于imx6ull的linux内核，github的地址<a href="https://github.com/Freescale/linux-fslc/tree/5.4-2.1.x-imx">GitHub - Freescale&#x2F;linux-fslc at 5.4-2.1.x-imx</a></p><p>交叉编译器使用的为arm-linux-gnueabihf-</p><p>随便弄一个内核下来，编译顶层的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH?= arm</span><br><span class="line">CROSS_COMPILE?=arm-linux-gnueabihf-</span><br></pre></td></tr></table></figure><p>这两个后面不要加空格直接回车，不然找不到交叉编译器。</p><h4 id="添加自己的板子"><a href="#添加自己的板子" class="headerlink" title="添加自己的板子"></a>添加自己的板子</h4><p>之后复制一份自己的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cdarch/arm/configs</span><br><span class="line">ls</span><br><span class="line">cpimx_v7_mfg_defonfig imx_alientek_emmc_defconfig</span><br></pre></td></tr></table></figure><p>之后进入arch&#x2F;arm&#x2F;boot&#x2F;dts，复制一份imx6ull-14x14-evk.dts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp imx6ull-14x14-evk.dts imx6ull-alientek-emmc.dts</span><br></pre></td></tr></table></figure><p>修改makefile的dtb-$(CONFIG_SOC_IMX6ULL)的内容，添加设备树</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-28%20103201.png"></p><p>之后返回顶层编译工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makedistclean</span><br><span class="line">makeimx_alientek_emmc_defconfig</span><br><span class="line">make-j8</span><br></pre></td></tr></table></figure><p>这里的-j8是因为我的虚拟机就只有8个处理器</p><h4 id="修改板子主频"><a href="#修改板子主频" class="headerlink" title="修改板子主频"></a>修改板子主频</h4><p>在串口软件例如我的是Mobaxterm，查看cpu信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><p>BogoMIPS 是 Linux 系统中衡量处理器运行速度的一个“尺子”，处理器性能越强，主频越高， BogoMIPS 值就越大。BogoMIPS 只是粗略的计算 CPU 性能，并不十分准确。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/bus/cpu/devices/cpu0/cpufreq</span><br><span class="line">cat cpuinfo_cur_freq</span><br></pre></td></tr></table></figure><p>此目录中记录了 CPU 频率等信息，这些文件的含义如下：<br>cpuinfo_cur_freq：当前 cpu 工作频率，从 CPU 寄存器读取到的工作频率。<br>cpuinfo_max_freq：处理器所能运行的最高工作频率(单位: KHz）。<br>cpuinfo_min_freq ：处理器所能运行的最低工作频率(单位: KHz）。<br>cpuinfo_transition_latency：处理器切换频率所需要的时间(单位:ns)。<br>scaling_available_frequencies：处理器支持的主频率列表(单位: KHz）。<br>scaling_available_governors：当前内核中支持的所有 governor(调频)类型。<br>scaling_cur_freq：保存着 cpufreq 模块缓存的当前 CPU 频率，不会对 CPU 硬件寄存器进行检查。<br>scaling_driver：该文件保存当前 CPU 所使用的调频驱动。<br>scaling_governor： governor(调频)策略， Linux 内核一共有 5 中调频策略，<br>①、 Performance，最高性能，直接用最高频率，不考虑耗电。<br>②、 Interactive，一开始直接用最高频率，然后根据 CPU 负载慢慢降低。<br>③、 Powersave，省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！<br>④、 Userspace，可以在用户空间手动调节频率。<br>⑤、 Ondemand，定时检查负载，然后根据负载来调节频率。负载低的时候降低 CPU 频率，这样省电，负载高的时候提高 CPU 频率，增加性能。<br>scaling_max_freq： governor(调频)可以调节的最高频率。<br>cpuinfo_min_freq： governor(调频)可以调节的最低频率。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat scaling_governor = ondemand</span><br></pre></td></tr></table></figure><p>ondmand是定期检查负载，调整功率，一般用这个。</p><p>查看 stats 目录下的 time_in_state 文件可以看到 CPU 在各频率下的工作时间，命令如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/bus/cpu/devices/cpu0/cpufreq/stats/time_in_state</span><br></pre></td></tr></table></figure><p>如果想一直高频就在内核文件的imx_alientek_emmc_defconfig文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y//屏蔽掉</span><br><span class="line">CONFIG_CPU_FREQ_GOV_ONDEMAND=y//添加</span><br></pre></td></tr></table></figure><h4 id="EMMC驱动修改"><a href="#EMMC驱动修改" class="headerlink" title="EMMC驱动修改"></a>EMMC驱动修改</h4><p>修改imx6ull-alientek-emmc.dts的usdhc2部分，将其修改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">734</span> &amp;usdhc2 &#123;</span><br><span class="line"><span class="number">735</span> pinctrl-names = <span class="string">&quot;default&quot;</span>, <span class="string">&quot;state_100mhz&quot;</span>, <span class="string">&quot;state_200mhz&quot;</span>;</span><br><span class="line"><span class="number">736</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_usdhc2_8bit&gt;;</span><br><span class="line"><span class="number">737</span> pinctrl<span class="number">-1</span> = &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;;</span><br><span class="line"><span class="number">738</span> pinctrl<span class="number">-2</span> = &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;;</span><br><span class="line"><span class="number">739</span> bus-width = &lt;<span class="number">8</span>&gt;;</span><br><span class="line"><span class="number">740</span> non-removable;</span><br><span class="line"><span class="number">741</span> no<span class="number">-1</span><span class="number">-8</span>-v;</span><br><span class="line"><span class="number">742</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">743</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="网络驱动修改"><a href="#网络驱动修改" class="headerlink" title="网络驱动修改"></a>网络驱动修改</h4><h5 id="修改LAN8720的复位以及网络时钟引脚驱动"><a href="#修改LAN8720的复位以及网络时钟引脚驱动" class="headerlink" title="修改LAN8720的复位以及网络时钟引脚驱动"></a>修改LAN8720的复位以及网络时钟引脚驱动</h5><p>ENET1 复位引脚 ENET1_RST 连接在 I.M6ULL 的 SNVS_TAMPER7 这个引脚上。 ENET2的复位引脚 ENET2_RST 连接在 I.MX6ULL 的 SNVS_TAMPER8 上。打开设备树文件 imx6ullalientek-emmc.dts，找到如下代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">584</span> pinctrl_spi4: spi4grp &#123;</span><br><span class="line"><span class="number">585</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">586</span> MX6ULL_PAD_BOOT_MODE0__GPIO5_IO10 <span class="number">0x70a1</span></span><br><span class="line"><span class="number">587</span> MX6ULL_PAD_BOOT_MODE1__GPIO5_IO11 <span class="number">0x70a1</span></span><br><span class="line"><span class="number">588</span> MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07 <span class="number">0x70a1</span></span><br><span class="line"><span class="number">589</span> MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08 <span class="number">0x80000000</span></span><br><span class="line"><span class="number">590</span> &gt;;</span><br><span class="line"><span class="number">591</span> &#125;;</span><br></pre></td></tr></table></figure><p>删除原有的588和589行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">125</span> spi4 &#123;</span><br><span class="line"><span class="number">126</span> compatible = <span class="string">&quot;spi-gpio&quot;</span>;</span><br><span class="line"><span class="number">127</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">128</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_spi4&gt;;</span><br><span class="line"><span class="number">129</span> pinctrl-assert-gpios = &lt;&amp;gpio5 <span class="number">8</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">......</span><br><span class="line"><span class="number">133</span> cs-gpios = &lt;&amp;gpio5 <span class="number">7</span> <span class="number">0</span>&gt;;</span><br></pre></td></tr></table></figure><p>GPIO5_IO07 和 GPIO5_IO08 分别作为 ENET1 和 ENET2 的复位引脚，而不是 SPI4 的什么功能引脚，因此将示例代码 37.4.3.2 中的第 129 行和第 133 行处的代码删除掉！！ 否则会干扰到网络复位引脚！ </p><p>在 imx6ull-alientek-emmc.dts 里面找到名为“iomuxc_snvs”的节点(就是直接搜索)，然后在此节点下添加网络复位引脚信息，添加完成以后的“iomuxc_snvs”的节点内容如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;iomuxc_snvs &#123;</span><br><span class="line"><span class="number">2</span> pinctrl-names = <span class="string">&quot;default_snvs&quot;</span>;</span><br><span class="line"><span class="number">3</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_hog_2&gt;;</span><br><span class="line"><span class="number">4</span> imx6ul-evk &#123;</span><br><span class="line"><span class="number">5</span></span><br><span class="line">...... <span class="comment">/*省略掉其他*/</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line"><span class="number">44</span> <span class="comment">/*enet1 reset zuozhongkai*/</span></span><br><span class="line"><span class="number">45</span> pinctrl_enet1_reset: enet1resetgrp &#123;</span><br><span class="line"><span class="number">46</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">47</span> <span class="comment">/* used for enet1 reset */</span></span><br><span class="line"><span class="number">48</span> MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07 <span class="number">0x10B0</span></span><br><span class="line"><span class="number">49</span> &gt;;</span><br><span class="line"><span class="number">50</span> &#125;;</span><br><span class="line"><span class="number">51</span></span><br><span class="line"><span class="number">52</span> <span class="comment">/*enet2 reset zuozhongkai*/</span></span><br><span class="line"><span class="number">53</span> pinctrl_enet2_reset: enet2resetgrp &#123;</span><br><span class="line"><span class="number">54</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">55</span> <span class="comment">/* used for enet2 reset */</span></span><br><span class="line"><span class="number">56</span> MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08 <span class="number">0x10B0</span></span><br><span class="line"><span class="number">57</span> &gt;;</span><br><span class="line"><span class="number">58</span> &#125;;</span><br><span class="line"><span class="number">59</span> &#125;;</span><br><span class="line"><span class="number">60</span> &#125;;</span><br></pre></td></tr></table></figure><p>最后还需要修改一下 ENET1 和 ENET2 的网络时钟引脚配置， 继续在 imx6ull-alientekemmc.dts 中找到如下所示代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">309</span> pinctrl_enet1: enet1grp &#123;</span><br><span class="line"><span class="number">310</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">311</span> MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">312</span> MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">313</span> MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">314</span> MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">315</span> MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">316</span> MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">317</span> MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">318</span> MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 <span class="number">0x4001b009</span></span><br><span class="line"><span class="number">319</span> &gt;;</span><br><span class="line"><span class="number">320</span> &#125;;</span><br><span class="line"><span class="number">321</span></span><br><span class="line"><span class="number">322</span> pinctrl_enet2: enet2grp &#123;</span><br><span class="line"><span class="number">323</span> fsl,pins = &lt;</span><br><span class="line"><span class="number">324</span> MX6UL_PAD_GPIO1_IO07__ENET2_MDC <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">325</span> MX6UL_PAD_GPIO1_IO06__ENET2_MDIO <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">326</span> MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">327</span> MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">328</span> MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">329</span> MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">330</span> MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">331</span> MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">332</span> MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01 <span class="number">0x1b0b0</span></span><br><span class="line"><span class="number">333</span> MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 <span class="number">0x4001b009</span></span><br><span class="line"><span class="number">334</span> &gt;;</span><br><span class="line"><span class="number">335</span> &#125;;</span><br></pre></td></tr></table></figure><p>第 318 和 333 行， 分别为 ENET1 和 ENET2 的网络时钟引脚配置信息，将这两个引脚的电气属性值改为 0x4001b009，原来默认值为 0x4001b031。 </p><h5 id="修改-fec1-和-fec2-节点的-pinctrl-0-属性"><a href="#修改-fec1-和-fec2-节点的-pinctrl-0-属性" class="headerlink" title="修改 fec1 和 fec2 节点的 pinctrl-0 属性"></a>修改 fec1 和 fec2 节点的 pinctrl-0 属性</h5><p>在 imx6ull-alientek-emmc.dts 文件中找到名为“fec1”和“fec2”的这两个节点，修改其中的“pinctrl-0”属性值，修改以后如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp;fec1 &#123;</span><br><span class="line"><span class="number">2</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">3</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet1&amp;pinctrl_enet1_reset&gt;;</span><br><span class="line"><span class="number">4</span> phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">9</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">10</span> &#125;;</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> &amp;fec2 &#123;</span><br><span class="line"><span class="number">13</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">14</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet2&amp;pinctrl_enet2_reset&gt;;</span><br><span class="line"><span class="number">15</span> phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">36</span> &#125;;</span><br></pre></td></tr></table></figure><p>第 3<del>4 行，修改后的 fec1 节点“pinctrl-0”属性值。<br>第 14</del>15 行，修改后的 fec2 节点“pinctrl-0”属性值 .</p><h5 id="修改-LAN8720A-的-PHY-地址"><a href="#修改-LAN8720A-的-PHY-地址" class="headerlink" title="修改 LAN8720A 的 PHY 地址"></a>修改 LAN8720A 的 PHY 地址</h5><p>ENET1 的 LAN8720A 地址为 0x0， ENET2 的 LAN8720A地址为 0x1 ，在 imx6ull-alientek-emmc.dts 中找到如下代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">171</span> &amp;fec1 &#123;</span><br><span class="line"><span class="number">172</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">175</span> phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line"><span class="number">176</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">177</span> &#125;;</span><br><span class="line"><span class="number">178</span></span><br><span class="line"><span class="number">179</span> &amp;fec2 &#123;</span><br><span class="line"><span class="number">180</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">......</span><br><span class="line"><span class="number">183</span> phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line"><span class="number">184</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">185</span></span><br><span class="line"><span class="number">186</span> mdio &#123;</span><br><span class="line"><span class="number">187</span> <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="number">188</span> <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"><span class="number">189</span></span><br><span class="line"><span class="number">190</span> ethphy0: ethernet-phy@<span class="number">0</span> &#123;</span><br><span class="line"><span class="number">191</span> compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line"><span class="number">192</span> reg = &lt;<span class="number">2</span>&gt;;</span><br><span class="line"><span class="number">193</span> &#125;;</span><br><span class="line"><span class="number">194</span></span><br><span class="line"><span class="number">195</span> ethphy1: ethernet-phy@<span class="number">1</span> &#123;</span><br><span class="line"><span class="number">196</span> compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line"><span class="number">197</span> reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line"><span class="number">198</span> &#125;;</span><br><span class="line"><span class="number">199</span> &#125;;</span><br><span class="line"><span class="number">200</span> &#125;;</span><br></pre></td></tr></table></figure><p>第 171<del>177 行， ENET1 对应的设备树节点。<br>第 179</del>200 行， ENET2 对应的设备树节点。但是第 186~198 行的 mdio 节点描述了 ENET1和 ENET2 的 PHY 地址信息。 改为如下内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">171</span> &amp;fec1 &#123;</span><br><span class="line"><span class="number">172</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">173</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet1</span><br><span class="line"><span class="number">174</span> &amp;pinctrl_enet1_reset&gt;;</span><br><span class="line"><span class="number">175</span> phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line"><span class="number">176</span> phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line"><span class="number">177</span> phy-reset-gpios = &lt;&amp;gpio5 <span class="number">7</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line"><span class="number">178</span> phy-reset-duration = &lt;<span class="number">200</span>&gt;;</span><br><span class="line"><span class="number">179</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">180</span> &#125;;</span><br><span class="line"><span class="number">181</span></span><br><span class="line"><span class="number">182</span> &amp;fec2 &#123;</span><br><span class="line"><span class="number">183</span> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="number">184</span> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet2</span><br><span class="line"><span class="number">185</span> &amp;pinctrl_enet2_reset&gt;;</span><br><span class="line"><span class="number">186</span> phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line"><span class="number">187</span> phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line"><span class="number">188</span> phy-reset-gpios = &lt;&amp;gpio5 <span class="number">8</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line"><span class="number">189</span> phy-reset-duration = &lt;<span class="number">200</span>&gt;;</span><br><span class="line"><span class="number">190</span> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="number">191</span></span><br><span class="line"><span class="number">192</span> mdio &#123;</span><br><span class="line"><span class="number">193</span> <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="number">194</span> <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"><span class="number">195</span></span><br><span class="line"><span class="number">196</span> ethphy0: ethernet-phy@<span class="number">0</span> &#123;</span><br><span class="line"><span class="number">197</span> compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line"><span class="number">198</span> smsc,disable-energy-detect;</span><br><span class="line"><span class="number">199</span> reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line"><span class="number">200</span> &#125;;</span><br><span class="line"><span class="number">201</span></span><br><span class="line"><span class="number">202</span> ethphy1: ethernet-phy@<span class="number">1</span> &#123;</span><br><span class="line"><span class="number">203</span> compatible = <span class="string">&quot;ethernet-phy-ieee802.3-c22&quot;</span>;</span><br><span class="line"><span class="number">204</span> smsc,disable-energy-detect;</span><br><span class="line"><span class="number">205</span> reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line"><span class="number">206</span> &#125;;</span><br><span class="line"><span class="number">207</span> &#125;;</span><br><span class="line"><span class="number">208</span> &#125;;</span><br></pre></td></tr></table></figure><h5 id="修改-fec-main-c-文件"><a href="#修改-fec-main-c-文件" class="headerlink" title="修改 fec_main.c 文件"></a>修改 fec_main.c 文件</h5><p>要 在 I.MX6ULL 上 使 用 LAN8720A ， 需 要 修 改 一 下 Linux 内 核 源 码 ， 打 开drivers&#x2F;net&#x2F;ethernet&#x2F;freescale&#x2F;fec_main.c，找到函数 fec_probe，在 fec_probe 中加入如下代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3438</span> <span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="number">3439</span> fec_probe(<span class="keyword">struct</span> platform_device *pdev)</span><br><span class="line"><span class="number">3440</span> &#123;</span><br><span class="line"><span class="number">3441</span> <span class="class"><span class="keyword">struct</span> <span class="title">fec_enet_private</span> *<span class="title">fep</span>;</span></span><br><span class="line"><span class="number">3442</span> <span class="class"><span class="keyword">struct</span> <span class="title">fec_platform_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="number">3443</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">ndev</span>;</span></span><br><span class="line"><span class="number">3444</span> <span class="type">int</span> i, irq, ret = <span class="number">0</span>;</span><br><span class="line"><span class="number">3445</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">r</span>;</span></span><br><span class="line"><span class="number">3446</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span>;</span></span><br><span class="line"><span class="number">3447</span> <span class="type">static</span> <span class="type">int</span> dev_id;</span><br><span class="line"><span class="number">3448</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node, *phy_node;</span><br><span class="line"><span class="number">3449</span> <span class="type">int</span> num_tx_qs;</span><br><span class="line"><span class="number">3450</span> <span class="type">int</span> num_rx_qs;</span><br><span class="line"><span class="number">3451</span></span><br><span class="line"><span class="number">3452</span> <span class="comment">/* 设置 MX6UL_PAD_ENET1_TX_CLK 和 MX6UL_PAD_ENET2_TX_CLK</span></span><br><span class="line"><span class="comment">3453 * 这两个 IO 的复用寄存器的 SION 位为 1。</span></span><br><span class="line"><span class="comment">3454 */</span></span><br><span class="line"><span class="number">3455</span> <span class="type">void</span> __iomem *IMX6U_ENET1_TX_CLK;</span><br><span class="line"><span class="number">3456</span> <span class="type">void</span> __iomem *IMX6U_ENET2_TX_CLK;</span><br><span class="line"><span class="number">3457</span></span><br><span class="line"><span class="number">3458</span> IMX6U_ENET1_TX_CLK = ioremap(<span class="number">0X020E00DC</span>, <span class="number">4</span>);</span><br><span class="line"><span class="number">3459</span> writel(<span class="number">0X14</span>, IMX6U_ENET1_TX_CLK);</span><br><span class="line"><span class="number">3460</span></span><br><span class="line"><span class="number">3461</span> IMX6U_ENET2_TX_CLK = ioremap(<span class="number">0X020E00FC</span>, <span class="number">4</span>);</span><br><span class="line"><span class="number">3462</span> writel(<span class="number">0X14</span>, IMX6U_ENET2_TX_CLK);</span><br><span class="line"><span class="number">3463</span></span><br><span class="line">......</span><br><span class="line"><span class="number">3656</span> <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">3657</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="配置-Linux-内核，使能-LAN8720-驱动"><a href="#配置-Linux-内核，使能-LAN8720-驱动" class="headerlink" title="配置 Linux 内核，使能 LAN8720 驱动"></a>配置 Linux 内核，使能 LAN8720 驱动</h5><p>输入命令“make menuconfig”，打开图形化配置界面，选择使能 LAN8720A 的驱动，路径如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">-&gt; Network device support</span><br><span class="line">-&gt; PHY Device support and infrastructure</span><br><span class="line">-&gt; Drivers for SMSC PHYs</span><br></pre></td></tr></table></figure><h5 id="修改-smsc-c-文件"><a href="#修改-smsc-c-文件" class="headerlink" title="修改 smsc.c 文件"></a>修改 smsc.c 文件</h5><p>LAN8720A 的驱动文件是 drivers&#x2F;net&#x2F;phy&#x2F;smsc.c， 修改SMSC PHY的复位函数 ，修改以后的 smsc_phy_reset函数内容如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">smsc_phy_reset</span><span class="params">(<span class="keyword">struct</span> phy_device *phydev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err, phy_reset;</span><br><span class="line"><span class="type">int</span> msec = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"><span class="type">int</span> timeout = <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">if</span>(phydev-&gt;addr == <span class="number">0</span>) <span class="comment">/* FEC1 */</span> </span><br><span class="line">    &#123;</span><br><span class="line">np = of_find_node_by_path(<span class="string">&quot;/soc/aips-bus@02100000/ethernet@02188000&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(np == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(phydev-&gt;addr == <span class="number">1</span>) <span class="comment">/* FEC2 */</span> </span><br><span class="line">    &#123;</span><br><span class="line">np = of_find_node_by_path(<span class="string">&quot;/soc/aips-bus@02000000/ethernet@020b4000&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(np == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = of_property_read_u32(np, <span class="string">&quot;phy-reset-duration&quot;</span>, &amp;msec);</span><br><span class="line"><span class="comment">/* A sane reset duration should not be longer than 1s */</span></span><br><span class="line"><span class="keyword">if</span> (!err &amp;&amp; msec &gt; <span class="number">1000</span>)</span><br><span class="line">msec = <span class="number">1</span>;</span><br><span class="line">phy_reset = of_get_named_gpio(np, <span class="string">&quot;phy-reset-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!gpio_is_valid(phy_reset))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">gpio_direction_output(phy_reset, <span class="number">0</span>);</span><br><span class="line">gpio_set_value(phy_reset, <span class="number">0</span>);</span><br><span class="line">msleep(msec);</span><br><span class="line">gpio_set_value(phy_reset, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> rc = phy_read(phydev, MII_LAN83C185_SPECIAL_MODES);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the SMSC PHY is in power down mode, then set it</span></span><br><span class="line"><span class="comment">* in all capable mode before using it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> ((rc &amp; MII_LAN83C185_MODE_MASK) == MII_LAN83C185_MODE_POWERDOWN) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set &quot;all capable&quot; mode and reset the phy */</span></span><br><span class="line">rc |= MII_LAN83C185_MODE_ALL;</span><br><span class="line">phy_write(phydev, MII_LAN83C185_SPECIAL_MODES, rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">phy_write(phydev, MII_BMCR, BMCR_RESET);</span><br><span class="line"><span class="comment">/* wait end of reset (max 500 ms) */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">udelay(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (timeout-- == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">rc = phy_read(phydev, MII_BMCR);</span><br><span class="line">&#125; <span class="keyword">while</span> (rc &amp; BMCR_RESET);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们还需要在 drivers&#x2F;net&#x2F;phy&#x2F;smsc.c 文件中添加两个头文件，因为修改后的smsc_phy_reset 函数用到了 gpio_direction_output 和 gpio_set_value 这两个函数，需要添加的头文件如下所示： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="网络驱动测试"><a href="#网络驱动测试" class="headerlink" title="网络驱动测试"></a>网络驱动测试</h4><p>修改好设备树和 Linux 内核以后重新编译一下，得到新的 zImage 镜像文件和 imx6ullalientek-emmc.dtb 设备树文件，使用网线将 I.MX6U-ALPHA 开发板的两个网口与路由器或者电脑连接起来，最后使用新的文件启动 Linux 内核。启动以后使用“ifconfig”命令查看一下当前活动的网卡有哪些 。</p><p>输入命令“ifconfig -a”来查看一下开发板中存在的所有网卡， </p><p>使用如下命令依次打开 eth0 和 eth1 这两个网卡： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth1 up</span><br></pre></td></tr></table></figure><p>使用命令给两个网卡配置IP地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.251</span><br><span class="line">ifconfig eth1 192.168.1.252</span><br></pre></td></tr></table></figure><p>一定要和自己的电脑处于同一个网段内 ，可以ping一下自己的主机地址。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内核分析</title>
      <link href="/2023/03/24/2023-3-24-Linux-%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/24/2023-3-24-Linux-%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="内核分析"><a href="#内核分析" class="headerlink" title="内核分析"></a>内核分析</h2><h3 id="linux内核组成部分"><a href="#linux内核组成部分" class="headerlink" title="linux内核组成部分"></a>linux内核组成部分</h3><p>linux内核主要由进程调度（SCHED）、内存管理（MM）、虚拟文件系统（VFS）、网络接口（NET）、进程间通信（IPC）5个子系统组成。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-03%20154334.png"></p><p>5个子系统依赖关系如下：</p><p>进程调度与内存管理之间的关系：这两个子系统相互依赖，在多程序环境下，程序要运行，则必须创建进程，而创建进程第一件事情就是将程序和数据装入内存。</p><p>进程间通信与内存管理的关系：进程间通信子系统要依赖内存管理支持共享内存通信机制，这种机制允许两个进程除了拥有自己的私有空间外，还可以存取共同的内存区域。</p><p>虚拟文件系统与网络接口之间的关系：虚拟文件系统利用网络接口支持网络文件系统（NFS），也利用内存管理支持RAMDISK设备。</p><p>内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程定期由调度程序调度，这也是内存管理依赖于进程调度的原因。</p><h3 id="详情参考"><a href="#详情参考" class="headerlink" title="详情参考"></a>详情参考</h3><p><a href="http://blog.csdn.net/lizuobin2/article/details/51447338">Makefile.txt文件翻译</a></p><h3 id="内核Makefile分类"><a href="#内核Makefile分类" class="headerlink" title="内核Makefile分类"></a>内核Makefile分类</h3><p>在Linux内核里，每个子目录都有一个makefile，它被称作Kbuilt-makefile，它将当前目录的文件编译成built-in.o、以及库文件、模块文件。然后顶层Makefile里指定这些built-in.o的路径，将它们连接在一起。</p><p><strong>将makefile分为 5部分，Kernel Makefile、ARCH Makefile、KBuild Makefile、.config文件以及scripts&#x2F;Makefile.</strong></p><p>①kernel Makefile(Top Makefile)位于Linux内核源代码的顶层目录，主要编译Linux Kernel目标文件（vmlinux）和模块（module）路径。它根据.config文件决定了内核根目录下的那些文件、子目录被编译进内核，是所有文件核心，从总体控制内核编译、链接。</p><p>②ARCH Makefile文件，是系统对应平台的Makefile。Kernel Top Makefile 会包含这个文件来指定平台相关信息。ARCH Makefile同样<strong>根据.config文件，决定了ARCH&#x2F;$(ARCH) 目录下 那些文件、子目录被编译进内核</strong> 只有平台开发人员会关心这个文件。</p><p>③Kbuild Makefile，从Linux 内核2.6 开始，Linux 内核的编译采用Kbuild 系统 ，这同过去的编译系统有很大的不同，Kbuild 系统使用Kbuild Makefile 来编译内核或模块。当Kernel Makefile 被解析完成后，Kbuild 会读取相关的Kbuild Makefile 进行内核或模块的编译。Kbuild Makefile 有特定的语法指定哪些编译进内核中、哪些编译为模块、及对应的源文件是什么等。内核及驱动开发人员需要编写这个Kbuild Makefile 文件。<br>④**scripts&#x2F;Makefile.* ，Makefile共用的通用规则、脚本等</p><p>⑤**.config**，来自配置过程，生成 auto.conf 以及 autoconf.h，被顶层Makefile所包含</p><h3 id="5大文件作用"><a href="#5大文件作用" class="headerlink" title="5大文件作用"></a>5大文件作用</h3><p>首先是顶层Makefile决定内核根目录下的哪些子目录将被编进内核。</p><p>arch&#x2F;$(ARCH)&#x2F;Makefile决定arch&#x2F;$(ARCH)目录下哪些文件、哪些目录被编进内核。</p><p>各级子目录下的Makefile决定所在目录下的哪些文件将被编进内核，哪些被编写成模块（驱动模块），进入哪些子目录继续调用它们的Makefile。</p><p>顶层Makefile和arch&#x2F;$(ARCH)&#x2F;Makefile设置了可以影响所有文件的编译、连接选项：CFLAGS、AFLAGS、LDFLAGS、ARFLAFGS。</p><p>各级子目录下的Makefile中可以设置成能够影响当前目录下所有文件的编译 、连接选项：EXTRA_CFLAGS、EXTRA_AFLAGS、EXTRA_LDFLAGS、EXTRA_ARFLAGS,还可以设置影响某个文件的编译选项。</p><p>顶层Makefile按照一定的顺序组织文件，根据连接脚本arch&#x2F;$(ARCH)&#x2F;kernel&#x2F;vmlinux.lds生成内核镜像文件vmlinux。</p><p>①、 vmlinux 是编译出来的最原始的内核文件，是未压缩的，比如正点原子提供的 Linux 源码编译出来的 vmlinux 差不多有 16MB，<br>②、 Image 是 Linux 内核镜像文件，但是 Image 仅包含可执行的二进制数据。 Image 就是使用 objcopy 取消掉 vmlinux 中的一些其他信息，比如符号表什么的。但是 Image 是没有压缩过的， Image 保存在 arch&#x2F;arm&#x2F;boot 目录下，其大小大概在 12MB 左右相比 vmlinux 的 16MB， Image 缩小到了 12MB。<br>③、 zImage 是经过 gzip 压缩后的 Image，经过压缩以后其大小大概在 6MB 左右 </p><h3 id="内核的配置"><a href="#内核的配置" class="headerlink" title="内核的配置"></a>内核的配置</h3><p> 1、Makefile：分布在 Linux 内核源代码根目录及各层目录中，定义 Linux 内核的编译规则；<br> 2、配置文件（config.in(2.4内核，2.6内核)）：给用户提供配置选择的功能；<br> 3、配置工具：包括配置命令解释器（对配置脚本中使用的配置命令进行解释）和配置用户界面</p><p>make menuconfig过程：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-23%20201421.png"></p><p> 1、scripts文件夹存放的是跟make menuconfig配置界面的图形绘制相关的文件，我们作为使用者无需关心这个文件夹的内容<br> 2、读取arch&#x2F;arch&#x2F;$ARCH&#x2F;Kconfig以及各子目录下的Kcondig文件，生成配置条目。<br>        $ARCH由linux内核根目录下的makefile文件决定<br>        ARCH            ?&#x3D; arm<br>        CROSS_COMPILE   ?&#x3D; arm-linux-<br>        Kconfig文件中为配置信息的宏定义，与我们在make menuconfig图形界面看到的信息一致。<br>        例如：<br>        config CPU_S3C2410_DMA<br>                bool<br>                depends on S3C2410_DMA &amp;&amp; (CPU_S3C2410 || CPU_S3C2442)<br>                default y if CPU_S3C2410 || CPU_S3C2442<br>                help<br>                   DMA device selection for S3C2410 and compatible CPUs<br>    <strong>因此，Kconfig文件很重要的作用就是：定义配置宏、相关依赖关系、帮助信息</strong><br>3、<strong>读取内核根目录下.config文件，生成配置选项:[*]编译进内核 [M]编译为模块 [ ]不编译</strong><br>        arch&#x2F;arm&#x2F;configs&#x2F;文件夹下存放了一些配置模板<br>        我们可以通过cp &#x2F;arch&#x2F;arm&#x2F;configs&#x2F;xx_defconfig .config来使用这些配置模板<br>        通过图形界面变更配置选项会自动更新到.config文件中<br>        make disclean 会删除.config<br>4、<strong>编译过程根据.config生成 Linux内核根目录下的 include&#x2F;config&#x2F;auto.conf文件</strong><br>        CONFIG_EEPROM_93CX6&#x3D;m<br>        CONFIG_DM9000&#x3D;y<br>        根目录Makefile以及子目录的Makefile根据auto.conf生成编译条件<br>        obj-$(CONFIG_DM9000) +&#x3D; dm9000.o &#x2F;&#x2F;obj-m +&#x3D; dm9000.o<br>5、<strong>编译过程根据.config生成Linux内核根目录下的 include&#x2F;linux&#x2F;autoconf.h文件</strong><br>        .config 或 auto.conf 中定义要编译为 m 模块的项，如：<br>        CONFIG_DEBUG_NX_TEST&#x3D;m<br>        在 autoconf.h 中会被定义为：<br>        #define CONFIG_DEBUG_NX_TEST_MODULE 1    </p><p>​.config或auto.conf 中定义为编译为 y 的选项,如：<br>​        CONFIG_DM9000&#x3D; y<br>​        在 autoconf.h 中会被定义为：<br>​        #define CONFIG_DM9000 1<br>​        autoconf.h中是.config或者auto.conf中配置信息的另一种体现形式，它是站在源码的角度，供源码使用的C语言宏定义。<br>   6、总结<br>​        我们在使用make menuconfig时，首先会确定架构arch，然后读取arch目录的Kconfig中的配置宏定义，生成编译条目，然后读取Linux内核根目录下的.config选项， 将.config中的配置信息显示在图形界面上[*] [M] or []。我们在图形界面中更改配置选项会自动保存到.config文件中。编译过程根据.config随后生成auto.conf文件，它决定了makefile中各个文件的编译类型，静态编译进内核、编译成模块、不编译;同时生成autoconf.h，它以C语言宏定义的形式表达了 各个文件是否被编译，源码中会判断某文件是否被编译进行不同的处理。</p><h2 id="内核启动流程"><a href="#内核启动流程" class="headerlink" title="内核启动流程"></a>内核启动流程</h2><p>linux启动前要求：</p><p>①、关闭 MMU。<br>②、关闭 D-cache。<br>③、 I-Cache 无所谓。<br>④、 r0&#x3D;0。<br>⑤、 r1&#x3D;machine nr(也就是机器 ID)。<br>⑥、 r2&#x3D;atags 或者设备树(dtb)首地址。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/20170315225401860.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootcmd和bootargs环境变量</title>
      <link href="/2023/03/22/2023-3-22-bootcmd%E5%92%8Cbootargs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2023/03/22/2023-3-22-bootcmd%E5%92%8Cbootargs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="环境变量bootcmd"><a href="#环境变量bootcmd" class="headerlink" title="环境变量bootcmd"></a>环境变量bootcmd</h2><p>bootcmd 保存着 uboot 默认命令， uboot 倒计时结束以后就会执行 bootcmd 中的命令。这些命令一般都是用来启动 Linux 内核的，比如读取 EMMC 或者 NAND Flash 中的 Linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 Linux 内核。 </p><p>如果 EMMC 或者 NAND 中没有保存 bootcmd 的值，那么 uboot 就会使用默认的值，板子第一次运行 uboot 的时候都会使用默认值来设置 bootcmd 环境变量。 </p><p>不设置bootcmd使用默认从emmc启动，<strong>先检查一下 EMMC 的分区 1 中有没有Image 文件和设备树文件，输入命令“ls mmc 1:1”</strong> 那么可以定义CONFIG_BOOTCOMMAND</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTCOMMAND \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;mmc dev 1;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fatload mmc 1:1 0x80800000 zImage;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fatload mmc 1:1 0x83000000 imx6ull-alientek-emmc.dtb;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootz 0x80800000 - 0x83000000;&quot;</span></span></span><br></pre></td></tr></table></figure><p>或者在uboot中设置bootcmd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000;&#x27;</span><br></pre></td></tr></table></figure><h2 id="环境变量bootargs"><a href="#环境变量bootargs" class="headerlink" title="环境变量bootargs"></a>环境变量bootargs</h2><p>bootargs 环境变量是由 mmcargs 设置的， mmcargs 环境变量如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; root=$&#123;mmcroot&#125;</span><br></pre></td></tr></table></figure><p>其中 console&#x3D;ttymxc0， baudrate&#x3D;115200， mmcroot&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw，因此将mmcargs 展开以后就是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmcargs=setenv bootargs console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw</span><br></pre></td></tr></table></figure><h4 id="console"><a href="#console" class="headerlink" title="console"></a>console</h4><p>console 用来设置 linux 终端(或者叫控制台)，也就是通过什么设备来和 Linux 进行交互，是串口还是 LCD 屏幕？如果是串口的话应该是串口几等等。一般设置串口作为 Linux 终端，这样我们就可以在电脑上通过 SecureCRT 来和 linux 交互了。 </p><p>设置 console 为 ttymxc0，因为 linux启动以后 I.MX6ULL 的串口 1 在 linux 下的设备文件就是&#x2F;dev&#x2F;ttymxc0 ，115200是波特率。</p><h4 id="root"><a href="#root" class="headerlink" title="root"></a>root</h4><p>root 用来设置根文件系统的位置， root&#x3D;&#x2F;dev&#x2F;mmcblk1p2 用于指明根文件系统存放在mmcblk1 设备的分区 2 中。emmc启动会存在两种文件，其中&#x2F;dev&#x2F;mmcblkx(x&#x3D;0<del>n)表示 mmc 设备，而&#x2F;dev&#x2F;mmcblkxpy(x&#x3D;0</del>n,y&#x3D;1~n)表示 mmc 设备x 的分区 y。在 I.MX6U-ALPHA 开发板中&#x2F;dev&#x2F;mmcblk1 表示 EMMC，而&#x2F;dev&#x2F;mmcblk1p2 表示EMMC 的分区 2。root 后面有“rootwait rw”， rootwait 表示等待 mmc 设备初始化完成以后再挂载，否则的话mmc 设备还没初始化完成就挂载根文件系统会出错的。 rw 表示根文件系统是可以读写的，不加rw 的话可能无法在根文件系统中进行写操作，只能进行读操作。 </p><h4 id="rootstype"><a href="#rootstype" class="headerlink" title="rootstype"></a>rootstype</h4><p>此选项一般配置 root 一起使用， rootfstype 用于指定根文件系统类型，如果根文件系统为ext 格式的话此选项无所谓。如果根文件系统是 yaffs、 jffs 或 ubifs 的话就需要设置此选项，指定根文件系统的类型。 </p><h2 id="网络启动Linux系统"><a href="#网络启动Linux系统" class="headerlink" title="网络启动Linux系统"></a>网络启动Linux系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz</span><br><span class="line">80800000 - 83000000&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>没网就完蛋。</p><h2 id="从emmc启动Linux系统"><a href="#从emmc启动Linux系统" class="headerlink" title="从emmc启动Linux系统"></a>从emmc启动Linux系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000</span><br><span class="line">imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000;&#x27;</span><br></pre></td></tr></table></figure><p>前提是设备树和镜像已经烧入emmc中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot移植</title>
      <link href="/2023/03/21/2023-3-21-U-Boot%E7%A7%BB%E6%A4%8D/"/>
      <url>/2023/03/21/2023-3-21-U-Boot%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="Uboot的移植"><a href="#Uboot的移植" class="headerlink" title="Uboot的移植"></a>Uboot的移植</h3><p>首先从官方下载一个Uboot，之后在此上面进行移植，可以进行使用脚本进行编译一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CORSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_evk_emmc_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><h3 id="在Uboot中添加使用的开发板"><a href="#在Uboot中添加使用的开发板" class="headerlink" title="在Uboot中添加使用的开发板"></a>在Uboot中添加使用的开发板</h3><h4 id="添加开发板默认配置文件"><a href="#添加开发板默认配置文件" class="headerlink" title="添加开发板默认配置文件"></a>添加开发板默认配置文件</h4><p>将cofigs目录下复制原有的mx6ull_14x14_evk_emmc_defconfig进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mx6ull_14x14_evk_emmc_defconfig mx6ull_alientek_emmc_defconfig</span><br></pre></td></tr></table></figure><p>修改mx6ull_alientek_emmc_defconfig文件，将原有的替换成mx6ull_alientek_emmc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYS_EXTRA_OPTIONS=&quot;IMX_CONFIG=board/freescale/mx6ull_alientek_emmc/imximage.cfg,MX6ULL_EVK_EMMC_REWORK&quot;</span><br><span class="line">CONFIG_ARM=y</span><br><span class="line">CONFIG_ARCH_MX6=y</span><br><span class="line">CONFIG_TARGET_MX6ULL_ALIENTEK_EMMC=y</span><br><span class="line">CONFIG_CMD_GPIO=y</span><br></pre></td></tr></table></figure><h4 id="添加开发板对应的头文件"><a href="#添加开发板对应的头文件" class="headerlink" title="添加开发板对应的头文件"></a>添加开发板对应的头文件</h4><p>在 目 录 include&#x2F;configs 下 添 加 I.MX6ULL-ALPHA 开 发 板 对 应 的 头 文 件 ， 复 制include&#x2F;configs&#x2F;mx6ullevk.h，并重命名为 mx6ull_alientek_emmc.h，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp include/configs/mx6ullevk.h mx6ull_alientek_emmc.h</span><br></pre></td></tr></table></figure><p>拷贝完成以后将：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __MX6ULLEVK_CONFIG_H</span><br><span class="line">#define __MX6ULLEVK_CONFIG_H</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __MX6ULL_ALIENTEK_EMMC_CONFIG_H</span><br><span class="line">#define __MX6ULL_ALIENTEK_EMMC_CONFIG_H </span><br></pre></td></tr></table></figure><p>此头文件主要功能就是配置或者裁剪 uboot。如果需要某个功能的话就在里面添加这个功能对应的 CONFIG_XXX 宏即可，如果不需要某个功能的话就删除掉对应的宏即可。 </p><h4 id="添加开发板对应的板级文件夹"><a href="#添加开发板对应的板级文件夹" class="headerlink" title="添加开发板对应的板级文件夹"></a>添加开发板对应的板级文件夹</h4><p>NXP 的 I.MX 系列芯片的所有板级文件夹都存放在 board&#x2F;freescale 目录下，在这个目录下有个名为 mx6ullevk 的文件夹，这个文件夹就是 NXP 官方 I.MX6ULL EVK 开发板的板级文件夹。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd board/freescale/</span><br><span class="line">cp mx6ullevk/ -r mx6ull_alientek_emmc</span><br><span class="line">cd mx6ull_alientek_emmc</span><br><span class="line">mv mx6ullevk.c mx6ull_alientek_emmc.c</span><br></pre></td></tr></table></figure><p>分别需要修改Makefile文件、imximage.cfg  文件、Kconfig 文件 、MAINTAINERS 文件 </p><p>Makefile要改编译的.o的文件名字。</p><p>imximage.cfg 需要修改PLUGIN 后面的板载二进制文件所在路径。</p><p>Kconfig 文件 需要改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if TARGET_MX6ULL_ALIENTEK_EMMC</span><br><span class="line"></span><br><span class="line">config SYS_BOARD</span><br><span class="line">default &quot;mx6ull_alientek_emmc&quot;</span><br><span class="line"></span><br><span class="line">config SYS_VENDOR</span><br><span class="line">default &quot;freescale&quot;</span><br><span class="line"></span><br><span class="line">config SYS_SOC</span><br><span class="line">default &quot;mx6&quot;</span><br><span class="line"></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line">default &quot;mx6ull_alientek_emmc&quot;</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>MAINTAINERS 文件需改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MX6ULL_ALIENTEK_EMMC BOARD</span><br><span class="line">M: Peng Fan &lt;peng.fan@nxp.com&gt;</span><br><span class="line">S: Maintained</span><br><span class="line">F: board/freescale/mx6ull_alientek_emmc/</span><br><span class="line">F: include/configs/mx6ull_alientek_emmc.h</span><br></pre></td></tr></table></figure><h4 id="修改U-boot图形化配置文件"><a href="#修改U-boot图形化配置文件" class="headerlink" title="修改U-boot图形化配置文件"></a>修改U-boot图形化配置文件</h4><p>修改文件arch&#x2F;arm&#x2F;cpu&#x2F;armv7&#x2F;mx6&#x2F;Kconfig ，207行加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config TARGET_MX6ULL_ALIENTEK_EMMC</span><br><span class="line">bool &quot;Support mx6ull_alientek_emmc&quot;</span><br><span class="line">select MX6ULL</span><br><span class="line">select DM</span><br><span class="line">select DM_THERMAL</span><br></pre></td></tr></table></figure><p>endif前加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &quot;board/freescale/mx6ull_alientek_emmc/Kconfig&quot;</span><br></pre></td></tr></table></figure><h3 id="LCD驱动修改"><a href="#LCD驱动修改" class="headerlink" title="LCD驱动修改"></a>LCD驱动修改</h3><p>一般 uboot 中修改驱动基本都是在 xxx.h 和 xxx.c 这两个文件中进行的， xxx 为板子名称，比如 mx6ull_alientek_emmc.h 和 mx6ull_alientek_emmc.c 这两个文件。<br>一般修改 LCD 驱动重点注意以下几点：<br>①、 LCD 所使用的 GPIO，查看 uboot 中 LCD 的 IO 配置是否正确。<br>②、 LCD 背光引脚 GPIO 的配置。<br>③、 LCD 配置参数是否正确。 </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20204212.png"></p><p>基于使用的lcd设置参数为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.mode= &#123;</span><br><span class="line">.name= &quot;TFT4384&quot;,</span><br><span class="line">.xres           = 800,</span><br><span class="line">.yres           = 480,</span><br><span class="line">.pixclock       = 31746,</span><br><span class="line">.left_margin    = 88,</span><br><span class="line">.right_margin   = 40,</span><br><span class="line">.upper_margin   = 32,</span><br><span class="line">.lower_margin   = 13,</span><br><span class="line">.hsync_len      = 48,</span><br><span class="line">.vsync_len      = 3,</span><br><span class="line">.sync           = 0,</span><br><span class="line">.vmode          = FB_VMODE_NONINTERLACED</span><br></pre></td></tr></table></figure><p>将mx6ull_alientek_emmc.h中的panel进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panel=TFT4384</span><br></pre></td></tr></table></figure><p>之后就可以编译烧录。正常显示出现以下东西。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-22%20133153.png"></p><p>如果没有出现效果，修改环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv panel TFT7016</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>如果只显示NXP没有uboot的版本号，并且报错<strong>no valid bmp image at 88000000</strong>，使用uboot命令清除一下环境变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env default -a</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><h3 id="网络驱动修改"><a href="#网络驱动修改" class="headerlink" title="网络驱动修改"></a>网络驱动修改</h3><p><strong>更换 PHY 芯片以后如何调整网络驱动</strong> </p><p>修改 ENET1 网络驱动的话重点就三点：<br>①、 ENET1 复位引脚初始化。<br>②、 LAN8720A 的器件 ID。<br>③、 LAN8720 驱动 </p><p>ENET2 网络驱动的修改也注意一下三点：<br>①、 ENET2 的复位引脚，从图 33.2.7.2 可以看出， ENET2 的复位引脚 ENET2_RST 接到了<br>I.MX6ULL 的 SNVS_TAMPER8 上。<br>②、 ENET2 所使用的 PHY 芯片器件地址，从图 33.2.7.2 可以看出， PHY 器件地址为 0X1。<br>③、 LAN8720 驱动， ENET1 和 ENET2 都使用的 LAN8720，所以驱动肯定是一样的。 </p><h4 id="网络PHY地址修改"><a href="#网络PHY地址修改" class="headerlink" title="网络PHY地址修改"></a>网络PHY地址修改</h4><p>修改ENETI和ENET2的PHY地址和驱动，ENET1和ENET2的PHY的地址存在mx6ull_alientek_emmc.h中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if (CONFIG_FEC_ENET_DEV == 0)</span><br><span class="line">#define CONFIG_FEC_MXC_PHYADDR 0x2//ENET1的地址改为0x0</span><br><span class="line">#elif (CONFIG_FEC_ENET_DEV == 1)</span><br><span class="line">#define CONFIG_FEC_MXC_PHYADDR 0x1//ENET2的地址相同不用改</span><br><span class="line">#define CONFIG_PHY_MICREL //使用 LAN8720A则改为CONFIG_PHY_SMSC</span><br></pre></td></tr></table></figure><p>因为两个板子的复位引脚不同。删除之前为了复位的扩展IO的代码，在mx6ull_alientek_emmc.c中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define IOX_SDI IMX_GPIO_NR(5, 10)</span><br><span class="line">#define IOX_STCP IMX_GPIO_NR(5, 7)</span><br><span class="line">#define IOX_SHCP IMX_GPIO_NR(5, 11)</span><br><span class="line">#define IOX_OE IMX_GPIO_NR(5, 8)</span><br></pre></td></tr></table></figure><p>替换为自己使用板子的网络复位IO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ENET1_RESET IMX_GPIO_NR(5, 7)</span><br><span class="line">#define ENET2_RESET IMX_GPIO_NR(5, 8)</span><br></pre></td></tr></table></figure><p>删除原有结构体和函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">iomux_v3_cfg_t</span> <span class="type">const</span> iox_pads[] = &#123;</span><br><span class="line"><span class="comment">/* IOX_SDI */</span></span><br><span class="line">MX6_PAD_BOOT_MODE0__GPIO5_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line"><span class="comment">/* IOX_SHCP */</span></span><br><span class="line">MX6_PAD_BOOT_MODE1__GPIO5_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line"><span class="comment">/* IOX_STCP */</span></span><br><span class="line">MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line"><span class="comment">/* IOX_nOE */</span></span><br><span class="line">MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">iox74lv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">gpio_direction_output(IOX_OE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">gpio_direction_output(IOX_SHCP, <span class="number">0</span>);</span><br><span class="line">gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="number">0</span>]);</span><br><span class="line">udelay(<span class="number">500</span>);</span><br><span class="line">gpio_direction_output(IOX_SHCP, <span class="number">1</span>);</span><br><span class="line">udelay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* shift register will be output to pins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">gpio_direction_output(IOX_STCP, <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iox74lv_set</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">gpio_direction_output(IOX_SHCP, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (i == index)</span><br><span class="line">gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">gpio_direction_output(IOX_SDI, seq[qn_output[i]][<span class="number">1</span>]);</span><br><span class="line">udelay(<span class="number">500</span>);</span><br><span class="line">gpio_direction_output(IOX_SHCP, <span class="number">1</span>);</span><br><span class="line">udelay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* shift register will be output to pins</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">gpio_direction_output(IOX_STCP, <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>删掉板子初始化函数中的相关程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">board_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));<span class="comment">//删掉</span></span><br><span class="line">iox74lv_init();<span class="comment">//删掉</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加自己开发板的网络复位引脚驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">iomux_v3_cfg_t</span> <span class="type">const</span> fec1_pads[] = </span><br><span class="line">&#123;</span><br><span class="line">MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),</span><br><span class="line">MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">...</span><br><span class="line">MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL), <span class="comment">//新加的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">iomux_v3_cfg_t</span> <span class="type">const</span> fec2_pads[] = </span><br><span class="line">&#123;</span><br><span class="line">MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),</span><br><span class="line">MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">...</span><br><span class="line">MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),<span class="comment">//新加的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改初始化网络IO的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_iomux_fec</span><span class="params">(<span class="type">int</span> fec_id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fec_id == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">imx_iomux_v3_setup_multiple_pads(fec1_pads,ARRAY_SIZE(fec1_pads));</span><br><span class="line">gpio_direction_output(ENET1_RESET, <span class="number">1</span>);</span><br><span class="line">gpio_set_value(ENET1_RESET, <span class="number">0</span>);</span><br><span class="line">mdelay(<span class="number">20</span>);</span><br><span class="line">gpio_set_value(ENET1_RESET, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(fec2_pads,ARRAY_SIZE(fec2_pads));</span><br><span class="line">gpio_direction_output(ENET2_RESET, <span class="number">1</span>);</span><br><span class="line">gpio_set_value(ENET2_RESET, <span class="number">0</span>);</span><br><span class="line">mdelay(<span class="number">20</span>);</span><br><span class="line">gpio_set_value(ENET2_RESET, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 drivers&#x2F;net&#x2F;phy&#x2F;phy.c 文件中的函数 genphy_update_link </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">genphy_update_link</span><span class="params">(<span class="keyword">struct</span> phy_device *phydev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mii_reg;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PHY_SMSC</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lan8720_flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> bmcr_reg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (lan8720_flag == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);</span><br><span class="line">phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);</span><br><span class="line"><span class="keyword">while</span>(phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR) &amp; <span class="number">0X8000</span>) </span><br><span class="line">        &#123;</span><br><span class="line">udelay(<span class="number">100</span>);</span><br><span class="line"> &#125;</span><br><span class="line">phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg);</span><br><span class="line">lan8720_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Wait if the link is up, and autonegotiation is in progress</span></span><br><span class="line"><span class="comment"> * (ie - we&#x27;re capable and it&#x27;s not done)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就在Uboot中设置环境变量网址就可以应用了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot启动流程</title>
      <link href="/2023/03/17/2023-3-17-U-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/03/17/2023-3-17-U-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Uboot顶层Makefile详解"><a href="#Uboot顶层Makefile详解" class="headerlink" title="Uboot顶层Makefile详解"></a>Uboot顶层Makefile详解</h3><p><a href="https://blog.csdn.net/liurunjiang/article/details/107386600#:~:text=U-Boot%20%E9%A1%B6%E5%B1%82%20Makefile%20%E8%AF%A6%E8%A7%A3_River-D%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2%20U-Boot%20%E9%A1%B6%E5%B1%82%20Makefile%20%E8%AF%A6%E8%A7%A31%E3%80%81U-Boot,%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90%E6%88%91%E4%BB%AC%E5%9C%A8%E5%88%86%E6%9E%90%20uboot%20%E6%BA%90%E7%A0%81%E4%B9%8B%E5%89%8D%E4%B8%80%E5%AE%9A%E8%A6%81%E5%85%88%E5%9C%A8%20Ubuntu%20%E4%B8%AD%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%8B%20uboot%20%E6%BA%90%E7%A0%81%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%BC%9A%E7%94%9F%E6%88%90%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6%EF%BC%8C%E8%80%8C%E7%94%9F%E6%88%90%E7%9A%84%E8%BF%99%E4%BA%9B%E6%81%B0%E6%81%B0%E6%98%AF%E5%88%86%E6%9E%90uboot%20%E6%BA%90%E7%A0%81%E4%B8%8D%E5%8F%AF%E6%88%96%E7%BC%BA%E7%9A%84%E6%96%87%E4%BB%B6%E3%80%82">(123条消息) U-Boot 顶层 Makefile 详解_River-D的博客-CSDN博客</a></p><table><thead><tr><th>名字</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>api</td><td>与硬件无关的 API 函数。</td><td>uboot 自带</td></tr><tr><td>arch</td><td>与架构体系有关的代码</td><td>uboot 自带</td></tr><tr><td>board</td><td>不同板子的代码</td><td>uboot 自带</td></tr><tr><td>cmd</td><td>命令相关的代码</td><td>uboot 自带</td></tr><tr><td>common</td><td>通用代码</td><td>uboot 自带</td></tr><tr><td>configs</td><td>配置文件</td><td>uboot 自带</td></tr><tr><td>disk</td><td>磁盘分区相关代码</td><td>uboot 自带</td></tr><tr><td>doc</td><td>文档</td><td>uboot 自带</td></tr><tr><td>drivers</td><td>驱动代码</td><td>uboot 自带</td></tr><tr><td>dts</td><td>设备树</td><td>uboot 自带</td></tr><tr><td>examples</td><td>示例代码</td><td>uboot 自带</td></tr><tr><td>fs</td><td>文件系统</td><td>uboot 自带</td></tr><tr><td>include</td><td>头文件</td><td>uboot 自带</td></tr><tr><td>lib</td><td>库文件</td><td>uboot 自带</td></tr><tr><td>Licenses</td><td>许可证相关代码</td><td>uboot 自带</td></tr><tr><td>net</td><td>网络相关代码</td><td>uboot 自带</td></tr><tr><td>post</td><td>上电自检代码</td><td>uboot 自带</td></tr><tr><td>scripts</td><td>脚本文件</td><td>uboot 自带</td></tr><tr><td>test</td><td>测试代码</td><td>uboot 自带</td></tr><tr><td>tools</td><td>工具文件夹</td><td>uboot 自带</td></tr><tr><td>.config配置文件</td><td>重要的文件</td><td>编译出来的文件</td></tr><tr><td>.gitignore git</td><td>工具相关文件</td><td>uboot 自带</td></tr><tr><td>.mailmap</td><td>邮件列表</td><td>uboot 自带</td></tr><tr><td>.u-boot.xxx.cmd(一系列)</td><td>这是一系列的文件，用于保存着一些命令</td><td>编译出来的文件</td></tr><tr><td>config.mk</td><td>某个Makefile 会调用此文件</td><td>uboot 自带</td></tr><tr><td>imxdownload</td><td>烧写软件</td><td></td></tr><tr><td>Kbuild</td><td>用于生成一些和汇编相关的文件</td><td>uboot 自带</td></tr><tr><td>Kconfig</td><td>图形配置界面描述文件</td><td>uboot 自带</td></tr><tr><td>MAINTAINERS</td><td>维护者联系方式文件</td><td>uboot 自带</td></tr><tr><td>MAKEALL</td><td>一个shell脚本文件，帮助编译uboot</td><td>uboot 自带</td></tr><tr><td>Makefile</td><td>主Makefile</td><td>uboot 自带</td></tr><tr><td>mx6ull_alientek_emmc.sh</td><td>编写的编译脚本文件</td><td></td></tr><tr><td>mx6ull_alientek_nand.sh</td><td>同上</td><td></td></tr><tr><td>README</td><td>帮助文档</td><td>uboot 自带</td></tr><tr><td>snapshot.commint</td><td>？</td><td>uboot 自带</td></tr><tr><td>System.map</td><td>系统映射文件</td><td>编译出来的文件</td></tr><tr><td>u-boot</td><td>编译出来的U-boot文件</td><td>编译出来的文件</td></tr><tr><td>u-boot.xxx(一系列)</td><td>生成一些u-boot相关的文件</td><td>编译出来的文件</td></tr></tbody></table><p>make命令的流程</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-17%20110210.png"></p><h3 id="Uboot启动流程"><a href="#Uboot启动流程" class="headerlink" title="Uboot启动流程"></a>Uboot启动流程</h3><p>1)设置CPU为管理模式<br>2)关看门狗<br>3)关中断<br>4）设置时钟频率<br>5)关mmu,初始化各个bank<br>6)进入board_init_f()函数 (初始化定时器,GPIO,串口等,划分内存区域)<br>7)重定位     复制uboot,然后修改SDRAM上的uboot链接地址)<br>8)清bss<br>9)跳转到board_init_r()函数,启动流程结束<br><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/11c1d307acd641938a58a17230b05bbb.png"></p><p>bootz启动Linux内核过程</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20143309.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6ull SPI控制六轴</title>
      <link href="/2023/03/16/2023-3-15-imx6ull-SPI%E6%8E%A7%E5%88%B6%E5%85%AD%E8%BD%B4/"/>
      <url>/2023/03/16/2023-3-15-imx6ull-SPI%E6%8E%A7%E5%88%B6%E5%85%AD%E8%BD%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>SPI 全称是 Serial Perripheral Interface，也就是串行外围设备接口。是一种高速、<strong>全双工</strong>的同步通信总线，SPI 时钟频率相比 I2C 要高很多，最高可以工作在上百 MHz。</p><p><a href="https://shequ.stmicroelectronics.cn/forum.php?mod=viewthread&tid=627137">SPI原理超详细讲解-值得一看 (stmicroelectronics.cn)</a></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/e84057dcf8574933a3875761dd6002ef.png"></p><p>支持<strong>单主多从模式应用，时钟由Master控制，在时钟移位脉冲下，数据按位传输，高位在前，低位在后（MSB first）。</strong> <strong>4线SPI器件有四个信号：时钟(SPI CLK, SCLK)、主机输出从机输入(MOSI)、主机输入从机输出(MISO)、片选(CS&#x2F;NSS)。</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20150651.png"></p><h3 id="SPI数据传输"><a href="#SPI数据传输" class="headerlink" title="SPI数据传输"></a>SPI数据传输</h3><p>在MOSI、MISO和SPI主从机内部的<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2762981085%7D">数据寄存器</a>构成一个数据串行传输的环路，在时钟SCLK的控制下实现数据的环形传输。 <strong>要开始SPI通信，主机必须发送时钟信号，并通过使能NSS信号选择从机。</strong></p><p><u>SPI只有主模式和从模式之分，没有读和写的说法，外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。</u></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-14%20213838.png"></p><p>SPI 有四种工作模式，通过串行时钟极性(CPOL)和相位(CPHA)的搭配来得到四种工作模式：<br>①、CPOL&#x3D;0，串行时钟空闲状态为低电平。<br>②、CPOL&#x3D;1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具体的传输协议。<br>③、CPHA&#x3D;0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据。<br>④、CPHA&#x3D;1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据。</p><p>主从设备必须使用相同的工作模式——SCLK、CPOL 和 CPHA，才能正常工作。如果有多个从设备，并且它们使用了不同的工作模式，那么主设备必须在读写不同从设备时需要重新修改对应从设备的模式。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20151311.png"></p><p>I.MX6U 自带的 SPI 外设叫做 ECSPI，ESPI特性：</p><p>①、全双工同步串行接口。<br>②、可配置的主&#x2F;从模式。<br>③、四个片选信号，支持多从机。<br>④、发送和接收都有一个 32x64 的 FIFO。<br>⑤、片选信号 SS&#x2F;CS，时钟信号 SCLK 极性可配置。<br>⑥、支持 DMA。</p><p>This section provides initialization information for ECSPI.<br>To initialize the block:</p><ol><li>Clear the EN bit in ECSPI_CONREG to reset the block.</li><li>Enable the clocks for ECSPI within the CCM.</li><li>Configure the Control Register and then set the EN bit in the ECSPI_CONREG to put ECSPI out of reset.</li><li>Configure corresponding IOMUX for ECSPI external signals.</li><li>Configure registers of ECSPI properly according to the specifications of the external SPI device.</li></ol><h3 id="使用的寄存器："><a href="#使用的寄存器：" class="headerlink" title="使用的寄存器："></a>使用的寄存器：</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20161914.png"></p><h3 id="ICM-20608传感器"><a href="#ICM-20608传感器" class="headerlink" title="ICM-20608传感器"></a>ICM-20608传感器</h3><p>陀螺仪具有两个特性：一个空间的刚性，一个行进性。<em><strong>螺仪就是测角速度的，加速度传感器就是测角加速度的，二者数据通过算法就可以得到PITCH、YAW、ROLL角了。</strong></em>关于陀螺仪传感器原理可看以下链接<a href="https://www.bilibili.com/video/BV1YK411A7HU/?spm_id_from=333.337.search-card.all.click&vd_source=a29cba237e61c1d3e1d8193673a58e41">解密手机陀螺仪原理_哔哩哔哩_bilibili</a></p><p>ICM-20608 内部有一个 512字节的 FIFO。陀螺仪的量程范围可以编程设置，可选择±250，±500，±1000 和±2000°&#x2F;s，加速度的量程范围也可以编程设置，可选择±2g，±4g，±8g 和±16g。陀螺仪和加速度计都是 16 位的 ADC，并且支持 I2C 和 SPI 两种协议，具有以下特点：</p><p>①、陀螺仪支持 X,Y 和 Z 三轴输出，内部集成 16 位 ADC，测量范围可设置：±250，±500，±1000 和±2000°&#x2F;s。<br>②、加速度计支持 X,Y 和 Z 轴输出，内部集成 16 位 ADC，测量范围可设置：±2g，±4g，±4g，±8g 和±16g。<br>③、用户可编程中断。<br>④、内部包含 512 字节的 FIFO。<br>⑤、内部包含一个数字温度传感器。<br>⑥、耐 10000g 的冲击。<br>⑦、支持快速 I2C，速度可达 400KHz。<br>⑧、支持 SPI，速度可达 8MHz。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-16%20142813.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git提交代码到远程仓库</title>
      <link href="/2023/03/16/2023-3-16-git%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2023/03/16/2023-3-16-git%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="git如何提交代码到远程仓库"><a href="#git如何提交代码到远程仓库" class="headerlink" title="git如何提交代码到远程仓库"></a>git如何提交代码到远程仓库</h2><p>使用这个的原因的是看到有的嵌入式就职询问会问道，而且使用git可以将本地代码部署到github，可以备份，多台电脑开发一个工程很方便。</p><p>首先是进行安装git再Linux的系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>注册用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>检查配置信息的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p><strong>下载代码</strong></p><p>使用git clone从现有的git仓库中拷贝项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-16%20132517.png"></p><p>如果克隆到指定目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址 目录</span><br></pre></td></tr></table></figure><p>如果git clone卡住了，可以参考以下链接<a href="https://zhuanlan.zhihu.com/p/557331130#:~:text=git%20clone%20%E7%89%B9%E5%88%AB%E6%85%A2%E6%98%AF%E7%94%B1%E4%BA%8E%20github.global.ssl.fastly.net%20%E5%92%8C%20github.com%20%E5%9F%9F%E5%90%8D%E8%A2%AB%E9%99%90%E5%88%B6%E4%BA%86%EF%BC%8C%E6%89%80%E4%BB%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%9D%E8%B7%AF%E5%B0%B1%E6%98%AF,%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%AA%E5%9F%9F%E5%90%8D%E5%AF%B9%E5%BA%94%E7%9A%84ip%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%88%91%E4%BB%AC%E6%9C%BA%E5%99%A8%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%8A%A0%E4%B8%8A%20ip%20-%3E%20%E5%9F%9F%E5%90%8D%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%88%B7%E6%96%B0%20DNS%20%E7%BC%93%E5%AD%98%E5%8D%B3%E5%8F%AF%20%E3%80%82">极智开发 | 解决 linux 上 git clone 慢或失败的方法 - 知乎 (zhihu.com)</a></p><p><strong>上传代码</strong></p><p>初始化本地仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>之后就可以往这个目录中写入文件，之后使用以下命令进行部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">这个命令是将目录下的所有文件添加到暂存区域</span><br><span class="line">git add 文件名</span><br><span class="line">添加文件到暂存库</span><br><span class="line">git status</span><br><span class="line">查看仓库当前的状态，显示变更的文件</span><br><span class="line">git log</span><br><span class="line">查看提交历史</span><br><span class="line">git commit</span><br><span class="line">添加文件到本地库</span><br><span class="line">git commit -m &quot;备注&quot;</span><br><span class="line">添加文件到本地库并写上备注</span><br><span class="line">git remote add origin 仓库地址</span><br><span class="line">git push -u origin master</span><br><span class="line">就可以部署了</span><br></pre></td></tr></table></figure><p>如果git push弹出账号和密码的输入，就需要填写用户信息，以及github的token，因为最近的版本的只允许使用token禁用了密码，如果想免除每次输入token的问题</p><p>可以使用以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p>之后一直回车</p><p>最后查看生成的id_rsa.pub文件内容，将其添加到GitHub中，形成私钥。</p><p>如果git push 失败那么，使用指令进行重置代理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global  --unset http.https://github.com.proxy </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Imx6ull数据手册生词</title>
      <link href="/2023/03/14/2023-3-14-Imx6ull%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E7%94%9F%E8%AF%8D/"/>
      <url>/2023/03/14/2023-3-14-Imx6ull%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%E7%94%9F%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>生词</th><th>汉译</th></tr></thead><tbody><tr><td>prescaler</td><td>预分频器</td></tr><tr><td>programmable</td><td>可编程</td></tr><tr><td>route</td><td>线路</td></tr><tr><td>formula</td><td>公式</td></tr><tr><td>subroutine</td><td>子程序</td></tr><tr><td>reprogram</td><td>重新编程</td></tr><tr><td>parameter</td><td>参数</td></tr><tr><td>slave</td><td>从机</td></tr><tr><td>arbitration</td><td>仲裁</td></tr><tr><td>addressed</td><td>解决</td></tr><tr><td>multiplexing</td><td>多路复用</td></tr><tr><td>acknowledge signal</td><td>应答信号</td></tr><tr><td>master drive high</td><td>主驱动器高</td></tr><tr><td>pending</td><td>待定</td></tr><tr><td>idle</td><td>闲置</td></tr><tr><td>muxe</td><td>多路复用器</td></tr><tr><td>peripheral</td><td>外设</td></tr><tr><td>dedicated software</td><td>专用软件</td></tr><tr><td>daisy chain</td><td>菊花链式结构</td></tr><tr><td>external</td><td>外部</td></tr><tr><td>diagram</td><td>图</td></tr><tr><td>synchronize</td><td>同步</td></tr><tr><td>field</td><td>场</td></tr><tr><td>initialize the counter</td><td>初始化计数器</td></tr><tr><td>duplex</td><td>双工</td></tr><tr><td>synchronous</td><td>同步</td></tr><tr><td>polarity</td><td>极性</td></tr><tr><td>FIFO</td><td>先进先出</td></tr><tr><td>kernel</td><td>内核</td></tr><tr><td>relocaddr</td><td>搬迁地址</td></tr><tr><td>bracket</td><td>把。。。分类</td></tr><tr><td>framebuffer</td><td>帧缓存</td></tr><tr><td>alignment</td><td>队列</td></tr><tr><td>alloc</td><td>分配内存</td></tr><tr><td>miscellaneous</td><td>杂项</td></tr><tr><td>modularize</td><td>模块化</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6ull的IIC实验</title>
      <link href="/2023/03/13/2023-3-13-imx6ull%E7%9A%84IIC%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/03/13/2023-3-13-imx6ull%E7%9A%84IIC%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h2><p>IIC是半双工通信（同一时间单向通信），I2C 使用两条线在主控制器和从机之间进行数据通信。一条是 SCL(串行时钟线)，另外一条是 SDA(串行数据线)，这两条数据线需要接上拉电阻，总线空闲的时候 SCL 和 SDA 处于高电平。I2C 总线标准模式下速度可以达到 100Kb&#x2F;S，快速模式下可以达到 400Kb&#x2F;S。I2C 总线工作是按照一定的协议来运行的，接下来就看一下 I2C 协议。</p><p>主机就是负责整个系统的任务协调与分配，从机一般是通过接收主机的指令从而完成某些特定的任务，主机和从机之间通过总线连接，进行数据通讯。</p><ul><li>发布主要命令的称为主机</li><li>接受命令的称为从机</li></ul><p>IIC主设备功能：主要产生时钟，产生起始信号，停止信号。</p><p>IIC从设备功能：可编程的IIC地址检测，停止位检测。</p><p>**IIC的一个优点是它支持多主控(multimastering)**， 其中任何一个能够进行发送和接收的设备都可以成为主总线。一个主控能够控制信号的传输和时钟频率。当然，在任何时间点上只能有一个主控。</p><p>I2C是支持多从机应答，也就是一个 I2C 控制器下可以挂多个 I2C 从设备，这些不同的 I2C从设备有不同的器件地址，这样 I2C 主控制器就可以通过 I2C 设备的器件地址访问指定的 I2C设备了，</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-11%20145203.png"></p><p>I2C协议</p><p>起始信号：在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位。</p><p>终止信号：停止位就是停止 I2C 通信的标志位，和起始位的功能相反。在 SCL 位高电平的时候，SDA出现上升沿就表示为停止位。</p><p>数据传输：I2C 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，因此 SDA 上的数据变化只能在 SCL 低电平期间发生</p><p>应答信号：当 I2C 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 I2C 从机应答，也就是等到 I2C 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。</p><h2 id="IIC写数据"><a href="#IIC写数据" class="headerlink" title="IIC写数据"></a>IIC写数据</h2><p>写时序</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-11%20153434.png"></p><p>起始信号-&gt;器件地址（7位地址加一个读写位）-&gt;等待应答-&gt;要操作内存的地址-&gt;等待应答-&gt;写入数据-&gt;等待应答-&gt;停止读时序</p><p>主机向从机写数据时候；</p><p>1.主机产生起始信号；</p><p>2.然后紧跟着发送一个地址，地址一共有7位，紧跟着第8位是数据方向位，0表示主机发送数据，1表示主机接受数据（读）；</p><p>3.主机发送地址时，总线上的每个从机都将7位地址位与自己的地址比较，相同代表正在被主机寻址，根据R&#x2F;T位将自己确定为发送器或者接收器；</p><p>4.这时主机等待从机的应答信号（A）；</p><p>5.当主机收到应答信号时，发送要访问从机的那个地址，继续等待从机的应答信号；</p><p>6.当主机收到应答信号时，发送N个字节的数据，继续等待从机的N次应答信号；</p><p>7.主机产生停止信号，结束传输过程。</p><h2 id="IIC读数据"><a href="#IIC读数据" class="headerlink" title="IIC读数据"></a>IIC读数据</h2><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-11%20153441.png"></p><p>起始信号-&gt;器件地址(7+1位写（0）)-&gt;应答-&gt;读取地址-&gt;应答-&gt;起始信号-.&gt;器件地址（7位+读（1））-&gt;应答-&gt;读取数据-&gt;发送应答-&gt;停止信号</p><p>1.主机产生起始信号；</p><p>2.然后紧跟着发送一从机个地址，地址一共有7位，第8位为0，表明是向从机写命令；</p><p>3.主机等待从机的应答信号（ACK）；</p><p>4.这时主机收到从机的应答信号（A），发送要访问的地址，继续等待从机的应答信号；</p><p>5.当主机收到应答信号后，主机要改变通信模式（主机将由发送变为接受，从机将由接受变为发送）所以主机重新发送一个起始信号，之后紧接着发送一个从机地址，此时该地址第8位为1，表明将主机设置成接受模式开始读取数据；</p><p>6.这时候主机等待从机的应答信号，当主机收到应答信号时， 就可以接受1个字节数据，当接受完成后， 主机发送非应答信号时候，表示不在接受数据；</p><p>7.主机产生停止信号，结束传输过程。</p><h3 id="使用的寄存器"><a href="#使用的寄存器" class="headerlink" title="使用的寄存器"></a>使用的寄存器</h3><p>IIC的地址寄存器 I2Cx_IADR(x&#x3D;1<del>4)寄存器，(x&#x3D;1</del>4)寄存器，这是I2C 的地址寄存器，只有 ADR(bit7:1)位有效，</p><p>用来保存 I2C 从设备地址数据。</p><p>I2C Frequency Divider Register (I2C1_IFDR) ：IC(bit5:0)这个位，用来设置 I2C 的波特率，I2C 的时钟源可以选择 IPG_CLK_ROOT&#x3D;66MHz，通过设置 IC 位既可以得到想要的 I2C 波特率。</p><p>&#x3D;&#x3D;<strong>时钟源&#x3D;IC设置的分频值*波特率。</strong>&#x3D;&#x3D;</p><p>I2C Control Register (I2C1_I2CR) </p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-11%20172654.png"></p><p>IEN(bit7)：I2C 使能位，为 1 的时候使能 I2C，为 0 的时候关闭 I2C。<br>IIEN(bit6)：I2C 中断使能位，为 1 的时候使能 I2C 中断，为 0 的时候关闭 I2C 中断。<br>MSTA(bit5)：主从模式选择位，设置 IIC 工作在主模式还是从模式，为 1 的时候工作在主<br>模式，为 0 的时候工作在从模式。<br>MTX(bit4)：传输方向选择位，用来设置是进行发送还是接收，为 0 的时候是接收，为 1 的<br>时候是发送。<br>TXAK(bit3)：传输应答位使能，为 0 的话发送 ACK 信号，为 1 的话发送 NO ACK 信号。<br>RSTA(bit2)：重复开始信号，为 1 的话产生一个重新开始信号。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-11%20173313.png"></p><p>ICF(bit7)：数据传输状态位，为 0 的时候表示数据正在传输，为 1 的时候表示数据传输完成。<br>IAAS(bit6)：当为 1 的时候表示 I2C 地址，也就是 I2Cx_IADR 寄存器中的地址是从设备地址。<br>IBB(bit5)：I2C 总线忙标志位，当为 0 的时候表示 I2C 总线空闲，为 1 的时候表示 I2C 总线忙。<br>IAL(bit4)：仲裁丢失位，为 1 的时候表示发生仲裁丢失。<br>SRW(bit2)：从机读写状态位，当 I2C 作为从机的时候使用，此位用来表明主机发送给从机的是读还是写命令。为 0 的时候表示主机要向从机写数据，为 1 的时候表示主机要从从机读取数据。<br>IIF(bit1)：I2C 中断挂起标志位，当为 1 的时候表示有中断挂起，此位需要软件清零。<br>RXAK(bit0)：应答信号标志位，为 0 的时候表示接收到 ACK 应答信号，为 1 的话表示检测到 NO ACK 信号。</p><p>I2C Data I&#x2F;O Register (I2C1_I2DR) ，这是 I2C 的数据寄存器，此寄存器只有低 8 位有效，当要发送数据的时候将要发送的数据写入到此寄存器，如果要接收数据的话直接读取此寄存器即可得到接收到的数据。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20112239.png"></p><h2 id="硬件IIC和软件IIC"><a href="#硬件IIC和软件IIC" class="headerlink" title="硬件IIC和软件IIC"></a>硬件IIC和软件IIC</h2><p>所谓硬件I2C对应芯片上的I2C外设，有相应I2C驱动电路，其所使用的I2C管脚也是专用的；软件I2C一般是用GPIO管脚，用软件控制管脚状态以模拟I2C通信波形。</p><p>硬件I2C的效率要远高于软件的，而软件I2C由于不受管脚限制，接口比较灵活。</p><p>至于如何区分它们：<br>可以看底层配置，比如IO口配置，如果配置了IO口的功能（IIC功能）那就是固件IIC，否则就是模拟。<br>可以看IIC写函数，看里面有木有调用现成的函数或者给某个寄存器赋值，如果有，则肯定是固件IIC功能，没有的话肯定是数据一个bit一个bit模拟发生送的，肯定用到了循环，则为模拟。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6ull的RTC 实时时钟实验</title>
      <link href="/2023/03/10/2023-3-20-imx6ull%E7%9A%84RTC-%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/03/10/2023-3-20-imx6ull%E7%9A%84RTC-%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="实时时钟实现原理"><a href="#实时时钟实现原理" class="headerlink" title="实时时钟实现原理"></a>实时时钟实现原理</h4><p>I.MX6U 系列的 RTC 是在 SNVS 里面，SNVS 直译过来就是安全的非易性存储，SNVS 里面主要是一些低功耗的外设，包括一个安全的实时计数器(RTC)、一个单调计数器(monotonic counter)和一些通用的寄存器。SNVS 有两部分：SNVS_HP 和 SNVS_LP，系统主电源断电以后 SNVS_HP 也会断电，但是在后备电源支持下，SNVS_LP 是不会断电的，而且 SNVS_LP是和芯片复位隔离开的，因此 SNVS_LP 相关的寄存器的值会一直保存着。</p><p>①、SNVS_LP：专用的always-powered-on电源域，系统主电源和备用电源都可以为其供电。<br>②、SNVS_HP：系统（芯片）电源。</p><p>SNVS_LP和SNVS_LP都有SRTC，为保证掉电后依旧可以执行，所以设置SNVS_LP中的SRTC来实现实时时钟。</p><p>在硬件方面，SRTC需要外界提供一个32.768KHz的时钟，寄存器 SNVS_LPSRTCMR 和 SNVS_LPSRTCLR 保存着秒数，直接读取这两个寄存器的值就知道过了多长时间了。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-10%20135947.png"></p><h4 id="使用的SNVS寄存器："><a href="#使用的SNVS寄存器：" class="headerlink" title="使用的SNVS寄存器："></a>使用的SNVS寄存器：</h4><p><strong>①</strong>SNVS_HPCOMR</p><p>NPSWA_EN(bit31)，这个位是非特权软件访问控制位，如果非特权软件要访问 SNVS 的话此位必须为 1</p><p><strong>②</strong>SNVS_LPCR</p><p>SRTC_ENV(bit0)，此位为 1 的话就使能 STC 计数器。</p><p><strong>③</strong>SNVS_SRTCMR</p><p>SNVS_SRTCMR 的 bit14:0 这 15 位是 SRTC 计数器的高 15 位。</p><p><strong>④</strong>SNVS_SRTCLR</p><p>SNVS_SRTCLR 的 bit31:bit15 这 17 位是 SRTC 计数器的低 17 位。</p><h4 id="使能SRTC的配置如下："><a href="#使能SRTC的配置如下：" class="headerlink" title="使能SRTC的配置如下："></a><strong>使能SRTC的配置如下：</strong></h4><p>（1）初始化SNVS_SRTC<br>     初始化SNVS_LP中的SRTC。<br>（2）设置RTC时间<br>     第一次使用RTC肯定要先设置时间。<br>（3）使能RTC<br>     配置好RTC并设置好初始时间以后就可以开启RTC了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补充知识点</title>
      <link href="/2023/03/07/2023-3-06-%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/03/07/2023-3-06-%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="嵌入式面向对象编程"><a href="#嵌入式面向对象编程" class="headerlink" title="嵌入式面向对象编程"></a>嵌入式面向对象编程</h3><p>面向对象，是编程界的一个概念。什么叫面向对象呢？编程有两种要素：程序（方法），数据（属性）。例如：一个LED，我们可以点亮或者熄灭它，这叫方法。LED什么状态？亮还是灭？这就是属性。我们通常这样编程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u8 ledsta = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ledset</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的编程有一个问题，假如我们有10个这样的LED，怎么写？这时我们可以引入面向对象编程，将每一个LED封装为一个对象。可以这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个结构体，将LED这个对象的属性跟方法封装。</span></span><br><span class="line"><span class="comment">这个结构体就是一个对象。</span></span><br><span class="line"><span class="comment">但是这个不是一个真实的存在，而是一个对象的抽象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u8 sta;</span><br><span class="line"><span class="type">void</span> (*setsta)(u8 sta);</span><br><span class="line">&#125;LedObj;</span><br><span class="line"><span class="comment">/* 声明一个LED对象，名称叫做LED1，并且实现它的方法drv_led1_setsta*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">drv_led1_setsta</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LedObj LED1=&#123;</span><br><span class="line"></span><br><span class="line">.sta = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">.setsta = drv_led1_setsta,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明一个LED对象，名称叫做LED2，并且实现它的方法drv_led2_setsta*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drv_led2_setsta</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LedObj LED2=&#123;</span><br><span class="line"></span><br><span class="line">.sta = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">.setsta = drv_led2_setsta,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 操作LED的函数，参数指定哪个led*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ledset</span><span class="params">(LedObj *led, u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">led-&gt;setsta(sta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，在C语言中，实现面向对象的手段就是结构体的使用。上面的代码，对于API来说，就很友好了。操作所有LED，使用同一个接口，只需告诉接口哪个LED。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u的RGBlCD显示</title>
      <link href="/2023/03/06/2023-3-06-imx6u%E7%9A%84RGBlCD%E6%98%BE%E7%A4%BA/"/>
      <url>/2023/03/06/2023-3-06-imx6u%E7%9A%84RGBlCD%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="像素格式"><a href="#像素格式" class="headerlink" title="像素格式"></a>像素格式</h3><p>一个像素点就相当于一个 RGB 小灯，通过控制 R、G、B 这三种颜色的亮度就可以显示出各种各样的色彩。那该如何控制 R、G、B 这三种颜色的显示亮度呢？一般一个 R、G、B 这三部分分别使用 8bit 的数据，那么一个像素点就是 8bit*3&#x3D;24bit，也就是说一个像素点3 个字节，这种像素格式称为 RGB888。如果再加入 8bit 的 Alpha(透明)通道的话一个像素点就是 32bit，也就是 4 个字节，这种像素格式称为 ARGB8888。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20140301.png"></p><p>一个像素点是 4 个字节，其中 bit31<del>bit24 是 Alpha 通道，bit23</del>bit16 是RED 通道，bit15<del>bit14 是 GREEN 通道，bit7</del>bit0 是 BLUE 通道。所以红色对应的值就是0X00FF0000，蓝色对应的值就是 0X000000FF，绿色对应的值为 0X0000FF00。通过调节 R、G、B的比例可以产生其它的颜色，比如0X00FFFF00就是黄色，0X00000000就是黑色，0X00FFFFFF就是白色。</p><p>R[7:0]、G[7:0]和B[7:0]这24根是数据线，DE、VSYNC、HSYNC 和 PCLK 这四根是控制信号线。RGB LCD 一般有两种驱动模式：DE 模式和 HV 模式，这两个模式的区别是 DE 模式需要用到 DE 信号线，而 HV 模式不需要用到 DE 信号线，在 DE模式下是可以不需要 HSYNC 信号线的，即使不接 HSYNC 信号线 LCD 也可以正常工作。</p><h3 id="lcd显示过程"><a href="#lcd显示过程" class="headerlink" title="lcd显示过程"></a><a href="https://www.cnblogs.com/fah936861121/articles/7116400.html">lcd显示过程</a></h3><h3 id="RGBLCD屏幕时序"><a href="#RGBLCD屏幕时序" class="headerlink" title="RGBLCD屏幕时序"></a>RGBLCD屏幕时序</h3><p>行显示时序图片：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20142928.png"></p><p>HSYNC：行同步信号，当此信号有效的话就表示开始显示新的一行数据，查阅所使用的LCD 数据手册可以知道此信号是低电平有效还是高电平有效，假设此时是低电平有效。<br>HSPW：有些地方也叫做 thp，是 HSYNC 信号宽度，也就是 HSYNC 信号持续时间。HSYNC信号不是一个脉冲，而是需要持续一段时间才是有效的，单位为 CLK。<br>HBP：有些地方叫做 thb，前面已经讲过了，术语叫做行同步信号后肩，单位是 CLK。<br>HOZVAL：有些地方叫做 thd，显示一行数据所需的时间，假如屏幕分辨率为 1024*600，那么 HOZVAL 就是 1024，单位为 CLK。<br>HFP：有些地方叫做 thf，术语叫做行同步信号前肩，单位是 CLK。当 HSYNC 信号发出以后，需要等待 HSPW+HBP 个 CLK 时间才会接收到真正有效的像素数据。当显示完一行数据以后需要等待 HFP 个 CLK 时间才能发出下一个 HSYNC 信号，所以显示一行所需要的时间就是：HSPW + HBP + HOZVAL + HFP。<br>一帧图像就是由很多个行组成的，</p><p>帧显示时序图片：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20143953.png"></p><p>VSYNC：帧同步信号，当此信号有效的话就表示开始显示新的一帧数据，查阅所使用的<br>LCD 数据手册可以知道此信号是低电平有效还是高电平有效，假设此时是低电平有效。<br>VSPW：有些地方也叫做 tvp，是 VSYNC 信号宽度，也就是 VSYNC 信号持续时间，单位为 1 行的时间。<br>VBP：有些地方叫做 tvb，前面已经讲过了，术语叫做帧同步信号后肩，单位为 1 行的时间。<br>LINE：有些地方叫做 tvd，显示一帧有效数据所需的时间，假如屏幕分辨率为 1024*600，那么 LINE 就是 600 行的时间。<br>VFP：有些地方叫做 tvf，前面已经讲过了，术语叫做帧同步信号前肩，单位为 1 行的时间。显示一帧所需要的时间就是：VSPW+VBP+LINE+VFP 个行时间</p><p><strong>最终的计算公式：</strong><br>T &#x3D; (VSPW+VBP+LINE+VFP) * (HSPW + HBP + HOZVAL + HFP)</p><p>4.3寸屏幕参数：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20212722.png"></p><p>显示一帧图像所要的时钟数为</p><p>&#x3D; (VSPW+VBP+LINE+VFP) * (HSPW + HBP + HOZVAL + HFP)</p><p>&#x3D;(480+3+32+13)*(48+88+800+40)&#x3D;515328</p><p>显示一帧图像需要515328个时钟数，那么显示60帧就是：515328 * 60 &#x3D; 30,919,680≈31M，所以像素时钟就是 31MHz。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20144933.png"></p><p>①、此部分是一个选择器，用于选择哪个 PLL 可以作为 LCDIF 时钟源，由寄存器CCM_CSCDR2 的位 LCDIF1_PRE_CLK_SEL(bit17:15)来决定，LCDIF1_PRE_CLK_SEL 选择设置如表</p><table><thead><tr><th align="center">值</th><th>时钟源</th></tr></thead><tbody><tr><td align="center">0</td><td>PLL2 作为 LCDIF 的时钟源。</td></tr><tr><td align="center">1</td><td>PLL3_PFD3 作为 LCDIF 的时钟源。</td></tr><tr><td align="center">2</td><td>PLL5 作为 LCDIF 的时钟源。</td></tr><tr><td align="center">3</td><td>PLL2_PFD0 作为 LCDIF 的时钟源。</td></tr><tr><td align="center">4</td><td>PLL2_PFD1 作为 LCDIF 的时钟源。</td></tr><tr><td align="center">5</td><td>PLL3_PFD1 作为 LCDIF 的时钟源。</td></tr></tbody></table><p>②、此部分是 LCDIF 时钟的预分频器，由寄存器 CCM_CSCDR2 的位 LCDIF1_PRED 来决定预分频值。可设置值为 0<del>7，分别对应 1</del>8 分频。<br>③、此部分进一步分频，由寄存器 CBCMR 的位 LCDIF1_PODF 来决定分频值。可设置值为 0<del>7，分别对应 1</del>8 分频。<br>④、此部分是一个选择器，选择 LCDIF 最终的根时钟，由寄存器 CSCDR2 的位LCDIF1_CLK_SEL 决定，LCDIF1_CLK_SEL 选择设置如表</p><table><thead><tr><th align="center">值</th><th align="left">时钟源</th></tr></thead><tbody><tr><td align="center">0</td><td align="left">前面复用器出来的时钟，也就是前面 PLL5 出来的时钟作<br/>为 LCDIF 的根时钟。</td></tr><tr><td align="center">1</td><td align="left">ipp_di0_clk 作为 LCDIF 的根时钟。</td></tr><tr><td align="center">2</td><td align="left">ipp_di1_clk 作为 LCDIF 的根时钟。</td></tr><tr><td align="center">3</td><td align="left">ldb_di0_clk 作为 LCDIF 的根时钟。</td></tr><tr><td align="center">4</td><td align="left">ldb_di1_clk 作为 LCDIF 的根时钟。</td></tr></tbody></table><p>定选择 PLL5 出来的那一路时钟作为 LCDIF 的根时钟，因此 LCDIF1_CLK_SEL 设置为 0。LCDIF 既然选择了 PLL5 作为时钟源，那么还需要初始化 PLL5，LCDIF 的时钟是由PLL5 和接口时钟图片②、③这两个分频值决定的，</p><p><strong>PLL5_CLK &#x3D; OSC24M * (loopDivider + (denominator &#x2F; numerator)) &#x2F; postDivider</strong></p><p>设置为24*（1+7&#x2F;8）&#x2F;1&#x3D;45</p><p>②和③进一步分频，设置②中为 1 分频，也就是寄存器 CCM_CSCDR2 的位 LCDIF1_PRED(bit14:12)为 0。设置③中为 5 分频，就是寄存器CCM_CBCMR 的位 LCDIF1_PODF(bit25:23)为 4。设置好以后最终进入到 LCDIF 的时钟频率就是：45&#x2F;1&#x2F;5 &#x3D;9MHz，这就是我们需要的像素时钟频率。</p><h3 id="显存"><a href="#显存" class="headerlink" title="显存"></a>显存</h3><p>如果采用 ARGB8888 格式的话一个像素需要 4 个字节的内存来存放像素数据，那么 1024<em>600 分辨率就需要 1024</em>600*4&#x3D;2457600B≈2.4MB 内存。但是 RGB LCD 内部是没有内存的，所以就需要在开发板上的 DDR3 中分出一段内存作为 RGB LCD 屏幕的显存，我们如果要在屏幕上显示什么图像的话直接操作这部分显存即可。</p><h3 id="eLCDIF-接口"><a href="#eLCDIF-接口" class="headerlink" title="eLCDIF 接口"></a>eLCDIF 接口</h3><p>eLCDIF 是 I.MX6U 自带的液晶屏幕接口，用于连接 RGB LCD 接口的屏幕，eLCDIF 接口特性如下：</p><p>①、支持 RGB LCD 的 DE 模式。<br>②、支持 VSYNC 模式以实现高速数据传输。<br>③、支持 ITU-R BT.656 格式的 4:2:2 的 YCbCr 数字视频，并且将其转换为模拟 TV 信号。<br>④、支持 8&#x2F;16&#x2F;18&#x2F;24&#x2F;32 位 LCD。</p><p>eLCDIF 支持三种接口：MPU 接口、VSYNC 接口和 DOTCLK 接口，这三种接口区别如下：</p><p>①MPU 接口用于在 I.MX6U 和 LCD 屏幕直接传输数据和命令，这个接口用于 6080&#x2F;8080 接口的 LCD 屏幕，关于 MPU 接口的详细信息以及时序参考《I.MX6ULL 参考手册》第 2150 页的“34.4.6MPU Interface”小节</p><p>⑤VSYNC 接口时序和 MPU 接口时序基本一样，只是多了 VSYNC 信号来作为帧同步，当LCDIF_CTRL 的位 VSYNC_MODE 为 1 的时候此接口使能。关于 VSYNC 接口的详细信息请参考《I.MX6ULL 参考手册》第 2152 页的“34.4.7 VSYNC Interface”小节。</p><p>③DOTCLK 接口就是用来连接 RGB LCD 接口屏幕的， 它包括 VSYNC、HSYNC、DOTCLK和 ENABLE(可选的)这四个信号，这样的接口通常被称为 RGB 接口。</p><h3 id="配置寄存器"><a href="#配置寄存器" class="headerlink" title="配置寄存器"></a>配置寄存器</h3><p><strong>配置eLCDIF接口的寄存器</strong>：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20154312.png"></p><p>SFTRST(bit31)：eLCDIF 软复位控制位，当此位为 1 的话就会强制复位 LCD。<br>CLKGATE(bit30)：正常运行模式下，此位必须为 0！如果此位为 1 的话时钟就不会进入到LCDIF。<br>BYPASS_COUNT(bit19)：如果要工作在 DOTCLK 模式的话就此位必须为 1。<br>VSYNC_MODE(bit18)：此位为 1 的话 LCDIF 工作在 VSYNC 接口模式。<br>DOTCLK_MODE(bit17)：此位为 1 的话 LCDIF 工作在 DOTCLK 接口模式。<br>INPUT_DATA_SWIZZLE(bit15:14)：输入数据字节交换设置，此位为 0 的话不交换字节也就是小端模式；为 1 的话交换所有字节，也就是大端模式；为 2 的话半字交换；为 3 的话在每个半字内进行字节交换。本章我们设置为 0，也就是不使用字节交换。<br>CSC_DATA_SWIZZLE(bit13:12) ： CSC 数 据 字 节 交 换 设 置 ， 交 换 方 式 和INPUT_DATA_SWIZZLE 一样，本章设置为 0，不使用字节交换。<br>LCD_DATABUS_WIDTH(bit11:10)：LCD 数据总线宽度，为 0 的话总线宽度为 16 位；为1 的话总线宽度为 8 位；为 2 的话总线宽度为 18 位；为 3 的话总线宽度为 24 位。本章我们使用 24 位总线宽度。WORD_LENGTH(bit9:8)：输入的数据格式，也就是像素数据宽度，为 0 的话每个像素 16位；为 1 的话每个像素 8 位；为 2 的话每个像素 18 位；为 3 的话每个像素 24 位。<br>MASTER(bit5)：为 1 的话设置 eLCDIF 工作在主模式。<br>DATA_FORMAT_16_BIT(bit3)：当此位为 1 并且 WORD_LENGTH 为 0 的时候像素格式为 ARGB555，当此位为 0 并且 WORD_LENGTH 为 0 的时候像素格式为 RGB565。<br>DATA_FORMAT_18_BIT(bit2)：只有当 WORD_LENGTH 为 2 的时候此位才有效，此位为 0 的话低 18 位有效，像素格式为 RGB666，高 14 位数据无效。当此位为 1 的话高 18 位有效，像素格式依旧是 RGB666，但是低 14 位数据无效。<br>DATA_FORMAT_24_BIT(bit1)：只有当 WORD_LENGTH 为 3 的时候此位才有效，为 0 的时候表示全部的 24 位数据都有效。为 1 的话实际输入的数据有效位只有 18 位，虽然输入的是24 位数据，但是每个颜色通道的高 2 位数据会被丢弃掉。<br>RUN(bit0)：eLCDIF 接口运行控制位，当此位为 1 的话 eLCDIF 接口就开始传输数据，也就是 eLCDIF 的使能位。</p><p>接 下 来 看 一 下 寄 存 器 <strong>LCDIF_CTRL1</strong> ， 此 寄 存 器 我 们 只 用 到 位BYTE_PACKING_FORMAT(bit19:16)，此位用来决定在 32 位的数据中哪些字节的数据有效，默认值为 0XF，也就是所有的字节有效，当为 0 的话表示所有的字节都无效。如果显示的数据是24 位(ARGB 格式，但是 A 通道不传输)的话就设置此位为 0X7。</p><p>接下来看一下寄存器 <strong>LCDIF_TRANSFER_COUNT</strong>，这个寄存器用来设置所连接的 RGB LCD 屏幕分辨率大小，寄存器LCDIF_TRANSFER_COUNT 分为两部分，高16位和低16位，高16位是V_COUNT，是 LCD 的垂直分辨率。低 16 位是 H_COUNT，是 LCD 的水平分辨率。如果 LCD 分辨率为480*272 的话，那么 V_COUNT 就是 272，H_COUNT 就是 480。</p><p>接下来看一下寄存器 <strong>LCDIF_VDCTRL0</strong>，这个寄存器是 VSYNC 和 DOTCLK 模式控制寄存器 0，</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20160914.png"></p><p>VSYNC_OEB(bit29)：VSYNC 信号方向控制位，为 0 的话 VSYNC 是输出，为 1 的话VSYNC 是输入。<br>ENABLE_PRESENT(bit28)：EBABLE 数据线使能位，也就是 DE 数据线。为 1 的话使能ENABLE 数据线，为 0 的话关闭 ENABLE 数据线。<br>VSYNC_POL(bit27)：VSYNC 数据线极性设置位，为 0 的话 VSYNC 低电平有效，为 1 的话 VSYNC 高电平有效，要根据所使用的 LCD 数据手册来设置。<br>HSYNC_POL(bit26)：HSYNC 数据线极性设置位，为 0 的话 HSYNC 低电平有效，为 1 的话 HSYNC 高电平有效，要根据所使用的 LCD 数据手册来设置。<br>DOTCLK_POL(bit25)：DOTCLK 数据线(像素时钟线 CLK) 极性设置位，为 0 的话下降沿锁存数据，上升沿捕获数据，为 1 的话相反，要根据所使用的 LCD 数据手册来设置。<br>ENABLE_POL(bit24)：EANBLE 数据线极性设置位，为 0 的话低电平有效，为 1 的话高电平有效。<br>VSYNC_PERIOD_UNIT(bit21)：VSYNC 信号周期单位，为 0 的话 VSYNC 周期单位为像素时钟。为 1 的话 VSYNC 周期单位是水平行，如果使用 DOTCLK 模式话就要设置为 1。<br>VSYNC_PULSE_WIDTH_UNIT(bit20) ： VSYNC 信 号 脉 冲 宽 度 单 位 ， 和VSYNC_PERIOD_UNUT 一样，如果使用 DOTCLK 模式的话要设置为 1。<br>VSYNC_PULSE_WIDTH(bit17:0)：VSPW 参数设置位。</p><p>看一下寄存器 <strong>LCDIF_VDCTRL1</strong>，这个寄存器是 VSYNC 和 DOTCLK 模式控制寄存器 1，此寄存器只有一个功能用来设置 VSYNC 总周期，就是：屏幕高度+VSPW+VBP+VFP。</p><p>接下来看一下寄存器 <strong>LCDIF_VDCTRL2</strong>，这个寄存器分为高 16 位和低 16 位两部分，高 16位是HSYNC_PULSE_WIDTH，用来设置 HSYNC 信号宽度，也就是 HSPW。低 16 位是HSYNC_PERIOD，设置 HSYNC 总周期，就是：屏幕宽度+HSPW+HBP+HFP。</p><p>看一下寄存器 <strong>LCDIF_VDCTRL3</strong>，HORIZONTAL_WAIT_CNT(bit27:16)：此位用于 DOTCLK 模式，用于设置 HSYNC 信号产生到有效数据产生之间的时间，也就是 HSPW+HBP。<br>VERTICAL_WAIR_CNT(bit15:0)：和 HORIZONTAL_WAIT_CNT 一样，只是此位用于VSYNC 信号，也就是 VSPW+VBP。</p><p>接下来看一下寄存器 <strong>LCDIF_VDCTRL4</strong>，寄存器 LCDIF_VDCTRL4 用到的重要位如下：<br>SYNC_SIGNALS_ON(bit18)：同步信号使能位，设置为 1 的话使能 VSYNC、HSYNC、DOTCLK 这些信号。<br>DOTCLK_H_VALID_DATA_CNT(bit15:0)：设置 LCD 的宽度，也就是水平像素数量。最后在看一下寄存器 LCDIF_CUR_BUF 和 LCDIF_NEXT_BUF，这两个寄存器分别为当前帧和下一帧缓冲区，也就是 LCD 显存。一般这两个寄存器保存同一个地址，也就是划分给 LCD的显存首地址。</p><h3 id="驱动屏幕的步骤"><a href="#驱动屏幕的步骤" class="headerlink" title="驱动屏幕的步骤"></a>驱动屏幕的步骤</h3><p>配置步骤如下：<br><strong>1、初始化 LCD 所使用的 IO</strong><br>首先肯定是初始化 LCD 所示使用的 IO，将其复用为 eLCDIF 接口 IO。<br><strong>2、设置 LCD 的像素时钟</strong><br>查阅所使用的 LCD 屏幕数据手册，或者自己计算出的时钟像素，然后设置 CCM 相应的寄存器。<br><strong>3、配置 eLCDIF 接口</strong><br>设置 LCDIF 的寄存器 CTRL、CTRL1、TRANSFER_COUNT、VDCTRL0~4、CUR_BUF 和NEXT_BUF。根据 LCD 的数据手册设置相应的参数。<br><strong>4、编写 API 函数</strong><br>驱动 LCD 屏幕的目的就是显示内容，所以需要编写一些基本的 API 函数，比如画点、画线、画圆函数，字符串显示函数等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot使用实验</title>
      <link href="/2023/03/01/2023-3-01-U-Boot%E4%BD%BF%E7%94%A8%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/03/01/2023-3-01-U-Boot%E4%BD%BF%E7%94%A8%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="U-Boot简介"><a href="#U-Boot简介" class="headerlink" title="U-Boot简介"></a>U-Boot简介</h3><h3 id="Linux启动简介以及Bootloader"><a href="#Linux启动简介以及Bootloader" class="headerlink" title="Linux启动简介以及Bootloader"></a>Linux启动简介以及Bootloader</h3><p>linux系统从软件角度看，可以分为以下四个层次。</p><ul><li>引导加载程序，包括固化固件的boot代码和Bootloader两个部分。大多数是没有固件的，Bootloader是上电后执行后的第一个程序。</li><li>Linux内核，特定于嵌入式板子的定制内核以及内核的启动参数，启动参数可以是内核默认的或者Bootloader传递的。</li><li>文件系统，博爱阔根文件系统和建立于flash内存上的文件系统，包含了Linux系统能过运行所需要的应用程序、库等。</li><li>用户应用程序，存储于文件系统中，又是在用户应用程序和内核层之间可能包含一个嵌入式图形用户界面，常用的GUI有：Qtopia和Mini GUI等。</li></ul><p>Bootloader存放参数如串口，IP地址等，正常启动Bootloader运行，它将kernel(内核）复制到内存中，并且在内存的固定地址设置好传递的内核参数，运行内核，内核启动后挂在根文件系统。</p><p>Bootloader启动要分两过程，第一个使用汇编，利用其完成CPU体系结构的初始化（硬件设备初始化，未加载第二过程准备RAM空间，复制Bootloader第二过程代码到RAM中，设置好栈，跳转到C的入口），并调第二过程代码，第二过程使用C语言来实现（初始化使用的硬件设备，检测系统内存映射，将内核映像和根文件系统映像从Flash读到RAM中，为内核设置启动参数，调用内核）。</p><p>调用内核前必须满足：</p><ol><li><p>CPU 寄存器的设置</p><ul><li><p>R0&#x3D;0</p></li><li><p>R1&#x3D;机器类型的ID</p></li><li><p>R2&#x3D;启动参数标记列表在RAM中的起始基地址</p></li></ul></li><li><p>CPU工作模式</p><ul><li><p>必须禁止中断</p></li><li><p>CPU必须为SVC 模式</p></li></ul></li><li><p>Cache和MMU的设置</p><ul><li><p>MMU必须关闭</p></li><li><p>指令Cache可开可关</p></li><li><p>数据Cache必须关</p></li></ul></li></ol><p>Uboot是通用Bootloader，可以引导多种架构的CPU，具有开源代码，支持多种嵌入式操作系统内核，支持多种处理器系列，有较高的可靠性和稳定性，高度灵活的功能设置，有丰富的设备驱动源码，有调试文档和技术支持，支持NFS挂载，支持目标板环境变量多种存储方式，上电自检。</p><h3 id="使用Uboot"><a href="#使用Uboot" class="headerlink" title="使用Uboot"></a>使用Uboot</h3><p>将Uboot压缩包在Ubuntu上解压后使用以下命令来编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- (加空格)</span><br><span class="line">mx6ull_14x14_ddr512_emmc_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</span><br></pre></td></tr></table></figure><p>这三条命令中 ARCH&#x3D;arm 设置目标为 arm 架构，CROSS_COMPILE 指定所使用的交叉编译器。第一条命令相当于“make distclean”，目的是清除工程，一般在第一次编译的时候最好清理一下工程。第二条指令相当于“make mx6ull_14x14_ddr512_emmc_defconfig”，用于配置 uboot，配置文件为 mx6ull_14x14_ddr512_emmc_defconfig。最后一条指令相当于 “make -j12”也就是使用 12 核来编译 uboot。</p><p>之后使用imxdownload将uboot.bin下载进入sd卡，之后将板子的uart1接上ttl转usb，之后打开MobaXterm。设置好参数后，复位linux板子，之后按下回车键，进入uboot命令行。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230302_164244.png"></p><h3 id="boot指令使用"><a href="#boot指令使用" class="headerlink" title="boot指令使用"></a>boot指令使用</h3><h4 id="信息查询命令"><a href="#信息查询命令" class="headerlink" title="信息查询命令"></a>信息查询命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bdinfo//用于查看板子信息</span><br><span class="line">printenv//用于输出环境变量</span><br><span class="line">version //用于查看uboot版本号</span><br></pre></td></tr></table></figure><h4 id="环境变量操作命令"><a href="#环境变量操作命令" class="headerlink" title="环境变量操作命令"></a>环境变量操作命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">saveenv //保存修改后的环境变量、</span><br><span class="line">setenv  //用于设置或者修改环境变量</span><br></pre></td></tr></table></figure><p>一般环境变量是存放在外部 flash 中的，uboot 启动的时候会将环境变量从 flash 读取到 DRAM 中。所以使用命令 setenv 修改的是 DRAM中的环境变量值，修改以后要使用 saveenv 命令将修改后的环境变量保存到 flash 中，否则的话uboot 下一次重启会继续使用以前的环境变量值。</p><p>也可以使用setenv来删除环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set author</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>上面命令中通过 setenv 给 author 赋空值，也就是什么都不写来删除环境变量 author。重启uboot 就会发现环境变量 author 没有了。</p><h4 id="内存操作命令"><a href="#内存操作命令" class="headerlink" title="内存操作命令"></a>内存操作命令</h4><p>md 命令用于显示内存值，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md[.b, .w, .l] address [# of objects]</span><br></pre></td></tr></table></figure><p>命令中的[.b .w .l]对应 byte、word 和 long，也就是分别以 1个字节、2 个字节、4 个字节来显示内存值。address 就是要查看的内存起始地址，[# of objects]表示要查看的数据长度。</p><p><strong>Uboot命令中的数字是十六进制的。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md.b 80000000 14 以 0X80000000 开始的 20 个字节的内存值</span><br></pre></td></tr></table></figure><p>nm 命令用于修改指定地址的内存值，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm [.b, .w, .l] address</span><br></pre></td></tr></table></figure><p>nm 命令同样可以以.b、.w 和.l 来指定操作格式，比如现在以.l格式修改 0x80000000 地址的数据为 0x12345678。输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm.l 80000000</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230302_203017.png"></p><p>80000000 表示现在要修改的内存地址，0500e031 表示地址0x80000000 现在的数据，？后面就可以输入要修改后的数据 0x12345678，输入完成以后按下回车，然后再输入‘q’即可退出</p><p>mm 命令也是修改指定地址内存值的，使用 mm 修改内存值的时候地址会自增。比如以.l 格式修改从地址 0x80000000 开始的连续 3 个内存块(3*4&#x3D;12个字节)的数据为 0X05050505。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230302_203845.png"></p><p>命令 mw 用于使用一个指定的数据填充一段内存，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mw [.b, .w, .l] address value [count]</span><br></pre></td></tr></table></figure><p>mw 命令同样可以以.b、.w 和.l 来指定操作格式，address 表示要填充的内存起始地址，value为要填充的数据，count 是填充的长度。比如使用.l 格式将以 0X80000000 为起始地址的 0x10 个内存块(0x10 * 4&#x3D;64 字节)填充为 0X0A0A0A0A</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mw.l 80000000 0A0A0A0A 10</span><br></pre></td></tr></table></figure><p>cp 是数据拷贝命令，用于将 DRAM 中的数据从一段内存拷贝到另一段内存中，或者把 Nor Flash 中的数据拷贝到 DRAM 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [.b, .w, .l] source target count</span><br></pre></td></tr></table></figure><p>cp 命令同样可以以.b、.w 和.l 来指定操作格式，source 为源地址，target 为目的地址，count为拷贝的长度。我们使用.l 格式将 0x80000000 处的地址拷贝到 0X80000100 处，长度为0x10 个内存块(0x10 * 4&#x3D;64 个字节)，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp.l 80000000 80000100 10</span><br></pre></td></tr></table></figure><p>cmp 是比较命令，用于比较两段内存的数据是否相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp [.b, .w, .l] addr1 addr2 count</span><br></pre></td></tr></table></figure><p>addr1 为第一段内存首地址，addr2 为第二段内存首地址，count 为要比较的长度。</p><h4 id="网络操作命令"><a href="#网络操作命令" class="headerlink" title="网络操作命令"></a>网络操作命令</h4><p>将开发板的enet2接口和wifi或者电脑连接，使用setenv和saveenv命令来设置网络的ip相关参数。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230303_130601.png"></p><p><strong>ping 命令</strong></p><p>开发板的网络能否使用，是否可以和服务器(Ubuntu 主机)进行通信，通过 ping 命令就可以验证，直接 ping 服务器的 IP 地址即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.1.115</span><br></pre></td></tr></table></figure><p><strong>dhcp 命令</strong></p><p>dhcp 用于从路由器获取 IP 地址，前提得开发板连接到路由器上的，如果开发板是和电脑直连的，那么 dhcp 命令就会失效。直接输入 dhcp 命令即可通过路由器获取到 IP 地址.</p><p><strong>nfs 命令</strong></p><p>nfs(Network File System)网络文件系统，通过 nfs 可以在计算机之间通过网络来分享资源，这样做的目的是为了方便调试 linux 镜像和设备树，也就是网络调试，通过网络调试是 Linux 开发中最常用的调试方法。在 Linux 内核调试阶段，如果用这个烧写软件的话将会非常浪费时间，而这个时候网络调试的优势就显现出来了，可以通过网络将编译好的 linux 镜像和设备树文件下载到 DRAM 中，然后就可以直接运行。</p><p>一般使用 uboot 中的 nfs 命令将 Ubuntu 中的文件下载到开发板的 DRAM 中，在使用之前需要开启 Ubuntu 主机的 NFS 服务，并且要新建一个 NFS 使用的目录，以后所有要通过NFS 访问的文件都需要放到这个 NFS 目录中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nfs [loadAddress] [[hostIPaddr:]bootfilename]</span><br></pre></td></tr></table></figure><p>loadAddress 是要保存的 DRAM 地址[[hostIPaddr:]bootfilename]是要下载的文件地址。</p><p>Ubuntu20.04具体参考以下方法：</p><p><a href="https://blog.csdn.net/weixin_56646002/article/details/127388021">(嵌入式Linux开发——解决uboot无法使用nfs服务从ubuntu中下载文件（TTT、cannot mount等错误）_</a></p><h4 id="EMMC-和-SD-卡操作命令"><a href="#EMMC-和-SD-卡操作命令" class="headerlink" title="EMMC 和 SD 卡操作命令"></a>EMMC 和 SD 卡操作命令</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230303_190432.png">                       </p><p>如果要在 uboot 中更新 SD对应的 uboot，可以使用如下所示命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 0 0//切换SD卡的0区</span><br><span class="line">mmc write 80800000 2 2E6//2E6这个数据根据写入的字节来转换为十六进制烧入第三个扇区</span><br></pre></td></tr></table></figure><p>如果要在 uboot 中更新 EMMC 对应的 uboot，可以使用如下所示命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 1 0 //切换到 EMMC 分区 0</span><br><span class="line">tftp 80800000 u-boot.imx //下载 u-boot.imx 到 DRAM</span><br><span class="line">mmc write 80800000 2 32E //烧写 u-boot.imx 到 EMMC 中的第三个扇区</span><br><span class="line">mmc partconf 1 1 0 0 //分区配置，EMMC 需要这一步！</span><br></pre></td></tr></table></figure><h4 id="FAT-格式文件系统操作命令"><a href="#FAT-格式文件系统操作命令" class="headerlink" title="FAT 格式文件系统操作命令"></a>FAT 格式文件系统操作命令</h4><p><strong>fatinfo 命令</strong></p><p>fatinfo 命令用于查询指定 MMC 设备分区的文件系统信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatinfo &lt;interface&gt; [&lt;dev[:part]&gt;]</span><br></pre></td></tr></table></figure><p>interface 表示接口，比如 mmc，dev 是查询的设备号，part 是要查询的分区。比如我们要查询 EMMC 分区 1 的文件系统信息，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatinfo mmc 1:1</span><br></pre></td></tr></table></figure><p><strong>fatls 命令</strong></p><p>fatls 命令用于查询 FAT 格式设备的目录和文件信息，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatls &lt;interface&gt; [&lt;dev[:part]&gt;] [directory]</span><br></pre></td></tr></table></figure><p>interface 是要查询的接口，比如 mmc，dev 是要查询的设备号，part 是要查询的分区，directory是要查询的目录。</p><p><strong>fstype 命令</strong></p><p>fstype 用于查看 MMC 设备某个分区的文件系统格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstype &lt;interface&gt; &lt;dev&gt;:&lt;part&gt;</span><br></pre></td></tr></table></figure><p><strong>fatload命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatload &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]]</span><br></pre></td></tr></table></figure><p>interface 为接口，比如 mmc，dev 是设备号，part 是分区，addr 是保存在 DRAM 中的起始地址，filename 是要读取的文件名字。bytes 表示读取多少字节的数据，如果 bytes 为 0 或者省略的话表示读取整个文件。pos 是要读的文件相对于文件首地址的偏移，如果为 0 或者省略的话表示从文件首地址开始读取。</p><p><strong>fatwrite命令</strong></p><p><u>uboot 默认没有使能 fatwrite 命令，需要修改板子配置头文件</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_FAT_WRITE /* 使能 fatwrite 命令 */</span><br></pre></td></tr></table></figure><p>fatwirte 命令用于将 DRAM 中的数据写入到 MMC 设备中，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatwrite &lt;interface&gt; &lt;dev[:part]&gt; &lt;addr&gt; &lt;filename&gt; &lt;bytes&gt;</span><br></pre></td></tr></table></figure><p>interface 为接口，比如 mmc，dev 是设备号，part 是分区，addr 是要写入的数据在 DRAM中的起始地址，filename 是写入的数据文件名字，bytes 表示要写入多少字节的数据。我们可以通过 fatwrite 命令在 uboot 中更新 linux 镜像文件和设备树。</p><h4 id="EXT-格式文件系统操作命令"><a href="#EXT-格式文件系统操作命令" class="headerlink" title="EXT 格式文件系统操作命令"></a>EXT 格式文件系统操作命令</h4><p>常用的就四个命令，分别为：ext2load、ext2ls、ext4load、ext4ls 和 ext4write，这些命令的含义和使用与 fatload、fatls 和 fatwrite一样，只是 ext2 和 ext4 都是针对 ext 文件系统的。</p><h4 id="Boot操作命令"><a href="#Boot操作命令" class="headerlink" title="Boot操作命令"></a>Boot操作命令</h4><p><strong>bootz命令</strong></p><p>要启动 Linux，需要先将 Linux 镜像文件拷贝到 DRAM 中，如果使用到设备树的话也需要将设备树拷贝到 DRAM 中。可以从 EMMC 或者 NAND 等存储设备中将 Linux 镜像和设备树文件拷贝到 DRAM，也可以通过 nfs 或者 tftp 将 Linux 镜像文件和设备树文件下载到 DRAM 中。</p><p>之后就可以使用bootz来启动zImage镜像文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootz [addr [initrd[:size]] [fdt]]</span><br></pre></td></tr></table></figure><p>命令 bootz 有三个参数，addr 是 Linux 镜像文件在 DRAM 中的位置，initrd 是 initrd 文件在DRAM 中的地址，如果不使用 initrd 的话使用‘-’代替即可，fdt 就是设备树文件在 DRAM 中的地址。</p><p><strong>bootm 命令</strong></p><p>bootm 和 bootz 功能类似，但是 bootm 用于启动 uImage 镜像文件。如果不使用设备树的话启动 Linux 内核的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootm addr</span><br></pre></td></tr></table></figure><p>addr 是 uImage 镜像在 DRAM 中的首地址。<br>如果要使用设备树，那么 bootm 命令和 bootz 一样，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootm [addr [initrd[:size]] [fdt]]</span><br></pre></td></tr></table></figure><p>其中 addr 是 uImage 在 DRAM 中的首地址，initrd 是 initrd 的地址，fdt 是设备树(.dtb)文件在 DRAM 中的首地址，如果 initrd 为空的话，同样是用“-”来替代。</p><p><strong>boot 命令</strong></p><p>boot 命令也是用来启动 Linux 系统的，只是 boot 会读取环境变量 bootcmd 来启动 Linux 系统，bootcmd 是一个很重要的环境变量！其名字分为“boot”和“cmd”，也就是“引导”和“命令”，说明这个环境变量保存着引导命令，其实就是启动的命令集合，具体的引导命令内容是可以修改的。比如我们要想使用 tftp 命令从网络启动 Linux 那么就可以设置 bootcmd 为“tftp 80800000 zImage; tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb; bootz 80800000 -83000000”，然后使用 saveenv 将 bootcmd 保存起来。然后直接输入 boot 命令即可从网络启动Linux 系统，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb; bootz 80800000 - 83000000&#x27;</span><br><span class="line">saveenv</span><br><span class="line">boot</span><br></pre></td></tr></table></figure><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><p><strong>reset命令</strong></p><p>输入reset即可实现复位重启。</p><p><strong>go 命令</strong></p><p>go 命令用于跳到指定的地址处执行应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go addr [arg ...]</span><br></pre></td></tr></table></figure><p><strong>run 命令</strong></p><p>run 命令用于运行环境变量中定义的命令，比如可以通过“run bootcmd”来运行 bootcmd 中的启动命令，但是 run 命令最大的作用在于运行我们自定义的环境变量。在后面调试 Linux 系统的时候常常要在网络启动和 EMMC&#x2F;NAND 启动之间来回切换，而 bootcmd 只能保存一种启动方式，如果要换另外一种启动方式的话就得重写 bootcmd，会很麻烦。这里我们就可以通过自定义环境变量来实现不同的启动方式，比如定义环境变量 mybootemmc 表示从 emmc 启动，定义 mybootnet 表示从网络启动，定义 mybootnand 表示从 NAND 启动。如果要切换启动方式的话只需要运行“run mybootxxx(xxx 为 emmc、net 或 nand)”即可。</p><p><strong>mtest 命令</strong></p><p>mtest 命令是一个简单的内存读写测试命令，可以用来测试自己开发板上的 DDR，命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtest [start [end [pattern [iterations]]]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 系统移植 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6ual的DDR3（内存芯片）的使用</title>
      <link href="/2023/02/28/2023-2-28-imx6ual%E7%9A%84DDR3%EF%BC%88%E5%86%85%E5%AD%98%E8%8A%AF%E7%89%87%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/28/2023-2-28-imx6ual%E7%9A%84DDR3%EF%BC%88%E5%86%85%E5%AD%98%E8%8A%AF%E7%89%87%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="何为位？位宽？字？字长？字节？"><a href="#何为位？位宽？字？字长？字节？" class="headerlink" title="何为位？位宽？字？字长？字节？"></a>何为位？位宽？字？字长？字节？</h3><p><strong>计算机在进行数据处理，一次存取、加工、传送的数据长度称为字(word)。</strong></p><p><strong>字长，是CPU一次能处理的二进制数的位数，*字长与之关联的是数据总线的位数</strong>，字长为32，则数据总线的宽度为32位。*比如CPU一次可以处理8个1（或者0），那么我们称这个CPU是8位的CPU，也就是说这个CPU的字长是8位。如果CPU一次可以处理16个二进制数，这个CPU的字长就是16位。<br><strong>位宽就是内存或显存一次能传输的数据量</strong>。(这里我对位宽的理解也仅限于此）简单地讲就是一次能传递的数据宽度。字长指的是计算能力，位宽指的是传输能力。</p><p><em>计算机三大总线：地址线，控制线，数据线。</em></p><p><strong>数据总线</strong><br>①是CPU与内存或其他器件之间的数据传送的通道。</p><p>②数据总线的宽度决定了CPU和外界的数据传送速度。</p><p>③每条传输线一次只能传输1位二进制数据。eg: 8根数据线一次可传送一个8位二进制数据(即一个字节)。</p><p>④数据总线是数据线数量之和。</p><p><strong>地址总线</strong><br>①CPU是通过地址总线来指定存储单元的。</p><p>②地址总线决定了cpu所能访问的最大内存空间的大小。eg: 10根地址线能访问的最大的内存为1024位二进制数据（1024个内存单元）(1B)</p><p>③地址总线是地址线数量之和。</p><p><strong>控制总线</strong><br>①CPU通过控制总线对外部器件进行控制。</p><p>②控制总线的宽度决定了CPU对外部器件的控制能力。</p><p>③控制总线是控制线数量之和。</p><h3 id="RAM和ROM"><a href="#RAM和ROM" class="headerlink" title="RAM和ROM"></a>RAM和ROM</h3><p>RAM：随机存储器，可以随时进行读写操作，速度很快，掉电以后数据会丢失。比如内存条、SRAM、SDRAM、DDR 等都是 RAM。RAM 一般用来保存程序数据、中间结果，掉电就会丢失数据。</p><p>ROM：只读存储器，容量大，但是掉电后数据不会丢失，适合用来存储资料，例如图片，音频，文件等。</p><p>SRAM：静态随机存储器，这里的“静态”说的就是只要 SRAM 上电，那么 SRAM 里面的数据就会一直保存着，直到 SRAM 掉电。</p><p>SDRAM 全称是 同步动态随机存储器，“同步”的意思是 SDRAM 工作需要时钟线，“动态”的意思是 SDRAM 中的数据需要不断的刷新来保证数据不会丢失，“随机”的意思就是可以读写任意地址的数据。SDRAM 分为 SDR SDRAM、DDR SDRAM、DDR2 SDRAM、DDR3 SDRAM、DDR4 SDRAM。</p><p>DDR 全称是 Double Data Rate SDRAM，也就是双倍速率 SDRAM，看名字就知道 DDR 的速率(数据传输速率)比 SDRAM 高 1 倍！这 1 倍的速度不是简简单单的将 CLK 提高 1 倍，SDRAM 在一个 CLK 周期传输一次数据，DDR 在一个 CLK 周期传输两次数据，也就是在上升沿和下降沿各传输一次数据，这个概念叫做预取(prefetch)，相当于 DDR 的预取为 2bit，因此DDR 的速度直接加倍！</p><p><a href="https://www.cnblogs.com/leaven/archive/2010/07/21/1782341.html#:~:text=1%E3%80%81%E5%B7%AE%E5%88%86%E6%97%B6%E9%92%9F%20%E5%B7%AE%E5%88%86%E6%97%B6%E9%92%9F%EF%BC%88%E5%8F%82%E8%A7%81%E4%B8%8A%E6%96%87%E2%80%9CDDR%20SDRAM%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE%E2%80%9D%EF%BC%89%E6%98%AFDDR%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BF%85%E8%A6%81%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%BD%86,CK%23%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%B9%B6%E4%B8%8D%E8%83%BD%E7%90%86%E8%A7%A3%E4%B8%BA%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%A7%A6%E5%8F%91%E6%97%B6%E9%92%9F%20%EF%BC%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%AE%B2%E8%BF%B0DDR%E5%8E%9F%E7%90%86%E6%97%B6%E7%AE%80%E5%8D%95%E5%9C%B0%E8%BF%99%E4%B9%88%E6%AF%94%E5%96%BB%EF%BC%89%EF%BC%8C%E8%80%8C%E6%98%AF%E8%B5%B7%E5%88%B0%20%E8%A7%A6%E5%8F%91%E6%97%B6%E9%92%9F%E6%A0%A1%E5%87%86%20%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82">DDR DQS （Double Data Rate SDRAM ） 原理及与SDRAM比较(cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u的串口通信</title>
      <link href="/2023/02/28/2023-2-28-imx6u%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/02/28/2023-2-28-imx6u%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>UART 通信格式</strong></p><p>串口全称叫做串行接口，通常也叫做 COM 接口，串行接口指的是数据一个一个的顺序传输，通信线路简单。使用两条线即可实现双向通信，一条用于发送，一条用于接收。串口通信距离远，但是速度相对会低，串口是一种很常用的工业接口。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230227_203724.png"></p><p>空闲位：数据线在空闲状态的时候为逻辑“1”状态，也就是高电平，表示没有数据线空闲，没有数据传输。<br>起始位：当要传输数据的时候先传输一个逻辑“0”，也就是将数据线拉低，表示开始数据传输。<br>数据位：数据位就是实际要传输的数据，数据位数可选择 5~8 位，我们一般都是按照字节传输数据的，一个字节 8 位，因此数据位通常是 8 位的。低位在前，先传输，高位最后传输。<br>奇偶校验位：这是对数据中“1”的位数进行奇偶校验用的，可以不使用奇偶校验功能。<br>停止位：数据传输完成标志位，停止位的位数可以选择 1 位、1.5 位或 2 位高电平，一般都选择 1 位停止位。<br>波特率：波特率就是 UART 数据传输的速率，也就是每秒传输的数据位数，一般选择 9600、19200、115200 等。</p><p>UART 一般的接口电平有 TTL 和 RS-232，一般开发板上都有 TXD 和 RXD 这样的引脚，这些引脚低电平表示逻辑 0，高电平表示逻辑 1，这个就是 TTL 电平。RS-232 采用差分线，-3<del>-15V 表示逻辑 1，+3</del>+15V 表示逻辑 0。</p><p>I.MX6U 一共有 8 个 UART，其主要特性如下：<br>①、兼容 TIA&#x2F;EIA-232F 标准，速度最高可到 5Mbit&#x2F;S。<br>②、支持串行 IR 接口，兼容 IrDA，最高可到 115.2Kbit&#x2F;s。<br>③、支持 9 位或者多节点模式(RS-485)。<br>④、1 或 2 位停止位。<br>⑤、可编程的奇偶校验(奇校验和偶校验)。<br>⑥、自动波特率检测(最高支持 115.2Kbit&#x2F;S)。</p><p>UCR1寄存器</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20122716.png"></p><p>ADBR(bit14)：自动波特率检测使能位，为 0 的时候关闭自动波特率检测，为 1 的时候使能自动波特率检测。<br>UARTEN(bit0)：UART 使能位，为 0 的时候关闭 UART，为 1 的时候使能 UART。</p><p>UCR2寄存器</p><p><img src="C:\Users\hanfeng\AppData\Roaming\Typora\typora-user-images\1678081179783.png" alt="1678081179783"></p><p>IRTS(bit14)：为 0 的时候使用 RTS 引脚功能，为 1 的时候忽略 RTS 引脚。<br>PREN(bit8)：奇偶校验使能位，为 0 的时候关闭奇偶校验，为 1 的时候使能奇偶校验。<br>PROE(bit7)：奇偶校验模式选择位，开启奇偶校验以后此位如果为 0 的话就使用偶校验，此位为 1 的话就使能奇校验。<br>STOP(bit6)：停止位数量，为 0 的话 1 位停止位，为 1 的话 2 位停止位。<br>WS(bit5)：数据位长度，为 0 的时候选择 7 位数据位，为 1 的时候选择 8 位数据位。<br>TXEN(bit2)：发送使能位，为 0 的时候关闭 UART 的发送功能，为 1 的时候打开 UART的发送功能。<br>RXEN(bit1)：接收使能位，为 0 的时候关闭 UART 的接收功能，为 1 的时候打开 UART的接收功能。<br>SRST(bit0)：软件复位，为 0 的是时候软件复位 UART，为 1 的时候表示复位完成。复位完成以后此位会自动置 1，表示复位完成。此位只能写 0，写 1 会被忽略掉。</p><p>UCR3寄存器</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/20230306134052.png"></p><p>UARTx_UCR3 中的位 RXDMUXSEL(bit2)，这个位应该始终为 1。</p><p>接下来看一下寄存器 UARTx_UFCR 、 UARTx_UBIR 和 UARTx_UBMR ，寄存器UARTx_UFCR 中我们要用到的是位 RFDIV(bit9:7)，用来设置参考时钟分频</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20134323.png"></p><p>波特率是</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-06%20134333.png"></p><p>Ref Freq：经过分频以后进入 UART 的最终时钟频率。<br>UBMR：寄存器 UARTx_UBMR 中的值。<br>UBIR：寄存器 UARTx_UBIR 中的值。</p><h3 id="Uart1的配置步骤"><a href="#Uart1的配置步骤" class="headerlink" title="Uart1的配置步骤"></a>Uart1的配置步骤</h3><p>UART1 的配置步骤如下：<br>1、设置 UART1 的时钟源<br>设置 UART 的时钟源为 pll3_80m，设置寄存器 CCM_CSCDR1 的 UART_CLK_SEL 位为 0即可。<br>2、初始化 UART1<br>初始化 UART1 所使用 IO，设置 UART1 的寄存器 UART1_UCR1~UART1_UCR3，设置内容包括波特率，奇偶校验、停止位、数据位等等。<br>4、使能 UART1<br>UART1 初始化完成以后就可以使能 UART1 了，设置寄存器 UART1_UCR1 的位 UARTEN为 1。<br>5、编写 UART1 数据收发函数<br>编写两个函数用于 UART1 的数据收发操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u的EPIT定时器</title>
      <link href="/2023/02/27/2023-2-27-imx6u%E7%9A%84EPIT%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2023/02/27/2023-2-27-imx6u%E7%9A%84EPIT%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="EPIT"><a href="#EPIT" class="headerlink" title="EPIT"></a>EPIT</h3><p>EPIT的全称是：Enhanced Periodic Interrupt Timer，直译过来就是增强的周期中断定时器，它主要是完成周期性中断定时的。</p><p>EPIT 是一个 32 位定时器，在处理器几乎不用介入的情况下提供精准的定时中断，软件使能以后 EPIT 就会开始运行，EPIT 定时器有如下特点：</p><p>①、时钟源可选的 32 位向下计数器。<br>②、12 位的分频值。<br>③、当计数值和比较值相等的时候产生中断。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230227_193455.png"></p><p>①、这是个多路选择器，用来选择 EPIT 定时器的时钟源，EPIT 共有 3 个时钟源可选择，ipg_clk、ipg_clk_32k 和 ipg_clk_highfreq。<br>②、这是一个 12 位的分频器，负责对时钟源进行分频，12 位对应的值是 0<del>4095，对应着1</del>4096 分频。<br>③、经过分频的时钟进入到 EPIT 内部，在 EPIT 内部有三个重要的寄存器：计数寄存器(EPIT_CNR)、加载寄存器(EPIT_LR)和比较寄存器(EPIT_CMPR)，这三个寄存器都是 32 位的。EPIT 是一个向下计数器，也就是说给它一个初值，它就会从这个给定的初值开始递减，直到减为 0，计数寄存器里面保存的就是当前的计数值。如果 EPIT 工作在 set-and-forget 模式下，当计数寄存器里面的值减少到 0，EPIT 就会重新从加载寄存器读取数值到计数寄存器里面，重新开始向下计数。比较寄存器里面保存的数值用于和计数寄存器里面的计数值比较，如果相等的话就会产生一个比较事件。<br>④、比较器。<br>⑤、EPIT 可以设置引脚输出，如果设置了的话就会通过指定的引脚输出信号。<br>⑥、产生比较中断，也就是定时中断。</p><p>EPIT 定时器有两种工作模式：set-and-forget 和 free-running，这两个工作模式的区别如下：</p><p>set-and-forget 模式：EPITx_CR(x&#x3D;1，2)寄存器的 RLD 位置 1 的时候 EPIT 工作在此模式下，在此模式下 EPIT 的计数器从加载寄存器 EPITx_LR 中获取初始值，不能直接向计数器寄存器写入数据。不管什么时候，只要计数器计数到 0，那么就会从加载寄存器 EPITx_LR 中重新加载数据到计数器中，周而复始。<br>free-running 模式：EPITx_CR 寄存器的 RLD 位清零的时候 EPIT 工作在此模式下，当计数器计数到0以后会重新从0XFFFFFFFF开始计数，并不是从加载寄存器EPITx_LR中获取数据。</p><p>三个寄存器的具体配置查询手册。</p><h3 id="EPIT-的配置步骤如下："><a href="#EPIT-的配置步骤如下：" class="headerlink" title="EPIT 的配置步骤如下："></a><strong>EPIT 的配置步骤如下：</strong></h3><p><strong>1、设置 EPIT1 的时钟源</strong><br>设置寄存器 EPIT1_CR 寄存器的 CLKSRC(bit25:24)位，选择 EPIT1 的时钟源。<br><strong>2、设置分频值</strong><br>设置寄存器 EPIT1_CR 寄存器的 PRESCALAR(bit15:4)位，设置分频值。<br><strong>3、设置工作模式</strong><br>设置寄存器 EPIT1_CR 的 RLD(bit3)位，设置 EPTI1 的工作模式。<br><strong>4、设置计数器的初始值来源</strong><br>设置寄存器 EPIT1_CR 的 ENMOD(bit1)位，设置计数器的初始值来源。<br><strong>5、使能比较中断</strong><br>使用就设置寄存器 EPIT1_CR 的 OCIEN(bit2)位，使能比较中断。<br><strong>6、设置加载值和比较值</strong><br>设置寄存器 EPIT1_LR 中的加载值和寄存器 EPIT1_CMPR 中的比较值，通过这两个寄存器就可以决定定时器的中断周期。<br><strong>7、EPIT1 中断设置和中断服务函数编写</strong><br>使能 GIC 中对应的 EPIT1 中断，注册中断服务函数，如果需要的话还可以设置中断优先级。最后编写中断服务函数。<br><strong>8、使能 EPIT1 定时器</strong><br>配置好 EPIT1 以后就可以使能 EPIT1 了，通过寄存器 EPIT1_CR 的 EN(bit0)位来设置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u的GPIO中断</title>
      <link href="/2023/02/22/2023-2-16-imx6u%E7%9A%84GPIO%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/02/22/2023-2-16-imx6u%E7%9A%84GPIO%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>STM32 的中断系统主要有以下几个关键点：<br>①、中断向量表。<br>②、NVIC(内嵌向量中断控制器)。<br>③、中断使能。<br>④、中断服务函数</p><p>而在imx6ul中的NVIC中断管理机构叫做GIC。</p><p>中断服务程序的入口地址或存放中断服务程序的首地址成为中断向量，因此中断向量表是一系列中断服务程序入口地址组成的表。</p><h3 id="Cortex-A7中断系统简介"><a href="#Cortex-A7中断系统简介" class="headerlink" title="Cortex-A7中断系统简介"></a>Cortex-A7中断系统简介</h3><p>跟 STM32 一样，Cortex-A7 也有中断向量表，中断向量表也是在代码的最前面。CortexA7 内核有 8 个异常中断，这 8 个异常中断的中断向量表如表 ：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_211414.png"></p><p>①、复位中断(Rest)，CPU 复位以后就会进入复位中断，我们可以在复位中断服务函数里面做一些初始化工作，比如初始化 SP 指针、DDR 等等。<br>②、未定义指令中断(Undefined Instruction)，如果指令不能识别的话就会产生此中断。<br>③、软中断(Software Interrupt,SWI)，由 SWI 指令引起的中断，Linux 的系统调用会用 SWI指令来引起软中断，通过软中断来陷入到内核空间。<br>④、指令预取中止中断(Prefetch Abort)，预取指令的出错的时候会产生此中断。<br>⑤、数据访问中止中断(Data Abort)，访问数据出错的时候会产生此中断。<br>⑥、IRQ 中断(IRQ Interrupt)，外部中断，前面已经说了，芯片内部的外设中断都会引起此中断的发生。<br>⑦、FIQ 中断(FIQ Interrupt)，快速中断，如果需要快速处理中断的话就可以使用此中断。</p><p>中断向量表一般写在start.S的前面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">示例代码 17.1.1.1 Cortex-A 向量表模板</span><br><span class="line">1 .global _start /* 全局标号 */</span><br><span class="line">2 </span><br><span class="line">3 _start:</span><br><span class="line">4 ldr pc, =Reset_Handler /* 复位中断 */ </span><br><span class="line">5 ldr pc, =Undefined_Handler /* 未定义指令中断 */</span><br><span class="line">6 ldr pc, =SVC_Handler /* SVC(Supervisor)中断 */</span><br><span class="line">7 ldr pc, =PrefAbort_Handler /* 预取终止中断 */</span><br><span class="line">8 ldr pc, =DataAbort_Handler /* 数据终止中断 */</span><br><span class="line">9 ldr pc, =NotUsed_Handler /* 未使用中断 */</span><br><span class="line">10 ldr pc, =IRQ_Handler /* IRQ 中断 */</span><br><span class="line">11 ldr pc, =FIQ_Handler /* FIQ(快速中断)未定义中断 */</span><br><span class="line">12</span><br><span class="line">13 /* 复位中断 */ </span><br><span class="line">14 Reset_Handler:</span><br><span class="line">15 /* 复位中断具体处理过程 */</span><br><span class="line">16</span><br><span class="line">17 /* 未定义中断 */</span><br><span class="line">18 Undefined_Handler:</span><br><span class="line">19 ldr r0, =Undefined_Handler</span><br><span class="line">20 bx r0</span><br><span class="line">21</span><br><span class="line">22 /* SVC 中断 */</span><br><span class="line">23 SVC_Handler:</span><br><span class="line">24 ldr r0, =SVC_Handler</span><br><span class="line">25 bx r0</span><br><span class="line">26</span><br><span class="line">27 /* 预取终止中断 */</span><br><span class="line">28 PrefAbort_Handler:</span><br><span class="line">29 ldr r0, =PrefAbort_Handler </span><br><span class="line">30 bx r0</span><br><span class="line">31</span><br><span class="line">32 /* 数据终止中断 */</span><br><span class="line">33 DataAbort_Handler:</span><br><span class="line">34 ldr r0, =DataAbort_Handler</span><br><span class="line">35 bx r0</span><br><span class="line">36</span><br><span class="line">37 /* 未使用的中断 */</span><br><span class="line">38 NotUsed_Handler:</span><br><span class="line">39</span><br><span class="line">40 ldr r0, =NotUsed_Handler</span><br><span class="line">41 bx r0</span><br><span class="line">42</span><br><span class="line">43 /* IRQ 中断！重点！！！！！ */</span><br><span class="line">44 IRQ_Handler:</span><br><span class="line">45 /* 复位中断具体处理过程 */</span><br><span class="line">46 </span><br><span class="line">47 /* FIQ 中断 */</span><br><span class="line">48 FIQ_Handler:</span><br><span class="line">49 ldr r0, =FIQ_Handler </span><br><span class="line">50 bx r0 </span><br></pre></td></tr></table></figure><h4 id="GIC控制器"><a href="#GIC控制器" class="headerlink" title="GIC控制器"></a>GIC控制器</h4><p>ARM 针对 GIC V2 就开发出了 GIC400 这个中断控制器 IP 核。当 GIC 接收到外部中断信号以后就会报给 ARM 内核，但是ARM 内核只提供了四个信号给 GIC 来汇报中断情况：VFIQ、VIRQ、FIQ 和 IRQ。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_212349.png"></p><p><strong>VFIQ:虚拟快速 FIQ。</strong><br><strong>VIRQ:虚拟外部 IRQ。</strong><br><strong>FIQ:快速中断 IRQ。</strong><br><strong>IRQ:外部中断 IRQ。</strong>（GPIO中断属于IRQ外部中断。）</p><p>GIC 将众多的中断源分为分为三类：<br>①、SPI(Shared Peripheral Interrupt),共享中断，顾名思义，所有 Core 共享的中断，这个是最常见的，那些外部中断都属于 SPI 中断(注意！不是 SPI 总线那个中断) 。比如按键中断、串口中断等等，这些中断所有的 Core 都可以处理，不限定特定 Core。<br>②、PPI(Private Peripheral Interrupt)，私有中断，我们说了 GIC 是支持多核的，每个核肯定有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断。<br>③、SGI(Software-generated Interrupt)，软件中断，由软件触发引起的中断，通过向寄存器GICD_SGIR 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信。</p><p><strong>中断源有很多，为了区分这些不同的中断源肯定要给他们分配一个唯一 ID，这些 ID 就是中断 ID</strong>。每一个 CPU 最多支持 1020 个中断 ID，中断 ID 号为 ID0<del>ID1019。这 1020 个 ID 包含了 PPI、SPI 和 SGI。<br>ID0</del>ID15：这 16 个 ID 分配给 SGI。<br>ID16<del>ID31：这 16 个 ID 分配给 PPI。<br>ID32</del>ID1019：这 988 个 ID 分配给 SPI。具体看手册。</p><p><strong>GIC 架构分为了两个逻辑块：Distributor 和 CPU Interface，也就是分发器端和 CPU 接口端。</strong></p><p>Distributor(分发器端)：此逻辑块负责处理各个中断事件的分发问题，也就是中断事件应该发送到哪个 CPU Interface 上去。分发器收集所有的中断源，可以控制每个中断的优先级，它总是将优先级最高的中断事件发送到 CPU 接口端。分发器端要做的主要工作如下：<br>①、全局中断使能控制。<br>②、控制每一个中断的使能或者关闭。<br>③、设置每个中断的优先级。<br>④、设置每个中断的目标处理器列表。<br>⑤、设置每个外部中断的触发模式：电平触发或边沿触发。<br>⑥、设置每个中断属于组 0 还是组 1。</p><p>CPU Interface(CPU 接口端)：CPU 接口端听名字就知道是和 CPU Core 相连接的，因此在每个 CPU Core 都可以在 GIC 中找到一个与之对应的 CPU Interface。CPU 接口端就是分发器和 CPU Core 之间的桥梁，CPU 接口端主要工作如下：<br>①、使能或者关闭发送到 CPU Core 的中断请求信号。<br>②、应答中断。<br>③、通知中断处理完成。<br>④、设置优先级掩码，通过掩码来设置哪些中断不需要上报给 CPU Core。<br>⑤、定义抢占策略。<br>⑥、当多个中断到来的时候，选择优先级最高的中断通知给 CPU Core。</p><p><strong>CP15 协处理器</strong></p><p>CP15 协处理器一般用于存储系统管理，但是在中断中也会使用到，CP15 协处理器一共有16 个 32 位寄存器。</p><p>CP15 协处理器的访问通过如下另个指令完成：</p><p>MRC: 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。读CP5寄存器<br>MCR: 将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中。写CP15寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MCR&#123;cond&#125; p15, &lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;, &lt;opc2&gt;</span><br><span class="line">MRC p15, 0, r0, c0, c0, 0//CP15 中 C0 寄存器的值读取到 R0 寄存器</span><br></pre></td></tr></table></figure><p>cond:指令执行的条件码，如果忽略的话就表示无条件执行。<br>opc1：协处理器要执行的操作码。<br>Rt：ARM 源寄存器，要写入到 CP15 寄存器的数据就保存在此寄存器中。<br>CRn：CP15 协处理器的目标寄存器。<br>CRm：协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将<br>CRm 设置为 C0，否则结果不可预测。<br>opc2：可选的协处理器特定操作码，当不需要的时候要设置为 0。</p><p>CP15 协处理器有 16 个 32 位寄存器，c0~c15，在使用 MRC 或者 MCR 指令访问这 16 个<br>寄存器的时候，指令中的 CRn、opc1、CRm 和 opc2 通过不同的搭配，其得到的寄存器含义是<br>不同的。例如C1寄存器的搭配。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_220740.png"></p><h4 id="中断使能"><a href="#中断使能" class="headerlink" title="中断使能"></a>中断使能</h4><p>中断使能包括两部分，一个是 IRQ 或者 FIQ 总中断使能，另一个就是 ID0~ID1019 这 1020<br>个中断源的使能。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_221931.png"></p><p>GIC 寄存器 GICD_ISENABLERn 和 GICD_ ICENABLERn 用来完成外部中断的使能和禁止，对于 Cortex-A7 内核来说中断 ID 只使用了 512 个。一个 bit 控制一个中断 ID 的使能，那么就需要 512&#x2F;32&#x3D;16 个 GICD_ISENABLER 寄存器来完成中断的使能。同理，也需要 16 个GICD_ICENABLER 寄存器来完成中断的禁止。其中 GICD_ISENABLER0 的 bit[15:0]对应ID15<del>0 的 SGI 中断，GICD_ISENABLER0 的 bit[31:16]对应 ID31</del>16 的 PPI 中断。剩下的GICD_ISENABLER1~GICD_ISENABLER15 就是控制 SPI 中断的。</p><h4 id="中断优先级设置"><a href="#中断优先级设置" class="headerlink" title="中断优先级设置"></a>中断优先级设置</h4><p><strong>优先级数配置</strong></p><p>GIC 控制器最多可以支持 256 个优先级，数字越小，优先级越高！Cortex-A7 选择了 32 个优先级。在使用中断的时候需要初始化 GICC_PMR 寄存器，此寄存器用来决定使用几级优先级。I.MX6U 是 Cortex-A7内核，所以支持 32 个优先级，因此 GICC_PMR 要设置为 0b11111000。</p><p><strong>抢占优先级和子优先级位数设置</strong></p><p>优先级寄存器分为两部分：抢占优先级和子优先级。分配给每个部分的位数是可配置的。抢占优先级定义了一个中断是否可以抢占一个已经在执行的中断。当两个抢占优先级相同的中断同时发生时，子优先级决定哪个中断将首先执行。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230219_222553.png"></p><p><strong>优先级设置</strong></p><p>前面已经设置好了 I.MX6U 一共有 32 个抢占优先级，数字越小优先级越高。具体要使用某个中断的时候就可以设置其优先级为 0~31。某个中断 ID 的中断优先级设置由寄存器D_IPRIORITYR 来完成，前面说了 Cortex-A7 使用了 512 个中断 ID，每个中断 ID 配有一个优先级寄存器，所以一共有 512 个 D_IPRIORITYR 寄存器。如果优先级个数为 32 的话，使用寄存器 D_IPRIORITYR 的 bit7:4 来设置优先级，也就是说实际的优先级要左移 3 位。比如要设置ID40 中断的优先级为 5，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GICD_IPRIORITYR[40] = 5 &lt;&lt; 3;</span><br></pre></td></tr></table></figure><p>有关优先级设置的内容就讲解到这里，优先级设置主要有三部分：<br>①、设置寄存器 GICC_PMR，配置优先级个数，比如 I.MX6U 支持 32 级优先级。<br>②、设置抢占优先级和子优先级位数。<br>③、设置指定中断 ID 的优先级，也就是设置外设优先级。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imx6u时钟配置</title>
      <link href="/2023/02/16/2023-2-16-imx6u%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/02/16/2023-2-16-imx6u%E6%97%B6%E9%92%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="系统时钟来源"><a href="#系统时钟来源" class="headerlink" title="系统时钟来源"></a>系统时钟来源</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230215_214959.png"></p><p>开发板的系统时钟来源于两部分：32.768KHz 和24MHz 的晶振，其中 32.768KHz 晶振是 I.MX6U 的 RTC 时钟源，24MHz 晶振是 I.MX6U 内核和其它外设的时钟源。</p><p>I.MX6U 的外设有很多，不同的外设时钟源不同，这些外设的时钟源分了7组，这 7 组时钟源都是从 24MHz 晶振 PLL 而来的，因此也叫做 7 组 PLL.</p><h3 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h3><p>由下面的时钟切换图可知，IMX6U总共有7组PLL：</p><p>PLL1（996M）、PLL2（528M）、PLL3（480M）、PLL4、PLL5、PLL6、PLL7</p><p>其中PLL2、PLL3各自有4组PFD，这些PFD以PLL为基础，经过不同的分频系数可以产生不同频率的时钟，在参考手册的相关寄存器的地方，可以看到官方有推荐的配置参数。(《IMX6UL参考手册》</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/edr.png"></p><p>①、 ARM_PLL（PLL1），此路 PLL 是供 ARM 内核使用的，ARM 内核时钟就是由此 PLL生成的，此 PLL 通过编程的方式最高可倍频到 1.3GHz。<br>②、528_PLL(PLL2)，此路 PLL 也叫做 System_PLL，此路 PLL 是固定的 22 倍频，不可编程修改。因此，此路 PLL 时钟&#x3D;24MHz * 22 &#x3D; 528MHz，这也是为什么此 PLL 叫做 528_PLL 的原因。此 PLL 分出了 4 路 PFD，分别为：PLL2_PFD0<del>PLL2_PFD3，这 4 路 PFD 和 528_PLL共同作为其它很多外设的根时钟源。通常 528_PLL 和这 4 路 PFD 是 I.MX6U 内部系统总线的时钟源，比如内处理逻辑单元、DDR 接口、NAND&#x2F;NOR 接口等等。<br>③、USB1_PLL(PLL3)，此路 PLL 主要用于 USBPHY，此 PLL 也有四路 PFD，为：PLL3_PFD0</del>PLL3_PFD3，USB1_PLL 是固定的 20 倍频，因此 USB1_PLL&#x3D;24MHz *20&#x3D;480MHz。<br>USB1_PLL虽然主要用于USB1PHY，但是其和四路PFD同样也可以作为其他外设的根时钟源。<br>④、USB2_PLL(PLL7，没有写错！就是 PLL7，虽然序号标为 4，但是实际是 PLL7)，看名字就知道此路PLL是给USB2PHY 使用的。同样的，此路PLL固定为20倍频，因此也是480MHz。<br>⑤、ENET_PLL(PLL6),此路 PLL 固定为 20+5&#x2F;6 倍频，因此 ENET_PLL&#x3D;24MHz * (20+5&#x2F;6) &#x3D; 500MHz。此路 PLL 用于生成网络所需的时钟，可以在此 PLL 的基础上生成 25&#x2F;50&#x2F;100&#x2F;125MHz的网络时钟。<br>⑥、VIDEO_PLL(PLL5),此路 PLL 用于显示相关的外设，比如 LCD，此路 PLL 的倍频可以调整，PLL 的输出范围在 650MHz<del>1300MHz。此路 PLL 在最终输出的时候还可以进行分频，可选 1&#x2F;2&#x2F;4&#x2F;8&#x2F;16 分频。<br>⑦、AUDIO_PLL(PLL4),此路 PLL 用于音频相关的外设，此路 PLL 的倍频可以调整，PLL的输出范围同样也是 650MHz</del>1300MHz，此路 PLL 在最终输出的时候也可以进行分频，可选1&#x2F;2&#x2F;4 分频。</p><p>PLL：接收锁相环输出时钟和锁相环旁路时钟。 简单来说，锁相环就是用来将外部晶振进行倍频，以实现稳定且高频的时钟信号。</p><h4 id="内核时钟设置（PLL1）"><a href="#内核时钟设置（PLL1）" class="headerlink" title="内核时钟设置（PLL1）"></a>内核时钟设置（PLL1）</h4><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_182344.png"></p><p>①、pll1_sw_clk 也就是 PLL1 的最终输出频率。<br>②、此处是一个选择器，选择 pll1_sw_clk 的时钟源，由寄存器 CCM_CCSR 的PLL1_SW_CLK_SEL 位决定 pll1_sw_clk 是选择 pll1_main_clk 还是 step_clk。正常情况下应该选择 pll1_main_clk，但是如果要对 pll1_main_clk(PLL1)的频率进行调整的话，比如我们要设置PLL1&#x3D;1056MHz，此时就要先将 pll1_sw_clk 切换到 step_clk 上。等 pll1_main_clk 调整完成以后再切换回来。<br>③、此处也是一个选择器，选择 step_clk 的时钟源，由寄存器 CCM_CCSR 的 STEP_SEL 位来决定 step_clk 是选择 osc_clk 还是 secondary_clk。一般选择 osc_clk，也就是 24MHz 的晶振。</p><p><strong>首先要使用CCM_CCSR寄存器来决定使用时钟源来进行配置。</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_174705.png"></p><p>①、 设置寄存器 CCSR 的 STEP_SEL 位，设置 step_clk 的时钟源为 24M 的晶振。<br>②、设置寄存器 CCSR 的 PLL1_SW_CLK_SEL 位，设置 pll1_sw_clk 的时钟源为<br>step_clk&#x3D;24MHz，通过这一步我们就将 I.MX6U 的主频先设置为 24MHz，直接来自于外部的<br>24M 晶振。<br>③、设置寄存器 CCM_ANALOG_PLL_ARMn，将 pll1_main_clk(PLL1)设置为 1056MHz。<br>④、设置寄存器 CCSR 的 PLL1_SW_CLK_SEL 位，重新将 pll1_sw_clk 的时钟源切换回<br>pll1_main_clk，切换回来以后的 pll1_sw_clk 就等于 1056MHz。<br>⑤、最后设置寄存器 CCM_CACRR 的 ARM_PODF 为 2 分频，I.MX6U 的内核主频就为<br>1056&#x2F;2&#x3D;528MHz。</p><h4 id="PFD-时钟设置"><a href="#PFD-时钟设置" class="headerlink" title="PFD 时钟设置"></a>PFD 时钟设置</h4><p>设置好主频以后我们还需要设置好其他的 PLL 和 PFD 时钟，PLL1 上一小节已经设置了，PLL2、PLL3 和 PLL7 固定为 528MHz、480MHz 和 480MHz，PLL4~PLL6 都是针对特殊外设的，用到的时候再设置。因此，接下来重点就是设置 PLL2 和 PLL3 的各自 4 路 PFD，这 8 路 PFD 频率如表  所示：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_183230.png"></p><p>设置PFD0~3需要按照寄存器的所在位进行置数。以下是寄存器CCM_ANALOG_PFD_528n的结构。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_191351.png"></p><p>频率计算公式</p><p><strong>PLL2_PFDX&#x3D;528*18&#x2F;PFDX_FRAC(X&#x3D;1~3)。</strong></p><p>*<em>PLL3_PFDX&#x3D;480</em>18&#x2F;PFDX_FRAC(X&#x3D;0~3)**。</p><p>例如设置PFD3的的频率为297MHz需要进行以下设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> reg = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">reg &amp;= ~(<span class="number">0X3F3F3F3F</span>);<span class="comment">//清楚以前设置</span></span><br><span class="line">x = <span class="number">32</span>;<span class="comment">//528*18/297</span></span><br><span class="line">reg |= (x&lt;&lt;<span class="number">24</span>);<span class="comment">//24是寄存器的位置</span></span><br></pre></td></tr></table></figure><h4 id="AHB、IPG-和-PERCLK-根时钟设置"><a href="#AHB、IPG-和-PERCLK-根时钟设置" class="headerlink" title="AHB、IPG 和 PERCLK 根时钟设置"></a>AHB、IPG 和 PERCLK 根时钟设置</h4><p>7 路 PLL 和 8 路 PFD 设置完成以后最后还需要设置 AHB_CLK_ROOT 和 IPG_CLK_ROOT的时钟，I.MX6U 外设根时钟可设置范围如图：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_192443.png"></p><p>AHB_CLK_ROOT 最高可以设置 132MHz，IPG_CLK_ROOT 和PERCLK_CLK_ROOT 最高可以设置66MHz。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230216_193126.png"></p><p>①、此选择器用来选择 pre_periph_clk 的时钟源，可以选择 PLL2、PLL2_PFD2、PLL2_PFD0和 PLL2_PFD2&#x2F;2。寄存器 CCM_CBCMR 的 PRE_PERIPH_CLK_SEL 位决定选择哪一个，默认选择 PLL2_PFD2，因此 pre_periph_clk&#x3D;PLL2_PFD2&#x3D;396MHz。<br>②、此选择器用来选择 periph_clk 的时钟源，由寄存器 CCM_CBCDR 的 PERIPH_CLK_SEL位与 PLL_bypass_en2 组成的或来选择。当 CCM_CBCDR 的 PERIPH_CLK_SEL 位为 0 的时候periph_clk&#x3D;pr_periph_clk&#x3D;396MHz。<br>③、通过 CBCDR 的 AHB_PODF 位来设置 AHB_CLK_ROOT 的分频值，可以设置 1<del>8 分频，如果想要 AHB_CLK_ROOT&#x3D;132MHz 的话就应该设置为 3 分频：396&#x2F;3&#x3D;132MHz。图 中虽然写的是默认 4 分频，但是 I.MX6U 的内部 boot rom 将其改为了 3 分频！<br>④、通过 CBCDR 的 IPG_PODF 位来设置 IPG_CLK_ROOT 的分频值，可以设置 1</del>4 分频，IPG_CLK_ROOT 时钟源是 AHB_CLK_ROOT，要想 IPG_CLK_ROOT&#x3D;66MHz 的话就应该设置2 分频：132&#x2F;2&#x3D;66MHz。</p><p><strong>设置 PERCLK_CLK_ROOT 时钟频率</strong></p><p>PERCLK_CLK_ROOT 来 源 有 两 种 ： OSC(24MHz) 和IPG_CLK_ROOT，由寄存器 CCM_CSCMR1 的 PERCLK_CLK_SEL 位来决定，如果为 0 的话，PERCLK_CLK_ROOT 的时钟源就是 IPG_CLK_ROOT&#x3D;66MHz 。可以通过寄存器CCM_CSCMR1 的 PERCLK_PODF 位来设置分频，如果要设置 PERCLK_CLK_ROOT 为 66MHz的话就要设置为 1 分频。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clk_enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">CCM-&gt;CCGR0 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR1 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR2 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR3 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR4 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR5 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">CCM-&gt;CCGR6 = <span class="number">0XFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 初始化系统时钟，设置系统时钟为792Mhz，并且设置PLL2和PLL3各个</span></span><br><span class="line"><span class="comment">   PFD时钟,所有的时钟频率均按照I.MX6U官方手册推荐的值.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">imx6u_clkinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> reg = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 1、设置ARM内核时钟为792MHz */</span></span><br><span class="line"><span class="comment">/* 1.1、判断当前ARM内核是使用的那个时钟源启动的，正常情况下ARM内核是由pll1_sw_clk驱动的，而</span></span><br><span class="line"><span class="comment"> *  pll1_sw_clk有两个来源：pll1_main_clk和tep_clk。</span></span><br><span class="line"><span class="comment"> *  如果我们要让ARM内核跑到792M的话那必须选择pll1_main_clk作为pll1的时钟源。</span></span><br><span class="line"><span class="comment"> *  如果我们要修改pll1_main_clk时钟的话就必须先将pll1_sw_clk从pll1_main_clk切换到step_clk,</span></span><br><span class="line"><span class="comment"> *当修改完pll1_main_clk以后在将pll1_sw_clk切换回pll1_main_clk。而step_clk的时钟源可以选择</span></span><br><span class="line"><span class="comment"> * 板子上的24MHz晶振。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((((CCM-&gt;CCSR) &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x1</span> ) == <span class="number">0</span>) <span class="comment">/* 当前pll1_sw_clk使用的pll1_main_clk*/</span></span><br><span class="line">&#123;</span><br><span class="line">CCM-&gt;CCSR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">8</span>);<span class="comment">/* 配置step_clk时钟源为24MH OSC */</span></span><br><span class="line">CCM-&gt;CCSR |= (<span class="number">1</span> &lt;&lt; <span class="number">2</span>);<span class="comment">/* 配置pll1_sw_clk时钟源为step_clk */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1.2、设置pll1_main_clk为792MHz</span></span><br><span class="line"><span class="comment"> *      因为pll1_sw_clk进ARM内核的时候会被二分频！</span></span><br><span class="line"><span class="comment"> *      配置CCM_ANLOG-&gt;PLL_ARM寄存器</span></span><br><span class="line"><span class="comment"> *      bit13: 1 使能时钟输出</span></span><br><span class="line"><span class="comment"> *      bit[6:0]: 66, 由公式：Fout = Fin * div_select / 2.0，792=24*div_select/2.0,</span></span><br><span class="line"><span class="comment"> *              得出：div_select=    66 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CCM_ANALOG-&gt;PLL_ARM = (<span class="number">1</span> &lt;&lt; <span class="number">13</span>) | ((<span class="number">66</span> &lt;&lt; <span class="number">0</span>) &amp; <span class="number">0X7F</span>); <span class="comment">/* 配置pll1_main_clk=792MHz */</span></span><br><span class="line">CCM-&gt;CCSR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>);<span class="comment">/* 将pll_sw_clk时钟重新切换回pll1_main_clk */</span></span><br><span class="line">CCM-&gt;CACRR = <span class="number">0</span>;<span class="comment">/* ARM内核时钟为pll1_sw_clk/1=792/1=792Mhz */</span></span><br><span class="line"><span class="comment">/* 2、设置PLL2(SYS PLL)各个PFD */</span></span><br><span class="line">reg = CCM_ANALOG-&gt;PFD_528;</span><br><span class="line">reg &amp;= ~(<span class="number">0X3F3F3F3F</span>);<span class="comment">/* 清除原来的设置 */</span></span><br><span class="line">reg |= <span class="number">32</span>&lt;&lt;<span class="number">24</span>;<span class="comment">/* PLL2_PFD3=528*18/32=297Mhz */</span></span><br><span class="line">reg |= <span class="number">24</span>&lt;&lt;<span class="number">16</span>;<span class="comment">/* PLL2_PFD2=528*18/24=396Mhz(DDR使用的时钟，最大400Mhz) */</span></span><br><span class="line">reg |= <span class="number">16</span>&lt;&lt;<span class="number">8</span>;<span class="comment">/* PLL2_PFD1=528*18/16=594Mhz */</span></span><br><span class="line">reg |= <span class="number">27</span>&lt;&lt;<span class="number">0</span>;<span class="comment">/* PLL2_PFD0=528*18/27=352Mhz  */</span></span><br><span class="line">CCM_ANALOG-&gt;PFD_528=reg;<span class="comment">/* 设置PLL2_PFD0~3  */</span></span><br><span class="line"><span class="comment">/* 3、设置PLL3(USB1)各个PFD */</span></span><br><span class="line">reg = <span class="number">0</span>;<span class="comment">/* 清零   */</span></span><br><span class="line">reg = CCM_ANALOG-&gt;PFD_480;</span><br><span class="line">reg &amp;= ~(<span class="number">0X3F3F3F3F</span>);<span class="comment">/* 清除原来的设置 */</span></span><br><span class="line">reg |= <span class="number">19</span>&lt;&lt;<span class="number">24</span>;<span class="comment">/* PLL3_PFD3=480*18/19=454.74Mhz */</span></span><br><span class="line">reg |= <span class="number">17</span>&lt;&lt;<span class="number">16</span>;<span class="comment">/* PLL3_PFD2=480*18/17=508.24Mhz */</span></span><br><span class="line">reg |= <span class="number">16</span>&lt;&lt;<span class="number">8</span>;<span class="comment">/* PLL3_PFD1=480*18/16=540Mhz*/</span></span><br><span class="line">reg |= <span class="number">12</span>&lt;&lt;<span class="number">0</span>;<span class="comment">/* PLL3_PFD0=480*18/12=720Mhz */</span></span><br><span class="line">CCM_ANALOG-&gt;PFD_480=reg;<span class="comment">/* 设置PLL3_PFD0~3 */</span></span><br><span class="line"><span class="comment">/* 4、设置AHB时钟 最小6Mhz， 最大132Mhz (boot rom自动设置好了可以不用设置)*/</span></span><br><span class="line">CCM-&gt;CBCMR &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">18</span>); <span class="comment">/* 清除设置*/</span> </span><br><span class="line">CCM-&gt;CBCMR |= (<span class="number">1</span> &lt;&lt; <span class="number">18</span>);<span class="comment">/* pre_periph_clk=PLL2_PFD2=396MHz */</span></span><br><span class="line">CCM-&gt;CBCDR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">25</span>);<span class="comment">/* periph_clk=pre_periph_clk=396MHz */</span></span><br><span class="line"><span class="keyword">while</span>(CCM-&gt;CDHIPR &amp; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>));<span class="comment">/* 等待握手完成 */</span></span><br><span class="line"><span class="comment">/* 5、设置IPG_CLK_ROOT最小3Mhz，最大66Mhz (boot rom自动设置好了可以不用设置)*/</span></span><br><span class="line">CCM-&gt;CBCDR &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">8</span>);<span class="comment">/* CBCDR的IPG_PODF清零 */</span></span><br><span class="line">CCM-&gt;CBCDR |= <span class="number">1</span> &lt;&lt; <span class="number">8</span>;<span class="comment">/* IPG_PODF 2分频，IPG_CLK_ROOT=66MHz */</span></span><br><span class="line"><span class="comment">/* 6、设置PERCLK_CLK_ROOT时钟 */</span></span><br><span class="line">CCM-&gt;CSCMR1 &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">6</span>);<span class="comment">/* PERCLK_CLK_ROOT时钟源为IPG */</span></span><br><span class="line">CCM-&gt;CSCMR1 &amp;= ~(<span class="number">7</span> &lt;&lt; <span class="number">0</span>);<span class="comment">/* PERCLK_PODF位清零，即1分频 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPIO寄存器配置原理</title>
      <link href="/2023/02/14/2023-2-14-GPIO%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
      <url>/2023/02/14/2023-2-14-GPIO%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="i-MX6ULL也有多种点灯方式：（究其本质，最终都是要操作i-MX6ULL的寄存器）"><a href="#i-MX6ULL也有多种点灯方式：（究其本质，最终都是要操作i-MX6ULL的寄存器）" class="headerlink" title="i.MX6ULL也有多种点灯方式：（究其本质，最终都是要操作i.MX6ULL的寄存器）"></a>i.MX6ULL也有多种点灯方式：（究其本质，最终都是要操作i.MX6ULL的寄存器）</h3><ul><li><strong>裸机系统</strong>：汇编操作寄存器点灯、C语言操作寄存器点灯</li><li><strong>跑Linux系统</strong>：字符驱动LED点灯、设备树驱动LED点灯</li></ul><h3 id="IO与GPIO是两个概念，GPIO是属于IO的一部分。"><a href="#IO与GPIO是两个概念，GPIO是属于IO的一部分。" class="headerlink" title="IO与GPIO是两个概念，GPIO是属于IO的一部分。"></a>IO与GPIO是两个概念，GPIO是属于IO的一部分。</h3><p>IO: Input Output，用于CPU与外界进行信息交互。例如CPU 读内存数据需要 I&#x2F;O 系统，CPU 输出数据到屏幕显示出来也需要 I&#x2F;O 系统，信息在 I&#x2F;O 系统上传输有串行或并行。<br>GPIO: General-Purpose IO ports，即通用I&#x2F;O口，在微控制器芯片上一般都会提供一个“通用可编程I&#x2F;O接口”。接口至少有两个寄存器——数据寄存器与控制寄存器。数据寄存器的各位直接引到芯片外部，控制寄存器则是对数据寄存器中每一位进行独立的设置。</p><h3 id="imx6ul的GPIO硬件结构"><a href="#imx6ul的GPIO硬件结构" class="headerlink" title="imx6ul的GPIO硬件结构"></a>imx6ul的GPIO硬件结构</h3><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230215_150827.png"></p><p>① PAD：它代表了i.MX6ULL芯片的一个GPIO引脚。</p><p>② IOMUX复用选择器：与STM32的引脚复用功能类似，i.MX6ULL芯片的每个IO通过IOMUXC中的MUX寄存器和PAD寄存器设置，可以支持多种功能(如GPIO、IIC、USART…)。</p><p>IOMUX由其左侧的IOMUXC提供寄存器给用户进行配置，它又分成MUX_Mode（IO 模式控制）以及Pad Settings（Pad 配置）两个部分：</p><ol><li><p>MUX_Mode配置：用来配置引脚的复用功能</p><p>2.Pad Settings 配置：配置引脚的属性，例如驱动能力，是否使用上下拉电阻，是否使用保持器，是否使用开漏模式以及使用施密特模式还是CMOS模式等</p></li></ol><p>③ Block外设功能控制块：例如具有PWM输出功能的引脚，它需要PWM外设的支持。</p><p>④ GPIO外设：GPIO模块是每个IO都具有的外设， 它是IO控制的基本功能， 如输出高低电平、 检测电平输入等。当需要使用引脚的GPIO功能时，就要配置GPIO外设中的各个寄存器(DR、GDIR、PSR…)。</p><p>⑤ 与其它引脚的连接：这里是另一个引脚PAD2，它与PAD1有一根信号线连接，表示部分引脚的输出可以作为另一个引脚的输入。</p><h4 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> DR;         <span class="comment">/**&lt; GPIO data register, offset: 0x0 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> GDIR;       <span class="comment">/**&lt; GPIO direction register, offset: 0x4 */</span></span><br><span class="line">  __I  <span class="type">uint32_t</span> PSR;        <span class="comment">/**&lt; GPIO pad status register, offset: 0x8 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ICR1;       <span class="comment">/**&lt; GPIO interrupt configuration register1, offset: 0xC */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ICR2;       <span class="comment">/**&lt; GPIO interrupt configuration register2, offset: 0x10 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> IMR;        <span class="comment">/**&lt; GPIO interrupt mask register, offset: 0x14 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ISR;        <span class="comment">/**&lt; GPIO interrupt status register, offset: 0x18 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> EDGE_SEL;   <span class="comment">/**&lt; GPIO edge select register, offset: 0x1C */</span></span><br><span class="line">&#125; GPIO_Type;</span><br></pre></td></tr></table></figure><p>DR（data register），即数据寄存器，它是32位的，一个GPIO组最大只有32个IO，因此DR寄存器中的每个位都对应一个 GPIO。当GPIO被配置为输出模式后，向指定的位写入数据那么相应的IO就会输出相应的高低电平，当 GPIO被配置为输入模式后，此寄存器就保存着对应IO的电平值，每个位对对应一个GPIO。</p><p><strong>GDIR（GPIO direction register）</strong>，即方向寄存器，也是32位的，用来设置某个GPIO的工作方向的，即输入&#x2F;输出。同样的，每个IO对应一个位，如果要设置GPIO为输入，就设置相应的位为0，如果要设置为输出，就设置为1</p><p><strong>PSR（Pad Status Register）</strong>，即状态寄存器，也是32位的。注意它是一个<strong>只读寄存器</strong>，每个IO对应一个位，读取相应的位即可获取对应的GPIO的状(高低电平值)，功能和输入状态下的DR寄存器一样。</p><p><strong>ICR1（interrupt configuration register1）和ICR2</strong>，都是中断控制寄存器， ICR1用于配置低16个GPIO，ICR2 用于配置高16 个GPIO。</p><p><strong>IMR（interrupt mask register）</strong>，即中断屏蔽寄存器，也是32位，每个IO对应一个位。IMR寄存器用来控制GPIO的中断禁止和使能，如果使能某个GPIO的中断，那么设置相应的位为1即可，反之，如果要禁止中断，那么就设置相应的位为0即可。</p><p><strong>ISR（interrupt status register）</strong>，即中断状态寄存器，也是32位，每个IO对应一个位。只要某个GPIO的中断发生，则ISR中相应的位就会被置1。所以通过读取ISR寄存器来判断是否发生了中断，类似于学习STM32用到的中断标志位。</p><p><strong>EDGE_SEL（edge select register）</strong>，即边沿选择寄存器，也是32位，每个IO对应一个位。</p><p>它用来设置边沿中断， 并会覆盖ICR1和ICR2的设置。</p><h4 id="时钟配置"><a href="#时钟配置" class="headerlink" title="时钟配置"></a>时钟配置</h4><p><strong>CCM（Clock Controller Module）时钟控制模块寄存器用来使能外设时钟。 CMM一共有CCM_CCGR0~CCM_CCGR6</strong>这 7 个寄存器，控制着I.MX6U的所有外设时钟开关。</p><p>以CCM_CCGR0为例，它是个32位寄存器，每2位控制一个外设的时钟，比如 bit31:30 控制着GPIO2 的外设时钟，两个位就有 4 种操作方式：</p><table><thead><tr><th>位设置</th><th>时钟控制</th></tr></thead><tbody><tr><td>00</td><td>所有模式下都关闭外设时钟</td></tr><tr><td>01</td><td>只有在运行模式下打开外设时钟，等待模式和停止模式下均关闭外设时钟</td></tr><tr><td>10</td><td>未使用(保留)</td></tr><tr><td>11</td><td>除了停止模式以外，其他所有模式下时钟都打开</td></tr></tbody></table><p><strong>配置总结</strong><br>使用i.MX6ULL的GPIO时，需要如下几步配置：</p><p>使能 GPIO 对应的时钟<br>配置MUX寄存器，设置IO的复用功能，使其复用为GPIO功能<br>配置PAD寄存器，设置 IO 的上下拉、速度等<br>配置GPIO的各种寄存器（DR、GDIR、…），设置输入&#x2F;输出、是否使用中断、默认输出电平等</p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bsp工程管理</title>
      <link href="/2023/02/12/2023-2-12-bsp%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2023/02/12/2023-2-12-bsp%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="BSP管理"><a href="#BSP管理" class="headerlink" title="BSP管理"></a>BSP管理</h3><p><strong>所有完成同一个功能的代码提取出来放到一个单独的文件中，也就是对程序分功能管理。</strong></p><p>所谓bsp管理就是按照各个功能函数模块化放入各自文件夹进行保存管理，使用时到各自的路径中进行调用。</p><p>类似于stm32的工程管理格式来存储。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230212_222148.png"></p><p>首先以led实验为例子,其中 bsp 用来存放驱动文件；imx6ul 用来存放跟芯片有关的文件，比如  SDK库文件；obj 用来存放编译生成的.o 文件；project 存放 start.S 和 main.c 文件，cc.h、fsl_common.h、fsl_iomuxc.h 和 MCIMX6Y2.h 这四个文件拷贝到文件夹 imx6ul 中；将 start.S 和 main.c 这两个文件拷贝到文件夹 project 中。前面的实验中所有的驱动相关的函数都写到了 main.c 文件中，比如函数 clk_enable、led_init 和 delay，这三个函数可以分为三类：时钟驱动、LED 驱动和延时驱动。因此我们可以在 bsp 文件夹下创建三个子文件夹：clk、delay 和 led，分别用来存放时钟驱动文件、延时驱动文件和 LED 驱动文件，这样main.c 函数就会清爽很多，程序功能模块清晰。工程文件夹都创建好了，接下来就是编写代码了，其实就是将时钟驱动、LED 驱动和延时驱动相关的函数从 main.c 中提取出来做成一个独立的驱动文件 。</p><p>代码部分就是将各部分的驱动函数打包成各自的驱动文件，剩余的不变。最主要的是makefile的编写和之前有很大的区别。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1 CROSS_COMPILE ?= arm-linux-gnueabihf</span><br><span class="line">2 TARGET ?= bsp</span><br><span class="line">3 </span><br><span class="line">4 CC := <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">5 LD := <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">6 OBJCOPY := <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">7 OBJDUMP := <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line">8 </span><br><span class="line">9 INCDIRS := imx6ul \                       //包含整个工程的.h 头文件目录</span><br><span class="line">10 bsp/clk \</span><br><span class="line">11 bsp/led \</span><br><span class="line">12 bsp/delay </span><br><span class="line">13 </span><br><span class="line">14 SRCDIRS := project \//包含的是整个工程的所有.c 和.S 文件目录。</span><br><span class="line">15 bsp/clk \</span><br><span class="line">16 bsp/led \</span><br><span class="line">17 bsp/delay </span><br><span class="line">18 </span><br><span class="line">19 INCLUDE := <span class="variable">$(<span class="built_in">patsubst</span> %, -I %, <span class="variable">$(INCDIRS)</span>)</span>//使用patsubst函数给INCDIRS后面加上-I</span><br><span class="line">20</span><br><span class="line">21 SFILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(SRCDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.S)</span>)//使用foreach和dir挑出所有的.S 汇编文件即可</span><br><span class="line">22 CFILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(SRCDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)//挑出所有的.c文件</span><br><span class="line">等同CFILES = project/main.c bsp/clk/bsp_clk.c bsp/led/bsp_led.c bsp/delay/bsp_delay.c</span><br><span class="line">23</span><br><span class="line">24 SFILENDIR := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(SFILES)</span>)</span>//使用函数 notdir 将 SFILES 和 CFILES 中的路径去掉</span><br><span class="line">25 CFILENDIR := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(CFILES)</span>)</span></span><br><span class="line">等同 SFILENDIR = start.S</span><br><span class="line">CFILENDIR = main.c bsp_clk.c bsp_led.c bsp_delay.c</span><br><span class="line">26</span><br><span class="line">27 SOBJS := <span class="variable">$(<span class="built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)</span><br><span class="line">28 COBJS := <span class="variable">$(<span class="built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)</span><br><span class="line">29 OBJS := <span class="variable">$(SOBJS)</span> <span class="variable">$(COBJS)</span></span><br><span class="line">30</span><br><span class="line">31 VPATH := <span class="variable">$(SRCDIRS)</span>//VPATH 是指定搜索目录</span><br><span class="line">32</span><br><span class="line">33 .PHONY: clean</span><br><span class="line">34 </span><br><span class="line">35 <span class="variable">$(TARGET)</span>.bin : <span class="variable">$(OBJS)</span></span><br><span class="line">36 <span class="variable">$(LD)</span> -Timx6ul.lds -o <span class="variable">$(TARGET)</span>.elf <span class="variable">$^</span></span><br><span class="line">37 <span class="variable">$(OBJCOPY)</span> -O binary -S <span class="variable">$(TARGET)</span>.elf <span class="variable">$@</span></span><br><span class="line">38 <span class="variable">$(OBJDUMP)</span> -D -m arm <span class="variable">$(TARGET)</span>.elf &gt; <span class="variable">$(TARGET)</span>.dis</span><br><span class="line">39</span><br><span class="line">40 <span class="variable">$(SOBJS)</span> : obj/%.o : %.S</span><br><span class="line">41 <span class="variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">42</span><br><span class="line">43 <span class="variable">$(COBJS)</span> : obj/%.o : %.c</span><br><span class="line">44 <span class="variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">45 </span><br><span class="line">46 clean:</span><br><span class="line">47 rm -rf <span class="variable">$(TARGET)</span>.elf <span class="variable">$(TARGET)</span>.dis <span class="variable">$(TARGET)</span>.bin <span class="variable">$(COBJS)</span> <span class="variable">$(SOBJS)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言点亮led</title>
      <link href="/2023/02/05/2023-2-5-C%E8%AF%AD%E8%A8%80%E7%82%B9%E4%BA%AEled/"/>
      <url>/2023/02/05/2023-2-5-C%E8%AF%AD%E8%A8%80%E7%82%B9%E4%BA%AEled/</url>
      
        <content type="html"><![CDATA[<p>Cortex-A 处理器运行模型</p><p>Cortex-A7 处理器有 9 种处理模式。如下图：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230206_165721.png"></p><p>所有的处理器模式都共用一个 CPSR 物理寄存器，因此 CPSR 可以在任何模式下被访问。CPSR 是当前程序状态寄存器，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志等一些状态位以及一些控制位。所有的处理器模式都共用一个 CPSR 必然会导致冲突，为此，除了 User 和 Sys 这两个模式以外，其他 7 个模式每个都配备了一个专用的物理状态寄存器，叫做 SPSR(备份程序状态寄存器)，当特定的异常中断发生时，SPSR 寄存器用来保存当前程序状态寄存器(CPSR)的值，当异常退出以后可以用 SPSR 中保存的值来恢复 CPSR。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230206_170328.png"></p><p>N(bit31)：当两个补码表示的 有符号整数运算的时候，N&#x3D;1 表示运算对的结果为负数，N&#x3D;0表示结果为正数。<br>Z(bit30)：Z&#x3D;1 表示运算结果为零，Z&#x3D;0 表示运算结果不为零，对于 CMP 指令，Z&#x3D;1 表示进行比较的两个数大小相等。<br>C(bit29)：在加法指令中，当结果产生了进位，则 C&#x3D;1，表示无符号数运算发生上溢，其它情况下 C&#x3D;0。在减法指令中，当运算中发生借位，则 C&#x3D;0，表示无符号数运算发生下溢，其它情况下 C&#x3D;1。对于包含移位操作的非加&#x2F;减法运算指令，C 中包含最后一次溢出的位的数值，对于其它非加&#x2F;减运算指令，C 位的值通常不受影响。<br>V(bit28)：对于加&#x2F;减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时，V&#x3D;1 表示符号位溢出，通常其他位不影响 V 位。<br>Q(bit27)：仅 ARM v5TE_J 架构支持，表示饱和状态，Q&#x3D;1 表示累积饱和，Q&#x3D;0 表示累积不饱和。<br>IT<a href="bit26:25">1:0</a>：和 IT<a href="bit15:bit10">7:2</a>一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。<br>J(bit24)：仅 ARM_v5TE-J 架构支持，J&#x3D;1 表示处于 Jazelle 状态，此位通常和 T(bit5)位一起表示当前所使用的指令集。<br>GE<a href="bit19:16">3:0</a>：SIMD 指令有效，大于或等于。<br>IT<a href="bit15:10">7:2</a>：参考 IT[1:0]。<br>E(bit9)：大小端控制位，E&#x3D;1 表示大端模式，E&#x3D;0 表示小端模式。<br>A(bit8)：禁止异步中断位，A&#x3D;1 表示禁止异步中断。<br>I(bit7)：I&#x3D;1 禁止 IRQ，I&#x3D;0 使能 IRQ。<br>F(bit6)：F&#x3D;1 禁止 FIQ，F&#x3D;0 使能 FIQ。<br>T(bit5)：控制指令执行状态，表明本指令是 ARM 指令还是 Thumb 指令，通常和 J(bit24)一起表明指令类型，参考 J(bit24)位。<br>M[4:0]：处理器模式控制位</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230206_170546.png"></p><h3 id="点亮led"><a href="#点亮led" class="headerlink" title="点亮led"></a>点亮led</h3><p>在开始部分用汇编来初始化一下 C 语言环境，比如初始化 DDR、设置堆栈指针 SP 等等，当这些工作都做完以后就可以进入 C 语言环境，也就是运行 C 语言代码，一般都是进入 main 函数。所以我们有两部分文件要做：<br>①、汇编文件：汇编文件只是用来完成 C 语言环境搭建。<br>②、C 语言文件：C 语言文件就是完成我们的业务层代码的，其实就是我们实际例程要完成的功能。</p><p>start.s文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 .global _start /* 全局标号 */</span><br><span class="line">2 </span><br><span class="line">3 /*</span><br><span class="line">4 * 描述： _start 函数，程序从此函数开始执行，此函数主要功能是设置 C</span><br><span class="line">5 * 运行环境。</span><br><span class="line">6 */</span><br><span class="line">7 _start:</span><br><span class="line">8 </span><br><span class="line">9 /* 进入 SVC 模式 */</span><br><span class="line">10 mrs r0, cpsr</span><br><span class="line">11 bic r0, r0, #0x1f /* 将 r0 的低 5 位清零，也就是 cpsr 的 M0~M4 */</span><br><span class="line">12 orr r0, r0, #0x13 /* r0 或上 0x13,表示使用 SVC 模式 */</span><br><span class="line">13 msr cpsr, r0 /* 将 r0 的数据写入到 cpsr_c 中 */</span><br><span class="line">14</span><br><span class="line">15 ldr sp, =0X80200000 /* 设置栈指针 */</span><br><span class="line">16 b main /* 跳转到 main 函数 */</span><br></pre></td></tr></table></figure><p>第 1 行定义了一个全局标号_start。<br>第 7 行就是标号_start 开始的地方，相当于是一个_start 函数，这个_start 就是第一行代码。<br>第 10<del>13 行就是设置处理器进入 SVC 模式，在 6.2 小节的“Cortex-A 处理器运行模型”中，设置处理器运行在 SVC 模式下。处理器模式的设置是通过修改 CPSR(程序状态)寄存器来完成的，其中 M[4:0](CPSR 的 bit[4:0])就是设置处理器运行模式的，如果要将处理器设置为 SVC 模式，那么 M[4:0]就要等于 0X13。11</del>13 行代码就是先使用指令 MRS 将 CPSR寄存器的值读取到 R0 中，然后修改 R0 中的值，设置 R0 的 bit[4:0]为 0X13，然后再使用指令MSR 将修改后的 R0 重新写入到 CPSR 中。<br>第 15 行通过 ldr 指令设置 SVC 模式下的 SP 指针&#x3D;0X80200000，因为 I.MX6U-ALPHA 开发板上的 DDR3 地址范围 是 0X80000000<del>0XA0000000(512MB) 或 者0X80000000</del>0X90000000(256MB)，不管是 512MB 版本还是 256MB 版本的，其 DDR3 起始地址都是 0X80000000。由于 Cortex-A7 的堆栈是向下增长的，所以将 SP 指针设置为 0X80200000，因此 SVC 模式的栈大小 0X80200000-0X80000000&#x3D;0X200000&#x3D;2MB，2MB 的栈空间已经很大了，如果做裸机开发的话绰绰有余。<br>第 16 行就是跳转到 main 函数，main 函数就是 C 语言代码了。<br>至此汇编部分程序执行完成，就几行代码，用来设置处理器运行到 SVC 模式下、然后初始化 SP 指针、最终跳转到 C 文件的 main 函数中。</p><p>编写led.h文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * CCM 相关寄存器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR0 *((volatile unsigned int *)0X020C4068)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR1 *((volatile unsigned int *)0X020C406C)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR2 *((volatile unsigned int *)0X020C4070)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR3 *((volatile unsigned int *)0X020C4074)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR4 *((volatile unsigned int *)0X020C4078)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR5 *((volatile unsigned int *)0X020C407C)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> CCM_CCGR6 *((volatile unsigned int *)0X020C4080)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * IOMUX 相关寄存器地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SW_MUX_GPIO1_IO03 *((volatile unsigned int *)0X020E0068)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SW_PAD_GPIO1_IO03 *((volatile unsigned int *)0X020E02F4)</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * GPIO1 相关寄存器地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_DR *((volatile unsigned int *)0X0209C000)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_GDIR *((volatile unsigned int *)0X0209C004)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_PSR *((volatile unsigned int *)0X0209C008)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_ICR1 *((volatile unsigned int *)0X0209C00C)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_ICR2 *((volatile unsigned int *)0X0209C010)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_IMR *((volatile unsigned int *)0X0209C014)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_ISR *((volatile unsigned int *)0X0209C018)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> GPIO1_EDGE_SEL *((volatile unsigned int *)0X0209C01C)</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>编写led.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  @description : 使能 I.MX6U 所有外设时钟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">clk_enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> CCM_CCGR0 = <span class="number">0xffffffff</span>;</span><br><span class="line"> CCM_CCGR1 = <span class="number">0xffffffff</span>;</span><br><span class="line"> CCM_CCGR2 = <span class="number">0xffffffff</span>;</span><br><span class="line">CCM_CCGR3 = <span class="number">0xffffffff</span>;</span><br><span class="line">CCM_CCGR4 = <span class="number">0xffffffff</span>;</span><br><span class="line">CCM_CCGR5 = <span class="number">0xffffffff</span>;</span><br><span class="line">CCM_CCGR6 = <span class="number">0xffffffff</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  @description : 初始化 LED 对应的 GPIO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">/* 1、初始化 IO 复用, 复用为 GPIO1_IO03 */</span></span><br><span class="line"> SW_MUX_GPIO1_IO03 = <span class="number">0x5</span>;  </span><br><span class="line"> <span class="comment">/* 2、配置 GPIO1_IO03 的 IO 属性 </span></span><br><span class="line"><span class="comment">bit 16:0 HYS 关闭</span></span><br><span class="line"><span class="comment">bit [15:14]: 00 默认下拉</span></span><br><span class="line"><span class="comment"> bit [13]: 0 kepper 功能</span></span><br><span class="line"><span class="comment"> bit [12]: 1 pull/keeper 使能</span></span><br><span class="line"><span class="comment"> bit [11]: 0 关闭开路输出</span></span><br><span class="line"><span class="comment"> bit [7:6]: 10 速度 100Mhz</span></span><br><span class="line"><span class="comment"> bit [5:3]: 110 R0/6 驱动能力</span></span><br><span class="line"><span class="comment"> bit [0]: 0 低转换率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SW_PAD_GPIO1_IO03 = <span class="number">0X10B0</span>; </span><br><span class="line"> <span class="comment">/* 3、初始化 GPIO, GPIO1_IO03 设置为输出 */</span></span><br><span class="line">GPIO1_GDIR = <span class="number">0X0000008</span>;</span><br><span class="line"> <span class="comment">/* 4、设置 GPIO1_IO03 输出低电平，打开 LED0 */</span></span><br><span class="line">GPIO1_DR = <span class="number">0X0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   打开 LED 灯</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">led_on</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将 GPIO1_DR 的 bit3 清零 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> GPIO1_DR &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : 关闭 LED 灯</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">led_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * 将 GPIO1_DR 的 bit3 置 1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> GPIO1_DR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * @description : 短时间延时函数</span></span><br><span class="line"><span class="comment">   * @param - n : 要延时循环次数(空操作循环次数，模式延时)</span></span><br><span class="line"><span class="comment">   * @return : 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_short</span><span class="params">(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span>(n--)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : 延时函数,在 396Mhz 的主频下延时时间大约为 1ms</span></span><br><span class="line"><span class="comment"> * @param - n : 要延时的 ms 数</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"> delay_short(<span class="number">0x7ff</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> clk_enable(); <span class="comment">/* 使能所有的时钟 */</span></span><br><span class="line"> led_init(); <span class="comment">/* 初始化 led */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">/* 死循环 */</span></span><br><span class="line">&#123; </span><br><span class="line"> led_off(); <span class="comment">/* 关闭 LED */</span></span><br><span class="line"> delay(<span class="number">500</span>); <span class="comment">/* 延时大约 500ms */</span></span><br><span class="line">led_on(); <span class="comment">/* 打开 LED */</span></span><br><span class="line"> delay(<span class="number">500</span>); <span class="comment">/* 延时大约 500ms */</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就编写Makefile文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">objects: start.o led.o</span></span><br><span class="line"><span class="section">ledc.bin:<span class="variable">$(objects)</span></span></span><br><span class="line">arm-linux-gnuebihf-ld -Ttext 0X8780000 -o ledc.elf start.o led.o</span><br><span class="line">arm-linux-gnuebihf-objcopy -O binary -S ledc.edf ledc.bin</span><br><span class="line">arm-linux-gnueabihf-objdump -D -m arm ledc.elf &gt; ledc.dis</span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.s</span></span><br><span class="line">arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">%.o:%.S</span></span><br><span class="line">arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">arm-linux-gnueabihf-gcc -Wall -nostdlib -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm-rf *.o ledc.bin ledc.elf ledc.dis</span><br></pre></td></tr></table></figure><p>第一行定义变量，第二行默认目标目的是生成start.o 和led.o，之后是使用arm-linux-gnueabihf-ld进行链接，链接地址是0X87800000,之后是编译为ledc.bin文件，在之后是反汇编，第七行是针对不同文件生成对应的.o文件，用到了自动变量$@和$&lt;,其中“$&lt;”的意思是依赖目标集合的第一个文件</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230206_230300.png"></p><h4 id="链接脚本编写格式"><a href="#链接脚本编写格式" class="headerlink" title="链接脚本编写格式"></a>链接脚本编写格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 SECTIONS&#123;</span><br><span class="line">2 . = 0X10000000;</span><br><span class="line">3 .text : &#123;*(.text)&#125;</span><br><span class="line">4 . = 0X30000000;</span><br><span class="line">5 .data ALIGN(4) : &#123; *(.data) &#125; </span><br><span class="line">6 .bss ALIGN(4) : &#123; *(.bss) &#125; </span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure><p>第 1 行我们先写了一个关键字“SECTIONS”，后面跟了一个大括号，这个大括号和第 7 行的大括号是一对，这是必须的。看起来就跟 C 语言里面的函数一样。<br>第 2 行对一个特殊符号“.”进行赋值，“.”在链接脚本里面叫做定位计数器，默认的定位计数器为 0。我们要求代码链接到以 0X10000000 为起始地址的地方，因此这一行给“.”赋值0X10000000，表示以 0X10000000 开始，后面的文件或者段都会以 0X10000000 为起始地址开始链接。<br>第 3 行的“.text”是段名，后面的冒号是语法要求，冒号后面的大括号里面可以填上要链接到“.text”这个段里面的所有文件，“*(.text)”中的“*”是通配符，表示所有输入文件的.text段都放到“.text”中。<br>第 4 行，我们的要求是数据放到 0X30000000 开始的地方，所以我们需要重新设置定位计数器“.”，将其改为 0X30000000。如果不重新设置的话会怎么样？假设“.text”段大小为 0X10000，那么接下来的.data 段开始地址就是 0X10000000+0X10000&#x3D;0X10010000，这明显不符合我们的要求。所以我们必须调整定位计数器为 0X30000000。<br>第 5 行跟第 3 行一样，定义了一个名为“.data”的段，然后所有文件的“.data”段都放到这里面。但是这一行多了一个“ALIGN(4)”，这是什么意思呢？这是用来对“.data”这个段的起始地址做字节对齐的，ALIGN(4)表示 4 字节对齐。也就是说段“.data”的起始地址要能被 4 整除，一般常见的都是 ALIGN(4)或者 ALIGN(8)，也就是 4 字节或者 8 字节对齐。<br>第 6 行定义了一个“.bss”段，所有文件中的“.bss”数据都会被放到这个里面，“.bss”数据就是那些定义了但是没有被初始化的变量。上面就是链接脚本最基本的语法格式，我们接下来就按照这个基本的语法格式来编写我们本试验的链接脚本，我们本试验的链接脚本要求如下：<br>①、链接起始地址为 0X87800000。<br>②、start.o 要被链接到最开始的地方，因为 start.o 里面包含这第一个要执行的命令。</p><h5 id="imx6ul-lds-链接脚本代码"><a href="#imx6ul-lds-链接脚本代码" class="headerlink" title="imx6ul.lds 链接脚本代码"></a>imx6ul.lds 链接脚本代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 SECTIONS&#123;</span><br><span class="line">2 . = 0X87800000;</span><br><span class="line">3 .text :</span><br><span class="line">4 &#123;</span><br><span class="line">5 start.o </span><br><span class="line">6led.o </span><br><span class="line">7 *(.text)</span><br><span class="line">8 &#125;</span><br><span class="line">9 .rodata ALIGN(4) : &#123;*(.rodata*)&#125; </span><br><span class="line">10 .data ALIGN(4) : &#123; *(.data) &#125; </span><br><span class="line">11 __bss_start = .; </span><br><span class="line">12 .bss ALIGN(4) : &#123; *(.bss) *(COMMON) &#125; </span><br><span class="line">13 __bss_end = .;</span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><p>第 11、13 这两行其实就是对这两个符号进行赋值，其值为定位符“.”，这两个符号用来保存.bss 段的起始地址和结束地址,前面说了.bss 段是定义了但是没有被初始化的变量，我们需要手动对.bss 段的变量清零的，因此我们需要知道.bss 段的起始和结束地址，这样我们直接对这段内存赋 0 即可完成清零。通过第 11、13 行代码，.bss 段的起始地址和结束地址就保存在了“__bss_start”和“__bss_end”中，我们就可以直接在汇编或者 C 文件里面使用这两个符号。</p><h5 id="修改-Makefile"><a href="#修改-Makefile" class="headerlink" title="修改 Makefile"></a>修改 Makefile</h5><p>已经编写好了链接脚本文件：imx6ul.lds，将 Makefile 中的如下一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld -Ttext 0X87800000 -o ledc.elf $^</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld -Timx6ul.lds -o ledc.elf $^</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编点亮led</title>
      <link href="/2023/02/05/2023-2-5-%E6%B1%87%E7%BC%96%E7%82%B9%E4%BA%AEled/"/>
      <url>/2023/02/05/2023-2-5-%E6%B1%87%E7%BC%96%E7%82%B9%E4%BA%AEled/</url>
      
        <content type="html"><![CDATA[<p>I.MX6ULL的IO分为SNVS域值和通用的。</p><p>点亮led的GPIO需要以下设置：</p><p>①、使能 GPIO 对应的时钟。<br>②、设置寄存器 IOMUXC_SW_MUX_CTL_PAD_XX_XX，设置 IO 的复用功能，使其复用<br>为 GPIO 功能。<br>③、设置寄存器 IOMUXC_SW_PAD_CTL_PAD_XX_XX，设置 IO 的上下拉、速度等等。<br>④、第②步已经将 IO 复用为了 GPIO 功能，所以需要配置 GPIO，设置输入&#x2F;输出、是否使<br>用中断、默认输出电平等。</p><p>1.首先是定义全局标号_start,代码是从这开始续写。</p><p>2.像stm32一样使能时钟，首先是查询手册查找每一个CCGR的地址并将其进行置1，为点亮led，使GPIO进行复用。查询手册寻找SW_MUX_GPIO_IO103_BASE的地址，并且查看手册MUX_MODE将其设置为GPIO的输出。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230205_220552.png"></p><p>会是ALT5模式置0101来调为GPIO输出，GPIO1_IO00有两个书签：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00<span class="comment">//配置复用模式</span></span><br><span class="line">IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO00<span class="comment">//配置电气属性</span></span><br></pre></td></tr></table></figure><p>3.查询IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03的地址根据手册配置电气属性。</p><p>4.之后配置GPIO为输出模式</p><p>5.GPIO1_IO03 已经配置好了，只需要向 GPIO1_DR 寄存器的 bit3 写入 0 即可控制 GPIO1_IO03 输出低电平，打开 LED，向 bit3 写入 1 可控制 GPIO1_IO03 输出高电平，关闭 LED。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">2 .global _start /* 全局标号 */</span><br><span class="line">3 </span><br><span class="line">4 /*</span><br><span class="line">5 * 描述： _start 函数，程序从此函数开始执行此函数完成时钟使能、</span><br><span class="line">6 * GPIO 初始化、最终控制 GPIO 输出低电平来点亮 LED 灯。</span><br><span class="line">7 */</span><br><span class="line">8 _start:</span><br><span class="line">9 /* 例程代码 */</span><br><span class="line">10 /* 1、使能所有时钟 */</span><br><span class="line">11 ldr r0, =0X020C4068 /* 寄存器 CCGR0 */</span><br><span class="line">12 ldr r1, =0XFFFFFFFF </span><br><span class="line">13 str r1, [r0] </span><br><span class="line">14 </span><br><span class="line">15 ldr r0, =0X020C406C /* 寄存器 CCGR1 */</span><br><span class="line">16 str r1, [r0]</span><br><span class="line">17</span><br><span class="line">18 ldr r0, =0X020C4070 /* 寄存器 CCGR2 */</span><br><span class="line">19 str r1, [r0]</span><br><span class="line">20 </span><br><span class="line">21 ldr r0, =0X020C4074 /* 寄存器 CCGR3 */</span><br><span class="line">22 str r1, [r0]</span><br><span class="line">23 </span><br><span class="line">24 ldr r0, =0X020C4078 /* 寄存器 CCGR4 */</span><br><span class="line">25 str r1, [r0]</span><br><span class="line">26 </span><br><span class="line">27 ldr r0, =0X020C407C /* 寄存器 CCGR5 */</span><br><span class="line">28 str r1, [r0]</span><br><span class="line">29 </span><br><span class="line">30 ldr r0, =0X020C4080 /* 寄存器 CCGR6 */</span><br><span class="line">31 str r1, [r0]</span><br><span class="line">32 </span><br><span class="line">33</span><br><span class="line">34 /* 2、设置 GPIO1_IO03 复用为 GPIO1_IO03 */</span><br><span class="line">35 ldr r0, =0X020E0068 /* 将寄存器 SW_MUX_GPIO1_IO03_BASE 加载到 r0 中 */</span><br><span class="line">36 ldr r1, =0X5 /* 设置寄存器 SW_MUX_GPIO1_IO03_BASE 的 MUX_MODE 为 5 */</span><br><span class="line">37 str r1,[r0]</span><br><span class="line">38</span><br><span class="line">39 /* 3、配置 GPIO1_IO03 的 IO 属性 </span><br><span class="line">40 *bit 16:0 HYS 关闭</span><br><span class="line">41 *bit [15:14]: 00 默认下拉</span><br><span class="line">42 *bit [13]: 0 kepper 功能</span><br><span class="line">43 *bit [12]: 1 pull/keeper 使能</span><br><span class="line">44 *bit [11]: 0 关闭开路输出</span><br><span class="line">45 *bit [7:6]: 10 速度 100Mhz</span><br><span class="line">46 *bit [5:3]: 110 R0/6 驱动能力</span><br><span class="line">47 *bit [0]: 0 低转换率</span><br><span class="line">48 */</span><br><span class="line">49 ldr r0, =0X020E02F4 /*寄存器 SW_PAD_GPIO1_IO03_BASE */</span><br><span class="line">50 ldr r1, =0X10B0/*把IO属性按照位来转换成16进制之后置位*/</span><br><span class="line">51 str r1,[r0]</span><br><span class="line">52</span><br><span class="line">53 /* 4、设置 GPIO1_IO03 为输出 */</span><br><span class="line">54 ldr r0, =0X0209C004 /*寄存器 GPIO1_GDIR */</span><br><span class="line">55 ldr r1, =0X0000008 </span><br><span class="line">56 str r1,[r0]</span><br><span class="line">57</span><br><span class="line">58 /* 5、打开 LED0</span><br><span class="line">59 * 设置 GPIO1_IO03 输出低电平</span><br><span class="line">60 */</span><br><span class="line">61 ldr r0, =0X0209C000 /*寄存器 GPIO1_DR */</span><br><span class="line">62 ldr r1, =0 </span><br><span class="line">63 str r1,[r0]</span><br><span class="line">64</span><br><span class="line">65 /*</span><br><span class="line">66 * 描述： loop 死循环</span><br><span class="line">67 */</span><br><span class="line">68 loop:</span><br><span class="line">69 b loop</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arm汇编</title>
      <link href="/2023/02/04/2023-2-4-arm%E6%B1%87%E7%BC%96/"/>
      <url>/2023/02/04/2023-2-4-arm%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="GNU-汇编语法"><a href="#GNU-汇编语法" class="headerlink" title="GNU 汇编语法"></a>GNU 汇编语法</h1><p>GNU汇编语法适用于所有架构，每条语句有三个可选部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label：instruction @ comment</span><br></pre></td></tr></table></figure><p>label 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。<br>instruction 即指令，也就是汇编指令或伪指令。<br>@符号，表示后面的是注释。<br>comment 就是注释内容。</p><p><strong>注意！ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。</strong></p><p>用户可以使用.section 伪操作来定义一个段，汇编系统预定义了一些段名：<br>.text 表示代码段。<br>.data 初始化的数据段。<br>.bss 未初始化的数据段。<br>.rodata 只读数据段。</p><p>常见的伪操作有：<br>.byte 定义单字节数据，比如.byte 0x12。<br>.short 定义双字节数据，比如.short 0x1234。<br>.long 定义一个 4 字节数据，比如.long 0x12345678。<br>.equ 赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示 num&#x3D;0x12。<br>.align 数据字节对齐，比如：.align 4 表示 4 字节对齐。<br>.end 表示源文件结束。<br>.global 定义一个全局符号，格式为：.global symbol，比如：.global _start。</p><h3 id="内部传输指令"><a href="#内部传输指令" class="headerlink" title="内部传输指令"></a>内部传输指令</h3><p><strong>MOV指令</strong></p><p>MOV 指令用于将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0，R1 @将寄存器 R1 中的数据传递给 R0，即 R0=R1</span><br><span class="line">MOV R0, #0X12 @将立即数 0X12 传递给 R0 寄存器，即 R0=0X12</span><br></pre></td></tr></table></figure><p><strong>MRS指令</strong></p><p>MRS 指令用于将特殊寄存器(如 CPSR 和 SPSR)中的数据传递给通用寄存器，要读取特殊寄存器的数据只能使MRS </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRS R0, CPSR @将特殊寄存器 CPSR 里面的数据传递给 R0，即 R0=CPSR</span><br></pre></td></tr></table></figure><p><strong>MSR指令</strong></p><p>MSR 指令用来将普通寄存器的数据传递给特殊寄存器，写特殊寄存器只能使用MSR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSR CPSR, R0 @将 R0 中的数据复制到 CPSR 中，即 CPSR=R0</span><br></pre></td></tr></table></figure><p><strong>存储器访问指令</strong></p><p>ARM 不能直接访问存储器，一般先将要配置的值写入到 Rx(x&#x3D;0~12)寄存器中，然后借助存储器访问指令将 Rx 中的数据写入到 I.MX6UL 寄存器中。常用的存储器访问指令有两种：LDR 和STR。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/capture_20230204195445731.bmp"></p><p>LDR 主要用于从存储加载数据到寄存器 Rx 中，LDR 也可以将一个立即数加载到寄存器 Rx中，LDR 加载立即数的时候要使用“&#x3D;”，而不是“#”。在嵌入式开发中，LDR 最常用的就是读取 CPU 的寄存器值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</span><br><span class="line">2 LDR R1, [R0] @读取地址 0X0209C004 中的数据到 R1 寄存器中</span><br></pre></td></tr></table></figure><p>STR 就是将数据写入到存储器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</span><br><span class="line">2 LDR R1, =0X20000002 @R1 保存要写入到寄存器的值，即 R1=0X20000002</span><br><span class="line">3 STR R1, [R0] @将 R1 中的值写入到 R0 中所保存的地址中</span><br></pre></td></tr></table></figure><p>LDR 和 STR 都是按照字进行读取和写入的（操作的 32 位数据），如果要按照字节、半字进行操作的话可以在指令“LDR”后面加上 B 或 H，比如按字节操作的指令就是 LDRB 和STRB，按半字操作的指令就是 LDRH 和 STRH。</p><p><strong>压栈和出栈命令</strong></p><p>我们通常会在 A 函数中调用 B 函数，当 B 函数执行完以后再回到 A 函数继续执行。要想再跳回 A 函数以后代码能够接着正常运行，那就必须在跳到 B 函数之前将当前处理器状态保存起来(就是保存 R0<del>R15 这些寄存器值)，当 B 函数执行完成以后再用前面保存的寄存器值恢复R0</del>R15 即可。保存 R0<del>R15 寄存器的操作就叫做<u>现场保护</u>，恢复 R0</del>R15 寄存器的操作就叫做<u>恢复现场</u>。<strong>在进行现场保护的时候需要进行压栈(入栈)操作，恢复现场就要进行出栈操作。</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230204_200747.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUSH &#123;R0~R3, R12&#125; @将 R0~R3 和 R12 压栈</span><br><span class="line">PUSH &#123;LR&#125; @将 LR 进行压栈</span><br><span class="line">POP &#123;LR&#125; @先恢复 LR</span><br><span class="line">POP &#123;R0~R3,R12&#125; @在恢复 R0~R3,R12</span><br></pre></td></tr></table></figure><p>PUSH 和 POP 的另外一种写法是“STMFD SP！”和“LDMFD SP!”.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 STMFD SP!,&#123;R0~R3, R12&#125; @R0~R3,R12 入栈</span><br><span class="line">2 STMFD SP!,&#123;LR&#125; @LR 入栈</span><br><span class="line">4 LDMFD SP!, &#123;LR&#125; @先恢复 LR</span><br><span class="line">5 LDMFD SP!, &#123;R0~R3, R12&#125; @再恢复 R0~R3, R12</span><br></pre></td></tr></table></figure><p>SP 指向最后一个入栈的数值，堆栈是由高地址向下增长的，也就是前面说的向下增长的堆栈。</p><p><strong>跳转指令</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230204_202454.png"></p><p><strong>B指令</strong></p><p>B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指令，ARM 处理器就会立即跳转到指定的目标地址。如果要调用的函数不会再返回到原来的执行处，那就可以用 B 指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 _start:</span><br><span class="line">2</span><br><span class="line">3 ldr sp,=0X80200000 @设置栈指针</span><br><span class="line">4 b main @跳转到 main 函数</span><br></pre></td></tr></table></figure><p>上述代码就是典型的在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行，只是初始化了 SP 指针，有些处理器还需要做其他的初始化，</p><p><strong>BL指令</strong></p><p>BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。比如 Cortex-A 处理器的 irq 中断服务函数都是汇编写的，主要用汇编来实现现场的保护和恢复、获取中断号等。但是具体的中断处理过程都是 C 函数，所以就会存在汇编中调用 C 函数的问题。而且当 C 语言版本的中断处理函数执行完成以后是需要返回到irq 汇编中断服务函数，因为还要处理其他的工作，一般是恢复现场。这个时候就不能直接使用B 指令了，因为 B 指令一旦跳转就再也不会回来了，这个时候要使用 BL 指令，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 push &#123;r0, r1&#125; @保存 r0,r1</span><br><span class="line">2 cps #0x13 @进入 SVC 模式，允许其他中断再次进去</span><br><span class="line">3</span><br><span class="line">5 bl system_irqhandler @加载 C 语言中断处理函数到 r2 寄存器中</span><br><span class="line">6</span><br><span class="line">7 cps #0x12 @进入 IRQ 模式</span><br><span class="line">8 pop &#123;r0, r1&#125; </span><br><span class="line">9 str r0, [r1, #0X10] @中断执行完成，写 EOIR</span><br></pre></td></tr></table></figure><p><strong>算数指令</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230204_223246.png"></p><p><strong>逻辑运算指令</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230204_223427.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 裸机开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2023/01/20/2023-1-20-%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/01/20/2023-1-20-%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>线程是参与系统调度的最小单位。它被包含在进程之中，是进程中的实际运行单位。一个线程指的是进程中一个单一顺序的控制流（或者说是执行路线、执行流），一个进程中可以创建多个线程，多个线程实现并发运行，每个线程执行不同的任务。</strong></p><p>任何一个进程都包含一个主线程，只有主线程的进程称为单线程进程.</p><p>那自然就存在多线程进程，所谓多线程指的是除了主线程以外，还包含其它的线程，其它线程通常由主线程来创建（调用pthread_create 创建一个新的线程），那么创建的新线程就是主线程的子线程。</p><p>主线程的重要性体现在两方面：<br>⚫ 其它新的线程（也就是子线程）是由主线程创建的；<br>⚫ 主线程通常会在最后结束运行，执行各种清理工作，譬如回收各个子线程。</p><p>线程是程序最基本的运行单位，而进程不能运行，真正运行的是进程中的线程。同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack，我们称为线程栈），自己的寄存器环境（register context）、自己的线程本地存储（thread-local storage）。</p><p><strong>多进程编程的劣势：</strong><br>⚫ 进程间切换开销大。多个进程同时运行（指宏观上同时运行，无特别说明，均指宏观上），微观上依然是轮流切换运行，进程间切换开销远大于同一进程的多个线程间切换的开销，通常对于一些中小型应用程序来说不划算。<br>⚫ 进程间通信较为麻烦。每个进程都在各自的地址空间中、相互独立、隔离，处在于不同的地址空间中，因此相互通信较为麻烦，在上一章节给大家有所介绍。<br>解决方案便是使用多线程编程，多线程能够弥补上面的问题：<br>⚫ 同一进程的多个线程间切换开销比较小。<br>⚫ 同一进程的多个线程间通信容易。它们共享了进程的地址空间，所以它们都是在同一个地址空间中，通信容易。<br>⚫ 线程创建的速度远大于进程创建的速度。<br>⚫ 多线程在多核处理器上更有优势！</p><blockquote><p>并行：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。<br>并发：当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。</p></blockquote><p>内核实现了调度算法，用于控制系统中所有线程的调度，简单点来说，系统中所有参与调度的线程会加入到系统的调度队列中，它们由内核控制，每一个线程执行一段时间后，由系统调度切换执行调度队列中下一个线程，依次进行。</p><p>就像每个进程都有一个进程 ID 一样，每个线程也有其对应的标识，称为线程 ID。进程 ID 在整个系统中是唯一的。一个线程可通过库函数 pthread_self()来获取自己的线程 ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure><p>如果两个线程 ID t1 和 t2 相等，则 pthread_equal()返回一个非零值；否则返回 0。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>主线程可以使用库函数 pthread_create()负责创建一个新的线程，创建出来的新线程被称为主线程的子线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><p>thread：pthread_t 类型指针，当 pthread_create()成功返回时，新创建的线程的线程 ID 会保存在参数 thread所指向的内存中，后续的线程相关函数会使用该标识来引用此线程。<br>attr：pthread_attr_t 类型指针，指向 pthread_attr_t 类型的缓冲区，pthread_attr_t 数据类型定义了线程的各种属性，如果将参数 attr 设置为 NULL，那么表示将线程的所有属性设置为默认值，以此创建新线程。<br>start_routine：参数 start_routine 是一个函数指针，指向一个函数，新创建的线程从 start_routine()函数开始运行，该函数返回值类型为void *，并且该函数的参数只有一个void *，其实这个参数就是pthread_create()函数的第四个参数 arg。如果需要向 start_routine()传递的参数有一个以上，那么需要把这些参数放到一个结构体中，然后把这个结构体对象的地址作为 arg 参数传入。<br>arg：传递给 start_routine()函数的参数。一般情况下，需要将 arg 指向一个全局或堆变量，意思就是说在线程的生命周期中，该 arg 指向的对象必须存在，否则如果线程中访问了该对象将会出现错误。当然也可将参数 arg 设置为 NULL，表示不需要传入参数给 start_routine()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">new_thread_start</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程: 进程 ID&lt;%d&gt; 线程 ID&lt;%lu&gt;\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"> <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pthread_t</span> tid;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;主线程: 进程 ID&lt;%d&gt; 线程 ID&lt;%lu&gt;\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>在新线程的启动函数（线程 start 函数）new_thread_start()通过 return 返回之<br>后，意味着该线程已经终止了，除了在线程 start 函数中执行 return 语句终止线程外，终止线程的方式还有<br>多种，可以通过如下方式终止线程的运行：<br>⚫ 线程的 start 函数执行 return 语句并返回指定值，返回值就是线程的退出码；<br>⚫ 线程调用 pthread_exit()函数；<br>⚫ 调用 pthread_cancel()取消线程</p><p>如果进程中的任意线程调用 exit()、_exit()或者_Exit()，那么将会导致整个进程终止，这里需要注意！</p><p>pthread_exit()函数将终止调用它的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><p>参数 retval 的数据类型为 void *，指定了线程的返回值、也就是线程的退出码，该返回值可由另一个线程通过调用 pthread_join()来获取；同理，如果线程是在 start 函数中执行 return 语句终止，那么 return 的返回值也是可以通过 pthread_join()来获取的。<br>参数 retval 所指向的内容不应分配于线程栈中，因为线程终止后，将无法确定线程栈的内容是否有效；出于同样的理由，也不应在线程栈中分配线程 start 函数的返回值。<br>调用 pthread_exit()相当于在线程的 start 函数中执行 return 语句，不同之处在于，可在线程 start 函数所调用的任意函数中调用 pthread_exit()来终止线程。如果主线程调用了 pthread_exit()，那么主线程也会终止，但其它线程依然正常运行，直到进程中的所有线程终止才会使得进程终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">new_thread_start</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程 start\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程 end\n&quot;</span>);</span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pthread_t</span> tid;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;主线程 end\n&quot;</span>);</span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取消线程"><a href="#取消线程" class="headerlink" title="取消线程"></a>取消线程</h3><p>进程中的多个线程会并发执行，每个线程各司其职，直到线程的任务完成之后，该线程中会调用 pthread_exit()退出，或在线程 start 函数执行 return 语句退出。</p><p>在程序设计需求当中，需要向一个线程发送一个请求，要求它立刻退出，我们把这种操作称为取消线程，也就是向指定的线程发送一个请求，要求其立刻终止、退出。譬如，一组线程正在执行一个运算，一旦某个线程检测到错误发生，需要其它线程退出，取消线程这项功能就派上用场了。</p><p>通过调用 pthread_cancel()库函数向一个指定的线程发送取消请求，其函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> ** retval)</span>;</span><br></pre></td></tr></table></figure><p>  thread 参数用于指定接收哪个线程的返回值；retval 参数表示接收到的返回值，如果 thread 线程没有返回值，又或者我们不需要接收 thread 线程的返回值，可以将 retval 参数置为 NULL。</p><p>pthread_join() 函数会一直阻塞调用它的线程，直至目标线程执行结束（接收到目标线程的返回值），阻塞状态才会解除。如果 pthread_join() 函数成功等到了目标线程执行结束（成功获取到目标线程的返回值），返回值为数字 0；反之如果执行失败，函数会根据失败原因返回相应的非零值，每个非零值都对应着不同的宏  。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">new_thread_start</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程--running\n&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> ( ; ; )</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pthread_t</span> tid;</span><br><span class="line"> <span class="type">void</span> *tret;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 创建新线程 */</span></span><br><span class="line"> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="comment">/* 向新线程发送取消请求 */</span></span><br><span class="line"> ret = pthread_cancel(tid);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_cancel error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 等待新线程终止 */</span></span><br><span class="line"> ret = pthread_join(tid, &amp;tret);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程终止, code=%ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消状态以及类型</p><p>当然，线程可以选择不被取消或者控制如何被取消，通过 pthread_setcancelstate()和 pthread_setcanceltype()来设置线程的取消性状态和类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure><p>使用这些函数需要包含头文件，pthread_setcancelstate()函数会将调用线程的取消性状态设置为参数 state 中给定的值，并将线程之前的取消性状态保存在参数 oldstate 指向的缓冲区中，如果对之前的状态不感兴趣，Linux 允许将参数 oldstate 设置为 NULL；pthread_setcancelstate()调用成功将返回 0，失败返回非 0 值的错误码。<br>pthread_setcancelstate()函数执行的设置取消性状态和获取旧状态操作，这两步是一个原子操作。<br>参数 state 必须是以下值之一：<br>⚫ PTHREAD_CANCEL_ENABLE：线程可以取消，这是新创建的线程取消性状态的默认值，所以<br>新建线程以及主线程默认都是可以取消的。<br>⚫ PTHREAD_CANCEL_DISABLE：线程不可被取消，如果此类线程接收到取消请求，则会将请求<br>挂起，直至线程的取消性状态变为 PTHREAD_CANCEL_ENABLE。</p><p><strong>pthread_setcanceltype()函数</strong><br>如果线程的取消性状态为 PTHREAD_CANCEL_ENABLE，那么对取消请求的处理则取决于线程的取消性类型，该类型可以通过调用 pthread_setcanceltype()函数来设置，它的参数 type 指定了需要设置的类型，而线程之前的取消性类型则会保存在参数 oldtype 所指向的缓冲区中，如果对之前的类型不敢兴趣，Linux下允许将参数 oldtype 设置为 NULL。同样 pthread_setcanceltype()函数调用成功将返回 0，失败返回非 0 值的错误码。<br>pthread_setcanceltype()函数执行的设置取消性类型和获取旧类型操作，这两步是一个原子操作。<br>参数 type 必须是以下值之一：<br>⚫ PTHREAD_CANCEL_DEFERRED：取消请求到来时，线程还是继续运行，取消请求被挂起，直到线程到达某个取消点（cancellation point，将在 11.6.3 小节介绍）为止，这是所有新建线程包括主线程默认的取消性类型。<br>⚫ PTHREAD_CANCEL_ASYNCHRONOUS：可能会在任何时间点（也许是立即取消，但不一定）<br>取消线程，当某个线程调用 fork()创建子进程时，子进程会继承调用线程的取消性状态和取消性类型，而当某线程<br>调 用 exec 函 数 时 ， 会 将 新 程 序 主 线 程 的 取 消 性 状 态 和 类 型 重 置 为 默 认 值 ， 也 就 是<br>PTHREAD_CANCEL_ENABLE 和 PTHREAD_CANCEL_DEFERRED。</p><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>默认情况下，当线程终止时，其它线程可以通过调用 pthread_join()获取其返回状态、回收线程资源，有时，程序员并不关系线程的返回状态，只是希望系统在线程终止时能够自动回收线程资源并将其移除。在这种情况下，可以调用 pthread_detach()将指定线程进行分离，也就是分离线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>使用该函数需要包含头文件，参数 thread 指定需要分离的线程，函数 pthread_detach()调用成功将返回 0；失败将返回一个错误码。一个线程既可以将另一个线程分离，同时也可以将自己分离，譬如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(pthread_self());</span><br></pre></td></tr></table></figure><p>一旦线程处于分离状态，就不能再使用 pthread_join()来获取其终止状态，此过程是不可逆的，一旦处于分离状态之后便不能再恢复到之前的状态。处于分离状态的线程，当其终止后，能够自动回收线程资源。</p><h3 id="注册线程清理处理函数"><a href="#注册线程清理处理函数" class="headerlink" title="注册线程清理处理函数"></a>注册线程清理处理函数</h3><p>使用 atexit()函数注册进程终止处理函数，当进程调用 exit()退出时就会执行进程终止处理函数；其实，当线程退出时也可以这样做，当线程终止退出时，去执行这样的处理函数，我们把这个称为线程清理函数（thread cleanup handler）。与进程不同，一个线程可以注册多个清理函数，这些清理函数记录在栈中，每个线程都可以拥有一个清理函数栈，栈是一种先进后出的数据结构，也就是说它们的执行顺序与注册（添加）顺序相反，当执行完所<br>有清理函数后，线程终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;<span class="comment">//添加清理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;<span class="comment">//移除清理函数</span></span><br></pre></td></tr></table></figure><p>当线程执行以下动作时，清理函数栈中的清理函数才会被执行：<br>⚫ 线程调用 pthread_exit()退出时；<br>⚫ 线程响应取消请求时；<br>⚫ 用非 0 参数调用 pthread_cleanup_pop()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;cleanup: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">new_thread_start</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程--start run\n&quot;</span>);</span><br><span class="line"> pthread_cleanup_push(cleanup, <span class="string">&quot;第 1 次调用&quot;</span>);</span><br><span class="line"> pthread_cleanup_push(cleanup, <span class="string">&quot;第 2 次调用&quot;</span>);</span><br><span class="line"> pthread_cleanup_push(cleanup, <span class="string">&quot;第 3 次调用&quot;</span>);</span><br><span class="line"> sleep(<span class="number">2</span>);</span><br><span class="line"> pthread_exit((<span class="type">void</span> *)<span class="number">0</span>); <span class="comment">//线程终止</span></span><br><span class="line"> <span class="comment">/* 为了与 pthread_cleanup_push 配对,不添加程序编译会通不过 */</span></span><br><span class="line"> pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line"> pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">     pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pthread_t</span> tid;</span><br><span class="line"> <span class="type">void</span> *tret;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 创建新线程 */</span></span><br><span class="line"> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 等待新线程终止 */</span></span><br><span class="line"> ret = pthread_join(tid, &amp;tret);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;新线程终止, code=%ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程栈属性"><a href="#线程栈属性" class="headerlink" title="线程栈属性"></a>线程栈属性</h2><p>每个线程都有自己的栈空间，pthread_attr_t 数据结构中定义了栈的起始地址以及栈大小，调用函数pthread_attr_getstack()可以获取这些信息，函数 pthread_attr_setstack()对栈起始地址和栈大小进行设置，其函<br>数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstack</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr, <span class="type">size_t</span> *stacksize)</span>;</span><br></pre></td></tr></table></figure><p>使用这些函数需要包含头文件，函数 pthread_attr_getstack()，参数和返回值含义如下：<br>attr：参数 attr 指向线程属性对象。<br>stackaddr：调用 pthread_attr_getstack()可获取栈起始地址，并将起始地址信息保存在*stackaddr 中；<br>stacksize：调用 pthread_attr_getstack()可获取栈大小，并将栈大小信息保存在参数 stacksize 所指向的内存中；<br>返回值：成功返回 0，失败将返回一个非 0 值的错误码。<br>函数 pthread_attr_setstack()，参数和返回值含义如下：<br>attr：参数 attr 指向线程属性对象。<br>stackaddr：设置栈起始地址为指定值。<br>stacksize：设置栈大小为指定值；<br>返回值：成功返回 0，失败将返回一个非 0 值的错误码。</p><p>如果想单独获取或设置栈大小、栈起始地址，可以使用下面这些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstackaddr</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstackaddr</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">new_thread_start</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pthread_attr_t</span> attr;</span><br><span class="line"> <span class="type">size_t</span> stacksize;</span><br><span class="line"> <span class="type">pthread_t</span> tid;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 对 attr 对象进行初始化 */</span></span><br><span class="line"> pthread_attr_init(&amp;attr);</span><br><span class="line"> <span class="comment">/* 设置栈大小为 4K */</span></span><br><span class="line"> pthread_attr_setstacksize(&amp;attr, <span class="number">4096</span>);</span><br><span class="line"> <span class="comment">/* 创建新线程 */</span></span><br><span class="line"> ret = pthread_create(&amp;tid, &amp;attr, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 等待新线程终止 */</span></span><br><span class="line"> ret = pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (ret) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 销毁 attr 对象 */</span></span><br><span class="line"> pthread_attr_destroy(&amp;attr);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C issue2</title>
      <link href="/2023/01/13/2022-11-25-C-issue2/"/>
      <url>/2023/01/13/2022-11-25-C-issue2/</url>
      
        <content type="html"><![CDATA[<h3 id="堆栈空间"><a href="#堆栈空间" class="headerlink" title="堆栈空间"></a>堆栈空间</h3><p>C源代码进过预处理、编译、汇编和链接4步生成一个可执行程序。程序在没有运行之前，也就是说程序没有被加载到内存前，可执行程序内部已经分好3段信息，分别是代码区(text)、数据区(data)和未初始化数据区(bss)三个部分。（部分人直接把data和bss合起来叫做全局区或静态区）。<br>运行可执行程序，系统把程序加载到内存，除了根据可执行程序的信息分出代码区、初始化数据区和未初始化数据区之外，还额外增加了栈区和堆区。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20093154.png"></p><p>linux下的内存分配：</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-20%20093433.png"></p><h3 id="结构体和结构体指针的内存申请"><a href="#结构体和结构体指针的内存申请" class="headerlink" title="结构体和结构体指针的内存申请"></a>结构体和结构体指针的内存申请</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span><span class="comment">//包含malloc函数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>//<span class="title">typedef</span>可以将<span class="keyword">struct</span> <span class="title">student</span>结构体类型用<span class="title">std</span>替代</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> subject[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;<span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span> student1;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;student1,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">std</span>));<span class="comment">//初始化从student1开始的地址到后面sizeof（std）也就是结构体的字节个空间，这些空间都初始化为0也就是空。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,student1.name);<span class="comment">//如果不用memset初始化内存，用scanf语句输入了student1.name的信息再用printf输出是看不出来的，如果不输入直接输出的话就会乱码（原因也是系统内存没有初始化谁也不知道里面本来存的是什么）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,student1.name);</span><br><span class="line">    <span class="comment">//结构体是直接由栈自动分配指针的所以不需要我们来手动分配和释放内存，而接下来是用结构体指针来申请内存</span></span><br><span class="line">    <span class="built_in">std</span>* student2 = (<span class="built_in">std</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">std</span>));</span><br><span class="line">    <span class="keyword">if</span>(student2 == <span class="literal">NULL</span>)<span class="comment">//如果申请内存失败，malloc会返回一个NULl</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc use failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//申请内存失败，错误退出</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">memset</span> (student2,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">std</span>));<span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,student2-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:%s\n&quot;</span>,student2-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>(student2);<span class="comment">//释放指针指向的堆的内存但是不释放指针本身的内存，指针本身存放在栈区，再程序运行结束后才能自动释放</span></span><br><span class="line">    student2 = <span class="literal">NULL</span>;<span class="comment">//这里就是将指针指向空指针，避免被错误调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件中读取结构体"><a href="#文件中读取结构体" class="headerlink" title="文件中读取结构体"></a>文件中读取结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体, 存储一个字符串和年龄 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要写入文件的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开要写入的文件</span></span><br><span class="line">    FILE *p = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开失败直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将结构体写出到文件中</span></span><br><span class="line">    fwrite(&amp;s1, <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p);</span><br><span class="line">    <span class="comment">// 读取文件中的结构体</span></span><br><span class="line">    <span class="comment">// 存储读取到的结构体数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    FILE *p2 = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果打开失败, 退出</span></span><br><span class="line">    <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从文件中读取结构体信息</span></span><br><span class="line">    fread(&amp;s2, <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p2);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p2);</span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;student : name=%s, age=%d\n&quot;</span>, s2.name, s2.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体, 存储一个字符串和年龄 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要写入文件的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span>[2] =</span> &#123;&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>&#125;, &#123;<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开要写入的文件</span></span><br><span class="line">    FILE *p = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开失败直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结构体写出到文件中</span></span><br><span class="line">    fwrite(s1, <span class="number">2</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p);</span><br><span class="line">    <span class="comment">// 读取文件中的结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储读取到的结构体数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span>[2] =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    FILE *p2 = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果打开失败, 退出</span></span><br><span class="line">    <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取结构体信息</span></span><br><span class="line">    fread(s2, <span class="number">2</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p2);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student : name=%s, age=%d\n&quot;</span>, s2[i].name, s2[i].age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/ybny0421/article/details/123263594?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167220768816800184180646%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167220768816800184180646&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-3-123263594-null-null.142">数据结构对于文件的增删查改</a></p><h3 id="做了一个小系统遇到的问题"><a href="#做了一个小系统遇到的问题" class="headerlink" title="做了一个小系统遇到的问题"></a>做了一个小系统遇到的问题</h3><p><a href="https://gitee.com/hanfengdyh/code/blob/master/%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.c">图书馆管理系统.c (gitee.com)</a></p><p>首先关于清屏linux有三种方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x1b[Hx1b[2J&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;033c&quot;</span>);</span><br></pre></td></tr></table></figure><p>虽然都是清屏但是略有区别，首先是system(“clear”)好处可以替代windows中的system(“clr”)不知道是什么问题调用写的次数多了，会有不执行的情况.之后是printf(“033c”)会清楚掉之前对于终端命令行打印颜色的命令，所以它应该是重置整个终端。</p><p>之后的一些问题基本都是结构体的问题都写在了前面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/2023/01/07/2023-1-7-%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/01/07/2023-1-7-%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>argc 和 argv 传参是如何实现的呢？</p><p>当在终端执行程序时，命令行参数（command-line argument）由 shell 进程逐一进行解析，shell 进程会将这些参数传递给加载器，加载器加载应用程序时会将其传递给应用程序引导代码，当引导程序调用 main()函数时，在由它最终传递给 main()函数，如此一来，在我们的应用程序当中便可以获取到命令行参数了。</p><p><strong>注册进程终止处理函数atexit()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><p>function：函数指针，指向注册的函数，此函数无需传入参数、无返回值。<br>返回值：成功返回 0；失败返回非 0。</p><p><strong>进程是操作系统对一个正在运行的程序的一种抽象。</strong></p><p><strong><u>进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后它就称为了一个进程，当程序运行结束后也就意味着进程终止，这就是进程的一个生命周期。</u></strong>*</p><p>在应用程序中，可通过系统调用 getpid()来获取本进程的进程号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//获取进程号</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//获取父进程进程号</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid = getpid();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;本进程的 PID 为: %d\n&quot;</span>, pid);</span><br><span class="line">    pid = getppid(); <span class="comment">//获取父进程 pid</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;父进程的 PID 为: %d\n&quot;</span>, pid);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>每一个进程都有一组与其相关的环境变量，这些环境变量以字符串形式存储在一个字符串数组列表中，把这个数组称为环境列表。其中每个字符串都是以“名称&#x3D;值（name&#x3D;value）”形式定义，所以环境变量是“名称-值”的成对集合，譬如在 shell 终端下可以使用 env 命令查看到 shell 进程的所有环境变量。</p><p>事实上，进程的环境变量是从其父进程中继承过来的，譬如在 shell 终端下执行一个应用程序，那么该进程的环境变量就是从其父进程（shell 进程）中继承过来的。新的进程在创建之前，会继承其父进程的环境变量副本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ; <span class="comment">// 申明外部全局变量 environ</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 打印进程的环境变量 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; <span class="literal">NULL</span> != environ[i]; i++)</span><br><span class="line"><span class="built_in">puts</span>(environ[i]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取指定环境变量getenv()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>name：指定获取的环境变量名称。<br>返回值：如果存放该环境变量，则返回该环境变量的值对应字符串的指针；如果不存在该环境变量返回NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *str_val = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> &gt; argc) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: 请传入环境变量名称\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 获取环境变量 */</span></span><br><span class="line"> str_val = getenv(argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">NULL</span> == str_val) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: 不存在[%s]环境变量\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 打印环境变量的值 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;环境变量的值: %s\n&quot;</span>, str_val);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加删除修改环境变量</strong></p><p><strong>putenv函数</strong>用于向进程的环境变量数组中添加一个新的环境变量，或者修改一个已经存在的环境变量的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br></pre></td></tr></table></figure><p>string：参数 string 是一个字符串指针，指向 name&#x3D;value 形式的字符串。<br>返回值：成功返回 0；失败将返回非 0 值，并设置 errno。</p><p>该函数调用成功之后，参数 string 所指向的字符串就成为了进程环境变量的一部分了，换言之，putenv()函数将设定 environ 变量（字符串数组）中的某个元素（字符串指针）指向该 string 字符串，而不是指向它的复制副本，这里需要注意！因此，不能随意修改参数 string 所指向的内容，这将影响进程的环境变量，出于这种原因，参数 string 不应为自动变量（即在栈中分配的字符数组）</p><p><strong>setenv()函数</strong>可以替代 putenv()函数，用于向进程的环境变量列表中添加一个新的环境变量或修改现有环境变量对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>;</span><br></pre></td></tr></table></figure><p>name：需要添加或修改的环境变量名称。<br>value：环境变量的值。<br>overwrite：若参数 name 标识的环境变量已经存在，在参数 overwrite 为 0 的情况下，setenv()函数将不改变现有环境变量的值，也就是说本次调用没有产生任何影响；如果参数 overwrite 的值为非 0，若参数 name标识的环境变量已经存在，则覆盖，不存在则表示添加新的环境变量。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。<br>setenv()函数为形如 name&#x3D;value 的字符串分配一块内存缓冲区，并将参数 name 和参数 value 所指向的字符串复制到此缓冲区中，以此来创建一个新的环境变量，所以，由此可知，setenv()与 putenv()函数有两个区别：</p><p>⚫ putenv()函数并不会为 name&#x3D;value 字符串分配内存；<br>⚫ setenv()可通过参数overwrite控制是否需要修改现有变量的值而仅以添加变量为目的，显然putenv()并不能进行控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">3</span> &gt; argc) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: 传入 name value\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/* 添加环境变量 */</span></span><br><span class="line"> <span class="keyword">if</span> (setenv(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="number">0</span>)) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;setenv error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unsetenv()函数<br>unsetenv()函数可以从环境变量表中移除参数 name 标识的环境变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p><strong>清空环境变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clearenv</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>clearenv()函数内部的做法其实就是将environ赋值为NULL。在某些情况下，使用setenv()函数和clearenv()函数可能会导致程序内存泄漏，前面提到过，setenv()函数会为环境变量分配一块内存缓冲区，随之称为进程的一部分；而调用 clearenv()函数时没有释放该缓冲区（clearenv()调用并不知晓该缓冲区的存在，故而也无法将其释放），反复调用者两个函数的程序，会不断产生内存泄漏。</p><h3 id="进程的内存布局"><a href="#进程的内存布局" class="headerlink" title="进程的内存布局"></a>进程的内存布局</h3><p>⚫ 正文段。也可称为代码段，这是 CPU 执行的机器语言指令部分，文本段具有只读属性，以防止程序由于意外而修改其指令；正文段是可以共享的，即使在多个进程间也可同时运行同一段程序。<br>⚫ 初始化数据段。通常将此段称为数据段，包含了显式初始化的全局变量和静态变量，当程序加载到内存中时，从可执行文件中读取这些变量的值。<br>⚫ 未初始化数据段。包含了未进行显式初始化的全局变量和静态变量，通常将此段称为 bss 段，这一名词来源于早期汇编程序中的一个操作符，意思是“由符号开始的块”（block started by symbol），在程序开始执行之前，系统会将本段内所有内存初始化为 0，可执行文件并没有为 bss 段变量分配存储空间，在可执行文件中只需记录 bss 段的位置及其所需大小，直到程序运行时，由加载器来分配这一段内存空间。<br>⚫ 栈。函数内的局部变量以及每次函数调用时所需保存的信息都放在此段中，每次调用函数时，函数传递的实参以及函数返回值等也都存放在栈中。栈是一个动态增长和收缩的段，由栈帧组成，系统会为每个当前调用的函数分配一个栈帧，栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。<br>⚫ 堆。可在运行时动态进行内存分配的一块区域，譬如使用 malloc()分配的内存空间，就是从系统堆内存中申请分配的。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230110_200011.png"></p><h3 id="进程的虚拟地址空间"><a href="#进程的虚拟地址空间" class="headerlink" title="进程的虚拟地址空间"></a>进程的虚拟地址空间</h3><p>在 Linux 系统中，采用了<strong>虚拟内存</strong>管理技术，虚拟地址会通过硬件 MMU（内存管理单元）映射到实际的物理地址空间中，建立虚拟地址到物理地址的映射关系后，对虚拟地址的读写操作实际上就是对物理地址的读写操作，MMU 会将物理地址“翻译”为对应的物理地址。</p><p>使得进程的虚拟地址空间和物理地址空间隔离开来，这样做带来了很多的优点：<br>⚫ 进程与进程、进程与内核相互隔离。一个进程不能读取或修改另一个进程或内核的内存数据，这是因为每一个进程的虚拟地址空间映射到了不同的物理地址空间。提高了系统的安全性与稳定性。<br>⚫ 在某些应用场合下，两个或者更多进程能够共享内存。因为每个进程都有自己的映射表，可以让不同进程的虚拟地址空间映射到相同的物理地址空间中。通常，共享内存可用于实现进程间通信。<br>⚫ 便于实现内存保护机制。譬如在多个进程共享内存时，允许每个进程对内存采取不同的保护措施，例如，一个进程可能以只读方式访问内存，而另一进程则能够以可读可写的方式访问。<br>⚫ 编译应用程序时，无需关心链接地址。前面提到了，当程序运行时，要求链接地址与运行地址一致，在引入了虚拟地址机制后，便无需关心这个问题。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是一个抽象概念，每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/blogImg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20103613.png"></p><h3 id="fork创建子进程"><a href="#fork创建子进程" class="headerlink" title="fork创建子进程"></a>fork创建子进程</h3><p>一个现有的进程可以调用 fork()函数创建一个新的进程，调用 fork()函数的进程称为父进程，由 fork()函数创建出来的进程被称为子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>在诸多的应用中，创建多个进程是任务分解时行之有效的方法，譬如，某一网络服务器进程可在监听客户端请求的同时，为处理每一个请求事件而创建一个新的子进程，与此同时，服务器进程会继续监听更多的客户端连接请求。在一个大型的应用程序任务中，创建子进程通常会简化应用程序的设计，同时提高了系统的并发性。</p><p><u>在程序代码中，可通过返回值来区分是子进程还是父进程。</u>fork()调用成功后，将会在父进程中返回子进程的 PID，而在子进程中返回值是 0；如果调用失败，父进程返回值-1，不创建子进程，并设置 errno。</p><p>ork()调用成功后，子进程和父进程会继续执行 fork()调用之后的指令，子进程、父进程各自在自己的进程空间中运行。事实上，子进程是父进程的一个副本，譬如子进程拷贝了父进程的数据段、堆、栈以及继承了父进程打开的文件描述符，父进程与子进程并不共享这些存储空间，这是子进程对父进程相应部分存储空间的完全复制，执行 fork()之后，每个进程均可修改各自的栈数据以及堆段中的变量，而并不影响另一个进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"> <span class="keyword">switch</span> (pid) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">-1</span>:perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">&quot;这是子进程打印信息&lt;pid: %d, 父进程 pid: %d&gt;\n&quot;</span>,getpid(), getppid());</span><br><span class="line"> _exit(<span class="number">0</span>); <span class="comment">//子进程使用_exit()退出</span></span><br><span class="line"> <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;这是父进程打印信息&lt;pid: %d, 子进程 pid: %d&gt;\n&quot;</span>,getpid(), pid);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>子进程被创建出来之后，便是一个独立的进程，拥有自己独立的进程空间，系统内唯一的进程号，拥有自己独立的 PCB（进程控制块），子进程会被内核同等调度执行，参与到系统的进程调度中。</u></p><h3 id="父子进程间的文件共享"><a href="#父子进程间的文件共享" class="headerlink" title="父子进程间的文件共享"></a>父子进程间的文件共享</h3><p><strong>调用 fork()函数之后，子进程会获得父进程所有文件描述符的副本，这些副本的创建方式类似于 dup()，这也意味着父、子进程对应的文件描述符均指向相同的文件表。</strong></p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230114_190912.png"></p><p>子进程拷贝了父进程的文件描述符表，使得父、子进程中对应的文件描述符指向了相同的文件表，也意味着父、子进程中对应的文件描述符指向了磁盘中相同的文件，因而这些文件在父、子进程间实现了共享.</p><p>fork()函数有以下两种用法：<br>⚫ 父进程希望子进程复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的，父进程等待客户端的服务请求，当接收到客户端发送的请求事件后，调用 fork()创建一个子进程，使子进程去处理此请求、而父进程可以继续等待下一个服务请求。<br>⚫ 一个进程要执行不同的程序。譬如在程序 app1 中调用 fork()函数创建了子进程，此时子进程是要去执行另一个程序 app2，也就是子进程需要执行的代码是 app2 程序对应的代码，子进程将从 app2程序的 main 函数开始运行。这种情况，通常在子进程从 fork()函数返回之后立即调用 exec 族函数来实现。</p><h3 id="fork-之后的竞争条件"><a href="#fork-之后的竞争条件" class="headerlink" title="fork()之后的竞争条件"></a>fork()之后的竞争条件</h3><p>调用 fork 之后，无法确定父、子两个进程谁将率先访问 CPU，也就是说无法确认谁先被系统调用运行（在多核处理器中，它们可能会同时各自访问一个 CPU），这将导致谁先运行、谁后运行这个顺序是不确定的。</p><p>为确保使子进程优先于父进程或者父进程优先于子进程，可以用信号阻塞来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收到信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">sigset_t</span> wait_mask;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;wait_mask);</span><br><span class="line">    </span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sigaction(SIGUSR1, &amp;sig, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">switch</span>(fork())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程开始执行\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程打印信息\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;~~~~~~~~~~~~~~~\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">2</span>);</span><br><span class="line">            kill(getppid(), SIGUSR1);</span><br><span class="line">            _exit(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(sigsuspend(&amp;wait_mask) != <span class="number">-1</span>)<span class="comment">//挂起阻塞</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程执行\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程打印信息\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程先运行打印相应信息，之后再执行父进程打印信息，在父进程分支中，直接调用了 sigsuspend()使父进程进入挂起状态，由子进程通过 kill 命令发送信号唤醒。</p><h3 id="进程的诞生与终止"><a href="#进程的诞生与终止" class="headerlink" title="进程的诞生与终止"></a>进程的诞生与终止</h3><p><u>init 进程的 PID 总是为 1，它是所有子进程的父进程，一切从 1 开始、一切从 init 进程开始！</u></p><p>进程有两种终止方式：异常终止和正常终止。</p><p>一般使用 exit()库函数而非_exit()系统调用，原因在于 exit()最终也会通过_exit()终止进程，但在此之前，它将会完成一些其它的工作，exit()函数会执行的动作如下：<br>⚫ 如果程序中注册了进程终止处理函数，那么会调用终止处理函数。<br>⚫ 刷新 stdio 流缓冲区。关于 stdio 流缓冲区的问题，稍后编写一个简单地测试程序进行说明；<br>⚫ 执行_exit()系统调用。</p><p>一般推荐的是子进程使用_exit()退出、而父进程则使用 exit()退出。其原因就在于调用 exit()函数终止进程时会刷新进程的 stdio 缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);<span class="comment">//有换行符打印1次没有打印两次</span></span><br><span class="line"> <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"> perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="comment">/* 子进程 */</span></span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="comment">/* 父进程 */</span></span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有换行符通过 fork()创建子进程时会复制这些缓冲区。标准输出设备默认使用的是行缓冲，当检测到换行符\n 时会立即显示函数 printf()输出的字符串；无换行符所以会立即读走缓冲区中的数据并显示，读走之后此时缓冲区就空了，子进程虽然拷贝了父进程的缓冲区，但是空的，虽然父、子进程使用 exit()退出时会刷新各自的缓冲区，但对于空缓冲区自然无数据可读。</p><p>可以采用以下任一方法来避免重复的输出结果：<br>⚫ 对于行缓冲设备，可以加上对应换行符，譬如 printf 打印输出字符串时在字符串后面添加\n 换行符，对于 puts()函数来说，本身会自动添加换行符；<br>⚫ 在调用 fork()之前，使用函数 fflush()来刷新 stdio 缓冲区，当然，作为另一种选择，也可以使用setvbuf()和 setbuf()来关闭 stdio 流的缓冲功能；<br>⚫ 子进程调用_ exit()退出进程不是使用exit()，调用_exit()在退出时便不会刷新 stdio 缓冲区。</p><h3 id="监视子进程"><a href="#监视子进程" class="headerlink" title="监视子进程"></a>监视子进程</h3><p>父进程需要知道子进程于何时被终止，并且需要知道子进程的终止状态信息，是正常终止、还是异常终止亦或者被信号终止等，意味着父进程会对子进程进行监视。</p><p><strong>wait()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure><p>status：参数 status 用于存放子进程终止时的状态信息，参数 status 可以为 NULL，表示不接收子进程终止时的状态信息。<br>返回值：若成功则返回终止的子进程对应的进程号；失败则返回-1。<br>系统调用 wait()将执行如下动作：</p><p>⚫ 调用 wait()函数，如果其所有子进程都还在运行，则 wait()会一直阻塞等待，直到某一个子进程终止；                                                                                                                                                                                    ⚫ 如果进程调用 wait()，但是该进程并没有子进程，也就意味着该进程并没有需要等待的子进程，那么 wait()将返回错误，也就是返回-1、并且会将 errno 设置为 ECHILD。<br>⚫ 如果进程调用 wait()之前，它的子进程当中已经有一个或多个子进程已经终止了，那么调用 wait()也不会塞。wait()函数的作用除了获取子进程的终止状态信息之外，更重要的一点，就是回收子进程的一些资源，俗称为子进程“收尸”，所以在调用 wait()函数之前，已经有子进程终止了，意味着正等待着父进程为其“收尸”，所以调用 wait()将不会阻塞，而是会立即替该子进程“收尸”、处理它的“后事”，然后返回到正常的程序流程中，一次 wait()调用只能处理一次。</p><p>参数 status 不为 NULL 的情况下，则 wait()会将子进程的终止时的状态信息存储在它指向的 int 变量中，可以通过以下宏来检查 status 参数：<br>⚫ WIFEXITED(status)：如果子进程正常终止，则返回 true；<br>⚫ WEXITSTATUS(status)：返回子进程退出状态，是一个数值，其实就是子进程调用_ exit()或 exit()时指定的退出状态；wait()获取得到的 status 参数并不是调用_exit()或 exit()时指定的状态，可通过WEXITSTATUS 宏转换；<br>⚫ WIFSIGNALED(status)：如果子进程被信号终止，则返回 true；<br>⚫ WTERMSIG(status)：返回导致子进程终止的信号编号。如果子进程是被信号所终止，则可以通过此宏获取终止子进程的信号；<br>⚫ WCOREDUMP(status)：如果子进程终止时产生了核心转储文件，则返回 true；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 循环创建 3 个子进程 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"> perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="comment">/* 子进程 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子进程&lt;%d&gt;被创建\n&quot;</span>, getpid());</span><br><span class="line"> sleep(i);</span><br><span class="line"> _exit(i);</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="comment">/* 父进程 */</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;~~~~~~~~~~~~~~\n&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line"> ret = wait(&amp;status);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ECHILD == errno) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;没有需要等待回收的子进程\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;回收子进程&lt;%d&gt;, 终止状态&lt;%d&gt;\n&quot;</span>, ret,WEXITSTATUS(status));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 for 循环创建了 3 个子进程，父进程中循环调用 wait()函数等待回收子进程，并将本次回收的子进程进程号以及终止状态打印出来。</p><p><strong>waitpid()函数</strong></p><p>使用 wait()系统调用存在着一些限制，这些限制包括如下：<br>⚫ 如果父进程创建了多个子进程，使用 wait()将无法等待某个特定的子进程的完成，只能按照顺序等待下一个子进程的终止，一个一个来、谁先终止就先处理谁；<br>⚫ 如果子进程没有终止，正在运行，那么 wait()总是保持阻塞，有时我们希望执行非阻塞等待，是否有子进程终止，通过判断即可得知；<br>⚫ 使用 wait()只能发现那些被终止的子进程，对于子进程因某个信号（譬如 SIGSTOP 信号）而停止（注意，这里停止指的暂停运行），或是已停止的子进程收到 SIGCONT 信号后恢复执行的情况就无能为力了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p>pid：参数 pid 用于表示需要等待的某个具体子进程，关于参数 pid 的取值范围如下：<br>⚫ 如果 pid 大于 0，表示等待进程号为 pid 的子进程；<br>⚫ 如果 pid 等于 0，则等待与调用进程（父进程）同一个进程组的所有子进程；<br>⚫ 如果 pid 小于-1，则会等待进程组标识符与 pid 绝对值相等的所有子进程；<br>⚫ 如果 pid 等于-1，则等待任意子进程。wait(&amp;status)与 waitpid(-1, &amp;status, 0)等价。<br>status：与 wait()函数的 status 参数意义相同。<br>参数 options 是一个位掩码，可以包括 0 个或多个如下标志：<br>⚫ WNOHANG：如果子进程没有发生状态改变（终止、暂停），则立即返回，也就是执行非阻塞等<br>待，可以实现轮训 poll，通过返回值可以判断是否有子进程发生状态改变，若返回值等于 0 表示没<br>有发生改变。<br>⚫ WUNTRACED：除了返回终止的子进程的状态信息外，还返回因信号而停止（暂停运行）的子进<br>程状态信息；<br>⚫ WCONTINUED：返回那些因收到 SIGCONT 信号而恢复运行的子进程的状态信息。</p><p>返回值：返回值与 wait()函数的返回值意义基本相同，在参数 options 包含了 WNOHANG 标志的情况<br>下，返回值会出现 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//waitpid()阻塞方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> status;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 循环创建 3 个子进程 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"> perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="comment">/* 子进程 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;子进程&lt;%d&gt;被创建\n&quot;</span>, getpid());</span><br><span class="line"> sleep(i);</span><br><span class="line"> _exit(i);</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="comment">/* 父进程 */</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;~~~~~~~~~~~~~~\n&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) </span><br><span class="line"> &#123;</span><br><span class="line"> ret = waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ECHILD == errno) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;没有需要等待回收的子进程\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;回收子进程&lt;%d&gt;, 终止状态&lt;%d&gt;\n&quot;</span>, ret,WEXITSTATUS(status));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//轮训方式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> status;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 循环创建 3 个子进程 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">switch</span> (fork()) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"> perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="comment">/* 子进程 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子进程&lt;%d&gt;被创建\n&quot;</span>, getpid());</span><br><span class="line"> sleep(i);</span><br><span class="line"> _exit(i);</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="comment">/* 父进程 */</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;~~~~~~~~~~~~~~\n&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) </span><br><span class="line"> &#123;</span><br><span class="line"> ret = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; ret) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (ECHILD == errno)</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == ret)</span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;回收子进程&lt;%d&gt;, 终止状态&lt;%d&gt;\n&quot;</span>, ret,WEXITSTATUS(status));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>僵尸进程和孤儿进程</p><p>父进程先于子进程结束，也就是意味着，此时子进程变成了一个“孤儿”，我们把这种进程就称为孤儿进程。在 Linux 系统当中，所有的孤儿进程都自动成为 init 进程（进程号为 1）的子进程，换言之，某一子进程的父进程结束后，该子进程调用 getppid()将返回 1，init 进程变成了孤儿进程的“养父”。</p><p>进程结束之后，通常需要其父进程为其“收尸”，回收子进程占用的一些内存资源，父进程通过调用wait()（或其变体 waitpid()、waitid()等）函数回收子进程资源，归还给系统。如果子进程先于父进程结束，此时父进程还未来得及给子进程“收尸”，那么此时子进程就变成了一个僵尸进程。</p><p>SIGCHLD 信号在第八章中给大家介绍过，当发生以下两种情况时，父进程会收到该信号：<br>⚫ 当父进程的某个子进程终止时，父进程会收到 SIGCHLD 信号；<br>⚫ 当父进程的某个子进程因收到信号而停止（暂停运行）或恢复时，内核也可能向父进程发送该信号。<br>子进程的终止属于异步事件，父进程事先是无法预知的，如果父进程有自己需要做的事情，它不能一直wait()阻塞等待子进程终止（或轮训），这样父进程将啥事也做不了，那么有什么办法来解决这样的尴尬情况，当然有办法，那就是通过 SIGCHLD 信号。<br>那既然子进程状态改变时（终止、暂停或恢复），父进程会收到 SIGCHLD 信号，SIGCHLD 信号的系统默认处理方式是将其忽略，所以我们要捕获它、绑定信号处理函数，在信号处理函数中调用 wait()收回子进程，回收完毕之后再回到父进程自己的工作流程中。<br>当调用信号处理函数时，会暂时将引发调用的信号添加到进程的信号掩码中（除非 sigaction()指定SA_NODEFER 标志），这样一来，当 SIGCHLD 信号处理函数正在为一个终止的子进程“收尸”时，如果相继有两个子进程终止，即使产生了两次 SIGCHLD 信号，父进程也只能捕获到一次 SIGCHLD 信号，结果是，父进程的 SIGCHLD 信号处理函数每次只调用一次 wait()，那么就会导致有些僵尸进程成为“漏网之鱼”。<br>解决方案就是：在 SIGCHLD 信号处理函数中循环以非阻塞方式来调用 waitpid()，直至再无其它终止的<br>子进程需要处理为止，所以，通常 SIGCHLD 信号处理函数内部代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>上述代码一直循环下去，直至 waitpid()返回 0，表明再无僵尸进程存在；或者返回-1，表明有错误发生。<br>应在创建任何子进程之前，为 SIGCHLD 信号绑定处理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wait_child</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 替子进程收尸 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;父进程回收子进程\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/* 为 SIGCHLD 信号绑定处理函数 */</span></span><br><span class="line">sigemptyset(sig.sa_mask);</span><br><span class="line">sig.sa_handler = wait_child;</span><br><span class="line">sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGCHLD, &amp;sig, <span class="literal">NULL</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建子进程 */</span></span><br><span class="line"><span class="keyword">switch</span> (fork()) </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">/* 子进程 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子进程&lt;%d&gt;被创建\n&quot;</span>, getpid());</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子进程结束\n&quot;</span>);</span><br><span class="line">_exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* 父进程 */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行新程序"><a href="#执行新程序" class="headerlink" title="执行新程序"></a>执行新程序</h3><p>系统调用 execve()可以将新程序加载到某一进程的内存空间，通过调用 execve()函数将一个外部的可执行文件加载到进程的内存空间运行，使用新的程序替换旧的程序，而进程的栈、数据、以及堆数据会被新程序的相应部件所替换，然后从新程序的 main()函数开始执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p>filename：参数 filename 指向需要载入当前进程空间的新程序的路径名，既可以是绝对路径、也可以是相对路径。<br>argv：参数 argv 则指定了传递给新程序的命令行参数。是一个字符串数组，该数组对应于 main(int argc, char *argv[])函数的第二个参数 argv，且格式也与之相同，是由字符串指针所组成的数组，以 NULL 结束。argv[0]对应的便是新程序自身路径名。<br>envp：参数 envp 也是一个字符串指针数组，指定了新程序的环境变量列表，参数 envp 其实对应于新程序的 environ 数组，同样也是以 NULL 结束，所指向的字符串格式为 name&#x3D;value。<br>返回值：execve 调用成功将不会返回；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个简单地程序，在测试程序 testApp 当中通过 execve()函数运行另一个新程序 newApp。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> *arg_arr[<span class="number">5</span>];</span><br><span class="line"> <span class="type">char</span> *env_arr[<span class="number">5</span>] = &#123;<span class="string">&quot;NAME=app&quot;</span>, <span class="string">&quot;AGE=25&quot;</span>,</span><br><span class="line"> <span class="string">&quot;SEX=man&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> arg_arr[<span class="number">0</span>] = argv[<span class="number">1</span>];</span><br><span class="line"> arg_arr[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"> arg_arr[<span class="number">2</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"> arg_arr[<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line"> execve(argv[<span class="number">1</span>], arg_arr, env_arr);</span><br><span class="line"> perror(<span class="string">&quot;execve error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将上述程序编译成一个可执行文件 testApp。</span></span><br><span class="line"><span class="comment">//接着编写新程序，在新程序当中打印出环境变量和传参，如下所示：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> **ep = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">int</span> j;</span><br><span class="line"> <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, j, argv[j]);</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;env:&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (ep = environ; *ep != <span class="literal">NULL</span>; ep++)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot; %s\n&quot;</span>, *ep);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exec 族函数包括多个不同的函数，这些函数命名都以 exec 为前缀。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p><strong>system()函数</strong></p><p><u><strong>使用 system()函数可以很方便地在我们的程序当中执行任意 shell 命令。</strong></u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure><p>system()函数其内部的是通过调用 fork()、execl()以及 waitpid()这三个函数来实现它的功能，首先 system()会调用 fork()创建一个子进程来运行 shell（可以把这个子进程成为 shell 进程），并通过 shell 执行参数command 所指定的命令。</p><p>system()的返回值如下：<br>⚫ 当参数 command 为 NULL，如果 shell 可用则返回一个非 0 值，若不可用则返回 0；针对一些非UNIX 系统，该系统上可能是没有 shell 的，这样就会导致 shell 不可能；如果 command 参数不为NULL，则返回值从以下的各种情况所决定。<br>⚫ 如果无法创建子进程或无法获取子进程的终止状态，那么 system()返回-1；<br>⚫ 如果子进程不能执行 shell，则 system()的返回值就好像是子进程通过调用_exit(127)终止了；<br>⚫ 如果所有的系统调用都成功，system()函数会返回执行 command 的 shell 进程的终止状态。</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>Linux 系统下进程通常存在 6 种不同的状态：</p><p>⚫ 就绪态（Ready）：指该进程满足被 CPU 调度的所有条件但此时并没有被调度执行，只要得到 CPU就能够直接运行；意味着该进程已经准备好被 CPU 执行，当一个进程的时间片到达，操作系统调度程序会从就绪态链表中调度一个进程；<br>⚫ 运行态：指该进程当前正在被 CPU 调度运行，处于就绪态的进程得到 CPU 调度就会进入运行态；<br>⚫ 僵尸态：僵尸态进程其实指的就是僵尸进程，指该进程已经结束、但其父进程还未给它“收尸”；<br>⚫ 可中断睡眠状态：可中断睡眠也称为浅度睡眠，表示睡的不够“死”，还可以被唤醒，一般来说可以通过信号来唤醒；<br>⚫ 不可中断睡眠状态：不可中断睡眠称为深度睡眠，深度睡眠无法被信号唤醒，只能等待相应的条件成立才能结束睡眠状态。把浅度睡眠和深度睡眠统称为等待态（或者叫阻塞态），表示进程处于一种等待状态，等待某种条件成立之后便会进入到就绪态；所以，处于等待态的进程是无法参与进程系统调度的。<br>⚫ 暂停态：暂停并不是进程的终止，表示进程暂停运行，一般可通过信号将进程暂停，譬如 SIGSTOP信号；处于暂停态的进程是可以恢复进入到就绪态的，譬如收到 SIGCONT 信号。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230118_205012.png" alt="进程各状态转换"></p><p>关于进程组需要注意以下以下内容：<br>⚫ 每个进程必定属于某一个进程组、且只能属于一个进程组；<br>⚫ 每一个进程组有一个组长进程，组长进程的 ID 就等于进程组 ID；<br>⚫ 在组长进程的 ID 前面加上一个负号即是操作进程组；<br>⚫ 组长进程不能再创建新的进程组；<br>⚫ 只要进程组中还存在一个进程，则该进程组就存在，这与其组长进程是否终止无关；<br>⚫ 一个进程组可以包含一个或多个进程，进程组的生命周期从被创建开始，到其内所有进程终止或离开该进程组；<br>⚫ 默认情况下，新创建的进程会继承父进程的进程组 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;<span class="comment">//获取进程组ID</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//获取进程组ID</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid = getpid();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;进程组 ID&lt;%d&gt;---getpgrp()\n&quot;</span>, getpgrp());</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;进程组 ID&lt;%d&gt;---getpgid(0)\n&quot;</span>, getpgid(<span class="number">0</span>));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;进程组 ID&lt;%d&gt;---getpgid(%d)\n&quot;</span>, getpgid(pid), pid);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//加入一个现有进程或者是创建一个新进程</span></span><br></pre></td></tr></table></figure><p>setpgid()函数将参数 pid 指定的进程的进程组 ID 设置为参数 gpid。如果这两个参数相等（pid&#x3D;&#x3D;gpid），则由 pid 指定的进程变成为进程组的组长进程，创建了一个新的进程；如果参数 pid 等于 0，则使用调用者的进程 ID；另外，如果参数 gpid 等于 0，则创建一个新的进程组，由参数 pid 指定的进程作为进程组组长进程。<br>setpgrp()函数等价于 setpgid(0, 0)。<br>一个进程只能为它自己或它的子进程设置进程组 ID，在它的子进程调用 exec 函数后，它就不能更改该子进程的进程组 ID 了。</p><p>守护进程（Daemon）也称为精灵进程，是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些事情的发生，主要表现为以下两个特点：<br>⚫ 长期运行。守护进程是一种生存期很长的一种进程，它们一般在系统启动时开始运行，除非强行终止，否则直到系统关机都会保持运行。与守护进程相比，普通进程都是在用户登录或运行程序时创建，在运行结束或用户注销时终止，但守护进程不受用户登录注销的影响，它们将会一直运行着、直到系统关机。<br>⚫ 与控制终端脱离。在 Linux 中，系统与用户交互的界面称为终端，每一个从终端开始运行的进程都会依附于这个终端，这是上一小节给大家介绍的控制终端，也就是会话的控制终端。当控制终端被关闭的时候，该会话就会退出，由控制终端运行的所有进程都会被终止，这使得普通进程都是和运行该进程的终端相绑定的；但守护进程能突破这种限制，它脱离终端并且在后台运行，脱离终端的目的是为了避免进程在运行的过程中的信息在终端显示并且进程也不会被任何终端所产生的信息所打断。</p><p>守护进程 Daemon，通常简称为 d，一般进程名后面带有 d 就表示它是一个守护进程。守护进程与终端无任何关联，用户的登录与注销与守护进程无关、不受其影响，守护进程自成进程组、自成会话，即pid&#x3D;gid&#x3D;sid。通过命令”ps -ajx”查看系统所有的进程。</p><h4 id="编写守护进程的步骤"><a href="#编写守护进程的步骤" class="headerlink" title="编写守护进程的步骤"></a>编写守护进程的步骤</h4><p><strong>1) 创建子进程、终止父进程</strong><br>父进程调用 fork()创建子进程，然后父进程使用 exit()退出，这样做实现了下面几点。第一，如果该守护进程是作为一条简单地 shell 命令启动，那么父进程终止会让 shell 认为这条命令已经执行完毕。第二，虽然子进程继承了父进程的进程组ID，但它有自己独立的进程ID，这保证了子进程不是一个进程组的组长进程，这是下面将要调用 setsid 函数的先决条件！<br><strong>2) 子进程调用 setsid 创建会话</strong><br>这步是关键，在子进程中调用上一小节给大家介绍的 setsid()函数创建新的会话，由于之前子进程并不是进程组的组长进程，所以调用 setsid()会使得子进程创建一个新的会话，子进程成为新会话的首领进程，同样也创建了新的进程组、子进程成为组长进程，此时创建的会话将没有控制终端。所以这里调用 setsid 有三个作用：让子进程摆脱原会话的控制、让子进程摆脱原进程组的控制和让子进程摆脱原控制终端的控制。在调用 fork 函数时，子进程继承了父进程的会话、进程组、控制终端等，虽然父进程退出了，但原先的会话期、进程组、控制终端等并没有改变，因此，那还不是真正意义上使两者独立开来。setsid 函数能够使子进程完全独立出来，从而脱离所有其他进程的控制。<br><strong>3) 将工作目录更改为根目录</strong><br>子进程是继承了父进程的当前工作目录，由于在进程运行中，当前目录所在的文件系统是不能卸载的，这对以后使用会造成很多的麻烦。因此通常的做法是让“&#x2F;”作为守护进程的当前目录，当然也可以指定其它目录来作为守护进程的工作目录。<br><strong>4) 重设文件权限掩码 umask</strong><br>文件权限掩码 umask 用于对新建文件的权限位进行屏蔽。由于使用 fork 函数新建的子进程继承了父进程的文件权限掩码，这就给子进程使用文件带来了诸多的麻烦。因此，把文件权限掩码设置为 0，确保子进程有最大操作权限、这样可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是 umask，通常的使用方法为 umask(0)。<br><strong>5) 关闭不再需要的文件描述符</strong><br>子进程继承了父进程的所有文件描述符，这些被打开的文件可能永远不会被守护进程（此时守护进程指的就是子进程，父进程退出、子进程成为守护进程）读或写，但它们一样消耗系统资源，可能导致所在的文件系统无法卸载，所以必须关闭这些文件，这使得守护进程不再持有从其父进程继承过来的任何文件描述符。<br><strong>6) 将文件描述符号为 0、1、2 定位到&#x2F;dev&#x2F;null</strong><br>将守护进程的标准输入、标准输出以及标准错误重定向到&#x2F;dev&#x2F;null，这使得守护进程的输出无处显示、也无处从交互式用户那里接收输入。<br><strong>7) 其它：忽略 SIGCHLD 信号</strong><br>处理 SIGCHLD 信号不是必须的，但对于某些进程，特别是并发服务器进程往往是特别重要的，服务器进程在接收到客户端请求时会创建子进程去处理该请求，如果子进程结束之后，父进程没有去 wait 回收子进程，则子进程将成为僵尸进程；如果父进程 wait 等待子进程退出，将又会增加父进程的负担、也就是增加服务器的负担，影响服务器进程的并发性能，在 Linux 下，可以将 SIGCHLD 信号的处理方式设置为SIG_IGN，也就是忽略该信号，可让内核将僵尸进程转交给 init 进程去处理，这样既不会产生僵尸进程、又省去了服务器进程回收子进程所占用的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建子进程 */</span></span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; pid) &#123;</span><br><span class="line"> perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt; pid)<span class="comment">//父进程</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//直接退出</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/* 1.创建新的会话、脱离控制终端 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; setsid()) &#123;</span><br><span class="line"> perror(<span class="string">&quot;setsid error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 2.设置当前工作目录为根目录 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; chdir(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 3.重设文件权限掩码 umask */</span></span><br><span class="line"> umask(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">/* 4.关闭所有文件描述符 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sysconf(_SC_OPEN_MAX); i++)</span><br><span class="line"> close(i);</span><br><span class="line"> <span class="comment">/* 5.将文件描述符号为 0、1、2 定位到/dev/null */</span></span><br><span class="line"> open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"> dup(<span class="number">0</span>);</span><br><span class="line"> dup(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">/* 6.忽略 SIGCHLD 信号 */</span></span><br><span class="line"> signal(SIGCHLD, SIG_IGN);</span><br><span class="line"> <span class="comment">/* 正式进入到守护进程 */</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;守护进程运行中......&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>但对于有些程序设计来说，不允许出现这种情况，程序只能被执行一次，只要该程序没有结束，就无法再次运行，我们把这种情况称为单例模式运行。</p><p>首先这是一个非常简单且容易想到的方法：用一个文件的存在与否来做标志，在程序运行正式代码之前，先判断一个特定的文件是否存在，如果存在则表明进程已经运行，此时应该立马退出；如果不存在则表明进程没有运行，然后创建该文件，当程序结束时再删除该文件即可！</p><p>有很大的问题，主要包括如下三个方面：<br>⚫ 程序中使用_exit()退出，那么将无法执行 delete_file()函数，意味着无法删除这个特定的文件；<br>⚫ 程序异常退出。程序异常同样无法执行到进程终止处理函数 delete_file()，同样将导致无法删除这个特定的文件；<br>⚫ 计算机掉电关机。这种情况就更加直接了，计算机可能在程序运行到任意位置时发生掉电关机的情况，这是无法预料的；如果文件没有删除就发生了这种情况，计算机重启之后文件依然存在，导致程序无法执行。</p><p>由此使用文件锁</p><p>同样也需要通过一个特定的文件来实现，当程序启动之后，首先打开该文件，调用 open 时一般使用O_WRONLY | O_CREAT 标志，当文件不存在则创建该文件，然后尝试去获取文件锁，若是成功，则将程序的进程号（PID）写入到该文件中，写入后不要关闭文件或解锁（释放文件锁），保证进程一直持有该文件锁；若是程序获取锁失败，代表程序已经被运行、则退出本次启动。Tips：当程序退出或文件关闭之后，文件锁会自动解锁！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FILE <span class="string">&quot;./testApp.pid&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> str[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="comment">/* 打开 lock 文件，如果文件不存在则创建 */</span></span><br><span class="line"> fd = open(LOCK_FILE, O_WRONLY | O_CREAT, <span class="number">0666</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 以非阻塞方式获取文件锁 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == flock(fd, LOCK_EX | LOCK_NB)) &#123;</span><br><span class="line"> <span class="built_in">fputs</span>(<span class="string">&quot;不能重复执行该程序!\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;程序运行中...&quot;</span>);</span><br><span class="line"> ftruncate(fd, <span class="number">0</span>); <span class="comment">//将文件长度截断为 0</span></span><br><span class="line"> <span class="built_in">sprintf</span>(str, <span class="string">&quot;%d\n&quot;</span>, getpid());</span><br><span class="line">write(fd, str, <span class="built_in">strlen</span>(str));<span class="comment">//写入 pid</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; )</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序启动首先打开一个特定的文件，这里只是举例，以当前目录下的 testApp.pid 文件作为特定文件，以 O_WRONLY | O_CREAT 方式打开，如果文件不存在则创建该文件；打开文件之后使用 flock 尝试获取文件锁，调用 flock()时指定了互斥锁标志 LOCK_NB，意味着同时只能有一个进程拥有该锁，如果获取锁失败，表示该程序已经启动了，无需再次执行，然后退出；如果获取锁成功，将进程的 PID 写入到该文件中，当程序退出时，会自动解锁、关闭文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C错题</title>
      <link href="/2022/12/17/2022-12-17-C%E9%94%99%E9%A2%98/"/>
      <url>/2022/12/17/2022-12-17-C%E9%94%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">sizeof</span>(i++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出等于1</p><p><strong>根据C99规范， sizeof是一个编译时刻就起效果的运算符，在其内的任何运算都没有意义，sizeof(i++); 在编译的时候被翻译成 sizeof((i++的数据类型)) 也就是 sizeof(int); 不会执行i++了 。</strong></p><p>sizeof是操作符</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>下面说法中正确的是（） </p><ul><li><pre><code>若全局变量仅在单个C 文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;<br>设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑变量生命周期问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  静态全局变量使用过多，可那会导致动态存储区(堆栈)溢出</span><br></pre></td></tr></table></figure></li></ul><p>Static 函数在非类中有三个作用： </p><p>  1、用来隐藏，利用这一特性，可以在不同的文件中定义同名变量和同名函数，而不用担心命名冲突，对应A选项； </p><p>  2、默认初始化为0； </p><p>  3、保持局部变量的持久 。所以A选项是对的。B选项毫无关系，C选项中动态全局变量、静态全局变量、静态局部变量生命期都为函数运行期间。 其中静态局部变量的生存周期虽然为整个源程序，但是其作用域任然与局部变量相同，当退出该函数时，该变量还继续存在，但是不能使用它。所以C选项是错的。  D选项中，静态全局变量存储在全局（静态）存储区。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`int` `a = ``248``, b = ``4``;``int` `const` `c = ``21``;``const` `int` `*d = &amp;a; ``int` `*``const` `e = &amp;b;``int` `const` `* ``const` `f = &amp;a; `</span><br></pre></td></tr></table></figure><p>  请问下列表达式哪些会被编译器禁止? </p><ul><li><pre><code>*c=32<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  *d=43</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>e=&amp;a<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  f=0x321f</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;<br>d&#x3D;&amp;b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  *e=34</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221217_210448.png"></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>假设函数原型和变量说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span>(*p)[<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>&#125;，</span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>&#125;，&#123;<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>&#125;，&#123;<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>，<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>下面调用非法的是（b）<br>f3(&amp;a);<br>f3(b[1]);<br>f3(&amp;b[1]);<br>f3(b);</p><p>void f3(<strong>int(*p)[4]</strong>);    其参数是<strong>数组指针</strong> ，指向数组p的指针。</p><ul><li>​    选项A：f3(<strong>&amp;a</strong>);  参数为一个地址，符合指针定义。   </li><li>​    选项B：f3(<strong>b[1]</strong>); 参数为一个数组的具体元素，不符合指针定义。<strong>所以B是非法的调用。</strong>   </li><li>​    选项C：f3(<strong>&amp;b[1]</strong>); 参数为一个数组元素的地址，符合指针定义。   </li><li>​    选项D：f3(<strong>b</strong>);  参数为数组名，表示该数组的首地址，符合指针定义。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号</title>
      <link href="/2022/12/17/2022-12-17-%E4%BF%A1%E5%8F%B7/"/>
      <url>/2022/12/17/2022-12-17-%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>信号是事件发生时对进程的通知机制，也可以把它称为软件中断。信号与硬件中断的相似之处在于能够打断程序当前执行的正常流程，其实是在软件层次上对中断机制的一种模拟。大多数情况下，是无法预测信号达到的准确时间，所以，信号提供了一种处理异步事件的方法。</p><p><strong>产生信号的方式：</strong></p><p>⚫ 硬件发生异常，即硬件检测到错误条件并通知内核，随即再由内核发送相应的信号给相关进程。硬件检测到异常的例子包括执行一条异常的机器语言指令，诸如，除数为 0、数组访问越界导致引用了无法访问的内存区域等，这些异常情况都会被硬件检测到，并通知内核、然后内核为该异常情况发生时正在运行的进程发送适当的信号以通知进程。<br>⚫ 用于在终端下输入了能够产生信号的特殊字符。譬如在终端上按下 CTRL + C 组合按键可以产生中断信号（SIGINT），通过这个方法可以终止在前台运行的进程；按下 CTRL + Z 组合按键可以产生暂停信（SIGCONT），通过这个方法可以暂停当前前台运行的进程。<br>⚫ 进程调用 kill()系统调用可将任意信号发送给另一个进程或进程组。当然对此是有所限制的，接收信号的进程和发送信号的进程的所有者必须相同，亦或者发送信号的进程的所有者是 root 超级用户。<br>⚫ 用户可以通过 kill 命令将信号发送给其它进程。kill 命令想必大家都会使用，通常我们会通过 kill命令来“杀死”（终止）一个进程，譬如在终端下执行”kill -9 xxx”来杀死 PID 为 xxx 的进程。kill命令其内部的实现原理便是通过 kill()系统调用来完成的。<br>⚫ 发生了软件事件，即当检测到某种软件条件已经发生。这里指的不是硬件产生的条件（如除数为 0、引用无法访问的内存区域等），而是软件的触发条件、触发了某种软件条件（进程所设置的定时器已经超时、进程执行的 CPU 时间超限、进程的某个子进程退出等等情况）</p><p><strong><u>通常进程会视具体信号执行以下操作之一：</u></strong><br>⚫ 忽略信号。也就是说，当信号到达进程后，该进程并不会去理会它、直接忽略，就好像是没有出该信号，信号对该进程不会产生任何影响。事实上，大多数信号都可以使用这种方式进行处理，但有两种信号却决不能被忽略，它们是 SIGKILL 和 SIGSTOP，这两种信号不能被忽略的原因是：它们向内核和超级用户提供了使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号，则进程的运行行为是未定义的。<br>⚫ 捕获信号。当信号到达进程后，执行预先绑定好的信号处理函数。为了做到这一点，要通知内核在某种信号发生时，执行用户自定义的处理函数，该处理函数中将会对该信号事件作出相应的处理，Linux 系统提供了 signal()系统调用可用于注册信号的处理函数，将会在后面向大家介绍。<br>⚫ 执行系统默认操作。进程不对该信号事件作出处理，而是交由系统进行处理，每一种信号都会有其对应的系统默认的处理方式，8中对此有进行介绍。需要注意的是，对大多数信号来说，系统默认的处理方式就是终止该进程。</p><p>实时信号与非实时信号其实是从时间关系上进行的分类，与可靠信号与不可靠信号是相互对应的，非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。实时信号保证了发送的多个信号都能被接收，实时信号是 POSIX 标准的一部分，可用于应用进程。</p><p>Linux 下对标准信号（不可靠信号、非实时信号）的编号为 1~31。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221217_122938.png"></p><h3 id="进程对信号的处理"><a href="#进程对信号的处理" class="headerlink" title="进程对信号的处理"></a>进程对信号的处理</h3><p><strong>signal函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sig_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sig_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sig_t</span> handler)</span>;</span><br></pre></td></tr></table></figure><p>signum：此参数指定需要进行设置的信号，可使用信号名（宏）或信号的数字编号，建议使用信号名。<br>handler：sig_t 类型的函数指针，指向信号对应的信号处理函数，当进程接收到信号后会自动执行该处理函数；参数 handler 既可以设置为用户自定义的函数，也就是捕获信号时需要执行的处理函数，也可以设置为 SIG_IGN 或 SIG_DFL，SIG_IGN 表示此进程需要忽略该信号，SIG_DFL 则表示设置为系统默认操作。<br>sig_t 函数指针的 int 类型参数指的是，当前触发该函数的信号，可将多个信号绑定到同一个信号处理函数上，此时就可通过此参数来判断当前触发的是哪个信号。</p><p>返回值：此函数的返回值也是一个 sig_t 类型的函数指针，成功情况下的返回值则是指向在此之前的信号处理函数；如果出错则返回 SIG_ERR，并会设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">sig_t</span> ret = <span class="literal">NULL</span>;</span><br><span class="line"> ret = signal(SIGINT, (<span class="type">sig_t</span>)sig_handler);</span><br><span class="line"> <span class="keyword">if</span> (SIG_ERR == ret) </span><br><span class="line"> &#123;</span><br><span class="line">perror(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 死循环 */</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123; &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sigaction()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><p>signum：需要设置的信号，除了 SIGKILL 信号和 SIGSTOP 信号之外的任何信号。<br>act：act 参数是一个 struct sigaction 类型指针，指向一个 struct sigaction 数据结构，该数据结构描述了信<br>号的处理方式，稍后介绍该数据结构；如果参数 act 不为 NULL，则表示需要为信号设置新的处理方式；如<br>果参数 act 为 NULL，则表示无需改变信号当前的处理方式。<br>oldact：oldact 参数也是一个 struct sigaction 类型指针，指向一个 struct sigaction 数据结构。如果参数<br>oldact 不为 NULL，则会将信号之前的处理方式等信息通过参数 oldact 返回出来；如果无意获取此类信息，<br>那么可将该参数设置为 NULL。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line"> <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line"> <span class="type">sigset_t</span> sa_mask;</span><br><span class="line"> <span class="type">int</span> sa_flags;</span><br><span class="line"> <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> ret = sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 死循环 */</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123; &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向进程发信号"><a href="#向进程发信号" class="headerlink" title="向进程发信号"></a>向进程发信号</h3><p><strong>kill</strong>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>pid：参数 pid 为正数的情况下，用于指定接收此信号的进程 pid；除此之外，参数 pid 也可设置为 0 或-1 以及小于-1 等不同值，稍后给说明。<br>sig：参数 sig 指定需要发送的信号，也可设置为 0，如果参数 sig 设置为 0 则表示不发送信号，但任执行错误检查，这通常可用于检查参数 pid 指定的进程是否存在。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。<br>参数 pid 不同取值含义：<br>⚫ 如果 pid 为正，则信号 sig 将发送到 pid 指定的进程。<br>⚫ 如果 pid 等于 0，则将 sig 发送到当前进程的进程组中的每个进程。<br>⚫ 如果 pid 等于-1，则将 sig 发送到当前进程有权发送信号的每个进程，但进程 1（init）除外。<br>⚫ 如果 pid 小于-1，则将 sig 发送到 ID 为-pid 的进程组中的每个进程。<br>进程中将信号发送给另一个进程是需要权限的，并不是可以随便给任何一个进程发送信号，超级用户root 进程可以将信号发送给任何进程，但对于非超级用户（普通用户）进程来说，其基本规则是发送者进程的实际用户 ID 或有效用户 ID 必须等于接收者进程的实际用户 ID 或有效用户 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> pid;</span><br><span class="line"> <span class="comment">/* 判断传参个数 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 将传入的字符串转为整形数字 */</span></span><br><span class="line"> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\n&quot;</span>, pid);</span><br><span class="line"> <span class="comment">/* 向 pid 指定的进程发送信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == kill(pid, SIGINT)) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;kill error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>raise()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>sig：需要发送的信号。<br>返回值：成功返回 0；失败将返回非零值。<br>raise()其实等价于：kill(getpid(), sig);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> ret = sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">/* 向自身发送 SIGINT 信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> != raise(SIGINT)) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;raise error\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">3</span>); <span class="comment">// 每隔 3 秒发送一次</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>alarm()和 pause()函数</p><p>使用 alarm()函数可以设置一个定时器（闹钟），当定时器定时时间到时，内核会向进程发送 SIGALRM信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p>seconds：设置定时时间，以秒为单位；如果参数 seconds 等于 0，则表示取消之前设置的 alarm 闹钟。<br>返回值：如果在调用 alarm()时，之前已经为该进程设置了 alarm 闹钟还没有超时，则该闹钟的剩余值作为本次 alarm()函数调用的返回值，之前设置的闹钟则被新的替代；否则返回 0。参数 seconds 的值是产生 SIGALRM 信号需要经过的时钟秒数，当这一刻到达时，由内核产生该信号，每个进程只能设置一个 alarm 闹钟；虽然 SIGALRM 信号的系统默认操作是终止进程，但是如果程序当中设置了 alarm 闹钟，但大多数使用闹钟的进程都会捕获此信号。<br>需要注意的是 alarm 闹钟并不能循环触发，只能触发一次，若想要实现循环触发，可以在 SIGALRM 信号处理函数中再次调用 alarm()函数设置定时器。</p><p>pause()系统调用可以使得进程暂停运行、进入休眠状态，直到进程捕获到一个信号为止，只有执行了信<br>号处理函数并从其返回时，pause()才返回，在这种情况下，pause()返回-1，并且将 errno 设置为 EINTR。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Alarm timeout&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> second;</span><br><span class="line"> <span class="comment">/* 检验传参个数 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 为 SIGALRM 信号绑定处理函数 */</span></span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGALRM, &amp;sig, <span class="literal">NULL</span>)) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 启动 alarm 定时器 */</span></span><br><span class="line"> second = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;定时时长: %d 秒\n&quot;</span>, second);</span><br><span class="line"> alarm(second);</span><br><span class="line"> <span class="comment">/* 进入休眠状态 */</span></span><br><span class="line"> pause();</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;休眠结束&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>有一个能表示多个信号（一组信号）的数据类型—信号集（signalset），很多系统调用都使用到了信号集这种数据类型来作为参数传递，譬如 sigaction()函数、sigprocmask()函数、sigpending()函数等。</p><p>信号集其实就是 sigset_t 类型数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __val[_SIGSET_NWORDS];</span><br><span class="line">&#125; <span class="type">sigset_t</span>;</span><br></pre></td></tr></table></figure><p>使用这个结构体可以表示一组信号，将多个信号添加到该数据结构中，当然 Linux 系统了用于操作sigset_t 信号集的 API，譬如 sigemptyset()、sigfillset()、sigaddset()、sigdelset()、sigismember()。</p><h4 id="信号集处理"><a href="#信号集处理" class="headerlink" title="信号集处理"></a>信号集处理</h4><p><strong>初始化sigemptyset()和 sigfillset()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>set：指向需要进行初始化的信号集变量。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigfillset(&amp;sig_set);</span><br></pre></td></tr></table></figure><p><strong>添加和删除信号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;<span class="comment">//set指向信号集，signum需要添加和删除的信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;<span class="comment">//成功返回 0；失败将返回-1，并设置 errno。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line">sigaddset(&amp;sig_set, SIGINT);<span class="comment">//信号集添加信号</span></span><br><span class="line"></span><br><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line">sigfillset(&amp;sig_set);</span><br><span class="line">sigdelset(&amp;sig_set, SIGINT);<span class="comment">//信号集移除信号</span></span><br></pre></td></tr></table></figure><p><strong>测试信号是否在信号集</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">//set：指定信号集。</span></span><br><span class="line"><span class="comment">//signum：需要进行测试的信号。</span></span><br><span class="line"><span class="comment">//返回值：如果信号 signum 在信号集 set 中，则返回 1；如果不在信号集 set 中，则返回 0；失败则返回1，并设置 errno。</span></span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line"><span class="keyword">if</span>(sigismember(&amp;sig_set, SIGINT) == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;信号集中包含SIGINT信号&quot;</span>);</span><br></pre></td></tr></table></figure><p>在 Linux 下，每个信号都有一串与之相对应的字符串描述信息，用于对该信号进行相应的描述。这些字符串位于 sys_siglist 数组中，sys_siglist 数组是一个 char *类型的数组，数组中的每一个元素存放的是一个字符串指针，指向一个信号描述信息。譬如，可以使用 sys_siglist[SIGINT]来获取对 SIGINT 信号的描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 描述信息: %s\n&quot;</span>, sys_siglist[SIGINT]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 描述信息: %s\n&quot;</span>, sys_siglist[SIGQUIT]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;SIGBUS 描述信息: %s\n&quot;</span>, sys_siglist[SIGBUS]);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>psignal()可以在标准错误（stderr）上输出信号描述信息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">psignal</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>信号掩码（阻塞信号传递）</p><p>内核为每一个进程维护了一个信号掩码（其实就是一个信号集），即一组信号。当进程接收到一个属于信号掩码中定义的信号时，该信号将会被阻塞、无法传递给进程进行处理，那么内核会将其阻塞，直到该信号从信号掩码中移除，内核才会把该信号传递给进程从而得到处理。</p><p>信号掩码中添加信号的方法：</p><p>①程序调用signal()或者sigaction函数为某一个信号设置处理方式时，进程会自动将该信号添加到信号掩码中，这样保证了处理一个给定信号时候，再次碰到该信号，会将请其阻塞。</p><p>②使用sigaction()函数为信号设置处理方式时，可以额外指定一组信号，当调用信号处理函数时将该组信号自动添加到信号掩码中，但信号处理函数结束返回后，再将这组信号从信号掩码中移除</p><p>③还可以使用sigprocmask()系统调用，随时可以显式地向信号掩码中添加&#x2F;移除信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure><p>how：参数 how 指定了调用函数时的一些行为。<br>set：将参数 set 指向的信号集内的所有信号添加到信号掩码中或者从信号掩码中移除；如果参数 set 为NULL，则表示无需对当前信号掩码作出改动。<br>oldset：如果参数 oldset 不为 NULL，在向信号掩码中添加新的信号之前，获取到进程当前的信号掩码，存放在 oldset 所指定的信号集中；如果为 NULL 则表示不获取当前的信号掩码。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。<br>参数 how 可以设置为以下宏：<br>⚫ <strong>SIG_BLOCK</strong>：将参数 set 所指向的信号集内的所有信号添加到进程的信号掩码中。换言之，将信号掩码设置为当前值与 set 的并集。<br>⚫ <strong>SIG_UNBLOCK</strong>：将参数 set 指向的信号集内的所有信号从进程信号掩码中移除。<br>⚫ <strong>SIG_SETMASK</strong>：进程信号掩码直接设置为参数 set 指向的信号集。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行信号处理函数\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">sigset_t</span> sig_set;</span><br><span class="line"> <span class="comment">/* 注册信号处理函数 */</span></span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 信号集初始化 */</span></span><br><span class="line"> sigemptyset(&amp;sig_set);</span><br><span class="line"> sigaddset(&amp;sig_set, SIGINT);</span><br><span class="line"> <span class="comment">/* 向信号掩码中添加信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_BLOCK, &amp;sig_set, <span class="literal">NULL</span>))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 向自己发送信号 */</span></span><br><span class="line"> raise(SIGINT);</span><br><span class="line"> <span class="comment">/* 休眠 2 秒 */</span></span><br><span class="line"> sleep(<span class="number">2</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;休眠结束\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 从信号掩码中移除添加的信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_UNBLOCK, &amp;sig_set, <span class="literal">NULL</span>))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞等待信号"><a href="#阻塞等待信号" class="headerlink" title="阻塞等待信号"></a>阻塞等待信号</h3><p>如果希望对一个信号解除阻塞后，然后调用 pause()以等待之前被阻塞的信号的传递，这将如何？譬如有如下代码段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> new_set, old_set;</span><br><span class="line"> <span class="comment">/* 信号集初始化 */</span></span><br><span class="line"> sigemptyset(&amp;new_set);</span><br><span class="line"> sigaddset(&amp;new_set, SIGINT);</span><br><span class="line"> <span class="comment">/* 向信号掩码中添加信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_BLOCK, &amp;new_set, &amp;old_set))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 受保护的关键代码段 */</span></span><br><span class="line"> ......</span><br><span class="line"> <span class="comment">/**********************/</span></span><br><span class="line"> <span class="comment">/* 恢复信号掩码 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigprocmask(SIG_SETMASK, &amp;old_set, <span class="literal">NULL</span>))</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> pause();<span class="comment">/* 等待信号唤醒 */</span></span><br></pre></td></tr></table></figure><p>执行受保护的关键代码时不希望被 SIGINT 信号打断，所以在执行关键代码之前将 SIGINT 信号添加到进程的信号掩码中，执行完毕之后再恢复之前的信号掩码。最后调用了 pause()阻塞等待被信号唤醒，如果此时发生了信号则会被唤醒、从 pause 返回继续执行；考虑到这样一种情况，如果信号的传递恰好发生在第二次调用sigprocmask()之后、pause()之前，如果确实发生了这种情况，就会产生一个问题，信号传递过来就会导致执行信号的处理函数，而从处理函数返回后又回到主程序继续执行，从而进入到 pause()被阻塞，知道下一次信号发生时才会被唤醒，这有违代码的本意。</p><p>要避免这个问题，需要将恢复信号掩码和 pause()挂起进程这两个动作封装成一个原子操作，这正是 sigsuspend()系统调用的目的所在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure><p>mask：参数 mask 指向一个信号集。<br>返回值：sigsuspend()始终返回-1，并设置 errno 来指示错误（通常为 EINTR），表示被信号所中断，如果调用失败，将 errno 设置为 EFAULT。</p><p>sigsuspend()函数会将参数 mask 所指向的信号集来替换进程的信号掩码，也就是将进程的信号掩码设置为参数 mask 所指向的信号集，然后挂起进程，直到捕获到信号被唤醒（如果捕获的信号是 mask 信号集中的成员，将不会唤醒、继续挂起）、并从信号处理函数返回，一旦从信号处理函数返回，sigsuspend()会将进程的信号掩码恢复成调用前的值。</p><p>调用 sigsuspend()函数相当于以不可中断（原子操作）的方式执行以下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;old_mask);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;old_mask, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="实时信号"><a href="#实时信号" class="headerlink" title="实时信号"></a>实时信号</h3><p>确定进程中处于等待状态的是哪些信号，用sigpending()函数获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p>set：处于等待状态的信号会存放在参数 set 所指向的信号集中。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p><u>判断 SIGINT 信号当前是否处于等待状态</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义信号集 */</span></span><br><span class="line"><span class="type">sigset_t</span> sig_set;</span><br><span class="line"><span class="comment">/* 将信号集初始化为空 */</span></span><br><span class="line">sigemptyset(&amp;sig_set);</span><br><span class="line"><span class="comment">/* 获取当前处于等待状态的信号 */</span></span><br><span class="line">sigpending(&amp;sig_set);</span><br><span class="line"><span class="comment">/* 判断 SIGINT 信号是否处于等待状态 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == sigismember(&amp;sig_set, SIGINT))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;SIGINT 信号处于等待状态&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!sigismember(&amp;sig_set, SIGINT))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;SIGINT 信号未处于等待状态&quot;</span>);</span><br></pre></td></tr></table></figure><p>等待信号集只是一个掩码，仅表明一个信号是否发生，而不能表示其发生的次数。换言之，如果一个同一个信号在阻塞状态下产生了多次，那么会将该信号记录在等待信号集中，并在之后仅传递一次（仅当做发生了一次），这是标准信号的缺点之一。</p><p>实时信号较之于标准信号，其优势如下：<br>⚫ 实时信号的信号范围有所扩大，可应用于应用程序自定义的目的，而标准信号仅提供了两个信号可用于应用程序自定义使用：SIGUSR1 和 SIGUSR2。<br>⚫ 内核对于实时信号所采取的是队列化管理。如果将某一实时信号多次发送给另一个进程，那么将会多次传递此信号。相反，对于某一标准信号正在等待某一进程，而此时即使再次向该进程发送此信号，信号也只会传递一次。<br>⚫ 当发送一个实时信号时，可为信号指定伴随数据（一整形数据或者指针值），供接收信号的进程在它的信号处理函数中获取。<br>⚫ 不同实时信号的传递顺序得到保障。如果有多个不同的实时信号处于等待状态，那么将率先传递具有最小编号的信号。换言之，信号的编号越小，其优先级越高，如果是同一类型的多个信号在排队，那么信号（以及伴随数据）的传递顺序与信号发送来时的顺序保持一致。</p><p>应用程序当中使用实时信号，需要有以下的两点要求：<br>⚫ 发送进程使用 sigqueue()系统调用向另一个进程发送实时信号以及伴随数据。<br>⚫ 接收实时信号的进程要为该信号建立一个信号处理函数，使用sigaction函数为信号建立处理函数，并加入 SA_SIGINFO，这样信号处理函数才能够接收到实时信号以及伴随数据，也就是要使用sa_sigaction 指针指向的处理函数，而不是 sa_handler，当然允许应用程序使用 sa_handler，但这样就不能获取到实时信号的伴随数据了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br></pre></td></tr></table></figure><p>pid：指定接收信号的进程对应的 pid，将信号发送给该进程。<br>sig：指定需要发送的信号。与 kill()函数一样，也可将参数 sig 设置为 0，用于检查参数 pid 所指定的进程是否存在。<br>value：参数 value 指定了信号的伴随数据，union sigval 数据类型。</p><p>返回值：成功将返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">sigval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> sival_int;</span><br><span class="line"><span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125; <span class="type">sigval_t</span>;</span><br></pre></td></tr></table></figure><p><strong>异常退出函数abort()</strong></p><p>使用 abort()终止进程运行，会生成核心转储文件，可用于判断程序调用 abort()时的程序状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><u>函数 abort()通常产生 SIGABRT 信号来终止调用该函数的进程，SIGABRT 信号的系统默认操作是终止进程运行、并生成核心转储文件；当调用 abort()函数之后，内核会向进程发送 SIGABRT 信号。</u></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统信息与系统资源</title>
      <link href="/2022/12/13/2022-12-13-Linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/"/>
      <url>/2022/12/13/2022-12-13-Linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="系统信息与系统资源"><a href="#系统信息与系统资源" class="headerlink" title="系统信息与系统资源"></a>系统信息与系统资源</h2><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><h4 id="系统标识uname"><a href="#系统标识uname" class="headerlink" title="系统标识uname"></a>系统标识uname</h4><p>系统调用uname()用于获取有关当前操作系统内核的名称和信息，原型可以通过man 2 uname查看</p><p>函数参数和返回值含义如下：<br>buf：struct utsname 结构体类型指针，指向一个 struct utsname 结构体类型对象。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>uname()函数用法非常简单，先定义一个 struct utsname 结构体变量，调用 uname()函数时传入变量的地<br>址即可，struct utsname 结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></span><br><span class="line"> <span class="type">char</span> sysname[]; <span class="comment">/* 当前操作系统的名称 */</span></span><br><span class="line"> <span class="type">char</span> nodename[]; <span class="comment">/* 网络上的名称（主机名） */</span></span><br><span class="line"> <span class="type">char</span> release[]; <span class="comment">/* 操作系统内核版本 */</span></span><br><span class="line"> <span class="type">char</span> version[]; <span class="comment">/* 操作系统发行版本 */</span></span><br><span class="line"> <span class="type">char</span> machine[]; <span class="comment">/* 硬件架构类型 */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> _GNU_SOURCE</span></span><br><span class="line"> <span class="type">char</span> domainname[];<span class="comment">/* 当前域名 */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="sysinfo函数"><a href="#sysinfo函数" class="headerlink" title="sysinfo函数"></a>sysinfo函数</h4><p>sysinfo 系统调用可用于获取一些系统统计信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *info)</span>;</span><br></pre></td></tr></table></figure><p>info：struct sysinfo 结构体类型指针，指向一个 struct sysinfo 结构体类型对象。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> &#123;</span></span><br><span class="line"> <span class="type">long</span> uptime; <span class="comment">/* 自系统启动之后所经过的时间（以秒为单位） */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> loads[<span class="number">3</span>]; <span class="comment">/* 1, 5, and 15 minute load averages */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> totalram; <span class="comment">/* 总的可用内存大小 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> freeram; <span class="comment">/* 还未被使用的内存大小 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> sharedram; <span class="comment">/* Amount of shared memory */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> bufferram; <span class="comment">/* Memory used by buffers */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> totalswap; <span class="comment">/* Total swap space size */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> freeswap; <span class="comment">/* swap space still available */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> procs; <span class="comment">/* 系统当前进程数量 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> totalhigh; <span class="comment">/* Total high memory size */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> freehigh; <span class="comment">/* Available high memory size */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> mem_unit; <span class="comment">/* 内存单元大小（以字节为单位） */</span></span><br><span class="line"> <span class="type">char</span> _f[<span class="number">20</span><span class="number">-2</span>*<span class="keyword">sizeof</span>(<span class="type">long</span>)-<span class="keyword">sizeof</span>(<span class="type">int</span>)]; <span class="comment">/* Padding to 64 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="gethostname函数"><a href="#gethostname函数" class="headerlink" title="gethostname函数"></a>gethostname函数</h4><p>此函数可用于单独获取 Linux 系统主机名，与 struct utsname 数据结构体中的 nodename 变量一样，原型通过命令man 2 gethostname查看。</p><p>name：指向用于存放主机名字符串的缓冲区。<br>len：缓冲区长度。<br>返回值：成功返回 0,；失败将返回-1，并会设置 errno。</p><h4 id="sysconf函数"><a href="#sysconf函数" class="headerlink" title="sysconf函数"></a>sysconf函数</h4><p>sysconf()函数是一个库函数，可在运行时获取系统的一些配置信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sysconf</span><span class="params">(<span class="type">int</span> name)</span>;</span><br></pre></td></tr></table></figure><p>⚫ _SC_ARG_MAX：exec 族函数的参数的最大长度，exec 族函数后面会介绍，这里先不管！<br>⚫ _SC_CHILD_MAX：每个用户的最大并发进程数，也就是同一个用户可以同时运行的最大进程数。<br>⚫ _SC_HOST_NAME_MAX：主机名的最大长度。<br>⚫ _SC_LOGIN_NAME_MAX：登录名的最大长度。<br>⚫ _SC_CLK_TCK：每秒时钟滴答数，也就是系统节拍率。<br>⚫ _SC_OPEN_MAX：一个进程可以打开的最大文件数。<br>⚫ _SC_PAGESIZE：系统页大小（page size）。<br>⚫ _SC_TTY_NAME_MAX：终端设备名称的最大长度。</p><p>更多请用man指令查询。</p><h3 id="时间、日期"><a href="#时间、日期" class="headerlink" title="时间、日期"></a>时间、日期</h3><h4 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h4><p>系统调用time()用于获取当前时间，以秒为单位，返回值是自 1970-01-01 00:00:00 +0000 (UTC)以来的秒数，原型可通过man2 time查看</p><p>tloc：如果 tloc 参数不是 NULL，则返回值也存储在 tloc 指向的内存中。</p><p>返回值：成功则返回自 1970-01-01 00:00:00 +0000 (UTC)以来的时间值（以秒为单位）；失败则返回-1，<br>并会设置 errno。</p><p>time 函数获取得到的是一个时间段，也就是从 1970-01-01 00:00:00 +0000 (UTC)到现在这段时间所经过的秒数，把这个称之为日历时间或 time_t 时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">time_t</span> t;</span><br><span class="line"> t = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == t) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;时间值: %ld\n&quot;</span>, t);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gettimeofday函数"><a href="#gettimeofday函数" class="headerlink" title="gettimeofday函数"></a>gettimeofday函数</h4><p>gettimeofday()函数提供微秒级时间精度。原型可通过man 2 gettimeofday查看</p><p>tv：参数 tv 是一个 struct timeval 结构体指针变量，struct timeval 结构体在前面章节内容中已经给大家介绍过，具体参考示例代码 5.6.3。<br>tz：参数 tz 是个历史产物，早期实现用其来获取系统的时区信息，目前已遭废弃，在调用 gettimeofday()函数时应将参数 tz 设置为 NULL。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tval</span>;</span></span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> ret = gettimeofday(&amp;tval, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;gettimeofday error&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;时间值: %ld 秒+%ld 微秒\n&quot;</span>, tval.tv_sec, tval.tv_usec);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间转换函数"><a href="#时间转换函数" class="headerlink" title="时间转换函数"></a>时间转换函数</h4><p><strong>ctime函数</strong></p><p>ctime可以将日历时间转换为可打印输出的字符串形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="type">char</span> *buf)</span>;</span><br></pre></td></tr></table></figure><p>timep：time_t 时间变量指针。<br>返回值：成功将返回一个 char *类型指针，指向转换后得到的字符串；失败将返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> tm_str[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">time_t</span> tm;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> tm = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == tm) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将时间转换为字符串形式 */</span></span><br><span class="line"> ctime_r(&amp;tm, tm_str);</span><br><span class="line"><span class="comment">/* 打印输出 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;当前时间: %s&quot;</span>, tm_str);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>localtime函数</strong></p><p>localtime()函数可以把 time()或 gettimeofday()得到的秒数（time_t 时间或日历时间）变成一个 struct tm<br>结构体所表示的时间，该时间对应的是本地时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br></pre></td></tr></table></figure><p>timep：需要进行转换的 time_t 时间变量对应的指针，可通过 time()或 gettimeofday()获取得到。<br>result：是一个 struct tm 结构体类型指针，稍后给大家介绍 struct tm 结构体，参数 result 是可重入函数<br>localtime_r()需要额外提供的参数。<br>返回值：对于不可重入版本 localtime()来说，成功则返回一个有效的 struct tm 结构体指针，而对于可重入版本 localtime_r()来说，成功执行情况下，返回值将会等于参数result；失败则返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> tm_sec; <span class="comment">/* 秒(0-60) */</span></span><br><span class="line"> <span class="type">int</span> tm_min; <span class="comment">/* 分(0-59) */</span></span><br><span class="line"> <span class="type">int</span> tm_hour; <span class="comment">/* 时(0-23) */</span></span><br><span class="line"> <span class="type">int</span> tm_mday; <span class="comment">/* 日(1-31) */</span></span><br><span class="line"> <span class="type">int</span> tm_mon; <span class="comment">/* 月(0-11) */</span></span><br><span class="line"> <span class="type">int</span> tm_year; <span class="comment">/* 年(这个值表示的是自 1900 年到现在经过的年数) */</span></span><br><span class="line"> <span class="type">int</span> tm_wday; <span class="comment">/* 星期(0-6, 星期日 Sunday = 0、星期一=1…) */</span></span><br><span class="line"> <span class="type">int</span> tm_yday; <span class="comment">/* 一年里的第几天(0-365, 1 Jan = 0) */</span></span><br><span class="line"> <span class="type">int</span> tm_isdst; <span class="comment">/* 夏令时 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">t</span>;</span></span><br><span class="line"> <span class="type">time_t</span> sec;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> sec = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sec) &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 转换得到本地时间 */</span></span><br><span class="line"> localtime_r(&amp;sec, &amp;t);</span><br><span class="line"> <span class="comment">/* 打印输出 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;当前时间: %d 年%d 月%d 日 %d:%d:%d\n&quot;</span>,</span><br><span class="line"> t.tm_year + <span class="number">1900</span>, t.tm_mon, t.tm_mday,</span><br><span class="line"> t.tm_hour, t.tm_min, t.tm_sec);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gmtime()函数</strong>把time_t时间变为struct tm结构体所表示的时间，得到的是UTC国际标准时间，不是本地时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">local_t</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">utc_t</span>;</span></span><br><span class="line"> <span class="type">time_t</span> sec;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> sec = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sec) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 转换得到本地时间 */</span></span><br><span class="line"> localtime_r(&amp;sec, &amp;<span class="type">local_t</span>);</span><br><span class="line"> <span class="comment">/* 转换得到国际标准时间 */</span></span><br><span class="line"> gmtime_r(&amp;sec, &amp;<span class="type">utc_t</span>);</span><br><span class="line"> <span class="comment">/* 打印输出 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;本地时间: %d 年%d 月%d 日 %d:%d:%d\n&quot;</span>,</span><br><span class="line"> <span class="type">local_t</span>.tm_year + <span class="number">1900</span>, <span class="type">local_t</span>.tm_mon, <span class="type">local_t</span>.tm_mday,</span><br><span class="line"> <span class="type">local_t</span>.tm_hour, <span class="type">local_t</span>.tm_min, <span class="type">local_t</span>.tm_sec);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;UTC 时间: %d 年%d 月%d 日 %d:%d:%d\n&quot;</span>,</span><br><span class="line"> <span class="type">utc_t</span>.tm_year + <span class="number">1900</span>, <span class="type">utc_t</span>.tm_mon, <span class="type">utc_t</span>.tm_mday,</span><br><span class="line"> <span class="type">utc_t</span>.tm_hour, <span class="type">utc_t</span>.tm_min, <span class="type">utc_t</span>.tm_sec);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mktime函数</strong>可以将使用 struct tm 结构体表示的分解时间转换为 time_t时间（日历时间）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure><p>tm：需要进行转换的 struct tm 结构体变量对应的指针。<br>返回值：成功返回转换得到 time_t 时间值；失败返回-1。</p><p><strong>asctime函数</strong>与 ctime()函数的作用一样，也可将时间转换为可打印输出的字符串形式，与 ctime()函数<br>的区别在于，ctime()是将 time_t 时间转换为固定格式字符串、而 asctime()则是将 struct tm 表示的分解时间转换为固定格式的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime_r</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm, <span class="type">char</span> *buf)</span>;</span><br></pre></td></tr></table></figure><p>tm：需要进行转换的 struct tm 表示的时间。<br>buf：可重入版本函数 asctime_r 需要额外提供的参数 buf，指向一个缓冲区，用于存放转换得到的字符串。<br>返回值：转换失败将返回 NULL；成功将返回一个 char *类型指针，指向转换后得到的时间字符串，对asctime_r 函数来说，返回值就等于参数 buf。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">local_t</span>;</span></span><br><span class="line"> <span class="type">char</span> tm_str[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">time_t</span> sec;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> sec = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (sec == <span class="number">-1</span>) </span><br><span class="line"> &#123;</span><br><span class="line">perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> localtime_r(&amp;sec, &amp;<span class="type">local_t</span>);</span><br><span class="line"> asctime_r(&amp;<span class="type">local_t</span>, tm_str);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;本地时间: %s&quot;</span>, tm_str);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>strftime 函数</strong>可以自定义时间显示格式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> max, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure><p>s：指向一个缓存区的指针，该缓冲区用于存放生成的字符串。<br>max：字符串的最大字节数。<br>format：这是一个用字符串表示的字段，包含了普通字符和特殊格式说明符，可以是这两种字符的任意<br>组合。特殊格式说明符将会被替换为 struct tm 结构体对象所指时间的相应值。</p><p>特殊格式可用命令man strftime查询。</p><p><strong>设置时间 settimeofday</strong></p><p>使用 settimeofday()函数可以设置时间，也就是设置系统的本地时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">settimeofday</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timeval *tv, <span class="type">const</span> <span class="keyword">struct</span> timezone *tz)</span>;</span><br></pre></td></tr></table></figure><p>tv：参数 tv 是一个 struct timeval 结构体指针变量，struct timeval 结构体在前面章节内容中已经给大家介绍了，需要设置的时间便通过参数 tv 指向的 struct timeval 结构体变量传递进去。<br>tz：参数 tz 是个历史产物，早期实现用其来设置系统的时区信息，目前已遭废弃，在调用 settimeofday()函数时应将参数 tz 设置为 NULL。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>使用 settimeofday 设置系统时间时内核会进行权限检查，只有超级用户（root）才可以设置系统时间，普通用户将无操作权限。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221211_135113.png"></p><h3 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h3><p>进程时间指的是进程从创建后（也就是程序运行后）到目前为止这段时间内使用 CPU 资源的时间总数，出于记录的目的，内核把 CPU 时间（进程时间）分为以下两个部分：<br>⚫ 用户 CPU 时间：进程在用户空间（用户态）下运行所花费的 CPU 时间。有时也成为虚拟时间（virtual time）。<br>⚫ 系统 CPU 时间：进程在内核空间（内核态）下运行所花费的 CPU 时间。这是内核执行系统调用或代表进程执行的其它任务（譬如，服务页错误）所花费的时间。<br>一般来说，进程时间指的是用户 CPU 时间和系统 CPU 时间的总和，也就是总的 CPU 时间。</p><h4 id="times函数"><a href="#times函数" class="headerlink" title="times函数"></a>times函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">times</span><span class="params">(<span class="keyword">struct</span> tms *buf)</span>;</span><br></pre></td></tr></table></figure><p>buf：times()会将当前进程时间信息存在一个 struct tms 结构体数据中</p><p>返回值：返回值类型为 clock_t（实质是 long 类型），调用成功情况下，将返回从过去任意的一个时间点（譬如系统启动时间）所经过的时钟滴答数（其实就是系统节拍数），将(节拍数 &#x2F; 节拍率)便可得到秒数，返回值可能会超过 clock_t 所能表示的范围（溢出）；调用失败返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">clock_t</span> tms_utime; <span class="comment">/* user time, 进程的用户 CPU 时间, tms_utime 个系统节拍数 */</span></span><br><span class="line"> <span class="type">clock_t</span> tms_stime; <span class="comment">/* system time, 进程的系统 CPU 时间, tms_stime 个系统节拍数 */</span></span><br><span class="line"> <span class="type">clock_t</span> tms_cutime; <span class="comment">/* user time of children, 已死掉子进程的 tms_utime + tms_cutime 时间总和 */</span></span><br><span class="line"> <span class="type">clock_t</span> tms_cstime; <span class="comment">/* system time of children, 已死掉子进程的 tms_stime + tms_cstime 时间总和 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="clock函数"><a href="#clock函数" class="headerlink" title="clock函数"></a>clock函数</h4><p>库函数 clock()提供了一个更为简单的方式用于进程时间，它的返回值描述了进程使用的总的 CPU 时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">clock</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>无参数。<br>返回值：返回值是到目前为止程序的进程时间，为 clock_t 类型，注意 clock()的返回值并不是系统节拍数，如果想要获得秒数，请除以 CLOCKS_PER_SEC（这是一个宏）。如果返回的进程时间不可用或其值无法表示，则该返回值是-1。<br>clock()函数虽然可以很方便的获取总的进程时间，但并不能获取到单独的用户 CPU 时间和系统 CPU 时间，在实际编程当中，根据自己的需要选择。</p><h4 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a>产生随机数</h4><p>rand()函数用于获取随机数。（是一种伪随机数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>返回值：返回一个介于 0 到 RAND_MAX（包含）之间的值，也就是数学上的[0, RAND_MAX]。程度当中调用 rand()可以得到[0, RAND_MAX]之间的伪随机数，多次调用 rand()便可以生成一组伪随机树序列，但是这里有个问题，就是每一次运行程序所得到的随机数序列都是相同的，那如何使得每一次启动应用程序所得到的随机数序列是不一样的呢？那就通过设置不同的随机数种子，可通过 srand()设置随机数种子。<br>如果没有调用 srand()设置随机数种子的情况下，rand()会将 1 作为随机数种子，如果随机数种子相同，那么每一次启动应用程序所得到的随机数序列就是一样的，所以每次启动应用程序需要设置不同的随机数种子，这样就可以使得程序每次运行所得到随机数序列不同。</p><p><strong>srand 函数</strong></p><p>使用 srand()函数为 rand()设置随机数种子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br></pre></td></tr></table></figure><p>seed：指定一个随机数中，int 类型的数据，一般尝尝将当前时间作为随机数种子赋值给参数 seed，譬如 time(NULL)，因为每次启动应用程序时间上是一样的，所以就能够使得程序中设置的随机数种子在每次启动程序时是不一样的。<br>返回值：void<br>常用的用法 srand(time(NULL))</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> random_number_arr[<span class="number">8</span>];</span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"> <span class="comment">/* 设置随机数种子 */</span></span><br><span class="line"> srand(time(<span class="literal">NULL</span>));</span><br><span class="line"> <span class="comment">/* 生成伪随机数 */</span></span><br><span class="line"> <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">8</span>; count++)</span><br><span class="line"> random_number_arr[count] = rand() % <span class="number">100</span>;</span><br><span class="line"> <span class="comment">/* 打印随机数数组 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">8</span>; count++) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, random_number_arr[count]);</span><br><span class="line"> <span class="keyword">if</span> (count != <span class="number">8</span> - <span class="number">1</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>有时需要将进程暂停或休眠一段时间，进入休眠状态之后，程序将暂停运行，直到休眠结束。常用的系统调用和 C 库函数有 sleep()、usleep()以及 nanosleep()，这些函数在应用程序当中通常作为延时使用。</p><p><strong>秒级休眠sleep</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p>seconds：休眠时长，以秒为单位。<br>返回值：如果休眠时长为参数 seconds 所指定的秒数，则返回 0；若被信号中断则返回剩余的秒数。<br>sleep()是一个秒级别休眠函数，程序在休眠过程中，是可以被其它信号所打断的。</p><p>微秒休眠usleep</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">usleep</span><span class="params">(<span class="type">useconds_t</span> usec)</span>;</span><br></pre></td></tr></table></figure><p>高精度休眠nanosleep</p><p>nanosleep()与 sleep()以及 usleep()类似，都用于程序休眠，但 nanosleep()具有更高精度来设置休眠时间长度，支持纳秒级时长设置。与 sleep()、usleep()不同的是，nanosleep()是一个 Linux 系统调用。</p><p>req：一个 struct timespec 结构体指针，指向一个 struct timespec 变量，用于设置休眠时间长度，可精确到纳秒级别。<br>rem：也是一个 struct timespec 结构体指针，指向一个 struct timespec 变量，也可设置 NULL。<br>返回值：在成功休眠达到请求的时间间隔后，nanosleep()返回 0；如果中途被信号中断或遇到错误，则返回-1，并将剩余时间记录在参数 rem 指向的 struct timespec 结构体变量中（参数 rem 不为 NULL 的情况下，如果为 NULL 表示不接收剩余时间），还会设置 errno 标识错误类型。</p><h3 id="申请堆内存"><a href="#申请堆内存" class="headerlink" title="申请堆内存"></a>申请堆内存</h3><p>在操作系统下，内存资源是由操作系统进行管理、分配的，当应用程序想要内存时（这里指的是堆内存），可以向操作系统申请内存，然后使用内存；当不再需要时，将申请的内存释放、归还给操作系统。</p><h4 id="堆上分配内存：malloc和free"><a href="#堆上分配内存：malloc和free" class="headerlink" title="堆上分配内存：malloc和free"></a>堆上分配内存：malloc和free</h4><p><strong>malloc</strong>为程序分配一段堆内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>size：需要分配的内存大小，以字节为单位。</p><p>返回值：返回值为 void *类型，如果申请分配内存成功，将返回一个指向该段内存的指针，void *并不是说没有返回值或者返回空指针，而是返回的指针类型未知,所以在调用 malloc()时通常需要进行强制类型转换，将 void *指针类型转换成我们希望的类型；如果分配内存失败（譬如系统堆内存不足）将返回 NULL，如果参数 size 为 0，返回值也是 NULL。</p><p>malloc()在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的，所以通常需要程序员对 malloc()分配的堆内存进行初始化操作。</p><p><strong>free</strong>释放堆内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p>ptr：指向需要被释放的堆内存对应的指针。<br>返回值：无返回值。</p><p><strong>用 calloc()分配内存</strong><br>calloc()函数用来动态地分配内存空间并初始化为 0，其函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>使用该函数同样也需要包含头文件。<br>calloc()在堆中动态地分配 nmemb 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 nmemb * size 个字节长度的内存空间，并且每个字节的值都是 0。<br>返回值：分配成功返回指向该内存的地址，失败则返回 NULL。<br>calloc()与 malloc()的一个重要区别是：calloc()在动态分配完内存后，自动初始化该内存空间为零，而malloc()不初始化，里边数据是未知的垃圾数据。下面的两种写法是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calloc()分配内存空间并初始化</span></span><br><span class="line"><span class="type">char</span> *buf1 = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// malloc()分配内存空间并用 memset()初始化</span></span><br><span class="line"><span class="type">char</span> *buf2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf2, <span class="number">0</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="分配对齐内存"><a href="#分配对齐内存" class="headerlink" title="分配对齐内存"></a>分配对齐内存</h4><p><a href="https://xie.infoq.cn/article/e071632f617563002552a7232">一文轻松理解内存对齐_</a></p><p>C 函数库中还提供了一系列在堆上分配对齐内存的函数，对齐内存在某些应用场合非常有必要，常用于分配对其内存的库函数有：posix_memalign()、aligned_alloc()、memalign()、valloc()、pvalloc()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">posix_memalign</span><span class="params">(<span class="type">void</span> **memptr, <span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">aligned_alloc</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">valloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">pvalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>posix_memalign()函数<br>posix_memalign()函数用于在堆上分配 size 个字节大小的对齐内存空间，将*memptr 指向分配的空间，分配的内存地址将是参数 alignment 的整数倍。参数 alignment 表示对齐字节数，alignment 必须是 2 的幂次方（譬如 2^4、2^5、2^8 等），同时也要是 sizeof(void *)的整数倍，对于 32 位系统来说sizeof(void *)等于4，如果是 64 位系统 sizeof(void *)等于 8。<br>函数参数和返回值含义如下：<br>memptr：void *<em>类型的指针，内存申请成功后会将分配的内存地址存放在</em>memptr 中。<br>alignment：设置内存对其的字节数，alignment 必须是 2 的幂次方（譬如 2^4、2^5、2^8 等），同时也要是 sizeof(void <em>)的整数倍。<br>size：设置分配的内存大小，以字节为单位，如果参数 size 等于 0，那么</em>memptr 中的值是 NULL。<br>返回值：成功将返回 0；失败返回非 0 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> *base = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 申请内存: 256 字节对齐 */</span></span><br><span class="line"> ret = posix_memalign((<span class="type">void</span> **)&amp;base, <span class="number">256</span>, <span class="number">1024</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> != ret) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;posix_memalign error\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* 使用内存 */</span></span><br><span class="line"> <span class="comment">// base[0] = 0;</span></span><br><span class="line"> <span class="comment">// base[1] = 1;</span></span><br><span class="line"> <span class="comment">// base[2] = 2;</span></span><br><span class="line"> <span class="comment">// base[3] = 3;</span></span><br><span class="line"> <span class="comment">/* 释放内存 */</span></span><br><span class="line"> <span class="built_in">free</span>(base);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="proc文件系统"></a>proc文件系统</h3><p>(1)proc是虚拟文件系统，虚拟的意思就是proc文件系统里的文件不对应硬盘上任何文件，我们用去查看proc目录下的文件大小都是零；<br>(2)proc文件系统是开放给上层了解内核运行状态的窗口，通过读取proc系统里的文件，可以知道内核中一些重要数据结构的数值，从而知道内核的运行情况，也可以方便调试内核和应用程序；<br>(3)proc文件系统的思路：在内核中构建一个虚拟文件系统&#x2F;proc，内核运行时将内核中一些关键的数据结构以文件的方式呈现在&#x2F;proc目录中的一些特定文件中，这样相当于将不可见的内核中的数据结构以可视化的方式呈现给内核的开发者</p><table><thead><tr><th align="center">文件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">&#x2F;proc&#x2F;cmdline</td><td align="center">查看内核的启动参数</td></tr><tr><td align="center">&#x2F;proc&#x2F;cpuinfo</td><td align="center">查看CPU的信息</td></tr><tr><td align="center">&#x2F;proc&#x2F;devices</td><td align="center">查看内核中已经注册的设备</td></tr><tr><td align="center">&#x2F;proc&#x2F;filesystems</td><td align="center">内核当前支持的文件系统类型</td></tr><tr><td align="center">&#x2F;proc&#x2F;interrupts</td><td align="center">中断的使用及触发次数，调试中断时很有用</td></tr><tr><td align="center">&#x2F;proc&#x2F;misc</td><td align="center">内核中注册的misc类设备</td></tr><tr><td align="center">&#x2F;proc&#x2F;modules</td><td align="center">已经加载的模块列表，对应lsmod命令</td></tr><tr><td align="center">&#x2F;proc&#x2F;partitions</td><td align="center">系统的分区表</td></tr><tr><td align="center">&#x2F;proc&#x2F;version</td><td align="center">系统的版本</td></tr><tr><td align="center">数字</td><td align="center">数字的文件夹都是相应的进程</td></tr><tr><td align="center">&#x2F;proc&#x2F;mounts</td><td align="center">已加载的文件系统的列表，对应mount命令</td></tr><tr><td align="center">&#x2F;proc&#x2F;meminfo</td><td align="center">内核的内存信息</td></tr><tr><td align="center">&#x2F;proc&#x2F;fb</td><td align="center">内核中注册的显示设备</td></tr></tbody></table><p><strong><u>proc 文件系统的使用就是去读取&#x2F;proc 目录下的这些文件，获取文件中记录的信息，可以直接使用 cat 命令读取，也可以在应用程序中调用 open()打开、然后再使用 read()函数读取。</u></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux调试工具gdb</title>
      <link href="/2022/12/12/2022-12-12-Linux%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/12/12/2022-12-12-Linux%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="linux中使用C-x2F-C-的调试工具gdb"><a href="#linux中使用C-x2F-C-的调试工具gdb" class="headerlink" title="linux中使用C&#x2F;C++的调试工具gdb"></a>linux中使用C&#x2F;C++的调试工具gdb</h3><p>gdb是GNU开源组织发布的一个强大的Linux下的程序调试工具。</p><p> 一般来说，GDB主要帮助你完成下面四个方面的功能：</p><p>1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</p><p>2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</p><p>3、当程序被停住时，可以检查此时你的程序中所发生的事。</p><p>4、你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。<br>首先要用gcc进行编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g 源文件 -o 目标文件</span><br></pre></td></tr></table></figure><p><strong><u>gdb的命令</u></strong></p><p>（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h</p><p>（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r</p><p>（gdb）start：单步执行，运行程序，停在第一执行语句</p><p>（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l</p><p>（gdb）set：设置变量的值</p><p>（gdb）next：单步调试（逐过程，函数直接执行）,简写n</p><p>（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s</p><p>（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt</p><p>（gdb）frame：切换函数的栈帧,简写f</p><p>（gdb）info：查看函数内部局部变量的数值,简写i</p><p>（gdb）finish：结束当前函数，返回到函数调用点</p><p>（gdb）continue：继续运行,简写c</p><p>（gdb）print：打印值及地址,简写p</p><p>（gdb）quit：退出gdb,简写q</p><p>（gdb）break+num：在第num行设置断点,简写b</p><p>（gdb）info breakpoints：查看当前设置的所有断点</p><p>（gdb）delete breakpoints num：删除第num个断点,简写d</p><p>（gdb）display：追踪查看具体变量值</p><p>（gdb）undisplay：取消追踪观察变量</p><p>（gdb）watch：被设置观察点的变量发生修改时，打印显示</p><p>（gdb）i watch：显示观察点</p><p>（gdb）enable breakpoints：启用断点</p><p>（gdb）disable breakpoints：禁用断点</p><p>（gdb）x：查看内存x&#x2F;20xw 显示20个单元，16进制，4字节每单元</p><p>（gdb）run argv[1] argv[2]：调试时命令行传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>; ilt;=<span class="number">100</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">           sum+=i;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">          result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result[1-100] = %d&quot;</span>, result );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result[1-250] = %d&quot;</span>, func(<span class="number">250</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">root&lt;span style=<span class="string">&quot;&quot;</span>&gt;@&lt;/span&gt;linux: /home/benben /test<span class="meta"># gdb tst &lt;---------- 启动GDB</span></span><br><span class="line">GNU gdb <span class="number">5.1</span><span class="number">.1</span></span><br><span class="line">Copyright <span class="number">2002</span> Free Software Foundation, Inc.</span><br><span class="line">GDB is <span class="built_in">free</span> software, covered by the GNU General Public License, and you are</span><br><span class="line">welcome to change it and/or distribute copies of it under certain conditions.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> to see the conditions.</span><br><span class="line">There is absolutely no warranty <span class="keyword">for</span> GDB. Type <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;i386-suse-linux&quot;</span>...</span><br><span class="line">(gdb) l &lt;-------------------- l命令相当于<span class="built_in">list</span>，从第一行开始例出原码。</span><br><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="type">int</span> func(<span class="type">int</span> n)</span><br><span class="line"><span class="number">4</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">0</span>; i</span><br><span class="line"><span class="number">7</span> &#123;</span><br><span class="line"><span class="number">8</span> sum+=i;</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span> sum;</span><br><span class="line">(gdb) &lt;-------------------- 直接回车表示，重复上一次命令</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> main()</span><br><span class="line"><span class="number">15</span> &#123;</span><br><span class="line"><span class="number">16</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">17</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line"><span class="number">19</span> &#123;</span><br><span class="line"><span class="number">20</span> result += i;</span><br><span class="line">(gdb) <span class="keyword">break</span> <span class="number">16</span> &lt;-------------------- 设置断点，在源程序第<span class="number">16</span>行处。</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x8048496</span>: file tst.c, line <span class="number">16.</span></span><br><span class="line">(gdb) <span class="keyword">break</span> func &lt;-------------------- 设置断点，在函数func()入口处。</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x8048456</span>: file tst.c, line <span class="number">5.</span></span><br><span class="line">(gdb) info <span class="keyword">break</span> &lt;-------------------- 查看断点信息。</span><br><span class="line">Num Type Disp Enb Address What</span><br><span class="line"><span class="number">1</span> breakpoint keep y <span class="number">0x08048496</span> in main at tst.c:<span class="number">16</span></span><br><span class="line"><span class="number">2</span> breakpoint keep y <span class="number">0x08048456</span> in func at tst.c:<span class="number">5</span></span><br><span class="line">(gdb) r &lt;--------------------- 运行程序，run命令简写</span><br><span class="line">Starting program: /home/benben /test/tst</span><br><span class="line"> </span><br><span class="line">Breakpoint <span class="number">1</span>, main () at tst.c:<span class="number">17</span> &lt;---------- 在断点处停住。</span><br><span class="line"><span class="number">17</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">(gdb) n &lt;--------------------- 单条语句执行，next命令简写。</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">20</span> result += i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">20</span> result += i;</span><br><span class="line">(gdb) c &lt;--------------------- 继续运行程序，<span class="keyword">continue</span>命令简写。</span><br><span class="line">Continuing.</span><br><span class="line">result[<span class="number">1</span><span class="number">-100</span>] = <span class="number">5050</span> &lt;----------程序输出。</span><br><span class="line"> </span><br><span class="line">Breakpoint <span class="number">2</span>, func (n=<span class="number">250</span>) at tst.c:<span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">(gdb) p i &lt;--------------------- 打印变量i的值，print命令简写。</span><br><span class="line">$<span class="number">1</span> = <span class="number">134513808</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">8</span> sum+=i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line">$<span class="number">2</span> = <span class="number">1</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">8</span> sum+=i;</span><br><span class="line">(gdb) p i</span><br><span class="line">$<span class="number">3</span> = <span class="number">2</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line">$<span class="number">4</span> = <span class="number">3</span></span><br><span class="line">(gdb) bt &lt;--------------------- 查看函数堆栈。</span><br><span class="line">#<span class="number">0</span> func (n=<span class="number">250</span>) at tst.c:<span class="number">5</span></span><br><span class="line"> </span><br><span class="line">#<span class="number">1</span> <span class="number">0x080484e4</span> in main () at tst.c:<span class="number">24</span></span><br><span class="line"> </span><br><span class="line">#<span class="number">2</span> <span class="number">0x400409ed</span> in __libc_start_main () from /lib/libc.so<span class="number">.6</span></span><br><span class="line">(gdb) finish &lt;--------------------- 退出函数。</span><br><span class="line">Run till <span class="built_in">exit</span> from #<span class="number">0</span> func (n=<span class="number">250</span>) at tst.c:<span class="number">5</span></span><br><span class="line"> </span><br><span class="line"><span class="number">0x080484e4</span> in main () at tst.c:<span class="number">24</span></span><br><span class="line"><span class="number">24</span> <span class="built_in">printf</span>(<span class="string">&quot;result[1-250] = %d&quot;</span>, func(<span class="number">250</span>) );</span><br><span class="line">Value returned is $<span class="number">6</span> = <span class="number">31375</span></span><br><span class="line">(gdb) c &lt;--------------------- 继续运行。</span><br><span class="line">Continuing.</span><br><span class="line">result[<span class="number">1</span><span class="number">-250</span>] = <span class="number">31375</span> &lt;----------程序输出。</span><br><span class="line"> </span><br><span class="line">Program exited with code <span class="number">027.</span> &lt;--------程序退出，调试结束。</span><br><span class="line">(gdb) q &lt;--------------------- 退出gdb。</span><br><span class="line">root@linux:/home/benben/test#</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/lvdongjie/p/8994092.html">【Linux】GDB用法详解(5小时快速教程)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习一个阶段的感受</title>
      <link href="/2022/12/04/2022-12-4-%E6%94%BE%E5%81%87/"/>
      <url>/2022/12/04/2022-12-4-%E6%94%BE%E5%81%87/</url>
      
        <content type="html"><![CDATA[<p>​因为疫情原因提前放假回家，大部分考试还不知道怎么考，现在要准备好材料，刷网课和弄选修论文，打算12月份学完C语言剩余两章，之后每天写个联系代码，linux方面继续应用层的编写学习，看看弄完后，可能要进入到C++，这样才能学习QT应用编程，东西还是不少的，先完成总的百分之40吧。</p><p>​待续。。。</p><p>​现在进入假期了，为了更好的使用linux的开发板，开始学习裸机开发，uboot和系统移植，驱动开发相关知识。</p><p>​看看之后学习C++，进入qt来更好的制作一个完整的项目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C issue1</title>
      <link href="/2022/11/25/2022-11-25-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/25/2022-11-25-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="scanf输入问题-输入缓冲区"><a href="#scanf输入问题-输入缓冲区" class="headerlink" title="scanf输入问题-输入缓冲区"></a>scanf输入问题-输入缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(b == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i++);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line"></span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">会得到</span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line">a<span class="comment">//输入a</span></span><br><span class="line"><span class="number">0</span>?a1?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因是因为scanf()函数会把回车、空格、Tab或一些不合理输入的字符当作此次输入的结束标志，它不会把这些字符输入到想要保存此次输入数据的变量中，而是把这些字符遗留在了输入缓冲区，那么，当下一次想要从标准输入中读取一个字符时，这个遗留的字符就正好充当了此次的输入字符。</p><p>程序在输入a后输入了回车来结束此次输入，那么回车就遗留在了输入缓冲区，当需要给c输入字符时，它自动的充当了输入的字符，因此，程序没有给我们输入c的字符的机会。</p><p>C语言为了解决这种问题，为我们提供了一种很方便的清空输入缓冲区的方式—-&gt;&gt;fflush()函数，fflush(stdin)它会把残留在输入缓冲区里的所有数据清空。头文件为stdio.h</p><p>或者使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//跳过该行剩下的内容。</span></span><br></pre></td></tr></table></figure><p><strong>C primer plus提供的输入程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> *st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * ret_val;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets( st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(st[i]!= <span class="string">&#x27;\n&#x27;</span> &amp;&amp;st[i]!= <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            i++;</span><br><span class="line">    <span class="keyword">if</span>(st[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            st[i] == <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span>(getchar()!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错题：位运算"><a href="#错题：位运算" class="headerlink" title="错题：位运算"></a>错题：位运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fun(<span class="number">2017</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">i = i&amp;(i<span class="number">-1</span>);<span class="comment">//i = i &amp; (i-1)，统计i二进制中有多少个1</span></span><br><span class="line">&#125;               <span class="comment">//i = i | (i+1)，统计i二进制中有多少个0</span></span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str[<span class="number">3</span>] =&#123;<span class="string">&quot;stra&quot;</span>, <span class="string">&quot;strb&quot;</span>, <span class="string">&quot;strc&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *p =str[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,p++);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char<a href="https://so.csdn.net/so/search?q=%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">指针数组</a>可以指向多个字符，直到遇到空为止。p本来指向第一个字符，但是因为是指针，所以要遇到空为止才算读完第一个‘字符’，后面p+1指向第二个字符，同样也是遇到空为止，同理p+2 所以输出为stra，tra，ra。注意循环里面是p++所以从p0开始打印啦。</p><h3 id="指针和自增自减的优先级"><a href="#指针和自增自减的优先级" class="headerlink" title="指针和自增自减的优先级"></a>指针和自增自减的优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">3668</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p++ );<span class="comment">//拿到arr[0]的值1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p++ ); <span class="comment">//上条语句结束后指针往后移动了一下，</span></span><br><span class="line"><span class="comment">//指到到arr[1]，然后又++，因为是后++，</span></span><br><span class="line"><span class="comment">//所以解得是arr[1]的值3668</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*p)++ );<span class="comment">//拿到上个++指向了arr[2],</span></span><br><span class="line"><span class="comment">//因为加了括号，所以先解值为5，然后++，</span></span><br><span class="line"><span class="comment">//把结果丢给了下语句。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*p)++ );<span class="comment">//括号优先级高，先解值，指针未移动，</span></span><br><span class="line"><span class="comment">//还指向着arr[2],拿到上个printf丢下来的值5+1=6，</span></span><br><span class="line"><span class="comment">//故解值为6，然6++,语句执行结束把6++结果丢给下一条语句。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h3><p>在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量&#x2F;函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。</p><h3 id="extern”C”-作用"><a href="#extern”C”-作用" class="headerlink" title="extern”C” 作用"></a>extern”C” 作用</h3><p>C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//把所有函数声明放在这。</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="if…-endif的作用"><a href="#if…-endif的作用" class="headerlink" title="#if…#endif的作用"></a>#if…#endif的作用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">code 执行代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">code 屏蔽代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>同样可以“屏蔽”一段代码，你想把说明文字写在里面也可以，这些和“&#x2F;* *&#x2F;”都一样，但不一样的是：第一它允许嵌套（层数上限由预处理器决定）、第二你随时可以把“#if 0”改成“#if 1”来取消对某段代码的“屏蔽。</p><h3 id="结构体大小"><a href="#结构体大小" class="headerlink" title="结构体大小"></a>结构体大小</h3><p>结构体计算遵循对齐原则：</p><p>1）结构体变量首地址能够背其最宽基本类型成员的大小所整除；</p><p>2）结构体<u>每个成员相对于结构体首地址的偏移量都是成员大小的整数倍</u>，如有比那一起会在成员之间加上填充字节；</p><p>3）结构体的<u>总大小为结构体最宽基本类型成员的大小的整数倍</u>，如有需要编译器会在最末一个成员之后加上填充字节。</p><p><strong>偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。</strong></p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> fname;<span class="comment">//第一个成员偏移量为0</span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//第二个成员偏移量等于0+第一个的大小1=1但是得是第二个成员大小的整数倍所以是4</span></span><br><span class="line">    <span class="type">double</span> time;<span class="comment">//第三个成员偏移量等于4+第二个的大小4=8但是得是第三个成员大小的整数倍所以是8</span></span><br><span class="line">    <span class="type">float</span> old;<span class="comment">//第四个成员偏移量等于8+第三个的大小8=16但是得是第四个成员大小的整数倍所以是16</span></span><br><span class="line">&#125;;<span class="comment">//16+4=20但是得是所有的整数倍所以是24；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">student</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>, <span class="keyword">sizeof</span>(student));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存对齐是什么</p><p><a href="https://xie.infoq.cn/article/e071632f617563002552a7232">一文轻松理解内存对齐_程序员_C语言与CPP编程</a></p><h3 id="为什么要用malloc何时用"><a href="#为什么要用malloc何时用" class="headerlink" title="为什么要用malloc何时用"></a>为什么要用malloc何时用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *malloc(unsigned int num_bytes);//分配num_bytes字节的内存块</span><br></pre></td></tr></table></figure><p>返回值是void指针，void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者其他数据类型），可以通过类型强制转化转化为其他任意类型指针。如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。</p><p>malloc（）是动态内存分配函数，用来向系统请求分配内存空间。当无法知道内存具体的位置时，想要绑定真正的内存空间，就要用到malloc（）函数。因为malloc只管分配内存空间，并不能对分配的空间进行初始化，所以申请到的内存中的值是随机的，经常会使用memset()进行置0操作后再使用。</p><p>与其配套的是free（），当申请到的空间不再使用时，要用free（）函数将内存空间释放掉，这样可以提高资源利用率，最重要的是—-就是因为它可以申请内存空间，然后根据需要进行释放，才被称为“动态内存分配”！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">　　p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">128</span>);</span><br><span class="line">　　　　<span class="comment">//分配128个整型存储单元，并将这128个连续的整型存储单元的首地址存储到指针变量p中</span></span><br><span class="line">　　<span class="type">double</span> *pd = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * <span class="number">12</span>);　　</span><br><span class="line">　　　　<span class="comment">//分配12个double型存储单元，并将首地址存储到指针变量pd中</span></span><br><span class="line">　　<span class="built_in">free</span>(p);</span><br><span class="line">　　<span class="built_in">free</span>(pd);</span><br><span class="line">　　p = <span class="literal">NULL</span>;</span><br><span class="line">　　pd = <span class="literal">NULL</span>;　　</span><br><span class="line">　　指针用完赋值<span class="literal">NULL</span>是一个很好的习惯。</span><br></pre></td></tr></table></figure><p>C语言中的联合</p><p>联合是在同一个内存空间中存储不同的数据类型（不能同时存在多个类型）。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> digit;</span><br><span class="line"><span class="type">double</span> bigf1;</span><br><span class="line"><span class="type">char</span> letter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上声明的结构只能存储整型或浮点型或者字符型的变量，不能同时存在。</p><p><u>初始化联合</u></p><p>有三种方法初始化联合：<br>1、把一个联合初始化为另一个同类型的联合</p><p>2、初始化联合的第一个成员</p><p>3、使用指定初始化器（C99标准）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">first_car</span>;</span></span><br><span class="line">first_car.car_name=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">sec_car</span>=</span>first_car; <span class="comment">//把一个联合初始化为另一个同类型的联合</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">car_a</span>=</span>&#123;<span class="string">&#x27;B&#x27;</span>&#125;;　　　　　<span class="comment">//初始化联合的第一个成员</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">car_b</span>=</span>&#123;.car_num=<span class="number">2</span>&#125;;　<span class="comment">//使用指定初始化器来初始化联合car_b</span></span><br></pre></td></tr></table></figure><p>用指针访问联合时候也是用-&gt;运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pu = &amp;fit;</span><br><span class="line">x = pu -&gt;digit;</span><br></pre></td></tr></table></figure><h3 id="传递结构体数组地址"><a href="#传递结构体数组地址" class="headerlink" title="传递结构体数组地址"></a>传递结构体数组地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTITL  40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXAUTL  40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBKS  100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> title [MAXTITL];</span><br><span class="line"><span class="type">char</span> author[MAXAUTL];</span><br><span class="line"><span class="type">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">srt</span><span class="params">( <span class="keyword">struct</span> book prt[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="keyword">struct</span> book pt[], <span class="type">int</span> m)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[<span class="title">MAXBKS</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">pst</span>;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">pst = &amp;library[<span class="number">0</span>];</span><br><span class="line">menu();</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; MAXBKS; i++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s_gets(library[i].title, MAXTITL) == <span class="literal">NULL</span> || library[i].title[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入作者\n&quot;</span>);</span><br><span class="line">s_gets(library[i].author, MAXAUTL);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入价格\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;library[i].value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入书名\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">srt(library, i);</span><br><span class="line"><span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; i; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;书名%s作者%s价格%.2f\n&quot;</span>, library[t].title, library[t].author, library[t].value);</span><br><span class="line">&#125;</span><br><span class="line">change(library, i);</span><br><span class="line"><span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; i; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;书名%s作者%s价格%.2f\n&quot;</span>, library[t].title, library[t].author, library[t].value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * ret_val;</span><br><span class="line"><span class="type">char</span> * find;</span><br><span class="line"></span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ret_val)</span><br><span class="line">&#123;</span><br><span class="line">find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(find)</span><br><span class="line">* find = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please enter the book title and author and value \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************************************************\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入书名\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">srt</span><span class="params">( <span class="keyword">struct</span> book prt[], <span class="type">int</span> n)</span><span class="comment">//价格排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">quantity</span>;</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)<span class="comment">//冒泡排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>-i; j++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(prt[j].value &gt; prt[j+<span class="number">1</span>].value)</span><br><span class="line">&#123;</span><br><span class="line">quantity = prt[j];</span><br><span class="line">prt[j] = prt[j+<span class="number">1</span>];</span><br><span class="line">prt[j+<span class="number">1</span>] = quantity;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="keyword">struct</span> book pt[], <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">letter</span>;</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; i++)                <span class="comment">//冒泡排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m<span class="number">-1</span>-i; j++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="type">int</span>)pt[j].title[<span class="number">0</span>]&gt;(<span class="type">int</span>)pt[j+<span class="number">1</span>].title[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">letter = pt[j];</span><br><span class="line">pt[j] = pt[j+<span class="number">1</span>];</span><br><span class="line">pt[j+<span class="number">1</span>] = letter;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——字符串处理</title>
      <link href="/2022/11/23/2022-11-23-Linux%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
      <url>/2022/11/23/2022-11-23-Linux%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h3><p>设备输出stdout、设备键盘输入stdin、设备错误显示stderr。</p><p>常用的字符串输入函数有putchar()、puts()、fputc()、fputs()只能输出字符串函数，不像printf可以格式化输出，所以一般用printf。</p><p><strong>puts</strong>函数原型可通过man 3 puts查看。</p><p>使用 puts()函数连换行符’ \n ‘都省了，函数内部会自动在其后添加一个换行符。</p><p><strong>putchar</strong>函数原型可通过man 3 putchar查看。</p><p>putchar()函数可以把参数 c 指定的字符（一个无符号字符）输出到标准输出设备，其输出可以是一个字符，可以是介于 0~127 之间的一个十进制整型数（包含 0 和 127，输出其对应的 ASCII 码字符），也可以是用 char 类型定义好的一个字符型变量。</p><p><strong>fputc</strong>函数原型可通过man 3 fputc查看</p><p>fputc()与 putchar()类似，也用于输出参数 c 指定的字符（一个无符号字符），与 putchar()区别在于，putchar()只能输出到标准输出设备，而 fputc()可把字符输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件。</p><p><strong>fputs</strong></p><p>fputs()与 puts()类似，也用于输出一条字符串，与 puts()区别在于，puts()只能输出到标准输出设备，而 fputs()可把字符串输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件。</p><h3 id="内存填充"><a href="#内存填充" class="headerlink" title="内存填充"></a>内存填充</h3><p>在编程中，经常需要将某一块内存中的数据全部设置为指定的值，譬如在定义数组、结构体这种类型变量时，通常需要对其进行初始化操作，而初始化操作一般都是将其占用的内存空间全部填充为 0。</p><p><strong>memset函数</strong>用于将某一块内存的数据全部设置为指定的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>s：需要进行数据填充的内存空间起始地址。<br>c：要被设置的值，该值以 int 类型传递。但在使用过程中是以无符号字符形式<br>n：填充的字节数。</p><p><strong>bzero函数</strong>用于将一块内存的数据都设置为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bzero</span><span class="params">(<span class="type">void</span> *s, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>s：内存空间的起始地址。<br>n：填充的字节数。<br>返回值：无返回值。</p><h3 id="Linux正则表达式"><a href="#Linux正则表达式" class="headerlink" title="Linux正则表达式"></a>Linux正则表达式</h3><p>正则表达式，又称为规则表达式（英语: Regular Expression），正则表达式通常被用来检索、替换那些符合某个模式（规则）的字符串，正则表达式描述了一种字符串的匹配模式（pattern），可以用来检查一个给定的字符串中是否含有某种子字符串、将匹配的字符串替换或者从某个字符串中取出符合某个条件的子字符串。</p><p>正则表达式其实也是一个字符串，该字符串由普通字符（譬如，数字 0~9、大小写字母以及其它字符）和特殊字符（称为“元字符”）所组成，由这些字符组成一个“规则字符串”，这个“规则字符串”用来表达对给定字符串的一种查找、匹配逻辑。</p><p><a href="https://www.runoob.com/regexp/regexp-intro.html">正则表达式 菜鸟教程</a></p><p>C语言中使用正则表达式一般分为三步：</p><p>1.编译正则表达式regcomp()</p><p>2匹配正则表达式regexec()</p><p>3释放正则表达式regfree()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">regmatch_t</span> pmatch = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">regex_t</span> reg;</span><br><span class="line"> <span class="type">char</span> errbuf[<span class="number">64</span>];</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">char</span> *sptr;</span><br><span class="line"> <span class="type">int</span> length;</span><br><span class="line"> <span class="type">int</span> nmatch; <span class="comment">//最多匹配出的结果</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">4</span> != argc) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="comment">/**********************************</span></span><br><span class="line"><span class="comment"> * 执行程序时需要传入两个参数:</span></span><br><span class="line"><span class="comment"> * arg1: 正则表达式</span></span><br><span class="line"><span class="comment"> * arg2: 待测试的字符串</span></span><br><span class="line"><span class="comment"> * arg3: 最多匹配出多少个结果</span></span><br><span class="line"><span class="comment"> **********************************/</span></span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;regex&gt; &lt;string&gt; &lt;nmatch&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(ret = regcomp(&amp;reg, argv[<span class="number">1</span>], REG_EXTENDED)) </span><br><span class="line">    &#123;</span><br><span class="line"> regerror(ret, &amp;reg, errbuf, <span class="keyword">sizeof</span>(errbuf));</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;regcomp error: %s\n&quot;</span>, errbuf);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 赋值操作 */</span></span><br><span class="line"> sptr = argv[<span class="number">2</span>]; <span class="comment">//待测试的字符串</span></span><br><span class="line"> length = <span class="built_in">strlen</span>(argv[<span class="number">2</span>]);<span class="comment">//获取字符串长度</span></span><br><span class="line"> nmatch = atoi(argv[<span class="number">3</span>]); <span class="comment">//获取最大匹配数</span></span><br><span class="line"> <span class="comment">/* 匹配正则表达式 */</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nmatch; j++) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="type">char</span> temp_str[<span class="number">100</span>];</span><br><span class="line"> <span class="comment">/* 调用 regexec 匹配正则表达式 */</span></span><br><span class="line"> <span class="keyword">if</span>(ret = regexec(&amp;reg, sptr, <span class="number">1</span>, &amp;pmatch, <span class="number">0</span>)) </span><br><span class="line">    &#123;</span><br><span class="line"> regerror(ret, &amp;reg, errbuf, <span class="keyword">sizeof</span>(errbuf));</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;regexec error: %s\n&quot;</span>, errbuf);</span><br><span class="line"> <span class="keyword">goto</span> out;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(<span class="number">-1</span> != pmatch.rm_so) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">if</span> (pmatch.rm_so == pmatch.rm_eo) </span><br><span class="line">        &#123;<span class="comment">//空字符串</span></span><br><span class="line"> sptr += <span class="number">1</span>;</span><br><span class="line"> length -= <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">//打印出空字符串</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt;= length)<span class="comment">//如果已经移动到字符串末尾、则退出</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">continue</span>; <span class="comment">//从 for 循环开始执行</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">memset</span>(temp_str, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(temp_str));<span class="comment">//清零缓冲区</span></span><br><span class="line"> <span class="built_in">memcpy</span>(temp_str, sptr + pmatch.rm_so,</span><br><span class="line"> pmatch.rm_eo - pmatch.rm_so);<span class="comment">//将匹配出来的子字符串拷贝到缓冲区</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, temp_str); <span class="comment">//打印字符串</span></span><br><span class="line">sptr += pmatch.rm_eo;</span><br><span class="line"> length -= pmatch.rm_eo;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt;= length)</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 释放正则表达式 */</span></span><br><span class="line">out:</span><br><span class="line"> regfree(&amp;reg);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习一个阶段的感受</title>
      <link href="/2022/11/18/2022-11-18-%E9%9A%8F%E7%AC%94/"/>
      <url>/2022/11/18/2022-11-18-%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>​目前在linux上学习了一个浅显的阶段，学会了命令行的一些常规的操作，也对Linux的内核有了少部分的了解，目前在C语言上的系统学习进入了尾声，之后应该就要时常复习C语言的编程，之前没有编写过底层，现在感觉C语言的应用编写确实复杂，主要是东西有点多，记不下来，打算趁着写选修论文的时候，用平时笔记复习复习，再加强一下C语言前些章节的编写能力，跨过这一阶段，再思考下一阶段科技树点哪的问题吧，科技树可真多呀，只能说还好现在课业不是很重。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文件属性</title>
      <link href="/2022/11/18/2022-11-18-Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/11/18/2022-11-18-Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>正所谓Linux下皆文件，系统下一共分为7种文件：</p><p><strong>①普通文件</strong></p><p>普通文件（regular file）在 Linux 系统下是最常见的，譬如文本文件、二进制文件，我们编写的源代码文件这些都是普通文件。</p><p>普通文件分为文本文件和二进制文件。</p><p>文本文件：文件中的内容是由文本构成的，所谓文本指的是 ASCII 码字符。文件中的内容其本质上都是数字。</p><p>二进制文件：二进制文件中存储的本质上也是数字，只不过对于二进制文件来说，这些数字并不是文本字符编码，而是真正的数字。譬如 Linux 系统下的可执行文件、C 代码编译之后得到的.o 文件、.bin 文件等都是二进制件。</p><p><strong>②目录文件</strong></p><p>目录（directory）就是文件夹，文件夹在 Linux 系统中也是一种文件，是一种特殊文件。</p><p><strong>③字符设备文件和块设备文件</strong></p><p>Linux 系统下，一切皆文件，也包括各种硬件设备。设备文件（字符设备文件、块设备文件）对应的是硬件设备，在 Linux 系统中，硬件设备会对应到一个设备文件，应用程序通过对设备文件的读写来操控、使用硬件设备。</p><p>Linux 系统中，可将硬件设备分为字符设备和块设备，所以就有了字符设备文件和块设备文件两种文件类型。虽然有设备文件，但是设备文件并不对应磁盘上的一个文件，也就是说设备文件并不存在于磁盘中，而是由文件系统虚拟出来的，一般是由内存来维护，当系统关机时，设备文件都会消失；字符设备文件一般存放在 Linux 系统&#x2F;dev&#x2F;目录下。</p><p><strong>④符号链接文件</strong></p><p>符号链接文件（link）类似于 Windows 系统中的快捷方式文件，是一种特殊文件，它的内容指向的是另一个文件路径，当对符号链接文件进行操作时，系统根据情况会对这个操作转移到它指向的文件上去，而不是对它本身进行操作。</p><p><strong>⑤管道文件</strong></p><p>管道文件（pipe）主要用于进程间通信。</p><p><strong>⑥套接字文件</strong></p><p>套接字文件（socket）也是一种进程间通信的方式，与管道文件不同的是，它们可以在不同主机上的进程间通信，实际上就是网络通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">stat</span> test_file<span class="comment">##可以查看文件属性</span></span></span><br></pre></td></tr></table></figure><p>这个命令内部就是通过调用 stat()函数来获取文件属性的，stat 函数是 Linux 中的系统调用，用于获取文件相关的信息，函数原型如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p>函数参数及返回值含义如下：<br>pathname：用于指定一个需要查看属性的文件路径。<br>buf：struct stat 类型指针，用于指向一个 struct stat 结构体变量。调用 stat 函数的时候需要传入一个 struct<br>stat 变量的指针，获取到的文件属性信息就记录在 struct stat 结构体中，稍后给大家介绍 struct stat 结构体中有记录了哪些信息。<br>返回值：成功返回 0；失败返回-1，并设置 error。</p><h4 id="struct-stat-结构体"><a href="#struct-stat-结构体" class="headerlink" title="struct stat 结构体"></a>struct stat 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">dev_t</span> st_dev; <span class="comment">/* 文件所在设备的 ID */</span></span><br><span class="line"> <span class="type">ino_t</span> st_ino; <span class="comment">/* 文件对应 inode 节点编号 */</span></span><br><span class="line"> <span class="type">mode_t</span> st_mode; <span class="comment">/* 文件对应的模式 */</span></span><br><span class="line"> <span class="type">nlink_t</span> st_nlink; <span class="comment">/* 文件的链接数 */</span></span><br><span class="line"> <span class="type">uid_t</span> st_uid; <span class="comment">/* 文件所有者的用户 ID */</span></span><br><span class="line"> <span class="type">gid_t</span> st_gid; <span class="comment">/* 文件所有者的组 ID */</span></span><br><span class="line"> <span class="type">dev_t</span> st_rdev; <span class="comment">/* 设备号（指针对设备文件） */</span></span><br><span class="line"> <span class="type">off_t</span> st_size; <span class="comment">/* 文件大小（以字节为单位） */</span></span><br><span class="line"> <span class="type">blksize_t</span> st_blksize; <span class="comment">/* 文件内容存储的块大小 */</span></span><br><span class="line"> <span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* 文件内容所占块数 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span> <span class="comment">/* 文件最后被访问的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span> <span class="comment">/* 文件内容最后被修改的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span> <span class="comment">/* 文件状态最后被改变的时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="st-mode变量"><a href="#st-mode变量" class="headerlink" title="st_mode变量"></a>st_mode变量</h4><p>st_mode 是 structstat 结构体中的一个成员变量，是一个 32 位无符号整形数据，该变量记录了文件的类型、文件的权限这些信息。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/st_mode.png"></p><p>这些 bit 位表达内容与 open 函数的 mode 参数相对应，这里不再重述。同样，在 mode 参数中表示权限的宏定义，在这里也是可以使用的，这些宏定义如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">S_IRWXU 00700 owner has read, write, and execute permission</span><br><span class="line">S_IRUSR 00400 owner has read permission</span><br><span class="line">S_IWUSR 00200 owner has write permission</span><br><span class="line">S_IXUSR 00100 owner has execute permission</span><br><span class="line">S_IRWXG 00070 group has read, write, and execute permission</span><br><span class="line">S_IRGRP 00040 group has read permission</span><br><span class="line">S_IWGRP 00020 group has write permission</span><br><span class="line">S_IXGRP 00010 group has execute permission</span><br><span class="line">S_IRWXO 00007 others (not in group) have read, write, and execute permission</span><br><span class="line">S_IROTH 00004 others have read permission</span><br><span class="line">S_IWOTH 00002 others have write permission</span><br><span class="line">S_IXOTH 00001 others have execute permission</span><br><span class="line"></span><br><span class="line">S_IFSOCK 0140000 socket（套接字文件）</span><br><span class="line">S_IFLNK 0120000 symbolic link（链接文件）</span><br><span class="line">S_IFREG 0100000 regular file（普通文件）</span><br><span class="line">S_IFBLK 0060000 block device（块设备文件）</span><br><span class="line">S_IFDIR 0040000 directory（目录）</span><br><span class="line">S_IFCHR 0020000 character device（字符设备文件）</span><br><span class="line">S_IFIFO 0010000 FIFO（管道文件）</span><br><span class="line"></span><br><span class="line">S_ISREG(m) #判断是不是普通文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISDIR(m) #判断是不是目录，如果是返回 true，否则返回 false</span><br><span class="line">S_ISCHR(m) #判断是不是字符设备文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISBLK(m) #判断是不是块设备文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISFIFO(m) #判断是不是管道文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISLNK(m) #判断是不是链接文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISSOCK(m) #判断是不是套接字文件，如果是返回 true，否则返回 false</span><br></pre></td></tr></table></figure><h4 id="struct-timespec结构体"><a href="#struct-timespec结构体" class="headerlink" title="struct timespec结构体"></a>struct timespec结构体</h4><p>该结构体定义在头文件中，是 Linux 系统中时间相关的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">time_t</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"> <span class="type">syscall_slong_t</span> tv_nsec; <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="fstat和lstat函数"><a href="#fstat和lstat函数" class="headerlink" title="fstat和lstat函数"></a>fstat和lstat函数</h4><p><strong>fstat函数</strong></p><p>fstat 与 stat 区别在于，stat 是从文件名出发得到文件属性信息，不需要先打开文件；而 fstat 函数则是从文件描述符出发得到文件属性信息，所以使用 fstat 函数之前需要先打开文件得到文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p><strong>lstat 函数</strong></p><p>lstat()与 stat、fstat 的区别在于，对于符号链接文件，stat、fstat 查阅的是符号链接文件所指向的文件对应的文件属性信息，而 lstat 查阅的是符号链接文件本身的属性信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><h3 id="文件属主"><a href="#文件属主" class="headerlink" title="文件属主"></a>文件属主</h3><p>Linux 是一个多用户操作系统，系统中一般存在着好几个不同的用户，而 Linux 系统中的每一个文件都有一个与之相关联的用户和用户组，通过这个信息可以判断文件的所有者和所属组。</p><p>文件所有者表示该文件属于“谁”，也就是属于哪个用户。一般来说文件在创建时，其所有者就是创建该文件的那个用户。文件所属组则表示该文件属于哪一个用户组。在 Linux 中，系统并不是通过用户名或用户组名来识别不同的用户和用户组，而是通过 ID。ID 就是一个编号，Linux 系统会为每一个用户或用户组分配一个 ID，将用户名或用户组名与对应的 ID 关联起来，所以系统通过用户 ID（UID）或组 ID（GID）就可以识别出不同的用户和用组。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/ID.png"></p><h4 id="有效用户-ID-和有效组-ID"><a href="#有效用户-ID-和有效组-ID" class="headerlink" title="有效用户 ID 和有效组 ID"></a>有效用户 ID 和有效组 ID</h4><p>这是进程所持有的概念，对于文件来说，并无此属性！有效用户 ID 和有效组 ID 是站在操作系统的角度，用于给操作系统判断当前执行该进程的用户在当前环境下对某个文件是否拥有相应的权限。</p><p>当进行权限检查时，并不是通过进程的实际用户和实际组来参与权限检查的，而是通过有效用户和有效组来参与文件权限检查。</p><p><strong>chown函数</strong></p><p>chown 是一个系统调用，该系统调用可用于改变文件的所有者（用户 ID）和所属组（组 ID）。其实在Linux 系统下也有一个 chown 命令，该命令的作用也是用于改变文件的所有者和所属组，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> root:root testApp.c<span class="comment">##该命令的作用也是用于改变文件的所有者和所属组</span></span></span><br></pre></td></tr></table></figure><h4 id="chown函数原型"><a href="#chown函数原型" class="headerlink" title="chown函数原型"></a>chown函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值如下所示：<br>pathname：用于指定一个需要修改所有者和所属组的文件路径。<br>owner：将文件的所有者修改为该参数指定的用户（以用户 ID 的形式描述）；<br>group：将文件的所属组修改为该参数指定的用户组（以用户组 ID 的形式描述）；<br>返回值：成功返回 0；失败将返回-1，兵并且会设置 errno。</p><p>有以下两个限制条件：</p><p>⚫ 只有超级用户进程能更改文件的用户 ID；<br>⚫ 普通用户进程可以将文件的组 ID 修改为其所从属的任意附属组 ID，前提条件是该进程的有效用户 ID 等于文件的用户 ID；而超级用户进程可以将文件的组 ID 修改为任意值。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == chown(<span class="string">&quot;./test_file&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;chown error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Linux 系统下，可以使用 getuid 和 getgid 两个系统调用分别用于获取当前进程的用户 ID 和用户组ID，这里说的进程的用户 ID 和用户组 ID 指的就是进程的实际用户 ID 和实际组 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;uid: %d\n&quot;</span>, getuid());</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == chown(<span class="string">&quot;./test_file&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;chown error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h3><p>struct stat 结构体中的 st_mode 字段记录了文件的访问权限位。当提及到文件时，并不仅仅指的是普通文件；所有文件类型（目录、设备文件）都有访问权限（access permission）。</p><p>文件的权限可以分为两个大类，分别是<u>普通权限和特殊权限</u>（也可称为附加权限）。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls-l##查看访问权限</span><br></pre></td></tr></table></figure><p><strong><u>-rwxrwxr-x</u></strong></p><p>-表示文件类型，前三位rwx为所有者权限，中间三位为同组用户权限，后三位为其它用户权限。</p><p>r表示具有读权限；w表示具有写权限；x表示具有执行权限；-表示没有权限</p><p><em><strong>当进程每次对文件进行读、写、执行等操作时，内核就会对文件进行访问权限检查，以确定该进程对文件是否拥有相应的权限。</strong></em>而对于进程来说，参与文件权限检查的是进程的有效用户、有效用户组以及进程的附属组用户。</p><p>如何判断权限，首先要搞清楚该进程对于需要进行操作的文件来说是属于哪一类“角色”：<br>⚫ 如果进程的有效用户 ID 等于文件所有者 ID（st_uid），意味着该进程以文件所有者的角色存在；<br>⚫ 如果进程的有效用户 ID 并不等于文件所有者 ID，意味着该进程并不是文件所有者身份；但是进程<br>的有效用户组 ID 或进程的附属组 ID 之一等于文件的组 ID（st_gid），那么意味着该进程以文件所<br>属组成员的角色存在，也就是文件所属组的同组用户成员。<br>⚫ 如果进程的有效用户 ID 不等于文件所有者 ID、并且进程的有效用户组 ID 或进程的所有附属组 ID<br>均不等于文件的组 ID（st_gid），那么意味着该进程以其它用户的角色存在。<br>⚫ 如果进程的有效用户 ID 等于 0（root 用户），则无需进行权限检查，直接对该文件拥有最高权限。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90.png"></p><p>宏定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S_ISUID 04000 set-user-ID bit</span><br><span class="line">S_ISGID 02000 set-group-ID bit (see below)</span><br><span class="line">S_ISVTX 01000 sticky bit (see below)</span><br></pre></td></tr></table></figure><p>譬如通过 st_mode 变量判断文件是否设置了 set-user-ID 位权限，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st.st_mode &amp; S_ISUID) &#123;</span><br><span class="line"><span class="comment">//设置了 set-user-ID 位权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//没有设置 set-user-ID 位权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种权限位的具体作用：</p><p>⚫ 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-user-ID 位权限被设置，内核会将进程的有效 ID 设置为该文件的用户 ID（文件所有者 ID），意味着该进程直接获取了文件所有的权限、以文件所有者的身份操作该文件。<br>⚫ 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-group-ID 位权限被设置，内核会将进程的有效用户组 ID 设置为该文件的用户组 ID（文件所属组 ID），意味着该进程直接获取了文件所属组成员的权限、以文件所属组成员的身份操作该文件。</p><h4 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h4><p>⚫ 目录的读权限：可列出（譬如：通过 ls 命令）目录之下的内容（即目录下有哪些文件）。<br>⚫ 目录的写权限：可以在目录下创建文件、删除文件。<br>⚫ 目录的执行权限：可访问目录下的文件，譬如对目录下的文件进行读、写、执行等操作。</p><p>要想访问目录下的文件，譬如查看文件的 inode 节点、大小、权限等信息，还需要对目录拥有执行权限。反之，若拥有对目录的执行权限、而无读权限，只要知道目录内文件的名称，仍可对其进行访问，但不能列出目录下的内容（即目录下包含的其它文件的名称）。要想在目录下创建文件或删除原有文件，需要同时拥有对该目录的执行和写权限。</p><h4 id="检查文件权限"><a href="#检查文件权限" class="headerlink" title="检查文件权限"></a>检查文件权限</h4><p>文件的权限检查不只关于文件本身的权限，还需要涉及到文件所在目录的权限，只有同时都满足了，才能通过操作系统的权限检查，进而才可以对文件进行相关操作。可以通过access来检查执行进程的用户是否对该文件拥有应的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要进行权限检查的文件路径。<br>mode：该参数可以取以下值：<br>pathname：需要进行权限检查的文件路径。<br>mode：该参数可以取以下值：<br>⚫ F_OK：检查文件是否存在<br>⚫ R_OK：检查是否拥有读权限<br>⚫ W_OK：检查是否拥有写权限<br>⚫ X_OK：检查是否拥有执行权限</p><p>返回值：检查项通过则返回 0，表示拥有相应的权限并且文件存在；否则返回-1，如果多个检查项组合在一起，只要其中任何一项不通过都会返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_FILE <span class="string">&quot;./test_file&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 检查文件是否存在 */</span></span><br><span class="line"> ret = access(MY_FILE, F_OK);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%: file does not exist.\n&quot;</span>, MY_FILE);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 检查权限 */</span></span><br><span class="line"> ret = access(MY_FILE, R_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Read permission: Yes\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Read permission: NO\n&quot;</span>);</span><br><span class="line"> ret = access(MY_FILE, W_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Write permission: Yes\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Write permission: NO\n&quot;</span>);</span><br><span class="line"> ret = access(MY_FILE, X_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Execution permission: Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Execution permission: NO\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>在 Linux 系统下，可以使用 chmod 命令修改文件权限，该命令内部实现方法其实是调用了 chmod 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要进行权限修改的文件路径，若该参数所指为符号链接，实际改变权限的文件是符号链接所指向的文件，而不是符号链接文件本身。<br>mode：该参数用于描述文件权限，与 open 函数的第三个参数一样，这里不再重述，可以直接使用八进制数据来描述，也可以使用相应的权限宏（单个或通过位或运算符” | “组合）。<br>返回值：成功返回 0；失败返回-1，并设置 errno。</p><p>fchmod()与 chmod()的区别在于使用了文件描述符来代替文件路径，就像是 fstat 与 stat 的区别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><h4 id="umask函数"><a href="#umask函数" class="headerlink" title="umask函数"></a>umask函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umask##查看/设置权限掩码</span><br></pre></td></tr></table></figure><p>权限掩码主要用于对新建文件的权限进行屏蔽。权限掩码的表示方式与文件权限的表示方式相同，但是需要去除特殊权限位，umask 不能对特殊权限位进行屏蔽。</p><p>umask 权限掩码是进程的一种属性，用于指明该进程新建文件或目录时，应屏蔽哪些权限位。进程的umask 通常继承至其父进程，譬如在 Ubuntu shell终端下执行的应用程序，它的 umask 继承至该 shell 进程。</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>mask：需要设置的权限掩码值，可以发现 make 参数的类型与 open 函数、chmod 函数中的 mode 参数对应的类型一样，所以其表示方式也是一样的，前面也给大家介绍了，既可以使用数字表示（譬如八进制数），也可以直接使用宏（S_IRUSR、S_IWUSR 等）。<br>返回值：返回设置之前的 umask 值，也就是旧的 umask。</p><h3 id="文件的时间属性"><a href="#文件的时间属性" class="headerlink" title="文件的时间属性"></a>文件的时间属性</h3><p>文件最后被访问的时间、文件内容最后被修改的时间以及文件状态最后被改变的时间，分别记录在 struct stat 结构体的 st_atim、st_mtim 以及 st_ctim 变量中。</p><table><thead><tr><th align="center">字段</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">st_atim</td><td align="center">文件最后被访问的时间</td></tr><tr><td align="center">st_mtim</td><td align="center">文件内容最后被修改的时间</td></tr><tr><td align="center">st_ctim</td><td align="center">文件状态最后被改变的时间</td></tr></tbody></table><p>⚫ 文件最后被访问的时间：访问指的是读取文件内容，文件内容最后一次被读取的时间，譬如使用read()函数读取文件内容便会改变该时间属性；<br>⚫ 文件内容最后被修改的时间：文件内容发生改变，譬如使用 write()函数写入数据到文件中便会改变该时间属性；<br>⚫ 文件状态最后被改变的时间：状态更改指的是该文件的 inode 节点最后一次被修改的时间，譬如更改文件的访问权限、更改文件的用户 ID、用户组 ID、更改链接数等，但它们并没有更改文件的实际内容，也没有访问（读取）文件内容。inode 中包含了很多文件信息，譬如：文件字节大小、文件所有者、文件对应的读&#x2F;写&#x2F;执行权限、文件时间戳（时间属性）、文件数据存储的 block（块）等，所以由此可知，状态的更改指的就是 inode 节点内容的更改。譬如 chmod()、chown()等<br>这些函数都能改变该时间属性。</p><p>列出了一些系统调用或 C 库函数对文件时间属性的影响，有些操作并不仅仅只会影响文件本身的时间属性，还会影响到其父目录的相关时间属性。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/time.png"></p><h4 id="utime-、utimes-修改时间属性"><a href="#utime-、utimes-修改时间属性" class="headerlink" title="utime()、utimes()修改时间属性"></a>utime()、utimes()修改时间属性</h4><p>utime()函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span>;</span><br></pre></td></tr></table></figure><p>filename：需要修改时间属性的文件路径。<br>times：将时间属性修改为该参数所指定的时间值，times 是一个 struct utimbuf 结构体类型的指针，如果times 参数设置为 NULL，则会将文件的访问时间和修改时间设置为系统当前时间。<br>返回值：成功返回值 0；失败将返回-1，并会设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">time_t</span> actime; <span class="comment">/* 访问时间 */</span></span><br><span class="line"><span class="type">time_t</span> modtime; <span class="comment">/* 内容修改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体中包含了两个 time_t 类型的成员，分别用于表示访问时间和内容修改时间，time_t 类型其实就是 long int 类型。</p><p>同样对于文件来说，时间属性也是文件非常重要的属性之一，对文件时间属性的修改也不是任何用户都可以随便修改的，只有以下两种进程可对其进行修改：<br>⚫ 超级用户进程（以 root 身份运行的进程）。<br>⚫ 有效用户 ID 与该文件用户 ID（文件所有者）相匹配的进程。<br>⚫ 在参数 times 等于 NULL 的情况下，对文件拥有写权限的进程。<br>除以上三种情况之外的用户进程将无法对文件时间戳进行修改。</p><p>utimes函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> timeval times[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>filename：需要修改时间属性的文件路径。<br>times：将时间属性修改为该参数所指定的时间值，times 是一个 struct timeval 结构体类型的数组，数组共有两个元素，第一个元素用于指定访问时间，第二个元素用于指定内容修改时间，稍后给大家介绍，如果times 参数为 NULL，则会将文件的访问时间和修改时间设置为当前时间。<br>返回值：成功返回 0；失败返回-1，并且会设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">long</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"><span class="type">long</span> tv_usec; <span class="comment">/* 微秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="futimens-、utimensat-修改时间属性"><a href="#futimens-、utimensat-修改时间属性" class="headerlink" title="futimens()、utimensat()修改时间属性"></a>futimens()、utimensat()修改时间属性</h4><p>futimens()、utimensat()函数是两个系统调用由于显示修改文件时间。</p><p>这两个系统调用相对于 utime 和 utimes 函数有以下三个优点：<br>⚫ 可按纳秒级精度设置时间戳。相对于提供微秒级精度的 utimes()，这是重大改进！<br>⚫ 可单独设置某一时间戳。譬如，只设置访问时间、而修改时间保持不变，如果要使用 utime()或 utimes()来实现此功能，则需要首先使用 stat()获取另一个时间戳的值，然后再将获取值与打算变更的时间戳一同指定。<br>⚫ 可独立将任一时间戳设置为当前时间。使用 utime()或 utimes()函数虽然也可以通过将 times 参数设置为NULL 来达到将时间戳设置为当前时间的效果，但是不能单独指定某一个时间戳，必须全部设置为当前时间（不考虑使用额外函数获取当前时间的方式，譬如 time()）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">futimens</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>fd：文件描述符。<br>times：将时间属性修改为该参数所指定的时间值，times 指向拥有 2 个 struct timespec 结构体类型变量的数组，数组共有两个元素，第一个元素用于指定访问时间，第二个元素用于指定内容修改时间。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>该函数的时间戳可以按下列 4 种方式之一进行指定：<br>⚫ 如果 times 参数是一个空指针，也就是 NULL，则表示将访问时间和修改时间都设置为当前时间。<br>⚫ 如果 times 参数指向两个 struct timespec 结构体类型变量的数组，任一数组元素的 tv_nsec 字段的值设置为 UTIME_NOW，则表示相应的时间戳设置为当前时间，此时忽略相应的 tv_sec 字段。<br>⚫ 如果 times 参数指向两个 struct timespec 结构体类型变量的数组，任一数组元素的 tv_nsec 字段的值设置为 UTIME_OMIT，则表示相应的时间戳保持不变，此时忽略 tv_sec 字段。<br>⚫ 如果 times 参数指向两个 struct timespec 结构体类型变量的数组，且 tv_nsec 字段的值既不是UTIME_NOW 也不是 UTIME_OMIT，在这种情况下，相应的时间戳设置为相应的 tv_sec 和 tv_nsec字段指定的值。</p><p>使用 <u>futimens()函数只有以下进程，可对文件时间戳进行修改：</u><br>⚫ 超级用户进程。<br>⚫ 在参数 times 等于 NULL 的情况下，对文件拥有写权限的进程。<br>⚫ 有效用户 ID 与该文件用户 ID（文件所有者）相匹配的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_FILE <span class="string">&quot;./test_file&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tmsp_arr</span>[2];</span></span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="comment">/* 检查文件是否存在 */</span></span><br><span class="line"> ret = access(MY_FILE, F_OK);</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Error: %s file does not exist!\n&quot;</span>, MY_FILE);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(MY_FILE, O_RDONLY);</span><br><span class="line"> <span class="keyword">if</span> (fd == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 修改文件时间戳 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"> ret = futimens(fd, <span class="literal">NULL</span>); <span class="comment">//同时设置为当前时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"> tmsp_arr[<span class="number">0</span>].tv_nsec = UTIME_OMIT;<span class="comment">//访问时间保持不变</span></span><br><span class="line"> tmsp_arr[<span class="number">1</span>].tv_nsec = UTIME_NOW;<span class="comment">//内容修改时间设置为当期时间</span></span><br><span class="line"> ret = futimens(fd, tmsp_arr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"> tmsp_arr[<span class="number">0</span>].tv_nsec = UTIME_NOW;<span class="comment">//访问时间设置为当前时间</span></span><br><span class="line"> tmsp_arr[<span class="number">1</span>].tv_nsec = UTIME_OMIT;<span class="comment">//内容修改时间保持不变</span></span><br><span class="line"> ret = futimens(fd, tmsp_arr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;futimens error&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line">err:</span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utimensat()函数功能也是一样的，具体可以使用man 2  utimensat查询用法</p><h3 id="符号链接与硬链接"><a href="#符号链接与硬链接" class="headerlink" title="符号链接与硬链接"></a>符号链接与硬链接</h3><p>在 Linux 系统中有两种链接文件，分为软链接（也叫符号链接）文件和硬链接文件，软链接文件也就是前面给大家的 Linux 系统下的七种文件类型之一，其作用类似于 Windows 下的快捷方式。硬链接两个文件相互影响。</p><p>复习一下shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ln</span> 源文件 链接文件<span class="comment">##硬链接</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ln-s 源文件 链接文件<span class="comment">##软链接</span></span></span><br></pre></td></tr></table></figure><p>使用 ln 命令创建的两个硬链接文件与源文件 test_file 都拥有相同的 inode 号，既然inode 相同，也就意味着它们指向了物理硬盘的同一个区块，仅仅只是文件名字不同而已，创建出来的硬链接文件与源文件对文件系统来说是完全平等的关系。</p><p>当为文件每创建一个硬链接，inode 节点上的链接数就会加一，每删除一个硬链接，inode 节点上的链接数就会减一，直到为 0，inode 节点和对应的数据块才会被文件系统所回收，也就意味着文件已经从文件系统中被删除了。</p><p>软链接文件与源文件有着不同的 inode 号，所以也就是意味着它们之间有着不同的数据块，但是软链接文件的数据块中存储的是源文件的路径名，链接文件可以通过这个路径找到被链接的源文件，它们之间类似于一种“主从”关系，当源文件被删除之后，软链接文件依然存在，但此时它指向的是一个无效的文件路径，这种链接文件被称为悬空链接。</p><p>⚫ 不能对目录创建硬链接（超级用户可以创建，但必须在底层文件系统支持的情况下）。<br>⚫ 硬链接通常要求链接文件和源文件位于同一文件系统中。<br>而软链接文件的使用并没有上述限制条件，优点如下所示：<br>⚫ 可以对目录创建软链接；<br>⚫ 可以跨越不同文件系统；<br>⚫ 可以对不存在的文件创建软链接。</p><h4 id="创建硬链接link"><a href="#创建硬链接link" class="headerlink" title="创建硬链接link"></a>创建硬链接link</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure><p>oldpath：用于指定被链接的源文件路径，应避免 oldpath 参数指定为软链接文件，为软链接文件创建硬链接没有意义，虽然并不会报错。<br>newpath：用于指定硬链接文件路径，如果 newpath 指定的文件路径已存在，则会产生错误。<br>返回值：成功返回 0；失败将返回-1，并且会设置 errno。</p><h4 id="创建软链接symlink"><a href="#创建软链接symlink" class="headerlink" title="创建软链接symlink"></a>创建软链接symlink</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>target：用于指定被链接的源文件路径，target 参数指定的也可以是一个软链接文件。<br>linkpath：用于指定硬链接文件路径，如果 newpath 指定的文件路径已存在，则会产生错误。<br>返回值：成功返回 0；失败将返回-1，并会设置 errno。<br>创建软链接时，并不要求 target 参数指定的文件路径已经存在，如果文件不存在，那么创建的软链接将成为“悬空链接”。</p><h4 id="读取软链接文件"><a href="#读取软链接文件" class="headerlink" title="读取软链接文件"></a>读取软链接文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *buf, <span class="type">size_t</span> bufsiz)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要读取的软链接文件路径。只能是软链接文件路径，不能是其它类型文件，否则调用函<br>数将报错。<br>buf：用于存放路径信息的缓冲区。<br>bufsiz：读取大小，一般读取的大小需要大于链接文件数据块中存储的文件路径信息字节大小。<br>返回值：失败将返回-1，并会设置 errno；成功将返回读取到的字节数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *buf, <span class="type">size_t</span> bufsiz)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要读取的软链接文件路径。只能是软链接文件路径，不能是其它类型文件，否则调用函数将报错。<br>buf：用于存放路径信息的缓冲区。<br>bufsiz：读取大小，一般读取的大小需要大于链接文件数据块中存储的文件路径信息字节大小。<br>返回值：失败将返回-1，并会设置 errno；成功将返回读取到的字节数。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="目录存储形式"><a href="#目录存储形式" class="headerlink" title="目录存储形式"></a>目录存储形式</h4><p>目录这种特殊文件在文件系统中的存储形式，其实目录在文件系统中的存储方式与常规文件类似，常规文件包括了 inode 节点以及文件内容数据存储块（block），但对于目录来说，其存储形式则是由 inode 节点和目录块所构成，目录块当中记录了有哪些文件组织在这个目录下，记录它们的文件名以及对应的 inode 编号。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/guazai.jpg"></p><p>目录块当中有多个目录项（或叫目录条目），每一个目录项（或目录条目）都会对应到该目录下的某一个文件，目录项当中记录了该文件的文件名以及它的 inode 节点编号，所以通过目录的目录块便可以遍历找到该目录下的所有文件以及所对应的 inode 节点。<br>所以对此总结如下：<br>⚫ 普通文件由 inode 节点和数据块构成<br>⚫ 目录由 inode 节点和目录块构成</p><h4 id="创建删除目录"><a href="#创建删除目录" class="headerlink" title="创建删除目录"></a>创建删除目录</h4><p><strong>mkdir函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要创建的目录路径。<br>mode：新建目录的权限设置，设置方式与 open 函数的 mode 参数一样，最终权限为（mode &amp; ~umask）。<br>返回值：成功返回 0；失败将返回-1，并会设置 errno。<br>pathname 参数指定的新建目录的路径，该路径名可以是相对路径，也可以是绝对路径，若指定的路径名已经存在，则调用 mkdir()将会失败。<br>mode 参数指定了新目录的权限，目录拥有与普通文件相同的权限位，但是其表示的含义与普通文件却有不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> ret = mkdir(<span class="string">&quot;./new_dir&quot;</span>, S_IRWXU |</span><br><span class="line"> S_IRGRP | S_IXGRP |</span><br><span class="line">S_IROTH | S_IXOTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;mkdir error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除目录rmdir</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要删除的目录对应的路径名，并且该目录必须是一个空目录，也就是该目录下只有.和..这两个目录项；pathname 指定的路径名不能是软链接文件，即使该链接文件指向了一个空目录。<br>返回值：成功返回 0；失败将返回-1，并会设置 errno。</p><p><strong>打开、读取以及关闭目录</strong></p><p><strong>opendir()函数</strong>用于打开一个目录，并返回指向该目录的句柄，供后续操作使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>name：指定需要打开的目录路径名，可以是绝对路径，也可以是相对路径。<br>返回值：成功将返回指向该目录的句柄，一个 DIR 指针（其实质是一个结构体指针），其作用类似于<br>open函数返回的文件描述符fd，后续对该目录的操作需要使用该DIR指针变量；若调用失败，则返回NULL。</p><p>**readdir()**用于读取目录，获取目录下所有文件的名称以及对应 inode 号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><p>dirp：目录句柄 DIR 指针。<br>返回值：返回一个指向 struct dirent 结构体的指针，该结构体表示 dirp 指向的目录流中的下一个目录条目。在到达目录流的末尾或发生错误时，它返回 NULL。</p><p><u>“流”这个概念是动态的，而不是静态的。编程当中提到这个概念，一般都是与 I&#x2F;O 相关，所以也经常叫做 I&#x2F;O 流；但对于目录这种特殊文件来说，这里将目录块中存储的数据称为目录流，存储了一个一个的目录项（目录条目）。</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">ino_t</span> d_ino; <span class="comment">/* inode 编号 */</span></span><br><span class="line"> <span class="type">off_t</span> d_off; <span class="comment">/* not an offset; see NOTES */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this record */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* type of file; not supported by all filesystem types */</span></span><br><span class="line"> <span class="type">char</span> d_name[<span class="number">256</span>]; <span class="comment">/* 文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每调用一次 readdir()，就会从 drip 所指向的目录流中读取下一条目录项（目录条目），并返回 struct dirent结构体指针，指向经静态分配而得的 struct dirent 类型结构，每次调用 readdir()都会覆盖该结构。一旦遇到目录结尾或是出错，readdir()将返回 NULL，针对后一种情况，还会设置 errno 以示具体错误。</p><p>那如何区别究竟是到了目录末尾还是出错了呢，可通过如下代码进行判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error = <span class="number">0</span>;</span><br><span class="line">direntp = readdir(dirp);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == direntp) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != error) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 出现了错误 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 已经到了目录末尾 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rewinddir()</strong><u>可将目录流重置为目录起点。</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewinddir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><p>dirp：目录句柄。<br>返回值：无返回值。</p><p>关闭目录close()函数用于关闭处于打开状态的目录，同时释放他所用的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><p>dirp：目录句柄。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p><strong>进程的当前工作目录</strong></p><p>Linux 下的每一个进程都有自己的当前工作目录（current working directory），当前工作目录是该进程解析、搜索相对路径名的起点。</p><p>一般情况下，运行一个进程时、其父进程的当前工作目录将被该进程所继承，成为该进程的当前工作目录。可通过 getcwd 函数来获取进程的当前工作目录，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>buf：getcwd()将内含当前工作目录绝对路径的字符串存放在 buf 缓冲区中。<br>size：缓冲区的大小，分配的缓冲区大小必须要大于字符串长度，否则调用将会失败。<br>返回值：如果调用成功将返回指向 buf 的指针，失败将返回 NULL，并设置 errno。</p><p><strong>改变当前工作目录</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchdir</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>path：将进程的当前工作目录更改为 path 参数指定的目录，可以是绝对路径、也可以是相对路径，指定的目录必须要存在，否则会报错。<br>fd：将进程的当前工作目录更改为 fd 文件描述符所指定的目录（譬如使用 open 函数打开一个目录）。<br>返回值：成功均返回 0；失败均返回-1，并设置 errno。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><strong>使用unlink函数删除一个文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要删除的文件路径，可使用相对路径、也可使用绝对路径，如果 pathname 参数指定的文件不存在，则调用 unlink()失败。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>unlink()系统调用实质上是移除 pathname 参数指定的文件路径对应的目录项（从其父级目录中移除该目录项），并将文件的 inode 链接计数将 1，如果该文件还有其它硬链接，则任可通过其它链接访问该文件的数据；只有当链接计数变为 0 时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内容—只要有进程打开了该文件，其内容也不能被删除。关闭一个文件时，内核会检查打开该文件的进程个数，如果这个计数达到 0，内核再去检查其链接计数，如果链接计数也是 0，那么就删除该文件对应的内容（也就是文件对应的 inode 以及数据块被回收，如果一个文件存在多个硬链接，删除其中任何一个硬链接，其inode 和数据块并没有被回收，还可通过其它硬链接访问文件的数据）。</p><p><strong>使用 remove 函数删除文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要删除的文件或目录路径，可以是相对路径、也可是决定路径。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。<br>pathname 参数指定的是一个非目录文件，那么 remove()去调用 unlink()，如果 pathname 参数指定的是一个目录，那么 remove()去调用 rmdir()。</p><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>本小节给大家介绍 rename()系统调用，借助于 rename()既可以对文件进行重命名，又可以将文件移至同一文件系统中的另一个目录下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure><p>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>根据 oldpath、newpath 的不同，有以下不同的情况需要进行说明：<br>⚫ 若 newpath 参数指定的文件或目录已经存在，则将其覆盖；<br>⚫ 若 newpath 和 oldpath 指向同一个文件，则不发生变化（且调用成功）。<br>⚫ rename()系统调用对其两个参数中的软链接均不进行解引用。如果 oldpath 是一个软链接，那么将重命名该软链接；如果 newpath 是一个软链接，则会将其移除、被覆盖。<br>⚫ 如果 oldpath 指代文件，而非目录，那么就不能将 newpath 指定为一个目录的路径名。要想重命名<br>一个文件到某一个目录下，newpath 必须包含新的文件名。<br>⚫ 如果 oldpath 指代为一个目录，在这种情况下，newpath 要么不存在，要么必须指定为一个空目录。<br>⚫ oldpath 和 newpath 所指代的文件必须位于同一文件系统。由前面的介绍，可以得出此结论！<br>⚫ 不能对.（当前目录）和..（上一级目录）进行重命名。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux标准IO库</title>
      <link href="/2022/11/12/2022-11-12-Linux%E6%A0%87%E5%87%86IO%E5%BA%93/"/>
      <url>/2022/11/12/2022-11-12-Linux%E6%A0%87%E5%87%86IO%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="标准IO库"><a href="#标准IO库" class="headerlink" title="标准IO库"></a>标准IO库</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓标准 I&#x2F;O 库则是标准 C 库中用于文件 I&#x2F;O 操作（譬如读文件、写文件等）相关的一系列库函数的集合，通常标准 I&#x2F;O 库函数相关的函数定义都在头文件中。</p><p><u>设计库函数是为了提供比底层系统调用更为方便、好用的调用接口，虽然标准 I&#x2F;O 构建于文件 I&#x2F;O 之上，但标准 I&#x2F;O 却有它自己的优势。</u></p><p>标准 I&#x2F;O 和文件 I&#x2F;O 的区别如下：</p><p>⚫ 虽然标准 I&#x2F;O 和文件 I&#x2F;O 都是 C 语言函数，但是标准 I&#x2F;O 是标准 C 库函数，而文件 I&#x2F;O 则是 Linux<br>系统调用；<br>⚫ 标准 I&#x2F;O 是由文件 I&#x2F;O 封装而来，标准 I&#x2F;O 内部实际上是调用文件 I&#x2F;O 来完成实际操作的；<br>⚫ 可移植性：标准 I&#x2F;O 相比于文件 I&#x2F;O 具有更好的可移植性。</p><p>⚫ 性能、效率：标准 I&#x2F;O 库在用户空间维护了自己的 stdio 缓冲区，所以标准 I&#x2F;O 是带有缓存的，而<br>文件 I&#x2F;O 在用户空间是不带有缓存的，所以在<em>性能、效率上，标准 I&#x2F;O 要优于文件 I&#x2F;O</em>。</p><h3 id="FILE-指针"><a href="#FILE-指针" class="headerlink" title="FILE 指针"></a>FILE 指针</h3><p>而对于标准 I&#x2F;O 库函数来说，它们的操作是围绕 FILE 指针进行的，当使用标准 I&#x2F;O 库函数打开或创建一个<br>文件时，会返回一个指向 FILE 类型对象的指针（FILE *），使用该 FILE 指针与被打开或创建的文件相关<br>联，然后该 FILE 指针就用于后续的标准 I&#x2F;O 操作（使用标准 I&#x2F;O 库函数进行 I&#x2F;O 操作），所以由此可知，<br>FILE 指针的作用相当于文件描述符，只不过 FILE 指针用于标准 I&#x2F;O 库函数中、而文件描述符则用于文件<br>I&#x2F;O 系统调用中。</p><p>FILE 是一个结构体数据类型，它包含了标准 I&#x2F;O 库函数为管理文件所需要的所有信息，包括用于实际<br>I&#x2F;O 的文件描述符、指向文件缓冲区的指针、缓冲区的长度、当前缓冲区中的字节数以及出错标志等。FILE<br>数据结构定义在标准 I&#x2F;O 库函数头文件 stdio.h 中。</p><h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p>所谓标准输入设备指的就是计算机系统的标准的输入设备，通常指的是计算机所连接的键盘；而标准输出设备指的是计算机系统中用于输出标准信息的设备，通常指的是计算机所连接的显示器；标准错误设备则指的是计算机系统中用于显示错误信息的设备，通常也指的是显示器设备。</p><p>用户通过标准输入设备与系统进行交互，进程将从标准输入（stdin）文件中得到输入数据，将正常输出<br>数据（譬如程序中 printf 打印输出的字符串）输出到标准输出（stdout）文件，而将错误信息（譬如函数调用报错打印的信息）输出到标准错误（stderr）文件。</p><h3 id="打开文件fopen"><a href="#打开文件fopen" class="headerlink" title="打开文件fopen()"></a>打开文件fopen()</h3><p>在标准 I&#x2F;O 中，我们将使用库函数fopen()打开或创建文件.函数原型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>path：参数 path 指向文件路径，可以是绝对路径、也可以是相对路径。<br>mode：参数 mode 指定了对该文件的读写权限，是一个字符串。<br>返回值：调用成功返回一个指向 FILE 类型对象的指针（FILE *），该指针与打开或创建的文件相关联，<br>后续的标准 I&#x2F;O 操作将围绕 FILE 指针进行。如果失败则返回 NULL，并设置 errno 以指示错误原因。</p><table><thead><tr><th>mode</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件</td></tr><tr><td>r+</td><td>以可读、可写方式打开文件</td></tr><tr><td>w</td><td>以只写方式打开文件，如果参数path指定的文件存在，将文件长度截断为0，不存在则创建该文件</td></tr><tr><td>w+</td><td>以可读、可写方式打开文件，如果参数 path 指定的文件存在，将文件长度截断为 0；如果指定文件不存在则创建该文件。</td></tr><tr><td>a</td><td>以只写方式打开文件，打开以进行追加内容（在文件末尾写入），如果文件不存在则创建该文件。</td></tr><tr><td>a+</td><td>以可读、可写方式打开文件，以追加方式写入（在文件末尾写入），如果文件不存在则创建该文件。</td></tr></tbody></table><p>虽然调用 fopen()函数新建文件时无法手动指定文件的权限，但却有一个默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH (0666)</span><br></pre></td></tr></table></figure><h3 id="fclose-关闭文件"><a href="#fclose-关闭文件" class="headerlink" title="fclose()关闭文件"></a>fclose()关闭文件</h3><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数 stream 为 FILE 类型指针，调用成功返回 0；失败将返回 EOF（也就是-1），并且会设置 errno 来<br>指示错误原因。</p><h3 id="读文件和写文件"><a href="#读文件和写文件" class="headerlink" title="读文件和写文件"></a>读文件和写文件</h3><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>库函数 fread()用于读取文件数据，其参数和返回值含义如下：</p><p>ptr：fread()将读取到的数据存放在参数 ptr 指向的缓冲区中；<br>size：fread()从文件读取 nmemb 个数据项，每一个数据项的大小为 size 个字节，所以总共读取的数据大<br>小为 nmemb * size 个字节。<br>nmemb：参数 nmemb 指定了读取数据项的个数。<br>stream：FILE 指针。<br>返回值：调用成功时返回读取到的数据项的数目（数据项数目并不等于实际读取的字节数，除非参数<br>size 等于 1）；如果发生错误或到达文件末尾，则 fread()返回的值将小于参数 nmemb，那么到底发生了错误还是到达了文件末尾，fread()不能区分文件结尾和错误，究竟是哪一种情况，此时可以使用 ferror()或 feof()函数来判断。</p><p>库函数 fwrite()用于将数据写入到文件中，其参数和返回值含义如下：<br>ptr：将参数 ptr 指向的缓冲区中的数据写入到文件中。<br>size：参数 size 指定了每个数据项的字节大小，与 fread()函数的 size 参数意义相同。<br>nmemb：参数 nmemb 指定了写入的数据项个数，与 fread()函数的 nmemb 参数意义相同。<br>stream：FILE 指针。<br>返回值：调用成功时返回写入的数据项的数目（数据项数目并不等于实际写入的字节数，除非参数 size<br>等于 1）；如果发生错误，则 fwrite()返回的值将小于参数 nmemb（或者等于 0）。<br>由此可知，库函数 fread()、fwrite()中指定读取或写入数据大小的方式与系统调用 read()、write()不同，<br>前者通过 nmemb（数据项个数）*size（每个数据项的大小）的方式来指定数据大小，而后者则直接通过一个 size 参数指定数据大小。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[] = <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line"> FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;./test_file&quot;</span>, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 写入数据 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(buf) &gt; fwrite(buf, <span class="number">1</span>, <span class="keyword">sizeof</span>(buf), fp)) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fwrite error\n&quot;</span>);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;数据写入成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">int</span> size;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">NULL</span> == (fp = fopen(<span class="string">&quot;./test_file&quot;</span>, <span class="string">&quot;r&quot;</span>))) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">12</span> &gt; (size = fread(buf, <span class="number">1</span>, <span class="number">12</span>, fp))) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ferror(fp)) &#123; <span class="comment">//使用 ferror 判断是否是发生错误</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fread error\n&quot;</span>);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 如果未发生错误则意味着已经到达了文件末尾 */</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;成功读取%d 个字节数据: %s\n&quot;</span>, size, buf);</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fseek定位"><a href="#fseek定位" class="headerlink" title="fseek定位"></a>fseek定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>stream：FILE 指针。<br>offset：与 lseek()函数的 offset 参数意义相同。<br>whence：与 lseek()函数的 whence 参数意义相同。<br>返回值：成功返回 0；发生错误将返回-1，并且会设置 errno 以指示错误原因；与 lseek()函数的返回值<br>意义不同，这里要注意！<br>调用库函数 fread()、fwrite()读写文件时，文件的读写位置偏移量会自动递增，使用 fseek()可手动设置<br>文件当前的读写位置偏移量。</p><p><u>将一个文件的打开写入文件数据，并进行读取要使用fseek来将读写位置移动到头部才能读取，否则fead</u></p><p><u>读取后面的空白信息，没有内容。</u></p><h3 id="ftell-函数"><a href="#ftell-函数" class="headerlink" title="ftell()函数"></a>ftell()函数</h3><p>用于获取文件当前的读写位置偏移量，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数 stream 指向对应的文件，函数调用成功将返回当前读写位置偏移量；调用失败将返回-1，并会设置<br>errno 以指示错误原因。</p><h3 id="feof函数"><a href="#feof函数" class="headerlink" title="feof函数"></a>feof函数</h3><p>库函数 feof()用于测试参数 stream 所指文件的 end-of-file 标志，如果 end-of-file 标志被设置了，则调用<br>feof()函数将返回一个非零值，如果 end-of-file 标志没有被设置，则返回 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="ferror-函数"><a href="#ferror-函数" class="headerlink" title="ferror()函数"></a>ferror()函数</h3><p>库函数 ferror()用于测试参数 stream 所指文件的错误标志，如果错误标志被设置了，则调用 ferror()函数<br>将返回一个非零值，如果错误标志没有被设置，则返回 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="clearerr函数"><a href="#clearerr函数" class="headerlink" title="clearerr函数"></a>clearerr函数</h3><p>库函数 clearerr()用于清除 end-of-file 标志和错误标志，当调用 feof()或 ferror()校验这些标志后，通常需<br>要清除这些标志，避免下次校验时使用到的是上一次设置的值，此时可以手动调用 clearerr()函数清除标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="IO缓冲"><a href="#IO缓冲" class="headerlink" title="IO缓冲"></a>IO缓冲</h3><p>调用 write()后仅仅只是将这 5 个字节数据拷贝到了内核空间的缓冲区中，拷贝完成之后函数就返回了，在后面的某个时刻，内核会将其缓冲区中的数据写入（刷新）到磁盘设备中，所以由此可知，系统调用 write()与磁盘操作并不是同步的，write()函数并不会等待数据真正写入到磁盘之后再返回。如果在此期间，其它进程调用 read()函数读取该文件的这几个字节数据，那么内核将自动从缓冲区中读取这几个字节数据返回给应用程序。</p><p>这个内核缓冲区就称为文件 I&#x2F;O 的内核缓冲。这样的设计，目的是为了提高文件 I&#x2F;O 的速度和效率，使得系统调用 read()、write()的操作更为快速，不需要等待磁盘操作（将数据写入到磁盘或从磁盘读取出数据），磁盘操作通常是比较缓慢的。同时这一设计也更为高效，减少了内核操作磁盘的次数，譬如线程1 调用 write()向文件写入数据”abcd”，线程 2 也调用 write()向文件写入数据”1234”，这样的话，数据”abcd”和”1234”都被缓存在了内核的缓冲区中，在稍后内核会将它们一起写入到磁盘中，只发起一次磁盘操作请求；加入没有内核缓冲区，那么每一次调用 write()，内核就会执行一次磁盘操作。</p><h4 id="刷新文件-I-x2F-O-的内核缓冲区"><a href="#刷新文件-I-x2F-O-的内核缓冲区" class="headerlink" title="刷新文件 I&#x2F;O 的内核缓冲区"></a>刷新文件 I&#x2F;O 的内核缓冲区</h4><p>当我们在 Ubuntu 系统下拷贝文件到 U 盘时，文件拷贝完成之后，通常在拔掉 U 盘之前，需要执行 sync 命令进行同步操作，这个同步操作其实就是将文件 I&#x2F;O 内核缓冲区中的数据更新到 U 盘硬件设备，所以如果在没有执行 sync 命令时拔掉 U 盘，很可能就会导致拷贝到 U 盘中的文件遭到破坏！</p><h4 id="fsync-函数"><a href="#fsync-函数" class="headerlink" title="fsync()函数"></a>fsync()函数</h4><p>系统调用 fsync()将参数 fd 所指文件的内容数据和元数据写入磁盘，只有在对磁盘设备的写入操作完成之后，fsync()函数才会返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>参数 fd 表示文件描述符，函数调用成功将返回 0，失败返回-1 并设置 errno 以指示错误原因。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_FILE <span class="string">&quot;./rfile&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_FILE <span class="string">&quot;./wfile&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> rfd, wfd;</span><br><span class="line"> <span class="type">size_t</span> size;</span><br><span class="line"> <span class="comment">/* 打开源文件 */</span></span><br><span class="line"> rfd = open(READ_FILE, O_RDONLY);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; rfd) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 打开目标文件 */</span></span><br><span class="line"> wfd = open(WRITE_FILE, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; wfd) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 拷贝数据 */</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">0</span> &lt; (size = read(rfd, buf, BUF_SIZE)))</span><br><span class="line"> write(wfd, buf, size);</span><br><span class="line"> <span class="comment">/* 对目标文件执行 fsync 同步 */</span></span><br><span class="line"> fsync(wfd);</span><br><span class="line"> <span class="comment">/* 关闭文件退出程序 */</span></span><br><span class="line"> close(rfd);</span><br><span class="line">  close(wfd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fdatasync-函数"><a href="#fdatasync-函数" class="headerlink" title="fdatasync()函数"></a>fdatasync()函数</h4><p>系统调用 fdatasync()与 fsync()类似，不同之处在于 fdatasync()仅将参数 fd 所指文件的内容数据写入磁<br>盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><h4 id="sync-函数"><a href="#sync-函数" class="headerlink" title="sync()函数"></a>sync()函数</h4><p>系统调用 sync()会将所有文件 I&#x2F;O 内核缓冲区中的文件内容数据和元数据全部更新到磁盘设备中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="O-DSYNC-标志"><a href="#O-DSYNC-标志" class="headerlink" title="O_DSYNC 标志"></a>O_DSYNC 标志</h4><p>在调用 open()函数时，指定 O_DSYNC 标志，其效果类似于在每个 write()调用之后调用 fdatasync()函数<br>进行数据同步。</p><h4 id="O-SYNC-标志"><a href="#O-SYNC-标志" class="headerlink" title="O_SYNC 标志"></a>O_SYNC 标志</h4><p>在调用 open()函数时，指定 O_SYNC 标志，使得每个 write()调用都会自动将文件内容数据和元数据刷<br>新到磁盘设备中，其效果类似于在每个 write()调用之后调用 fsync()函数进行数据同步</p><h4 id="直接IO"><a href="#直接IO" class="headerlink" title="直接IO"></a>直接IO</h4><p>Linux 允许应用程序在执行文件 I&#x2F;O 操作时绕过内核缓冲区，从用户空间直接将数据传递到文件或磁盘设备，把这种操作也称为直接 I&#x2F;O（direct I&#x2F;O）或裸 I&#x2F;O（raw I&#x2F;O）。</p><p>因为直接 I&#x2F;O 涉及到对磁盘设备的直接访问，所以在执行直接 I&#x2F;O 时，必须要遵守以下三个对齐限制要求：<br>⚫ 应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐；<br>⚫ 写文件时，文件的位置偏移量必须是块大小的整数倍；<br>⚫ 写入到文件的数据大小必须是块大小的整数倍。</p><h4 id="stdio缓冲"><a href="#stdio缓冲" class="headerlink" title="stdio缓冲"></a>stdio缓冲</h4><p>标准 I&#x2F;O（fopen、fread、fwrite、fclose、fseek 等）是 C 语言标准库函数，而文件 I&#x2F;O（open、read、write、close、lseek 等）是系统调用，虽然标准 I&#x2F;O 是在文件 I&#x2F;O 基础上进行封装而实现（譬如 fopen 内部实际上调用了 open、fread 内部调用了 read 等），但在效率、性能上标准 I&#x2F;O 要优于文件 I&#x2F;O，其原因在于标准 I&#x2F;O 实现维护了自己的缓冲区，把这个缓冲区称为 stdio 缓冲区。为了减少调用系统调用的次数，标准 I&#x2F;O 函数会将用户写入或读取文件的数据缓存在 stdio 缓冲区，然后再一次性将 stdio 缓冲区中缓存的数据通过调用系统调用I&#x2F;O（文件 I&#x2F;O）写入到文件 I&#x2F;O 内核缓冲区或者拷贝到应用程序的 buf 中。</p><h5 id="stdio缓冲区的函数"><a href="#stdio缓冲区的函数" class="headerlink" title="stdio缓冲区的函数"></a>stdio缓冲区的函数</h5><h5 id="setvbuf-函数"><a href="#setvbuf-函数" class="headerlink" title="setvbuf()函数"></a>setvbuf()函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>stream：FILE 指针，用于指定对应的文件，每一个文件都可以设置它对应的 stdio 缓冲区。<br>buf：如果参数 buf 不为 NULL，那么 buf 指向 size 大小的内存区域将作为该文件的 stdio 缓冲区，因为stdio 库会使用 buf 指向的缓冲区，所以应该以动态（分配在堆内存）或静态的方式在堆中为该缓冲区分配一块空间，而不是分配在栈上的函数内的自动变量（局部变量）。如果 buf 等于 NULL，那么 stdio 库会自动分配一块空间作为该文件的 stdio 缓冲区（除非参数 mode 配置为非缓冲模式）。<br>mode：参数 mode 用于指定缓冲区的缓冲类型，可取值如下：<br>⚫ _IONBF：不对 I&#x2F;O 进行缓冲（无缓冲）。意味着每个标准 I&#x2F;O 函数将立即调用 write()或者 read()，并且忽略 buf 和 size 参数，可以分别指定两个参数为 NULL 和 0。标准错误 stderr 默认属于这一种类型，从而保证错误信息能够立即输出。<br>⚫ _IOLBF：采用行缓冲 I&#x2F;O。在这种情况下，当在输入或输出中遇到换行符”\n”时，标准 I&#x2F;O 才会执行文件 I&#x2F;O 操作。对于输出流，在输出一个换行符前将数据缓存（除非缓冲区已经被填满），当输出换行符时，再将这一行数据通过文件 I&#x2F;O write()函数刷入到内核缓冲区中；对于输入流，每次读取一行数据。对于终端设备默认采用的就是行缓冲模式，譬如标准输入和标准输出。<br>⚫ _IOFBF：采用全缓冲 I&#x2F;O。在这种情况下，在填满 stdio 缓冲区后才进行文件 I&#x2F;O 操作（read、write）。对于输出流，当 fwrite 写入文件的数据填满缓冲区时，才调用 write()将 stdio 缓冲区中的数据刷入内核缓冲区；对于输入流，每次读取 stdio 缓冲区大小个字节数据。默认普通磁盘上的常规文件默认常用这种缓冲模式。<br>size：指定缓冲区的大小。<br>返回值：成功返回 0，失败将返回一个非 0 值，并且会设置 errno 来指示错误原因。</p><h5 id="setbuffer-函数"><a href="#setbuffer-函数" class="headerlink" title="setbuffer()函数"></a>setbuffer()函数</h5><p>setbuffer函数类似setbuf（）但是允许调用者指定buf缓冲区的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><h5 id="刷新-stdio-缓冲区"><a href="#刷新-stdio-缓冲区" class="headerlink" title="刷新 stdio 缓冲区"></a>刷新 stdio 缓冲区</h5><p>无论我们采取何种缓冲模式，在任何时候都可以使用库函数 fflush()来强制刷新（将输出到 stdio 缓冲区中的数据写入到内核缓冲区，通过 write()函数）stdio 缓冲区，该函数会刷新指定文件的 stdio 输出缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"> fflush(<span class="built_in">stdout</span>); <span class="comment">//刷新标准输出 stdio 缓冲区</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; )</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些其它的情况下，也会自动刷新 stdio 缓冲区，譬如当文件关闭时、程序退出时。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/set.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux深入文件IO</title>
      <link href="/2022/11/10/2022-11-10-Linux%E6%B7%B1%E5%85%A5%E6%96%87%E4%BB%B6IO/"/>
      <url>/2022/11/10/2022-11-10-Linux%E6%B7%B1%E5%85%A5%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux管理文件"><a href="#Linux管理文件" class="headerlink" title="Linux管理文件"></a>Linux管理文件</h3><h4 id="静态文件与inode"><a href="#静态文件与inode" class="headerlink" title="静态文件与inode"></a>静态文件与inode</h4><p>文件存放在磁盘文件系统中，并且以一种固定的形式进行存放，称为静态文件。调用 open 函数的时候，会将文件数据（文件内容）从磁盘等块设备读取到内存中，将文件数据在内存中进行维护，内存中的这份文件数据我们就把它称为动态文件。</p><p>硬盘的最小存储单位叫做“扇区”（Sector），每个扇区储存 512 字节（相当于 0.5KB），操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的4KB，即连续八个 sector 组成一个 block。</p><p>磁盘在进行分区、格式化的时候会将其分为两个区域，一个是数据区，用于存储文件中的数据；<br>另一个是 inode 区，用于存放 inode table（inode 表），inode table 中存放的是一个一个的 inode（也成为 inode节点），不同的 inode 就可以表示不同的文件，每一个文件都必须对应一个 inode。</p><p><a href="https://postimg.cc/JD4mjgVd"><img src="https://i.postimg.cc/DZ1Z3kCF/2022-11-10-142428.png" alt="2022-11-10-142428.png"></a></p><p>打开一个文件，系统内部会将这个过程分为三步：</p><ol><li>系统找到这个文件名所对应的 inode 编号；</li><li>通过 inode 编号从 inode table 中找到对应的 inode 结构体；</li><li>根据 inode 结构体中记录的信息，确定文件数据所在的 block，并读出数据。</li></ol><p>调用 open 函数去打开文件的时候，内核会申请一段内存（一段缓冲区），并且将静态文件的数据内容从磁盘这些存储设备中读取到内存中进行管理、缓存（也把内存中的这份文件数据叫做动态文件、内核缓冲区）。打开文件后，以后对这个文件的读写操作，都是针对内存中这一份动态文件进行相关的操作，而并不是针对磁盘中存放的静态文件。</p><p>因为磁盘、硬盘、U 盘等存储设备基本都是 Flash 块设备，因为块设备硬件本身有读写限制等特征，块设备是以一块一块为单位进行读写的（一个块包含多个扇区，而一个扇区包含多个字节），一个字节的改动也需要将该字节所在的 block 全部读取出来进行修改，修改完成之后再写入块设备中，所以导致对块设备的读写操作非常不灵活；而内存可以按字节为单位来操作，而且可以随机操作任意地址数据，非常地很灵活。</p><p>内核会为每个进程设置一个专门的数据结构用于管理该进程，譬如用于记录进程的状态信息、运行特征等，我们把这个称为进程控制块（Process control block，缩写PCB）。<br>PCB 数据结构体中有一个指针指向了文件描述符表（File descriptors），文件描述符表中的每一个元素索引到对应的文件表（File table），文件表也是一个数据结构体。</p><h4 id="返回错误处理与errno"><a href="#返回错误处理与errno" class="headerlink" title="返回错误处理与errno"></a>返回错误处理与errno</h4><p>在 Linux 系统下对常见的错误做了一个编号，每一个编号都代表着每一种不同的错误类型，当函数执行发生错误的时候，操作系统会将这个错误所对应的编号赋值给 errno 变量，每一个进程（程序）都维护了自己的 errno 变量，它是程序中的全局变量，该变量用于存储就近发生的函数执行错误编号，也就意味着下一次的错误码会覆盖上一次的错误码。</p><p>errno 本质上是一个 int 类型的变量，用于存储错误编号，但是需要注意的是，并不是执行所有的系统调用或 C 库函数出错时，操作系统都会设置 errno。</p><h5 id="常用的函数perror函数"><a href="#常用的函数perror函数" class="headerlink" title="常用的函数perror函数"></a>常用的函数perror函数</h5><p>一般用的最多的还是这个函数，调用此函数不需要传入 errno，函数内部会自己去获取 errno 变量的值，调用此函数会直接将错误提示字符串打印出来，而不是返回字符串。</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>s：在错误提示字符串信息之前，可加入自己的打印信息，也可不加，不加则传入空字符串即可。<br>返回值：void 无返回值。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">/* 打开文件 */</span></span><br><span class="line">fd = open(<span class="string">&quot;./test_file&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="exit、-exit、-Exit"><a href="#exit、-exit、-Exit" class="headerlink" title="exit、__exit、_Exit"></a>exit、__exit、_Exit</h4><p>在 Linux 系统下，进程（程序）退出可以分为正常退出和异常退出，注意这里说的异常并不是执行函数出现了错误这种情况，异常往往更多的是一种不可预料的系统异常，可能是执行了某个函数时发生的、也有可能是收到了某种信号等.</p><p>main 函数中使用 return 后返回，return 执行后把控制权交给调用函数，结束该进程。调用_exit()函数会清除其使用的内存空间，并销毁其在内核中的各种数据结构，关闭进程的所有文件描述符，并结束进程、将控制权交给操作系统。exit()是一个标准 C 库函数，而_exit()和_Exit()是系统调用。</p><p>__exit()函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>_Exit()函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _Exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>exit()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><h4 id="空洞文件"><a href="#空洞文件" class="headerlink" title="空洞文件"></a>空洞文件</h4><p>使用 write()函数对文件进行写入操作，也就是说此时将是从偏移文件头部 6000 个字节处开始写入数据，也就意味着 4096~6000 字节之间出现了一个空洞，因为这部分空间并没有写入任何数据，所以形成了空洞，这部分区域就被称为文件空洞，那么相应的该文件也被称为空洞文件。<br>文件空洞部分实际上并不会占用任何物理空间，直到在某个时刻对空洞部分进行写入数据时才会为它<br>分配对应的空间，但是空洞文件形成时，逻辑上该文件的大小是包含了空洞部分的大小的</p><p><u>空洞文件对多线程共同操作文件是及其有用的</u>，有时候我们创建一个很大的文件，如果单个线程从头开始依次构建该文件需要很长的时间，有一种思路就是将文件分为多段，然后使用多线程来操作，每个线程负责其中一段数据的写入。</p><p>eg：新建一个空洞文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(<span class="string">&quot;./hole_file&quot;</span>, O_WRONLY | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将文件读写位置移动到偏移文件头 4096 个字节(4K)处 */</span></span><br><span class="line"> ret = lseek(fd, <span class="number">4096</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 初始化 buffer 为 0xFF */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 循环写入 4 次，每次写入 1K */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例代码中，使用 open 函数新建了一个文件 hole_file，在 Linux 系统中，新建文件大小是 0，也就<br>是没有任何数据写入，此时使用lseek函数将读写偏移量移动到4K字节处，再使用write函数写入数据0xFF，每次写入 1K，一共写入 4 次，也就是写入了 4K 数据，也就意味着该文件前 4K 是文件空洞部分，而后 4K数据才是真正写入的数据。</p><h4 id="O-APPEND-和-O-TRUNC-标志"><a href="#O-APPEND-和-O-TRUNC-标志" class="headerlink" title="O_APPEND 和 O_TRUNC 标志"></a>O_APPEND 和 O_TRUNC 标志</h4><p>O_TRUNC 这个标志的作用是调用 open 函数打开文件的时候会将文件原本的内容全部丢弃，文件大小变为 0。</p><p><u><strong>O_APPEND</strong></u>标志作用open函数携带了O_APPEND，调用 open 函数打开文件，当每次使用 write()函数对文件进行写操作时，都会自动把文件当前位置偏移量移动到文件末尾，从文件末尾开始写入数据，也就是意味着每次写入数据都是从文件末尾开始。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_APPEND);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 初始化 buffer 中的数据 */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0x55</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 写入数据: 写入 4 个字节数据 */</span></span><br><span class="line"> ret = write(fd, buffer, <span class="number">4</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将 buffer 缓冲区中的数据全部清 0 */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 将位置偏移量移动到距离文件末尾 4 个字节处 */</span></span><br><span class="line"> ret = lseek(fd, <span class="number">-4</span>, SEEK_END);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line">    ret = read(fd, buffer, <span class="number">4</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;0x%x 0x%x 0x%x 0x%x\n&quot;</span>, buffer[<span class="number">0</span>], buffer[<span class="number">1</span>],</span><br><span class="line"> buffer[<span class="number">2</span>], buffer[<span class="number">3</span>]);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用O_APPEND多次打开同一个文件测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> buffer1[<span class="number">4</span>], buffer2[<span class="number">4</span>];</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL | O_APPEND,</span><br><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd1) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 再次打开 test_file 文件 */</span></span><br><span class="line"> fd2 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_APPEND);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd2) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* buffer 数据初始化 */</span></span><br><span class="line"> buffer1[<span class="number">0</span>] = <span class="number">0x11</span>;</span><br><span class="line"> buffer1[<span class="number">1</span>] = <span class="number">0x22</span>;</span><br><span class="line"> buffer1[<span class="number">2</span>] = <span class="number">0x33</span>;</span><br><span class="line"> buffer1[<span class="number">3</span>] = <span class="number">0x44</span>;</span><br><span class="line"> buffer2[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line"> buffer2[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line"> buffer2[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line"> buffer2[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line"> <span class="comment">/* 循环写入数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = write(fd2, buffer2, <span class="keyword">sizeof</span>(buffer2));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将读写位置偏移量移动到文件头 */</span></span><br><span class="line"> ret = lseek(fd1, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"> ret = read(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x%x%x%x&quot;</span>, buffer1[<span class="number">0</span>], buffer1[<span class="number">1</span>],</span><br><span class="line"> buffer1[<span class="number">2</span>], buffer1[<span class="number">3</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复制文件描述符"><a href="#复制文件描述符" class="headerlink" title="复制文件描述符"></a>复制文件描述符</h4><p>在 Linux 系统中，open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新的文件描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，复制得到的文件描述符和旧的文件描述符拥有相同的权限，譬如使用旧的文件描述符对文件有读写权限，那么新的文件描述符同样也具有读写权限。</p><p>dup函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br></pre></td></tr></table></figure><p>oldfd：需要被复制的文件描述符。<br>返回值：成功时将返回一个新的文件描述符，由操作系统分配，分配置原则遵循文件描述符分配原则；<br>如果复制失败将返回-1，并且会设置 errno 值</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> buffer1[<span class="number">4</span>], buffer2[<span class="number">4</span>];</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 复制文件描述符 */</span></span><br><span class="line"> fd2 = dup(fd1);</span><br><span class="line"> <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;dup error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d\nfd2: %d\n&quot;</span>, fd1, fd2);</span><br><span class="line"> <span class="comment">/* buffer 数据初始化 */</span></span><br><span class="line"> buffer1[<span class="number">0</span>] = <span class="number">0x11</span>;</span><br><span class="line"> buffer1[<span class="number">1</span>] = <span class="number">0x22</span>;</span><br><span class="line"> buffer1[<span class="number">2</span>] = <span class="number">0x33</span>;</span><br><span class="line"> buffer1[<span class="number">3</span>] = <span class="number">0x44</span>;</span><br><span class="line"> buffer2[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line"> buffer2[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line"> buffer2[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line"> buffer2[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line"> <span class="comment">/* 循环写入数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = write(fd2, buffer2, <span class="keyword">sizeof</span>(buffer2));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将读写位置偏移量移动到文件头 */</span></span><br><span class="line"> ret = lseek(fd1, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"> ret = read(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x%x%x%x&quot;</span>, buffer1[<span class="number">0</span>], buffer1[<span class="number">1</span>],</span><br><span class="line"> buffer1[<span class="number">2</span>], buffer1[<span class="number">3</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dup 系统调用分配的文件描述符是由系统分配的，遵循文件描述符分配原则，并不能自己指定一个文件<br>描述符，这是 dup 系统调用的一个缺陷；而 dup2 系统调用修复了这个缺陷，可以手动指定文件描述符，而不需要遵循文件描述符分配原则。dup2函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p>oldfd：需要被复制的文件描述符。<br>newfd：指定一个文件描述符（需要指定一个当前进程没有使用到的文件描述符）。<br>返回值：成功时将返回一个新的文件描述符，也就是手动指定的文件描述符 newfd；如果复制失败将返回-1，并且会设置 errno 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 复制文件描述符 */</span></span><br><span class="line"> fd2 = dup2(fd1, <span class="number">100</span>);</span><br><span class="line"> <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;dup error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d\nfd2: %d\n&quot;</span>, fd1, fd2);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>文件共享指的是同一个文件（譬如磁盘上的同一个文件，对应同一个 inode）被多个独立的读写体同时进行 IO 操作。同时进行 IO 操作指的是一个读写体操作文件尚未调用 close 关闭的情况下，另一个读写体去操作文件。</p><p>文件共享的意义有很多，多用于多进程或多线程编程环境中，譬如我们可以通过文件共享的方式来实现<br>多个线程同时操作同一个大文件，以减少文件读写时间、提升效率。<br><strong><u>文件共享的核心</strong></u>是：如何制造出多个不同的文件描述符来指向同一个文件。其实方法在上面的内容中都已经给大家介绍过了，譬如多次调用 open 函数重复打开同一个文件得到多个不同的文件描述符、使用 dup()或 dup2()函数对文件描述符进行复制以得到多个不同的文件描述符。</p><p><strong>常见三种文件共享实现方式</strong></p><p>(1)同一个进程中多次调用 open 函数打开同一个文件</p><p>(2)不同进程中分别使用 open 函数打开同一个文件</p><p>(3)同一个进程中通过 dup（dup2）函数对文件描述符进行复制</p><h4 id="原子操作和竞争冒险"><a href="#原子操作和竞争冒险" class="headerlink" title="原子操作和竞争冒险"></a>原子操作和竞争冒险</h4><p>[原子操作和竞争冒险]: <a href="https://copyfuture.com/blogs-details/202208241006207606">https://copyfuture.com/blogs-details/202208241006207606</a>“竞争冒险”</p><h4 id="截断文件"><a href="#截断文件" class="headerlink" title="截断文件"></a>截断文件</h4><p>truncate()或ftruncate()可将普通文件截断为指定字节长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p>这两个函数都可以对文件进行截断操作，将文件截断为参数 length 指定的字节长度，什么是截断？如<br>果文件目前的大小大于参数 length 所指定的大小，则多余的数据将被丢失，类似于多余的部分被“砍”掉<br>了；如果文件目前的大小小于参数 length 所指定的大小，则将其进行扩展，对扩展部分进行读取将得到空字节”\0”。</p><p>使用 ftruncate()函数进行文件截断操作之前，必须调用 open()函数打开该文件得到文件描述符，并且必<br>须要具有可写权限，也就是调用 open()打开文件时需要指定 O_WRONLY 或 O_RDWR。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="comment">/* 打开 file1 文件 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; (fd = open(<span class="string">&quot;./file1&quot;</span>, O_RDWR))) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 使用 ftruncate 将 file1 文件截断为长度 0 字节 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; ftruncate(fd, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;ftruncate error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 使用 truncate 将 file2 文件截断为长度 1024 字节 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; truncate(<span class="string">&quot;./file2&quot;</span>, <span class="number">1024</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;truncate error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 关闭 file1 退出程序 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——文件IO操作</title>
      <link href="/2022/11/08/2022-11-8-Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/11/08/2022-11-8-Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="文件IO基础"><a href="#文件IO基础" class="headerlink" title="文件IO基础"></a>文件IO基础</h3><p>文件IO是指对文件的输入输出操作。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>调用函数会有返回值，该返回值为一个文件描述符，对于Linux内核而言，所有打开文件都会通过文件描述符进行索引。</p><p>当调用open函数打开或者创建一个新文件，内核会向进程返回一个文件描述符，用于指带被打开的文件，所有执行 IO 操作的系统调用都是通过文件描述符来索引到对应的文件。一个进程可以打开多个文件，但是在 Linux 系统中，一个进程可以打开的文件数是有限制，并不是可以无限制打开很多的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -n<span class="comment">##查看进程打开文件的最大数量</span></span></span><br><span class="line">1024</span><br></pre></td></tr></table></figure><p>每一个被打开的文件在同一个进程中都有一个唯一的文件描述符，不会重复，如果文件被关闭后，它对应的文件描述符将会被释放，那么这个文件描述符将可以再次分配给其它打开的文件、与对应的文件绑定起来。</p><p>每次给打开的文件分配文件描述符都是从最小的没有被使用的文件描述符（0~1023）开始，当之前打开的文件被关闭之后，那么它对应的文件描述符会被释放，释放之后也就成为了一个没有被使用的文件描述符了。</p><p>但是 0、1、2 这三个文件描述符已经默认被系统占用了，分别分配给了系统标准输入（0）、标准输出（1）以及标准错误（2）。</p><h4 id="open打开文件"><a href="#open打开文件" class="headerlink" title="open打开文件"></a>open打开文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>open 函数用于打开文件，当然除了打开已经存在的文件之外，还可以创建一个新的文件。</p><p>在应用程序中调用 open 函数即可传入 2 个参数（pathname、flags）、也可传入 3 个参数（pathname、flags、mode），但是第三个参数 mode 需要在第二个参数 flags 满足条件时才会有效，稍后将对此进行说明；从图 2.3.1 可知，在应用程序中使用 open 函数时，需要包含 3 个头文件“#include<br>”、“#include ”、“#include ”。</p><p>函数参数和返回值定义</p><p>pathname：字符串类型，用于标识需要打开或创建的文件，可以包含路径（绝对路径或者相对路径）信息。</p><p>flags：调用open函数时需要提供的标志，包括文件访问模式标志以及其它文件相关标志，这些标志使用宏定义进行描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;./app.c&quot;</span>, O_RDWR)<span class="comment">//打开一个已经存在的文件，使用可读可写的方式打开</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line"><span class="keyword">return</span> fd;</span><br></pre></td></tr></table></figure><h4 id="write写文件"><a href="#write写文件" class="headerlink" title="write写文件"></a>write写文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>函数参数返回值含义如下：</p><p>fd：文件描述符。将进行写操作的文件所对应的文件描述符传递给 write 函数。<br>buf：指定写入数据对应的缓冲区。<br>count：指定写入的字节数。<br>返回值：如果成功将返回写入的字节数（0 表示未写入任何字节），如果此数字小于 count 参数，这不是错误，譬如磁盘空间已满，可能会发生这种情况；如果写入出错，则返回-1。</p><h4 id="read读文件"><a href="#read读文件" class="headerlink" title="read读文件"></a>read读文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>fd：文件描述符。与 write 函数的 fd 参数意义相同。</p><p>buf：指定用于存储读取数据的缓冲区。</p><p>count：指定需要读取的字节数。</p><p>返回值：如果读取成功将返回读取到的字节数，实际读取到的字节数可能会小于 count 参数指定的字节<br>数，也有可能会为 0，譬如进行读操作时，当前文件位置偏移量已经到了文件末尾。实际读取到的字节数少<br>于要求读取的字节数，譬如在到达文件末尾之前有 30 个字节数据，而要求读取 100 个字节，则 read 读取成<br>功只能返回 30；而下一次再调用 read 读，它将返回 0（文件末尾）。</p><h4 id="close关闭文件"><a href="#close关闭文件" class="headerlink" title="close关闭文件"></a>close关闭文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>fd：文件描述符，需要关闭的文件所对应的文件描述符。<br>返回值：如果成功返回 0，如果失败则返回-1。</p><h4 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>对于每个打开的文件，系统都会记录它的读写位置偏移量，我们也把这个读写位置偏移量称为读写偏移<br>量，记录了文件当前的读写位置，当调用 read()或 write()函数对文件进行读写操作时，就会从当前读写位置<br>偏移量开始进行数据读写。</p><p>读写偏移量用于指示 read()或 write()函数操作时文件的起始位置，会以相对于文件头部的位置偏移量来<br>表示，文件第一个字节数据的位置偏移量为 0。</p><p>函数参数和返回值含义如下：<br>fd：文件描述符。<br>offset：偏移量，以字节为单位。<br>whence：用于定义参数 offset 偏移量对应的参考值，该参数为下列其中一种（宏定义）：</p><p>SEEK_SET：读写偏移量将指向 offset 字节位置处（从文件头部开始算）</p><p>SEEK_CUR：读写偏移量将指向当前位置偏移量 + offset 字节位置处，offset 可以为正、也可以为负，如果是正数表示往后偏移，如果是负数则表示往前偏移；</p><p>SEEK_END：读写偏移量将指向文件末尾 + offset 字节位置处，同样 offset 可以为正、也可以为负，如果是正数表示往后偏移、如果是负数则表示往前偏移。</p><p>eg：<br>(1)将读写位置移动到文件开头处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(2)将读写位置移动到文件末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(3)将读写位置移动到偏移文件开头 100 个字节处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">100</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(4)获取当前读写位置偏移量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>函数执行成功将返回文件当前读写位置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——Shell脚本学习</title>
      <link href="/2022/10/23/2022-10-23-Linux%E2%80%94%E2%80%94Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/23/2022-10-23-Linux%E2%80%94%E2%80%94Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h3><p>Shell通常指的是命令行界面的解析器,也用于泛指所有为用户提供操作界面的程序，也就是程序和用户<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%A4%E4%BA%92&action=edit&redlink=1">交互</a>的层面。</p><p>Shell 执行shell程序，这些程序叫脚本。</p><p>创建脚本使用文本编辑器来创建包含指令的文件，这里使用vim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim bash.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash<span class="comment">##创建脚本文件时候必须在文件第一行指明要用到的shell</span></span></span><br><span class="line">for file in *#以#开头的行不会被shell处理</span><br><span class="line">do </span><br><span class="line">  if grep -q POSIX $file</span><br><span class="line">  then</span><br><span class="line">    echo $file</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>把脚本设置为可执行，</p><p>1、</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/bash bash.sh</span></span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x bash.sh<span class="comment">##改变文件权限，使这个文件可以被所有用户执行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bash.sh</span></span><br></pre></td></tr></table></figure><h3 id="Shell-语法"><a href="#Shell-语法" class="headerlink" title="Shell 语法"></a>Shell 语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>所有变量都被看作字符串并以字符串来存储.</p><p> 注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：（变量名称使用小写英文命名，因为系统中的全局变量是大写命名的，为防止重复定义就用小写）</p><p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>中间不能有空格，可以使用下划线 _。<br>不能使用标点符号。<br>不能使用bash里的关键字（可用help命令查看保留关键字）。</p><p>在shell中，可以通过在变量名前加上$符号来访问它的内容， 一种检查变量内容的简单方式就是变量前加上$再用echo命令将它的内容输出到终端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> salutation=Hello</span><br><span class="line"> echo $salutation</span><br><span class="line"> echo salutation</span><br><span class="line">Hello</span><br><span class="line">salutation</span><br></pre></td></tr></table></figure><p>read可以给变量复制相当于C语言的input</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> read salutation</span><br><span class="line"> echo $ salutation</span><br><span class="line">sa</span><br><span class="line">sa</span><br></pre></td></tr></table></figure><p>要想输出空格需要用双引号给引用出来，要想显示双引号可，以用单引号来显示出来，在显示信息中想要有美元符号，必须在前面加上\</p><p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。</p><p>可以通过&#96;反引号来将命令输出赋值给变量或者$()</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">testing = `<span class="built_in">date</span>`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">testing = $(<span class="built_in">date</span>)</span></span><br></pre></td></tr></table></figure><p>使用 unset 命令可以删除变量。</p><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>运行shell时，会同时存在三种变量：</p><ul><li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h4 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a>Shell数组</h4><p>bash支持一维数组，并且没有限制大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)#例如这样array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure><h5 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;数组名[下标]&#125;<span class="comment">#例如echo $&#123;array_name[@]&#125;</span></span></span><br></pre></td></tr></table></figure><h5 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取得数组元素的个数</span></span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取得数组单个元素的长度</span></span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure><p>bash shell脚本不支持浮点型运算，只支持整数运算，如果想要计算可用bash的计算器bc</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="if-else"><a href="#if-else" class="headerlink" title="if -else"></a>if -else</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>如果使用 ((…)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if (( $a == $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif (( $a &gt; $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif (( $a &lt; $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p><p>顺序输出当前列表中的数字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h4><p>until 循环执行一系列命令直至条件为 true 时停止。condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="case…-esac"><a href="#case…-esac" class="headerlink" title="case… esac"></a>case… esac</h4><p>case … esac 为多选择语句，与其他语言中的 switch … case 语句类似，是一种多分支选择结构，每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><u><strong>和C语言一样break用来跳出所有循环，continue是用来跳出当前循环。</strong></u></p><h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于等于则为真</td></tr><tr><td>-ge</td><td>小于等于则为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table><p>eg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个数相等！&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个数不相等！&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e文件名</td><td>如果文件存在则为真</td></tr><tr><td>-f文件名</td><td>如果文件存在且可读则为真</td></tr><tr><td>-w文件名</td><td>如果文件存在且可写则为真</td></tr><tr><td>-x文件名</td><td>如果文件存在且可执行则为真</td></tr><tr><td>-s文件名</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td>-d文件名</td><td>如果文件存在且为目录则为真</td></tr><tr><td>-f文件名</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td>-c文件名</td><td>如果文件存在且为字符型特殊文件则为真</td></tr><tr><td>-b文件名</td><td>如果文件存在且为块特殊文件则为真</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo &#x27;文件已存在!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;文件不存在!&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br></pre></td></tr></table></figure><p>传参</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数处理</th><th>说明</th></tr></thead><tbody><tr><td align="left">$#</td><td>传递到脚本或函数的参数个数</td></tr><tr><td align="left">$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td align="left">$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td align="left">$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td align="left">$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr><tr><td align="left">@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td align="left">$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——进程管理</title>
      <link href="/2022/10/20/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/20/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>进程</p><p><u>进程是用来表示正在进行的程序。</u></p><p>内核中一些重要的进程信息如下：</p><p>进程的内存地址；</p><p>进程当前的状态；</p><p>进程正在使用的资源；</p><p>进程的优先级；</p><p>进程的属组；</p><p><strong>PID</strong>：进程的ID号</p><p><strong>PPID</strong>：父进程的PID</p><p>所有的进程都必须由另一个进程创建——除了系统在系统引导时，由内核自主创建并安装的进程。当一个进程被创建时，创建他的那个进程称为父进程。这个进程叫做子进程；PPID就是父进程的PID。</p><p>只有进程的创建者和root用户才有权对该进程进行操作，记录进程的创建者（属组）就必要了，进程的<strong>UID</strong>就是创建者的ID。</p><p>Linux为进程保存了有效用户ID号叫<strong>EUID</strong>，用来确定进程对某些资源和文件的访问权限。绝大部分情况，UID和EUID一样，除了seruid程序。</p><p>进程的<strong>GID</strong>是创建者所属组的ID号，进程同样有一个<strong>EGID</strong>号，当进程需要创建一个新文件时候，这个文件将采用该进程的GID。</p><h4 id="监视进程：PS命令"><a href="#监视进程：PS命令" class="headerlink" title="监视进程：PS命令"></a>监视进程：PS命令</h4><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d0ada7c0d.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d0ada7c0d.png" alt="屏幕截图 2022-10-20 123723.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line">$ ps lax##可以提供父进程ID（PPID）和谦让度（IN）</span><br></pre></td></tr></table></figure><h4 id="即时跟踪进程信息"><a href="#即时跟踪进程信息" class="headerlink" title="即时跟踪进程信息"></a>即时跟踪进程信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top##实时检测10更新一回q退出</span><br></pre></td></tr></table></figure><h4 id="查看占用文件的进程"><a href="#查看占用文件的进程" class="headerlink" title="查看占用文件的进程"></a>查看占用文件的进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof database.doc##查找文件的进程</span><br></pre></td></tr></table></figure><h4 id="向进程发送信号：kill"><a href="#向进程发送信号：kill" class="headerlink" title="向进程发送信号：kill"></a>向进程发送信号：kill</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d50bb4963.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d50bb4963.png" alt="屏幕截图 2022-10-20 125610.png"></a></p><h4 id="调整进程的谦让度（优先级的反义）nice和renice"><a href="#调整进程的谦让度（优先级的反义）nice和renice" class="headerlink" title="调整进程的谦让度（优先级的反义）nice和renice"></a>调整进程的谦让度（优先级的反义）nice和renice</h4><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d9a16f49d.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d9a16f49d.png" alt="屏幕截图 2022-10-20 131600.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言算法项</title>
      <link href="/2022/10/20/2022-10-20-C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/"/>
      <url>/2022/10/20/2022-10-20-C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正三角-反三角"><a href="#正三角-反三角" class="headerlink" title="正三角(反三角)"></a>正三角(反三角)</h3><p>使用为两个for循环进行嵌套</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="keyword">for</span>(a=<span class="number">0</span>;a&lt;<span class="number">6</span>;a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(b=<span class="number">0</span>;b&lt;a;b++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h3><p>使用为四个for进行循环思想核心为中间数量为行数n的两倍减去1，外层循环控制换行，内层三个控制空格以及他的打印数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rows,i,j,space,star;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp; rows);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=rows;++i)</span><br><span class="line">    &#123;</span><br><span class="line">         star = <span class="number">2</span>*i <span class="number">-1</span> ;     <span class="comment">//星号个数</span></span><br><span class="line">         space = rows - i;   <span class="comment">//空格个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//左边空格</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;star;++j)       <span class="comment">//中间 *</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//右边空格有没有都可以</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, space, rows, k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter number of rows: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;rows);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=rows; ++i, k=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(space=<span class="number">1</span>; space&lt;=rows-i; ++space)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k != <span class="number">2</span>*i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断一个数字是否素数</p><p>判断一个数字是否能被比他小的数整除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;yes!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;x;i++)</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//一旦判断不是，跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==x) <span class="built_in">puts</span>(<span class="string">&quot;yes!&quot;</span>);<span class="comment">//如果是的话，for循环一定执行到了i=x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C语言二分查找"><a href="#C语言二分查找" class="headerlink" title="C语言二分查找"></a>C语言二分查找</h3><p>找到最左边元素（low）和最右边元素（high），确定中间元素（mid），比较中间元素（mid）和目标元素（k）的大小，调整low和high，再确定新的mid….我们要不断确定mid直到找到k，自然需要用到循环，我们有明确的目标：找到k。因此选择while循环，找到k后循环不再进行，而当low和high之间还有元素，即low在high的左边或与之重合，k就依然可能存在，所以循环条件为low&lt;&#x3D;high，接下来的问题在于怎样调整low和high的值，mid和k比较无非就三种情况：mid&lt;k，mid&gt;k,mid&#x3D;k。第一种情况，k在mid的右边，我们将low调整为mid+1，high不用调整；第二种情况，k在mid的左边，我们将high调整为mid-1，low不用调整。最后一种情况最简单，我们已经找到了k，直接将mid打印出来就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bin_Search</span><span class="params">(<span class="type">int</span> *num,<span class="type">int</span> cnt,<span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> first = <span class="number">0</span>,last = cnt<span class="number">-1</span>,mid;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(first &lt;= last)</span><br><span class="line">&#123;</span><br><span class="line">counter ++;</span><br><span class="line">mid = (first + last) / <span class="number">2</span>;<span class="comment">//确定中间元素</span></span><br><span class="line"><span class="keyword">if</span>(num[mid] &gt; target)</span><br><span class="line">&#123;</span><br><span class="line">last = mid<span class="number">-1</span>; <span class="comment">//mid已经交换过了,last往前移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num[mid] &lt; target)</span><br><span class="line">&#123;</span><br><span class="line">first = mid+<span class="number">1</span>;<span class="comment">//mid已经交换过了,first往后移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//判断是否相等</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找次数:%d\n&quot;</span>,counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找次数:%d\n&quot;</span>,counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>,target;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您要查找的数字:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;target);</span><br><span class="line">flag = Bin_Search(num,<span class="number">10</span>,target);</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;已经找到该数字!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;无该数字!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找数组最大值"><a href="#查找数组最大值" class="headerlink" title="查找数组最大值"></a>查找数组最大值</h3><h4 id="循环对比"><a href="#循环对比" class="headerlink" title="循环对比"></a>循环对比</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">findMaxValue(arr) &#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>; <span class="comment">// 最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123; <span class="comment">// 当前值大于最大值，赋值为最大值</span></span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串排列顺序"><a href="#字符串排列顺序" class="headerlink" title="字符串排列顺序"></a>字符串排列顺序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HALT <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stsrt</span><span class="params">(<span class="type">char</span> *strings [], <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> input[LIM][SIZE];</span><br><span class="line"><span class="type">char</span> *ptstr[LIM];</span><br><span class="line"><span class="type">int</span> ct = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input up to %d lines, and I will sort them.\n&quot;</span>, LIM);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;To stop ,press the Enter key at a line&#x27;s start.\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(ct &lt; LIM &amp;&amp; s_gets(input[ct], SIZE) != <span class="literal">NULL</span> &amp;&amp; input[ct][<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptstr[ct] = input[ct];</span><br><span class="line">ct ++;</span><br><span class="line">&#125;</span><br><span class="line">stsrt(ptstr, ct);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nHere&#x27;s the sorted list:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; ct; k++)</span><br><span class="line"><span class="built_in">puts</span>(ptstr[k]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stsrt</span><span class="params">(<span class="type">char</span> * strings[], <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * temp;</span><br><span class="line"><span class="type">int</span> top, seek;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(top = <span class="number">0</span>; top &lt; num - <span class="number">1</span>; top++)</span><br><span class="line"><span class="keyword">for</span>(seek = top + <span class="number">1</span>; seek &lt; num; seek++)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(strings[top], strings[seek]) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = strings[top];</span><br><span class="line">strings[top] = strings[seek];</span><br><span class="line">strings[seek] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * ret_val;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret_val = fgets(st , n , <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ret_val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(st[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> len)</span><span class="comment">//函数实现</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)<span class="comment">//需要进行len-1趟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//flag=1，说明已经排好序</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i;j++)<span class="comment">//每趟两两比较较未排好序元素个数-1次。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p[j] &gt; p[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = p[j];</span><br><span class="line">p[j] = p[j + <span class="number">1</span>];</span><br><span class="line">p[j + <span class="number">1</span>] = tmp;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag==<span class="number">1</span>)<span class="comment">//判断是否排好序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">46</span>,<span class="number">79</span>,<span class="number">12</span> &#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span> arr / <span class="keyword">sizeof</span> arr[<span class="number">0</span>];</span><br><span class="line">bubble_sort(arr,sz);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux工具vim</title>
      <link href="/2022/10/20/2022-10-20-Linux%E5%B7%A5%E5%85%B7vim/"/>
      <url>/2022/10/20/2022-10-20-Linux%E5%B7%A5%E5%85%B7vim/</url>
      
        <content type="html"><![CDATA[<p>vi编辑器是所有Unix及<a href="http://www.2cto.com/os/linux/">Linux</a>系统下标准的编辑器，他就相当于<a href="http://www.2cto.com/os/windows/">windows</a>系统中的记事本一样，它的强大不逊色于任何最新的文本编辑器。他是我们使用Linux系统不能缺少的工具。<a href="https://so.csdn.net/so/search?q=vim&spm=1001.2101.3001.7020">vim</a> 具有程序编辑的能力，可以以字体颜色辨别语法的正确性。</p><p>vi可以分为三种状态，分别是一般模式、编辑模式和命令行模式</p><p>一般模式：<br>以vi打开一个文件就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用上下左右按键来移动光标，你可以使用删除字符或删除整行来处理文件内容， 也可以使用复制、粘贴来处理你的文件数据。</p><p>编辑模式：<br>在一般模式中可以进行删除、复制、粘贴等的操作，但是却无法编辑文件的内容，只有当你按下【i, I, o, O, a, A, r, R】等任何一个字母之后才会进入编辑模式。这时候屏幕的左下方会出现【INSERT或 REPLACE】的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下【Esc】即可退出编辑模式。</p><p>命令行模式：<br>输入【 : &#x2F; ? 】三个中的任何一个，就可以将光标移动到最底下那一行。在这个模式中， 可以提供查找、读取、存盘、替换字符、离开vi、显示行号等的动作则是在此模式中完成的！</p><p>针对程序员配置</p><p>打开高亮功能，vim会通过文件的扩展名自动决定哪些是关键字。</p><p>：syntax on</p><p>自动缩进</p><p>：set autoindent</p><p>设置tab键的空格数</p><p>：set shiftwidth&#x3D;4</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/vimopen.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/vimParenthesis.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/sn.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/close.png"></p><p>如何在vim中进行搜索</p><p>想要在 Vim 中进行搜索，必须处于 normal 模式。当你启动 Vim 编辑器的时候，你就在这个模式。 想要从其他任何模式回到正常模式，仅仅需要按 ESC 按键。</p><p>Vim 允许你使用<code>/</code>和<code>?</code>快速搜索文本。</p><p>想要向前搜索按<code>/</code>，想要向后搜索按<code>?</code>，输入搜索样式，并且按<code>Enter</code>进行搜索：</p><p>Vim 搜索的基本步骤如下：</p><p>01.按<code>/</code></p><p>02.输入搜索样式</p><p>03.按<code>Enter</code>进行搜索</p><p>04.按<code>n</code>搜索下一个匹配结果，或者<code>N</code>查找前面一个匹配结果。</p><p>例如搜索gnu输入&#x2F;\&lt;gnu\&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——用户管理</title>
      <link href="/2022/10/19/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/19/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="添加新用户并建立主目录"><a href="#添加新用户并建立主目录" class="headerlink" title="添加新用户并建立主目录"></a>添加新用户并建立主目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uesradd -m john##添加用户叫john并建立主目录</span><br><span class="line">$ sudo passwd john##更改john的密码</span><br></pre></td></tr></table></figure><h4 id="添加用户命令行工具"><a href="#添加用户命令行工具" class="headerlink" title="添加用户命令行工具"></a>添加用户命令行工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useradd john##添加用户john</span><br><span class="line">$ passwd john##john设置密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -g users john##创立john并指定属于users组</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -s /bin/bash mike##建立mike用户并指定登陆后使用bash作为Shell</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd newgroup##在系统中太内疚newgroup的组</span><br></pre></td></tr></table></figure><h4 id="记录用户操作"><a href="#记录用户操作" class="headerlink" title="记录用户操作"></a>记录用户操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ history</span><br><span class="line">$ history 10##记录了最近用的10条指令</span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uesrdel mike##删除用户mike</span><br><span class="line">$ sudo userdel -r john##删除john删除其主目录</span><br></pre></td></tr></table></figure><h4 id="管理用户账号"><a href="#管理用户账号" class="headerlink" title="管理用户账号"></a>管理用户账号</h4><p><a href="https://cdn2.pandaimg.com/2022/10/19/634ff773348ce.png"><img src="https://cdn2.pandaimg.com/2022/10/19/634ff773348ce.png" alt="屏幕截图 2022-10-19 211029.png"></a></p><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ id hanfeng##查看用户的UID、GID及所属组的信息</span><br></pre></td></tr></table></figure><h4 id="用户转换"><a href="#用户转换" class="headerlink" title="用户转换"></a>用户转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su john##进入john用户</span><br><span class="line">$ exit##回到之前的用户</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇-压缩与解压缩</title>
      <link href="/2022/10/18/2022-10-18-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
      <url>/2022/10/18/2022-10-18-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h4 id="gzip压缩工具"><a href="#gzip压缩工具" class="headerlink" title="gzip压缩工具"></a>gzip压缩工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gzip gztest##压缩gztest</span><br><span class="line">$ gzip -d gztest##解压缩gztest</span><br><span class="line">$ gzip -r gztest##对文件夹压缩</span><br><span class="line">$ gzip -rd gztest.gz##对文件夹解压缩</span><br></pre></td></tr></table></figure><p>gzip 虽然对文件夹进行压缩，但是不能提供打包服务，只对文件夹<strong>内部的文件进行单独压缩。</strong></p><h4 id="bzip2压缩工具"><a href="#bzip2压缩工具" class="headerlink" title="bzip2压缩工具"></a>bzip2压缩工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bzip2 -z a.c##压缩</span><br><span class="line">$ bzip2 -d a.c.bz2##解压缩</span><br></pre></td></tr></table></figure><h4 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h4><p>tar工具提供打包服务，就是将多个文件打包。常用参数-f归档 ,-c创建新归档创建压缩文件，-x：从文档中解压缩</p><p>-j：使用bzip2压缩格式，-z 使用gzip压缩格式 -v 打印命令执行过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar -vxjf xxx.tar.bz2##解压缩</span><br><span class="line">$ tar -vcjf xxx.tar.bz2 xxx ##压缩</span><br><span class="line">$ tar -vxzfxxx.tar.gz##解压缩</span><br><span class="line">$ tar -vczf xxx.tar.gz xxx ##压缩</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇-软件包管理</title>
      <link href="/2022/10/16/2022-10-16-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/16/2022-10-16-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="管理-deb软件包"><a href="#管理-deb软件包" class="headerlink" title="管理.deb软件包"></a>管理.deb软件包</h4><h6 id="查看已安装的软件包"><a href="#查看已安装的软件包" class="headerlink" title="查看已安装的软件包"></a>查看已安装的软件包</h6><p> OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dpkg -l | grep openssh##查找openssh的版本信息</span><br><span class="line">$ dekg -s openssh##查看哪些文件是openssh带来的</span><br></pre></td></tr></table></figure><h6 id="安装卸载软件包"><a href="#安装卸载软件包" class="headerlink" title="安装卸载软件包"></a>安装卸载软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$sudo dpkg -i xxx.deb##安装xxx</span><br><span class="line"></span><br><span class="line">$sudo dpkg --remove opera##删除opera浏览器</span><br></pre></td></tr></table></figure><h4 id="管理RPM软件包"><a href="#管理RPM软件包" class="headerlink" title="管理RPM软件包"></a>管理RPM软件包</h4><h6 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -i -v -h dump-0.4b41-1.src.rpm##-i是安装命令-v显示正在执行工作-h打印提醒进度</span><br></pre></td></tr></table></figure><p>升级安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -Uvh dump-0.4b41-1.src.rpm</span><br></pre></td></tr></table></figure><p>查看已经安装的软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -q check##rpm -q命令可以查询已经安装的软件包是安装包文件的名字，不是文件的名字</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/16/634ba96fd0a8e.png"><img src="https://cdn2.pandaimg.com/2022/10/16/634ba96fd0a8e.png" alt="屏幕截图 2022-10-16 144841.png"></a></p><h6 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -e tcpdump##卸载tcpdump软件包</span><br></pre></td></tr></table></figure><h4 id="高级软件包工具APT"><a href="#高级软件包工具APT" class="headerlink" title="高级软件包工具APT"></a>高级软件包工具APT</h4><h6 id="下载和安装软件包"><a href="#下载和安装软件包" class="headerlink" title="下载和安装软件包"></a>下载和安装软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update##更新软件包</span><br><span class="line">$ sduo apt-get install wesnoth##下载安装wesnoth</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/16/634baf70f406c.png"><img src="https://cdn2.pandaimg.com/2022/10/16/634baf70f406c.png" alt="屏幕截图 2022-10-16 151437.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get -h##可以列出apt-get的完整用法</span><br></pre></td></tr></table></figure><h6 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache search flight##搜索带有flight的软件包</span><br><span class="line">$ apt-cache depends flightgear##查询flightgear的依赖关系</span><br></pre></td></tr></table></figure><p>apt-get是安装源放在&#x2F;etc&#x2F;apt&#x2F;source.list中，这是一个文本文件。</p><h6 id="源码文件安装"><a href="#源码文件安装" class="headerlink" title="源码文件安装"></a>源码文件安装</h6><p>make先编译</p><p>之后使用make install具体方法看软件安装要求</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——磁盘管理</title>
      <link href="/2022/10/16/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/16/2022-10-19-Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="磁盘管理三个常用的命令fdisk、du、df"><a href="#磁盘管理三个常用的命令fdisk、du、df" class="headerlink" title="磁盘管理三个常用的命令fdisk、du、df"></a>磁盘管理三个常用的命令fdisk、du、df</h4><p>df：检查文件系统的整体磁盘使用量</p><p>du：检查磁盘空间使用量</p><p>fdisk：用于磁盘的分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df [-ahikHTm][目录或文件名]##具体参数可以查看 df --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du [-ahskm] 文件或目录名称    ##具体参数可以查看 du --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk [-l] 装置名称##fdisk是Linux的磁盘分区表操作工具</span><br></pre></td></tr></table></figure><p>若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</p><p>linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。fsck（file system check）用来检查和维护不一致的文件系统。</p><p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck [-t 文件系统] [-ACay] 装置名称</span><br></pre></td></tr></table></figure><p>磁盘挂载使用mount卸载使用umount命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure><p>关于具体操作事例可以看<a href="https://zhuanlan.zhihu.com/p/296777898">一篇看懂！Linux磁盘的管理（分区、格式化、挂载），LVM逻辑卷，RAID磁盘阵列 - 知乎 (zhihu.com)</a></p><h4 id="创建并使用一个分区的步骤"><a href="#创建并使用一个分区的步骤" class="headerlink" title="创建并使用一个分区的步骤"></a>创建并使用一个分区的步骤</h4><p>①创建分区并分配空间</p><p>②磁盘格式化</p><p>③将格式化后的磁盘进行挂载</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——文件目录管理指令</title>
      <link href="/2022/10/13/2022-10-13-Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/10/13/2022-10-13-Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>linux系统不存在盘这个概念，用户通过操作目录来实现磁盘读写，Linux需要首先建立一个根‘“&#x2F;”文件系统，并在这个文件系统中建立一系列空目录，然后将其他硬盘分区中的 文件系统挂载到这些目录中。</p><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347abc1a4403.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347abc1a4403.png" alt="屏幕截图 2022-10-13 140836.png"></a></p><h6 id="用户间共享文件"><a href="#用户间共享文件" class="headerlink" title="用户间共享文件"></a>用户间共享文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##新建一个名为workgroup的用户组</span><br><span class="line">$ sudo groupadd workgroup</span><br><span class="line">##新建用户，并归入workgroup组</span><br><span class="line">$sudo useradd -G workgroup lucy</span><br><span class="line">$sudo passwd lucy##为用户lewis设置登录密码</span><br><span class="line">$sudo useradd -G workgroup lewis</span><br><span class="line">$sudo passwd lewis##为用户peter设置登录密码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="建立文件和目录"><a href="#建立文件和目录" class="headerlink" title="建立文件和目录"></a>建立文件和目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~##进入用户主目录</span><br><span class="line">$ mkdir document picture##新建两个目录</span><br><span class="line">$ mkdir ~/picture/temp##在主目录下新建名为temp的目录</span><br><span class="line">##如果没有中间的目录也就无法在下面创建一个新的文件或目录为此，使用-p选项</span><br><span class="line">$ mkdir -p ~/tempx/job##创建一个tempx文件夹在下面创建一个job文件夹</span><br></pre></td></tr></table></figure><h6 id="建立一个空文件"><a href="#建立一个空文件" class="headerlink" title="建立一个空文件"></a>建立一个空文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch hello##新建一个hello的文件</span><br><span class="line">$ touch hello##已经有hello的文件，所以可以更新hello文件的创建日期</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="移动和重命名"><a href="#移动和重命名" class="headerlink" title="移动和重命名"></a>移动和重命名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv hello bin/##移动hello到bin/中</span><br><span class="line">$ mv photos/桌面/   ##移动photos目录到桌面</span><br><span class="line">$ mv -i hello test/##使用防止替换同名文件并加以提示.</span><br><span class="line">$ mv -b hello test/##在目标目录的同名文件后面加上~，相当于重命名</span><br></pre></td></tr></table></figure><h6 id="复制文件和目录"><a href="#复制文件和目录" class="headerlink" title="复制文件和目录"></a>复制文件和目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp test.php test/##将test.php 放入到test下</span><br><span class="line">$ cp -i test.php test/##提示是否覆盖同名文件</span><br><span class="line">$ cp -r test/ 桌面/   ##连子目录带文件一起复制到下面</span><br></pre></td></tr></table></figure><h6 id="删除目录和文件"><a href="#删除目录和文件" class="headerlink" title="删除目录和文件"></a>删除目录和文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rmdir remove##删除目录</span><br><span class="line">$ rmdir text/*.php##删除test目录下的所有php文件</span><br><span class="line">$ rmdir -r test##删除前有提示</span><br><span class="line">$ rmdir -f##避免交互直接回答y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="改变文件所有权"><a href="#改变文件所有权" class="headerlink" title="改变文件所有权"></a>改变文件所有权</h6><p>chown语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [OPTION]... [OWNEr][:[GROUP]] FILE..</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347f350c425d.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347f350c425d.png" alt="屏幕截图 2022-10-13 191232.png"></a></p><p>sudo 提供-R选项用于改变一个目录及其下所有文件的所有权设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R lewis iso/##将iso/和下面所有文件交给lewis</span><br></pre></td></tr></table></figure><h6 id="改变目标文件权限"><a href="#改变目标文件权限" class="headerlink" title="改变目标文件权限"></a>改变目标文件权限</h6><p>chmod用于改变一个文件的权限。使用用户组+&#x2F;-权限的表达方式，来增加&#x2F;删除权限。用户组包括文件属主（u）、文件数组（g）、其他人（o）和所有人（a），权限包括读取（r）、写入（w）和执行（x）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod u+x days##增加属主对文件的执行权限</span><br><span class="line">$ chmod a-x days##删除所有人对days的执行权限</span><br><span class="line">$ chmod o=u days##将其他人的权限和属主一致</span><br></pre></td></tr></table></figure><h6 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h6><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347f9e831a3c.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347f9e831a3c.png" alt="屏幕截图 2022-10-13 194308.png"></a></p><p>Linux有两类设备文件：字符设备和块设备文件。字符设备指的是能够从他那里读取成字符序列的设备，如磁带和串行线路，块设备指的是用来存储数据并对其各部分内容提供同等访问权的设备。如磁盘。</p><h6 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h6><p>符号链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s days my_days##建立一个my_days的符号链接指向文本文件days</span><br></pre></td></tr></table></figure><p>访问my_days就相当于访问days了。可以看作快捷方式删除并不会对源文件有影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s /usr/local/share/ local_share##建立一个指向/usr/local/share的符号链接local_share</span><br></pre></td></tr></table></figure><p>硬链接：将两个独立的文件联系在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln days hard_days##建立一个链接到days的新文件hard_days</span><br></pre></td></tr></table></figure><p>两个文件的改动会相互影响。</p><h6 id="输入输出重定向和管道"><a href="#输入输出重定向和管道" class="headerlink" title="输入输出重定向和管道"></a>输入输出重定向和管道</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls &gt; ~/ls_out##将ls的输出重定向到lsout文件中，ls的输出不显示在屏幕上</span><br></pre></td></tr></table></figure><p>如果ls_out不存在那么会尝试建立这个文件，如果已经存在会替换原来的文件内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; days##让程序从一个文件中获取输入</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/13/634808e94fcc6.png"><img src="https://cdn2.pandaimg.com/2022/10/13/634808e94fcc6.png" alt="屏幕截图 2022-10-13 204659.png"></a></p><h6 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h6><p><a href="https://cdn2.pandaimg.com/2022/10/13/6348095b998d1.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6348095b998d1.png" alt="屏幕截图 2022-10-13 204909.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——基本指令</title>
      <link href="/2022/10/12/2022-10-12-Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/10/12/2022-10-12-Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h6 id="浏览文件硬盘"><a href="#浏览文件硬盘" class="headerlink" title="浏览文件硬盘"></a>浏览文件硬盘</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /         ##进入根目录</span><br><span class="line">$ ls           ##列出文件和目录</span><br><span class="line">$ cat animal.c ##查看animal.c</span><br></pre></td></tr></table></figure><p>在输入文件名时候，只用输入前面几个字符按下TAB，Shell会自动补全。如果不止一个，shell会以列表形式全部打印出来。</p><h6 id="查看目录和文件"><a href="#查看目录和文件" class="headerlink" title="查看目录和文件"></a>查看目录和文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pwd                     ##显示当前目录</span><br></pre></td></tr></table></figure><h6 id="改变目录"><a href="#改变目录" class="headerlink" title="改变目录"></a>改变目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..##进入/usr子目录</span><br><span class="line">$ cd ../..##进入根目录即/目录</span><br><span class="line">$ cd ##回到用户主目录</span><br></pre></td></tr></table></figure><h6 id="列出目录"><a href="#列出目录" class="headerlink" title="列出目录"></a>列出目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -a##查看目录下的所有文件包含隐藏文件</span><br><span class="line">$ ls -1##查看文件的各种属性</span><br><span class="line">$ ls -F##区分目录下文件类型</span><br></pre></td></tr></table></figure><h6 id="列出目录-1"><a href="#列出目录-1" class="headerlink" title="列出目录"></a>列出目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dir##和ls一样</span><br><span class="line">$ vdir##相当于ls-1</span><br></pre></td></tr></table></figure><h6 id="查看文本文件"><a href="#查看文本文件" class="headerlink" title="查看文本文件"></a>查看文本文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat bool。c##查看bool.c文件的内容</span><br><span class="line">$ cat bool.c data.c##查看bool.c data.c 文件内容，可以查看不只一个文件内容</span><br><span class="line">$ cat -n bool.c##可以问内容前显示行数</span><br></pre></td></tr></table></figure><h6 id="阅读的文件开头和结尾"><a href="#阅读的文件开头和结尾" class="headerlink" title="阅读的文件开头和结尾"></a>阅读的文件开头和结尾</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ head data.c##显示data。c的开头</span><br><span class="line">$ head -n 2 data.c##显示data.c文件的前两行</span><br></pre></td></tr></table></figure><h6 id="文本阅读less"><a href="#文本阅读less" class="headerlink" title="文本阅读less"></a>文本阅读less</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ less /c/data.c##打开C下的data.c文件</span><br><span class="line">之后向下翻页按空格向上翻页按B使用/内容，可以查询高亮显示查询下一个再输入/</span><br><span class="line">按下q可退出</span><br></pre></td></tr></table></figure><h6 id="查找文件内容"><a href="#查找文件内容" class="headerlink" title="查找文件内容"></a>查找文件内容</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep main data.c##查找data.c中包含main的行</span><br><span class="line">$ grep main data.c animal.c     ##可以在多个文件中查找，查关键词时候要加上‘’单引号</span><br></pre></td></tr></table></figure><h6 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [OPTION] [path..] [expression]</span><br><span class="line">$ find c/d/2.c##c/d/2.c</span><br><span class="line">$ find c/d -name 2.c##c/d2.c</span><br><span class="line">$ find c/d -name 2.c -printf ok ##ok</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find c/d -type f -mtime -7 ##7天内修改过的文件</span><br></pre></td></tr></table></figure><h6 id="快速定位文件"><a href="#快速定位文件" class="headerlink" title="快速定位文件"></a>快速定位文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locate *.c</span><br></pre></td></tr></table></figure><h6 id="查找特定程序"><a href="#查找特定程序" class="headerlink" title="查找特定程序"></a>查找特定程序</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ whereis find##查找find</span><br><span class="line">$ whereis -b find##查找这个程序的二进制可执行文件</span><br></pre></td></tr></table></figure><h6 id="用户版本信息查看"><a href="#用户版本信息查看" class="headerlink" title="用户版本信息查看"></a>用户版本信息查看</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ who##看有哪些人登录</span><br><span class="line">$ whoami##我是谁</span><br></pre></td></tr></table></figure><h6 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a##显示系统版本信息</span><br><span class="line">$ uname -r##显示内核版本信息</span><br></pre></td></tr></table></figure><h6 id="寻求帮助指令"><a href="#寻求帮助指令" class="headerlink" title="寻求帮助指令"></a>寻求帮助指令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man find##获取find指令的信息</span><br></pre></td></tr></table></figure><h6 id="获取命令简介"><a href="#获取命令简介" class="headerlink" title="获取命令简介"></a>获取命令简介</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whatis uame##-printf system information</span><br></pre></td></tr></table></figure><h6 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h6><p>ldd可以列出一个程序所需要的共享库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldd animal##查询animal文件需要的animal文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32实战篇</title>
      <link href="/2022/10/09/2022-10-9-stm32%E5%AE%9E%E6%88%98%E7%AF%87/"/>
      <url>/2022/10/09/2022-10-9-stm32%E5%AE%9E%E6%88%98%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="实战第一篇跑马灯"><a href="#实战第一篇跑马灯" class="headerlink" title="实战第一篇跑马灯"></a>实战第一篇跑马灯</h2><p>第一篇没什么好说的，没什么新鲜的东西，就是使用cubemx进行建立工程，新建led.c和led.h文件，对引脚进行赋予高低电平，此次不一样的是在led.h文件中对相应的IO口用英文做了宏定义，防止以后进行重复混乱调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_PIN         GPIO_PIN_8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_GPIO_PORT   GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_PIN         GPIO_PIN_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_GPIO_PORT   GPIOD</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="实战第二篇按键检测"><a href="#实战第二篇按键检测" class="headerlink" title="实战第二篇按键检测"></a>实战第二篇按键检测</h2><h4 id="硬件消抖"><a href="#硬件消抖" class="headerlink" title="硬件消抖"></a>硬件消抖</h4><p>首先是硬件的设计，按下按键不会立即响应，有波纹信号，不方便检测需要进行滤波消抖。可以利用电容的放电延迟达到消除抖动的目的，这样只需要检测引脚的电平。</p><p><a href="https://postimg.cc/62dPcFkc"><img src="https://i.postimg.cc/hjwqDBMk/2022-09-27-181925.png" alt="2022-09-27-181925.png"></a></p><h4 id="软件消抖"><a href="#软件消抖" class="headerlink" title="软件消抖"></a>软件消抖</h4><p>当检测到按键状态变化后，先等待一个10ms左右的延时时间，让抖动消失后再进行一次按键状态检测，如果与刚才的状态相同，就是稳定了，但是有局限性。</p><p>查询相关IO口在cubemx中进行设置为输入状态。由于引脚的默认电平受按键电路影响，所以设置成“浮空&#x2F;上拉&#x2F;下拉”模式均没有区别。</p><p>arm汇编指令集</p><p><a href="https://postimg.cc/v413R6K1"><img src="https://i.postimg.cc/zG7MgCSk/2022-09-27-202146.png" alt="2022-09-27-202146.png"></a></p><p>栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部 SRAM 的大<br>小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。如果某一天，你<br>写的程序出现了莫名奇怪的错误，并进入了硬 fault 的时候，这时你就要考虑下是不是栈不够大，<br>溢出了。堆主要用来动态内存的分配</p><h2 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h2><p>设置系统时钟 SYSCLK、设置 AHB 分频因子（决定 HCLK 等于多少）、设置 APB2 分频因子（决<br>定 PCLK2 等于多少）、设置 APB1 分频因子（决定 PCLK1 等于多少）、设置各个外设的分频因子；<br>控制 AHB、APB2 和 APB1 这三条总线时钟的开启、控制每个外设的时钟的开启。</p><p>一般是：PCLK2 &#x3D; HCLK &#x3D; SYSCLK&#x3D;PLLCLK &#x3D; 72M，<br>               PCLK1&#x3D;HCLK&#x2F;2 &#x3D; 36M</p><p>HSE 是高速的外部时钟信号，可以由有源晶振或者无源晶振提供，频率从 4-16MHZ 不等。当<br>使用有源晶振时，时钟从 OSC_IN 引脚进入，OSC_OUT 引脚悬空，当选用无源晶振时，时钟从<br>OSC_IN 和 OSC_OUT 进入，并且要配谐振电容。</p><p>系统时钟 SYSCLK 经过 AHB 预分频器分频之后得到时钟叫 APB 总线时钟，即 HCLK。</p><p>APB2 总线时钟 PCLK2 由 HCLK 经过高速 APB2 预分频器得到，HCLK2 属于高速的总线时钟，片上<br>高速的外设就挂载到这条总线上。APB1 总线时钟 PCLK1 由 HCLK 经过低速 APB 预分频器得到，PCLK1 属于低速的总线时钟，最高为 36M，片上低速的外设就挂载到这条总线上，比如 USART2&#x2F;3&#x2F;4&#x2F;5、SPI2&#x2F;3，I2C1&#x2F;2 等。</p><p>USB 时钟是由 PLLCLK 经过 USB 预分频器得到，USB 对时钟要求比较高，所以 PLLCLK 只能是由 HSE 倍频得到，不能使用 HSI 倍频。</p><p>ADC 时钟由 PCLK2 经过 ADC 预分频器得到。</p><p>RTC 时钟可由 HSE&#x2F;128 分频得到，也可由低速外部时钟信号 LSE 提供，频率为 32.768KHZ，也可由<br>低速内部时钟信号LSI提供。独立看门狗的时钟由 LSI 提供，且只能是由 LSI 提供，LSI 是低速的内部时钟信号，频率为 30~60KHZ 直接不等，一般取 40KHZ。</p><h2 id="中断应用"><a href="#中断应用" class="headerlink" title="中断应用"></a>中断应用</h2><p>在 NVIC 有一个专门的寄存器：中断优先级寄存器 NVIC_IPRx，用来配置外部中断的优先级，IPR宽度为 8bit，原则上每个外部中断可配置的优先级为 0~255，数值越小，优先级越高。如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行，如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。</p><p>IRQn：用来设置中断源</p><p>PreemptionPriority：抢占优先级</p><p>SubPriority：子优先级</p><h5 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h5><p>EXTI（External interrupt&#x2F;event controller）—外部中断&#x2F;事件控制器，管理了控制器的 20 个中断&#x2F;事件线。每个中断&#x2F;事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。</p><p>产生中断线路目的是把输入信号输入到 NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。而产生事件线路目的就是传输一个脉冲信号给其他外设使用，并且是电路级别的信号传输，属于硬件级的。</p><p>cubemx进行引脚配置，对相应的IO引脚选择GPIO_EXITx,xi表示挂载在中断线几，如GPIO_EXTI0就是挂在中断线0上。</p><p>开启下降沿触发中断：即在 <strong>按下按键时</strong> 电平由高变为低时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Falling edge trigger detection</code> </p><p>开启上升沿触发中断：即在 <strong>按下按键后松开时</strong> 电平由低变为高时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising edge trigger detection</code> </p><p>开启下降沿上升沿都触发中断：即在 <strong>按下时触发，松开时再次触发</strong>，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising/Falling edge trigger detection</code></p><p>如果硬件上已外部上拉或下拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>No pull-up and no pull-down</code> 既不上拉也不下拉。</p><p>如果硬件外部没有上拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>Pull-up</code> 内部上拉电阻。</p><p>如果不希望电平跳变事件触发中断，就配置为事件模式，反之，配置为中断模式。</p><p>中断执行流程为先中断初始化，使用中断可以避免使用论询来检测，发生电平变化触发外部中断，进入中断服务函数，中断服务函数中会调用中断处理公用函数（使用cubemx会在stm32f1xx_it.c中自动生成），中断处理公用函数中会检测标志位，并清零执行回调函数，终端中要执行的事情就放入中断回调函数中。</p><p>可以在stm32f1xx_it.c中看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 0 */</span></span><br><span class="line">  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go to Defnition of HAL_GPIO_EXTI_IRQHandler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">  <span class="keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="number">0x00</span>u)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断并清除中断标志位，然后调用HAL_GPIO_EXTI_Callback(GPIO_Pin);处理中断，同样的方式找到HAL_GPIO_EXTI_Callback的定义，你可以看到这个函数的声明前面有一个__weak声明，这个声明表示这个函数一旦被重新声明，这里的函数就自动失效，其他函数调用的时候就会找到你新定义的同名函数。</p><h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h2><p>通讯协议，我们也以分层的方式来理解，最基本的是把它分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。串口通讯有很多标准，以下是RS-232标准</p><p><a href="https://postimg.cc/zHmFByDH"><img src="https://i.postimg.cc/d33H5Cz6/2022-09-30-200343.png" alt="2022-09-30-200343.png"></a></p><p>由于 RS-232 电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个“电平转换芯片”转换成控制器能识别的“TTL 标准”的电平信号，才能实现通讯。电平标准不同分为TTL标准和RS232电平标准</p><p><a href="https://postimg.cc/LhHzyFYp"><img src="https://i.postimg.cc/2jW2SzCV/2022-09-30-201456.png" alt="2022-09-30-201456.png"></a></p><p><a href="https://postimg.cc/MXCz6q7k"><img src="https://i.postimg.cc/zXBvkf3f/2022-09-30-201723.png" alt="2022-09-30-201723.png"></a></p><p>通用同步异步收发器 (Universal Synchronous Asynchronous Receiver and Transmitter) 是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。有别于 USART 还有一个 UART(UniversalAsynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能，只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</p><p>串口通信有三种方式，分别为论询方式、中断方式、DMA方式。串口的通讯协议由开始位，数据位，校验位，结束位构成。一般以一个低电平作为一帧数据的起始，接着跟随 8 位或者 9 位数据位，之后为校验位，分为奇校验，偶校验和无校验，最后以一个先高后低的脉冲表示结束位，长度可以设置为 0.5，1，1.5 或 2 位长度。</p><p>当使用校验位时，串口传输的长度将是 8 位的数据帧加上 1 位的校验位总共 9 位，此时 USART_CR1 寄存器的 M 位需要设置为 1，即 9 数据位。将 USART_CR1 寄存器的 PCE 位置 1 就可以启动奇偶校验控制，奇偶校验由硬件自动完成。启动了奇偶校验控制之后，在发送数据帧时会自动添加校验位，接收数据时自动验证校验位。接收<br>数据时如果出现奇偶校验位验证失败，会见 USART_SR 寄存器的 PE 位置 1，并可以产生奇偶校验中断。使能了奇偶校验控制后，每个字符帧的格式将变成：起始位 + 数据帧 + 校验位 + 停止位</p><p>​      什么是硬件流控呢？流控的概念源于 RS232 这个标准，在 RS232 标准里面包含了串口、流控的定义。大家一定了解，RS232 中的“RS”是Recommend Standard 的缩写，即”推荐标准“之意，它并不像 IEEE-1284、IEEE-1394 等标准，是由“委员会定制”。因而，不同的厂商在做 RS232 时，多少会有不同，流控也都会存在差异。</p><p>为什么需要流控?</p><p>　　数据在两个串口之间进行通讯的时候常常会出现丢失数据的现象，比如两台计算机或者是一台计算机和一个单片机之间进行通讯，当接收端的数据缓冲区已经满了，这个时候如果还有数据发送过来，因为接收端没有时间进行处理，那这样的数据就有可能会丢失。在工业现场或者其他领域，经常会遇到这种问题，本质原因是速度不匹配、处理能力不匹配。比如单片机的主频只有20M或30M，ARM的处理能力可能是200M，PC机的处理能力是几个G，这种处理能力的不匹配造成了传输的时候数据容易丢失。</p><p>　　硬件流控就是来解决这个速度匹配的问题。它的基本含义非常简单，当接收端接收到的数据处理不过来时，就向发送端发送不再接收的信号，发送端接收到这个信号之后就会停止发送，直到收到可以继续发送的信号再继续发送。因此流控本身是可以控制数据传输的进度，进而防止数据丢失。</p><p>　　一般常用的流控方式有两种：硬件流控和软件流控。</p><p>​硬件流控和软件流控的区别</p><p>　　软件流控是以特殊的字符来代表从机已经不能再接收新的数据了，基本的流程就是从机在接收数据很多的时候或主动给发送端发送一个特殊字符，当发送端接收到这个特殊字符后就不能再发送数据了。</p><p>　　软件流控很方便，不需要增加新的硬件，还是以前的TX、RX，但是使用了软件流控，它本身的字符也是数据，这个数据只不过是说在软件里把它设置了一个特殊的含义。如果它是一个全双工的通讯，在给另一个串口发送数据的时候如果也包含了这样一个特殊字符，对方就会误以为我让它不要再发送数据了，会有一定的概率出现错误，而硬件流控就不需要考虑这方面，只需要使用 CTS 和 RTS，所有的数据都是由硬件来操作的。具体可以看<img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20230227_210206.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line">HAL_UART_Transmit();串口轮询模式发送，使用超时管理机制</span><br><span class="line">HAL_UART_Receive();串口轮询模式接收，使用超时管理机制</span><br><span class="line">HAL_UART_Transmit_IT();串口中断模式发送</span><br><span class="line">HAL_UART_Receive_IT();串口中断模式接收</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式发送</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式接收</span><br><span class="line"><span class="number">2</span>、阻塞传输是调用这个函数并在等待时间内一直等待操作完成。</span><br><span class="line">HAL_UART_Transmit</span><br><span class="line">HAL_UART_Receive</span><br><span class="line">查询的方式一般少用，这里不做过多介绍。</span><br><span class="line"><span class="number">3</span>、串口中断</span><br><span class="line">串口中断函数</span><br><span class="line">HAL_UART_TxHalfCpltCallback();一半数据发送完成时调用</span><br><span class="line">HAL_UART_TxCpltCallback();数据完全发送完成后调用</span><br><span class="line">HAL_UART_RxHalfCpltCallback();一半数据接收完成时调用</span><br><span class="line">HAL_UART_RxCpltCallback();数据完全接受完成后调用</span><br><span class="line">HAL_UART_ErrorCallback();传输出现错误时调用</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Qxiaofei_/article/details/119029425">(具体配置) 【STM32】HAL库——串口中断通信(二)_Q大帅的博客-CSDN博客_hal 串口中断</a></p><p>当printf打印不好使时是因为工程中没有选Micro USB</p><p><a href="https://postimg.cc/Z9kXMvXH"><img src="https://i.postimg.cc/XvX3Xw8R/2022-10-04-193120.png" alt="2022-10-04-193120.png"></a></p><p><a href="https://blog.csdn.net/zxt510001/article/details/125892562">() STM32 HAL库串口串口通信基础知识+HAL库代码理解</a></p><h2 id="DMA-直接存储访问"><a href="#DMA-直接存储访问" class="headerlink" title="DMA-直接存储访问"></a>DMA-直接存储访问</h2><p>DMA是单片机外设，不占用CPU，传输数据时候CPU可以做别的。如果外设要想通过 DMA 来传输数据，必须先给 DMA 控制器发送 DMA 请求，DMA 收到请求信号之后，控制器会给外设一个应答信号，当外设应答后且 DMA 控制器收到应答信号之后，就会启动 DMA 的传输，直到传输完毕。DMA有12个可独立编程通道，每个通道对应不同的外设DMA请求，可以接受多个请求，但同时只能接受一个。仲裁器，处理响应顺序的问题，分为软件阶段和硬件阶段，可以在 DMA_CCRx 寄存器中设置，有 4 个等级：非常高、高、中和低四个优先级，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高。</p><p>MA 传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器。具体的方向 DMA_CCR 位 4 DIR 配置：0 表示从外设到存储器，1 表示从存储器到外设。</p><p>更多原理可参看<a href="https://blog.csdn.net/as480133937/article/details/104927922"> DMA原理</a></p><p>在cubemx的配置只需要加上相应设备的DMA模式便可以生成代码进行使用。</p><p>I2C协议</p><p>首先分为物理层和协议层，两方面来看。</p><h4 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h4><p>它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。</p><p>一个 I2C 总线只使用两条总线线路，一条双向串行数据线 (SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。</p><p> 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。</p><p>总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</p><p>多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p><p>具有三种传输模式：标准模式传输速率为 100kbit&#x2F;s ，快速模式为 400kbit&#x2F;s ，高速模式下可达 3.4Mbit&#x2F;s，但目前大多 I2C 设备尚不支持高速模式</p><h4 id="协议层："><a href="#协议层：" class="headerlink" title="协议层："></a>协议层：</h4><p>I2C 的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。</p><p>S 表示由主机的 I2C 接口产生的传输起始信号 (S)，这时连接到 I2C 总线上的所有从机都会接收到这个信号。<br>起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号 (SLAVE_ADDRESS)。在I2C 总线上，每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7位或 10 位。在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。从机接收到匹配的地址后，主机或从机会返回一个应答 (ACK) 或非应答 (NACK) 信号，只有接收<br>到应答信号后，主机才能继续发送或接收数据。</p><p>若是传输为写数据方向，接收到应答信号后，主机开始正式向从机传输数据 (DATA)，数据包的大小为 8 位那么主机每发送完一个字节数据，都要等待从机的应答信号 (ACK)。</p><p>若配置的方向传输位为“读数据”方向，接收到应答信号后，从机开始向主机返回数据 (DATA)，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号 (ACK)。</p><p><a href="https://cdn2.pandaimg.com/2022/10/11/634564df3130c.png"><img src="https://cdn2.pandaimg.com/2022/10/11/634564df3130c.png" alt="SDA.png"></a></p><h5 id="SCL处于1时-SDA由高变低↓—-gt-Start"><a href="#SCL处于1时-SDA由高变低↓—-gt-Start" class="headerlink" title="SCL处于1时, SDA由高变低↓—&gt;Start"></a>SCL处于1时, SDA由高变低↓—&gt;Start</h5><h5 id="图中末尾P为结束信号-SCL-x3D-1-SDA-由低变高"><a href="#图中末尾P为结束信号-SCL-x3D-1-SDA-由低变高" class="headerlink" title="图中末尾P为结束信号: SCL&#x3D;1, SDA 由低变高"></a>图中末尾P为结束信号: SCL&#x3D;1, SDA 由低变高</h5><h5 id="数据传送-每次数据传送都是8个字节-SCL-x3D-1时-SDA的数据不可以变化-只有SCL为低电平-数据线的数据才可以变化"><a href="#数据传送-每次数据传送都是8个字节-SCL-x3D-1时-SDA的数据不可以变化-只有SCL为低电平-数据线的数据才可以变化" class="headerlink" title="数据传送: 每次数据传送都是8个字节; SCL&#x3D;1时, SDA的数据不可以变化, 只有SCL为低电平, 数据线的数据才可以变化;"></a>数据传送: 每次数据传送都是8个字节; SCL&#x3D;1时, SDA的数据不可以变化, 只有SCL为低电平, 数据线的数据才可以变化;</h5><p><a href="%5B(88%E6%9D%A1%E6%B6%88%E6%81%AF"> IIchal相关函数分析</a> <a href="https://blog.csdn.net/kouxi1/article/details/123834448?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32hal%E5%BA%93iic&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-123834448.142%5Ev52%5Econtrol,201%5Ev3%5Econtrol&spm=1018.2226.3001.4187">015] [STM32] IIC协议详解与HAL库相关函数分析_柯西的彷徨的博客-CSDN博客</a>)</p><h2 id="SPI协议"><a href="#SPI协议" class="headerlink" title="SPI协议"></a>SPI协议</h2><p>SPI是一种高速全双工的通信总线</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>SPI 通讯使用 3 条总线及片选线，3 条总线分别为 SCK、MOSI、MISO，片选线</p><p>从设备选择信号线，常称为片选信号线，也称为 NSS、CS设备的其它信号线 SCK、MOSI 及 MIS O 同时并联到相同的 SPI 总线上，即无论有多少个从设备，都共同只使用这 3 条总线；而每个从设备都有独立的这一条 NSS 信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。而 SPI 协议中没有设备地址，它使用 NSS 信号线来寻址，当主机要选择从设备时，把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI 通讯。所以 SPI 通讯以 NSS 线置低电平为开始信号，以 NSS 线被拉高作为结束信号。</p><p>SCK ：时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样。<br> MOSI ：主设备输出&#x2F;从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。<br>MISO(Master Input,，Slave Output)：主设备输入&#x2F;从设备输出引脚。主机从这条信线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。</p><p><a href="https://cdn2.pandaimg.com/2022/10/11/63457405a869b.png"><img src="https://cdn2.pandaimg.com/2022/10/11/63457405a869b.png" alt="屏幕截图 2022-10-11 214647.png"></a></p><p>NSS 信号线由高变低，是 SPI 通讯的起始信号。NSS 是每个从机各自独占的信号线，当从机在自己的 NSS 线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号处，NSS 信号由低变高，是 SPI 通讯的停止信号，表示本次通讯结束，从机的选中状态被取消。</p><p>观察图中的标号处，MOSI 及 MISO 的数据在 SCK 的上升沿期间变化输出，在 SCK 的下降沿时被采样。即在 SCK 的下降沿时刻，MOSI 及 MISO 的数据有效，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效，MOSI 及 MISO 为下一次表示数据做准备。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32系统学习</title>
      <link href="/2022/09/24/2022-12-17-stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/24/2022-12-17-stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>stm32主系统由四个去驱动单元和四个被动单元构成。</strong></p><p>四个驱动是内核DCode总线；系统总线；通用DMA1；通用DMA2</p><p>四被动单元是AHB到APB的桥：连接所有APB的设备；内存FLASH；内部SRAM；FSMC</p><p>① ICode 总线：该总线将 M3 内核指令总线和闪存指令接口相连，指令的预取在该总线上<br>面完成。<br>② DCode 总线：该总线将 M3 内核的 DCode 总线与闪存存储器的数据接口相连接，常量<br>加载和调试访问在该总线上面完成。<br>③ 系统总线：该总线连接 M3 内核的系统总线到总线矩阵，总线矩阵协调内核和 DMA 间<br>访问。<br>④ DMA 总线：该总线将 DMA 的 AHB 主控接口与总线矩阵相连，总线矩阵协调 CPU 的<br>DCode 和 DMA 到 SRAM,闪存和外设的访问。<br>⑤ 总线矩阵：总线矩阵协调内核系统总线和 DMA 主控总线之间的访问仲裁，仲裁利用<br>轮换算法。<br>⑥ AHB&#x2F;APB 桥:这两个桥在 AHB 和 2 个 APB 总线间提供同步连接，APB1 操作速度限于<br>36MHz,APB2 操作速度全速。</p><p><strong>stm32的5个时钟源</strong></p><p>用来配置时钟树</p><p>①HSI 是高速内部时钟，RC 振荡器，频率为 8MHz。<br>②HSE 是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz到16MHz。<br>③LSI 是低速内部时钟，RC 振荡器，频率为 40kHz。独立看门狗的时钟源只能是 LSI，同<br>时 LSI 还可以作为 RTC 的时钟源。<br>④LSE 是低速外部时钟，使用频率为 32.768kHz 的石英晶体。这个主要是 RTC 的时钟源。<br>⑤PLL 为锁相环倍频输出，其时钟输入源可选择为 HSI&#x2F;2、HSE 或者 HSE&#x2F;2。倍频可选择为2到16 倍，但是其输出频率最大不得超过 72MHz。</p><p>程序执行顺序</p><p><a href="https://postimg.cc/68vJqYZh"><img src="https://i.postimg.cc/2SHzHt8g/liucheng.png" alt="liucheng.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32最小系统板制作</title>
      <link href="/2022/09/21/2022-09-21-stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/09/21/2022-09-21-stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>此次制作使用的为立创EDA，主要是快速上手制板，没有选择AD。</p><p>首先了解<strong>stm32最小系统电路</strong>构成如下：</p><p>复位电路、电源电路、SWD&#x2F;JTAG下载接口、晶振电路（时钟电路）、启动选择电路、stm32构成。</p><p>关于启动选择电路可以查看以下链接来了解。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">Boot模式选择</a> STM32中BOOT模式配置的作用_qq_22010549的博客-CSDN博客_stm32f103boot设置](<a href="https://blog.csdn.net/qq_22010549/article/details/123425814">https://blog.csdn.net/qq_22010549/article/details/123425814</a>))</p><p>可以将boot0和boot1的两个分别设计单刀双制开关接3.3V和GND</p><p>主闪存模式是用<strong>flash</strong>，使用串口下载，或者可以选择使用SWD，或者将串口接一个板载USB电路，使用usb接口来进行下载。</p><p>本款设计芯片选择stm32f103RCT６芯片。</p><p>晶振电路分别使用两种晶振８MＨｚ晶振提供外部时钟和３２．７６８ＫＨｚ内部晶振为RTC提供时钟信号。</p><p>复位电路由电容、电阻、开关组成，电路采用手动复位的方式，当开关闭合时电路导通，RSET为芯片的复位引脚信号，此时芯片复位引脚接通GND，芯片将会复位重启。其中的电容的功能则是储能，当开发板上电瞬间，电容开始充电，复位引脚为低电平，所以上电瞬间开发板也会复位重启，但随着电容充电完成，引脚变为高电平，则不会再进行复位重启。</p><p>为了方便下载程序设计JTAG电路</p><p>电源电路把电源电压稳压在3.3V给单片机供电。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">稳压电路选择</a> 5V降压转3.3V，5V转3V电路图芯片_usb type的博客-CSDN博客_5v转3.3v稳压芯片](<a href="https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142%5Ev49%5Econtrol,201%5Ev3%5Econtrol_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142^v49^control,201^v3^control_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187</a>))</p><p>大多数选择为LDO电路，使用的一般为LM1117或者AMS117芯片。</p><p>stm32的MCU接口VDD接正极3.3V，VSS接地，VBAT使用电池或者其他电源，</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32最小系统板制作</title>
      <link href="/2022/09/21/2022-9-21-stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/09/21/2022-9-21-stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>此次制作使用的为立创EDA，主要是快速上手制板，没有选择AD。</p><p>首先了解<strong>stm32最小系统电路</strong>构成如下：</p><p>复位电路、电源电路、SWD&#x2F;JTAG下载接口、晶振电路（时钟电路）、启动选择电路、stm32构成。</p><p>关于启动选择电路可以查看以下链接来了解。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">Boot模式选择</a> STM32中BOOT模式配置的作用_qq_22010549的博客-CSDN博客_stm32f103boot设置](<a href="https://blog.csdn.net/qq_22010549/article/details/123425814">https://blog.csdn.net/qq_22010549/article/details/123425814</a>))</p><p>可以将boot0和boot1的两个分别设计单刀双制开关接3.3V和GND</p><p>主闪存模式是用ｆｌａｓｈ，使用串口下载，或者可以选择使用SWD</p><p>本款设计芯片选择stm32f103RCT６芯片。</p><p>晶振电路分别使用两种晶振８MＨｚ晶振提供外部时钟和３２．７６８ＫＨｚ内部晶振为RTC提供时钟信号。</p><p>复位电路由电容、电阻、开关组成，电路采用手动复位的方式，当开关闭合时电路导通，RSET为芯片的复位引脚信号，此时芯片复位引脚接通GND，芯片将会复位重启。其中的电容的功能则是储能，当开发板上电瞬间，电容开始充电，复位引脚为低电平，所以上电瞬间开发板也会复位重启，但随着电容充电完成，引脚变为高电平，则不会再进行复位重启。</p><p>为了方便下载程序设计JTAG电路</p><p>电源电路把电源电压稳压在3.3V给单片机供电。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">稳压电路选择</a> 5V降压转3.3V，5V转3V电路图芯片_usb type的博客-CSDN博客_5v转3.3v稳压芯片](<a href="https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142%5Ev49%5Econtrol,201%5Ev3%5Econtrol_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142^v49^control,201^v3^control_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187</a>))</p><p>大多数选择为LDO电路，使用的一般为LM1117或者AMS117芯片。</p><p>stm32的MCU接口VDD接正极3.3V，VSS接地，VBAT使用电池或者其他电源，</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arm-linux -ld、-objcopy和obdump</title>
      <link href="/2022/07/08/2022-7-8-arm-linux-ld%E5%92%8Carm-linux-objcopy/"/>
      <url>/2022/07/08/2022-7-8-arm-linux-ld%E5%92%8Carm-linux-objcopy/</url>
      
        <content type="html"><![CDATA[<p><strong>arm-linux-ld用于将多个目标文件、库文件连接成可执行文件。</strong></p><p>-T 直接指定代码段、数据段、bss段的起始地址,只用于连接Bootloader、内核等没有底层软件支持的软件</p><p>连接操作系统应用程序时候，无需-T，默认连接。</p><p>1.直接指定代码段、数据段、bss段的起始地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure><p>startaddr分别代表代码段、数据段、bss段的起始地址</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-ld -Ttext 0x000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure><p>代表代码段运行地址为0x000000，没有定义数据段、bss段起始地址所以被放入代码段的后面</p><p>2.使用连接脚本设置地址</p><p><strong>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可用不同于源文件的格式来输出目的文件，即可以进行格式转换。</strong></p><p>1、input-file、outfile分别是输入目标文件和输出目标文件，如果没有明确指定outfile，将创建一个临时文件来存放结果，用input-file的名字来命名。</p><p>2、 -l bfname或–input-target&#x3D;bfdname</p><p>用来指明源文件的格式，bfdname是BFD库描述的标准格式名，如果不指明格式，会自己分析源文件格式，去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</p><p>3、-O bfdname或–output-target&#x3D;bfdname</p><p>使用指定格式来输出文件，bdfname是BFD库中的标准格式名。</p><p><strong>arm-linux-objdump用于显示二进制文件信息</strong></p><p>未完待续。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32hal库</title>
      <link href="/2022/07/01/2022-7-1-stm32hal%E5%BA%93/"/>
      <url>/2022/07/01/2022-7-1-stm32hal%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>为方便使用，用typedef来给变量起名将以下放入main.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>  s32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int16_t</span> s16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int8_t</span>  s8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int32_t</span> sc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int16_t</span> sc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int8_t</span> sc8;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int32_t</span>  vs32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int16_t</span>  vs16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int8_t</span>   vs8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int32_t</span> vsc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int16_t</span> vsc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int8_t</span> vsc8;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span>  u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span>  u8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint32_t</span> uc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint16_t</span> uc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint8_t</span> uc8; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint32_t</span>  vu32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint16_t</span> vu16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint8_t</span>  vu8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint32_t</span> vuc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint16_t</span> vuc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint8_t</span> vuc8;  </span><br></pre></td></tr></table></figure><p>点亮led</p><p>GPIO用IO口的输出模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOF,GPIO_PIN_9,GPIO_PIN_SET);<span class="comment">//控制电平</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5);<span class="comment">//翻转电平</span></span><br><span class="line">HAL_GPIO_ReadPin(GPIOA, GPIO_Pin_8);<span class="comment">//读取电平</span></span><br></pre></td></tr></table></figure><p>点亮led就需要按键了，按键首先要看按键的引脚设置IO口为输入模式，写一个案件处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">static</span> u8 key_up=<span class="number">1</span>; <span class="comment">//按键松开标志</span></span><br><span class="line"> <span class="keyword">if</span>(mode==<span class="number">1</span>)key_up=<span class="number">1</span>; <span class="comment">//支持连按</span></span><br><span class="line"> <span class="keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="number">0</span>||KEY1==<span class="number">0</span>||WK_UP==<span class="number">1</span>))</span><br><span class="line"> &#123;</span><br><span class="line"> delay_ms(<span class="number">10</span>);</span><br><span class="line"> key_up=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(KEY0==<span class="number">0</span>) <span class="keyword">return</span> KEY0_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">0</span>) <span class="keyword">return</span> KEY1_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(WK_UP==<span class="number">1</span>) <span class="keyword">return</span> WKUP_PRES; </span><br><span class="line">ALIENTEK MiniSTM32 V3<span class="number">.0</span> 开发板教程</span><br><span class="line"><span class="number">137</span></span><br><span class="line">STM32 不完全手册(HAL 库版)</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">1</span>&amp;&amp;KEY1==<span class="number">1</span>&amp;&amp;WK_UP==<span class="number">0</span>)key_up=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在头文件中进行添加宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5) <span class="comment">//KEY0 按键 PC5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15) <span class="comment">//KEY1 按键 PA15</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WK_UP HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) <span class="comment">//WKUP 按键 PA0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0_PRES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRES 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WKUP_PRES 3</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>串口通信</p><p>usart和uart区别为 usart比uart多了同步时钟频率通信，都有异步时钟通信。</p><p>串口设置的一般步骤可以总结为如下几个步骤：</p><ol><li>串口时钟使能，GPIO 时钟使能。</li><li>设置引脚复用器映射：调用 GPIO_PinAFConfig 函数。</li><li>GPIO 初始化设置：要设置模式为复用功能。</li><li>串口参数初始化：设置波特率，字长，奇偶校验等参数。</li><li>开启中断并且初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）。</li><li>使能串口。</li><li>编写中断处理函数：函数名格式为 USARTxIRQHandler(x 对应串口号)。</li></ol><p>串口通信的结构体如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> uint32_t BaudRate; //波特率</span><br><span class="line"> uint32_t WordLength; //字长</span><br><span class="line"> uint32_t StopBits; //停止位</span><br><span class="line"> uint32_t Parity; //奇偶校验</span><br><span class="line"> uint32_t Mode; //收/发模式设置</span><br><span class="line"> uint32_t HwFlowCtl; //硬件流设置</span><br><span class="line"> uint32_t OverSampling; //过采样设置</span><br><span class="line">&#125;UART_InitTypeDef</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile的学习</title>
      <link href="/2022/06/30/2022-6-30-makefile/"/>
      <url>/2022/06/30/2022-6-30-makefile/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tieba.baidu.com/p/591519800">Makefile详解（超级好）【mingw吧】_百度贴吧 (baidu.com)</a></p><p>上面挂一个较好的makefile的教程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学</title>
      <link href="/2022/06/28/2022-06-28-linux%E5%88%9D%E5%AD%A6/"/>
      <url>/2022/06/28/2022-06-28-linux%E5%88%9D%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>一个C&#x2F;C++文件要经过预处理、编译、汇编、连接等四步才能变为可执行文件。</p><p>预处理就是要将包含（include）的文件插入到原文件中、宏定义展开、根据条件编译命令选择要使用的代码。</p><p>编译是把C&#x2F;C++代码翻译成汇编代码。</p><p>汇编是将输出的汇编代码翻译成一定格式的机器代码。</p><p>连接是将上部生成的OBJ和系统库的OBJ文件、库文件连接起来，最终生成可执行文件。</p><p>首先记录一些常用的linux指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~$ cd 目标文件夹名称                 导向目标文件夹所在终端</span><br><span class="line"></span><br><span class="line">~$ touch hel                               创建一个叫hel的文件</span><br><span class="line"></span><br><span class="line">~$ gedit hel.c                             创建一个叫hel.c的文件并用文本编辑器打开</span><br><span class="line"></span><br><span class="line">~$ gcc hel.c -o test                    编译hel.c为test可执行文件</span><br><span class="line"></span><br><span class="line">~$ ./test                                     执行test可执行文件</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多个.c文件使用命令将多个文件连接到一个可执行文件中，之后执行。</p><p>在C语言文件中调用math.h库报错只需要gcc将代码与链接库连接起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc two.c -lm -o two</span><br></pre></td></tr></table></figure><p>编译C语言文件会有警告以及报错，但是警告是不显示的，需要用指令进行显示。</p><p>比如显示hello.c文件的警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ gcc -Wll -c hello.c</span><br></pre></td></tr></table></figure><p>如果文件里有没定义的变量就会出现如下现象</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20145045.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学</title>
      <link href="/2022/06/28/2022-6-28-linux%E5%88%9D%E5%AD%A6/"/>
      <url>/2022/06/28/2022-6-28-linux%E5%88%9D%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>一个C&#x2F;C++文件要经过预处理、编译、汇编、连接等四步才能变为可执行文件。</p><p>预处理就是要将包含（include）的文件插入到原文件中、宏定义展开、根据条件编译命令选择要使用的代码。</p><p>编译是把C&#x2F;C++代码翻译成汇编代码。</p><p>汇编是将输出的汇编代码翻译成一定格式的机器代码。</p><p>连接是将上部生成的OBJ和系统库的OBJ文件、库文件连接起来，最终生成可执行文件。</p><p>首先记录一些常用的linux指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">cd</span> 目标文件夹名称                 导向目标文件夹所在终端</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash"><span class="built_in">touch</span> hel                               创建一个叫hel的文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">gedit hel.c                             创建一个叫hel.c的文件并用文本编辑器打开</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">gcc hel.c -o <span class="built_in">test</span>                    编译hel.c为<span class="built_in">test</span>可执行文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">./test                                     执行<span class="built_in">test</span>可执行文件</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多个.c文件使用命令将多个文件连接到一个可执行文件中，之后执行。</p><p>在C语言文件中调用math.h库报错只需要gcc将代码与链接库连接起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc two.c -lm -o two</span></span><br></pre></td></tr></table></figure><p>编译C语言文件会有警告以及报错，但是警告是不显示的，需要用指令进行显示。</p><p>比如显示hello.c文件的警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">gcc -Wll -c hello.c</span></span><br></pre></td></tr></table></figure><p>如果文件里有没定义的变量就会出现如下现象</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-15%20145045.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/03/hello-world/"/>
      <url>/2022/05/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
