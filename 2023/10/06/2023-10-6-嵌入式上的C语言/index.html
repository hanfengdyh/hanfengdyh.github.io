<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>嵌入式上的C语言 | 涵风 Blog</title><meta name="keywords" content="C"><meta name="author" content="HF"><meta name="copyright" content="HF"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="这篇文章其实更适合在裸机开发操作寄存器之前来学习。 内存为什么需要内存？程序&#x3D; 代码 + 数据 程序运行的目的要么重在数据结果（有返回值），要么重在过程（无返回值），要么即重于结果又重过程。 计算机程序的运行过程，其实就是程序中很多个函数相继运行的过程。程序是由很多个函数组成的，程序的本质就是函数，函数的本质就是加工数据的动作。  哈佛结构：将程序的代码和数据分开存放的一种结构，但是存放">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式上的C语言">
<meta property="og:url" content="https://example.com/2023/10/06/2023-10-6-%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8A%E7%9A%84C%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="涵风 Blog">
<meta property="og:description" content="这篇文章其实更适合在裸机开发操作寄存器之前来学习。 内存为什么需要内存？程序&#x3D; 代码 + 数据 程序运行的目的要么重在数据结果（有返回值），要么重在过程（无返回值），要么即重于结果又重过程。 计算机程序的运行过程，其实就是程序中很多个函数相继运行的过程。程序是由很多个函数组成的，程序的本质就是函数，函数的本质就是加工数据的动作。  哈佛结构：将程序的代码和数据分开存放的一种结构，但是存放">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://example.com/img/taozhuang.jpg">
<meta property="article:published_time" content="2023-10-06T04:20:32.000Z">
<meta property="article:modified_time" content="2023-10-09T06:30:43.097Z">
<meta property="article:author" content="HF">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://example.com/img/taozhuang.jpg"><link rel="shortcut icon" href="/img/tb.png"><link rel="canonical" href="https://example.com/2023/10/06/2023-10-6-%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8A%E7%9A%84C%E8%AF%AD%E8%A8%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '嵌入式上的C语言',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-09 14:30:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxaing.gif" onerror="onerror=null;src='/img/fr.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">117</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/taozhuang.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">涵风 Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">嵌入式上的C语言</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-06T04:20:32.000Z" title="发表于 2023-10-06 12:20:32">2023-10-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-09T06:30:43.097Z" title="更新于 2023-10-09 14:30:43">2023-10-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="嵌入式上的C语言"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这篇文章其实更适合在裸机开发操作寄存器之前来学习。</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="为什么需要内存？"><a href="#为什么需要内存？" class="headerlink" title="为什么需要内存？"></a>为什么需要内存？</h2><p>程序&#x3D; 代码 + 数据</p>
<p>程序运行的目的要么重在数据结果（有返回值），要么重在过程（无返回值），要么即重于结果又重过程。</p>
<p><strong>计算机程序的运行过程，其实就是程序中很多个函数相继运行的过程。</strong>程序是由很多个函数组成的，程序的本质就是函数，函数的本质就是加工数据的动作。 </p>
<p>哈佛结构：将程序的代码和数据分开存放的一种结构，但是存放的位置可以是相同的也可以是不同的（ROM&amp;RAM或RAM）,<u>总之只要是分成两个部分单独访问的结构都是哈佛结构。</u></p>
<p><strong>哈佛结构的特点就是代码和数据单独存放，使之不会互相干扰，进而当程序出 BUG 时，最多只会修改数据的值（因为代码部分是只读的，不可改写），而不会修改程序的执行顺序。因此，这种结构大量应用在嵌入式编程 。</strong></p>
<p>冯诺依曼结构：将代码和数据统一放在RAM（随机存取存储器）中，数据和代码之间一般是按照程序的执行顺序依次存储。</p>
<p>这样就会导致一个问题，<strong>如果程序出 BUG，由于程序没有对代码段的读写限定，因此，它将拥有和数据一样的读写操作权限。于是就会很容易的死机</strong>，一旦代码执行出现一点改变就会出现非常严重的错误。但是，冯诺依曼结构的好处是可以充分利用有限的内存空间，并使 CPU 对程序的执行十分的方便，不用来回跑。 </p>
<h2 id="程序运行为什么需要内存？"><a href="#程序运行为什么需要内存？" class="headerlink" title="程序运行为什么需要内存？"></a>程序运行为什么需要内存？</h2><p>程序运行时要存放代码和数据，代码放在 DRAM 的只读权限代码段，数据放在 DRAM 的可读可写数据段，程序要跑，内存是必要条件 。 </p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>从 OS 角度讲： OS 掌握所有的硬件内存，因为内存很大，所以 OS 把内存分成 1 个 1 个的页面（其实就是分块，一般是 4KB），然后以页面为单位来管理。页面内用更细小的方式来以字节为单位管理。 （只要调用系统的API就能管理内存）</p>
<p>在没有 OS 时，也就是裸机程序中程序需要直接操作内存，编程者需要自己计算内存的使用和安排。 </p>
<p>C： C 语言编译器帮我们管理内存地址，我们都是通过编译器通过的变量名来访问内存的，<br>OS 下如果需要大块内存，可以通过 API（mallos、 free）来访问内存。 裸机程序中需要大块内存需要自己定义数组等来解决。<br>C++： C++对内存的使用进一步封装。我们可以用 new 来创建对象（其实就是为对象分配内存），然后使用完了用 delete 来删除对象（其实就是释放内存）。所以 C++比 C 更容易一些。但是 C++中的内存管理还是要靠程序员自己来做，例如需要使用 delete 删除对象释放内存，如果忘记，就会造成内存不能释放，就是所谓的内存泄露 </p>
<p>从硬件角度：硬件的内存实现本身就是有宽度的，也就是内存条本身就有 8 位、 16 位等。需要注意的是，内存芯片之间可以并联，通过并联后 8 位内存芯片可以做出来 16 位、 32位的硬件内存。 从逻辑角度：内存位宽在逻辑上是任意的，甚至逻辑上内存的位宽可以是 24 位，但没必要。从逻辑角度，不管内存位宽多少，直接操作即可。但因为所有的逻辑操作都是要硬件实现，所以还是要尊重硬件内存位宽。 </p>
<h2 id="内存编制和寻址、内存对齐"><a href="#内存编制和寻址、内存对齐" class="headerlink" title="内存编制和寻址、内存对齐"></a>内存编制和寻址、内存对齐</h2><p>在程序运行中，CPU实际只认识内存地址，而不关心这个地址所代表的空间在哪里、怎么分布的，因为硬件设计保证了这个地址就能找到这个格子，所以内存单元的两个概念：地址和空间是内存单元的两个概念。<br><strong>内存编制是以字节为单位的。</strong><br><strong>数据类型是用来定义变量的，而这些变量需要在内存中存储和运算。所以数据类型必须和内存相匹配才能获得最好的性能。</strong><br>内存的对齐访问不是逻辑问题， 是硬件问题。从硬件角度来说， 32 位的内存它 0、1、2、3 四个单元本身逻辑上就有相关性，这 4 个字节组合起来当做一个 int，硬件上就是合适的，效率就高。</p>
<h1 id="C语言操作内存"><a href="#C语言操作内存" class="headerlink" title="C语言操作内存"></a>C语言操作内存</h1><p>变量名即对内存地址的封装。指针即保存这个地址的变量。函数名实质就是一段代码的首地址。 </p>
<h3 id="C-语言数据类型的本质含义：表示内存格子的个数（每个格子-1-个字节）和解析方法。"><a href="#C-语言数据类型的本质含义：表示内存格子的个数（每个格子-1-个字节）和解析方法。" class="headerlink" title="C 语言数据类型的本质含义：表示内存格子的个数（每个格子 1 个字节）和解析方法。"></a>C 语言数据类型的本质含义：表示内存格子的个数（每个格子 1 个字节）和解析方法。</h3><p>(1)决定内存格子的个数：如果给一个地址 0x30000000，那么这个地址即一个格子。如果int 定义它，这个地址就会扩展为 4 个格子。<br>(2)解析方法：（int） 0x30000000 含义就是从 0x30000000 开始的 4 个格子连起来共同存放的一个 int 型数据。（float） 0x30000000 含义就是从 0x30000000 开始的 4 个格子连起来共同存放的一个 float 型数据。</p>
<h3 id="用指针来间接访问内存"><a href="#用指针来间接访问内存" class="headerlink" title="用指针来间接访问内存"></a>用指针来间接访问内存</h3><p>C 语言中的指针，全名叫指针变量，指针变量其实很普通变量没有任何区别。譬如 int a 和int *p 其实没有任何区别， a 和 p 都代表一个内存地址（譬如是 0x20000000），但是这个内存地址（0x20000000）的长度和解析方法不同。 a 是 int 型所以 a 的长度是 4 字节，解析方法是按照 int 的规定来的(以 0x20000000 开头的连续的 4 个字节的空间中存了一个 int型的数)； p 是 int *类型，所以长度是 4 字节，解析方法是 int *的规定来的（以 0x20000000开头的连续 4 字节的空间中存储了 1 个地址，这个地址所代表的内存单元中存放的是一个int 类型的数）。在 32 位系统中，指针变量永远占 4 个字节的内存空间。 </p>
<h3 id="用数组来管理内存"><a href="#用数组来管理内存" class="headerlink" title="用数组来管理内存"></a>用数组来管理内存</h3><p>数组管理内存和变量其实没有本质区别，只是符号的解析方法不用。（普通变量、数组、指针变量其实都没有本质差别，都是对内存地址的解析，只是解析方法不一样）。<br>int a; &#x2F;&#x2F;编译器分配 4 个字节长度给 a，并且把首地址和符号 a 绑定起来。<br>int b[10]; &#x2F;&#x2F;编译器分配 40 个字节长度给 b，并且把首元素的首地址和符号 b绑定起来。<br>数组中第一个元素（b[0]）就称为首元素；每一个元素都是类型都是 int，所以长度都是 4个字节，其中第一个字节的地址就称为首地址；首元素 b[0]的首地址就称为首元素首地址。</p>
<p>数组的缺陷：（1）数组中元素类型必须相同 （2）数组大小必须在定义时给出，而且一旦给出不能更改 </p>
<h3 id="内存管理之结构体"><a href="#内存管理之结构体" class="headerlink" title="内存管理之结构体"></a>内存管理之结构体</h3><p><strong>结构体和数组的本质差异还是在于怎么找变量地址的问题。</strong> </p>
<p>C 语言作为面向过程的语言，可以通过结构体内嵌指针实现面向对象的代码。<br>当然，面向对象的语言更为简单直观。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age <span class="comment">// 普通变量</span></span><br><span class="line">	<span class="type">void</span> (*pFunc)(<span class="type">void</span>); <span class="comment">// 函数指针，指向 void func(void)这类的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>使用这样的结构体就可以实现面向对象。 </p>
<h3 id="内存管理之栈"><a href="#内存管理之栈" class="headerlink" title="内存管理之栈"></a>内存管理之栈</h3><p>栈是一种数据结构， <strong>C 语言中使用栈来存放局部变量。</strong> </p>
<blockquote>
<p>栈管理内存的特点（小内存、自动化）：<br>先进后出 FILO（First In Last Out） 栈<br>先进先出 FIFO（First In First Out） 队列 </p>
</blockquote>
<p>栈的特点是入口即出口，只有一个口，另一个口是堵死的。所以先进去的必须后出来队列的特点是入口和出口都有，必须从入口进，从出口出，所以先进去的必须先出来，否则就堵住后边的。 </p>
<h4 id="栈的应用举例：局部变量"><a href="#栈的应用举例：局部变量" class="headerlink" title="栈的应用举例：局部变量"></a>栈的应用举例：局部变量</h4><p>C 语言中的局部变量是用栈来实现的。<br>我们在 C 语言中定义一个局部变量时（int a），编译器会在栈中分配一段空间（4 字节）给这个局部变量用（分配时栈顶指针会移动给出空间，给局部变量 a 用的意思就是，将这字节的栈内存的内存地址和我们定义的局部变量名 a 给关联起来），对应栈的操作是入栈。<br>注意：这里栈指针的移动和内存分配都是自动的。<br>然后等我们函数退出时，局部变量就会灭亡。对应栈的操作就是弹栈（出栈）。出栈时也是栈顶指针移动将栈空间中与 a 关联的那 4 个字节空间释放。这个动作也是自动的，不需要写代码干预。<br>栈的优点：入栈和出栈都由 C 语言自动完成。<br>分析一个细节： C 语言中，定义局部变量时如果未初始化，则值是随机的，为什么？<br>定义局部变量，其实就是在栈中通过移动栈指针来给程序提供一个内存空间和这个局部变量名绑定。因为这段内存空间在栈上，而栈内存是反复使用的（脏的，上次用完没清零的），所以说使用栈来实现的局部变量定义时如果不显式初始化，值就是脏的（也就是随机值）。<br>栈的约束：预定栈大小不灵活，怕溢出首先，栈是有大小的。所以栈内存大小不好设置。如果太小怕溢出，太大怕浪费内存。（这个缺点有点像数组）<br>其次，栈的溢出危害很大，一定要避免。所以我们在 C 语言中定义局部变量时不能定义太多或者太大（譬如不能定义局部变量时 int a[10000]; 使用递归来解决问题时一定要注意递归收敛）。</p>
<h3 id="内存管理之堆"><a href="#内存管理之堆" class="headerlink" title="内存管理之堆"></a>内存管理之堆</h3><p>堆内存管理方式特点就是自由（随时释放申请；大小块随意）。堆内存是OS规划给堆管理器来管理的，之后来给使用的API来使用。</p>
<p>我们会在需要内存容量比较大，需要反复使用及释放时，会使用堆内存。很多数据结构（譬如链表）的实现都需要使用堆内存。 </p>
<blockquote>
<p>特点 1：容量不限（常规使用的需求容量都能满足）。<br>特点 2：申请及释放都需要手工进行，手工进行的含义就是需要写代码明确申请 malloc 和<br>释放 free。如果申请内存并使用后未释放，这段内存就丢失了（在堆管理器的记录中，这<br>段内存仍然属于你这个进程，但是进程自己又以为这段内存已经不用了，再用的时候又会<br>去申请新的内存块，这就叫吃内存。），称为内存泄露 </p>
</blockquote>
<p>C 语言操作堆内存的接口（malloc、 free）<br>堆内存释放时最简单，直接调用 free 释放即可。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br></pre></td></tr></table></figure>

<p>堆内存申请时，有 3 个可选择的类似功能的函数： malloc、 calloc、 realloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>; <span class="comment">//nmemb 个单元，每个单元 size 字节</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>; <span class="comment">//改变原来申请的空间的大小</span></span><br></pre></td></tr></table></figure>

<p>譬如要申请 10 个 int 元素的内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">40</span>); </span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">10</span>, <span class="number">4</span>); </span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>)); </span><br></pre></td></tr></table></figure>

<p><strong>堆内存申请时必须给定大小，然后一旦申请完成大小不能更改，如果要变更，只能通过realloc 接口</strong> </p>
<h1 id="复杂数据结构"><a href="#复杂数据结构" class="headerlink" title="复杂数据结构"></a>复杂数据结构</h1><h2 id="链表、哈希表（散列表）、二叉树、图等"><a href="#链表、哈希表（散列表）、二叉树、图等" class="headerlink" title="链表、哈希表（散列表）、二叉树、图等"></a>链表、哈希表（散列表）、二叉树、图等</h2><p>链表是最重要的，链表在 Linux 内核中使用非常多，驱动、应用编写很多时候都需要使用链表。所以对链表必须掌握。<strong>掌握到： 会自己定义结构体来实现链表、会写链表的节点插入（前插、后插）、节点删除、节点查找、节点遍历等。</strong></p>
<p>哈希表不是很常用，一般不需要自己写实现，而直接使用别人实现的哈希表表较多。对我们来说，最重要的是明白哈希表的原理、从而知道哈希表的特点，从而知道什么时候该使用哈希表，当看到别人用了哈希表的时候要明白别人为什么要用哈希表、合适不合适？有<br>没有更好的选择？<br>二叉树、图不用深究。 </p>
<h1 id="C语言位操作"><a href="#C语言位操作" class="headerlink" title="C语言位操作"></a>C语言位操作</h1><h2 id="位与-amp"><a href="#位与-amp" class="headerlink" title="位与&amp;"></a>位与&amp;</h2><p>(1)注意：位与符号是一个&amp;，两个&amp;&amp;是逻辑与。<br>(2)真值表： 1&amp;0&#x3D;0 1&amp;1&#x3D;1 0&amp;0&#x3D;0 0&amp;1&#x3D;0<br>(3)从真值表可以看出：位与操作的特点是，只有 1 和 1 位于结果为 1，其余全是 0.<br>(4)位与和逻辑与的区别：<strong>位与时两个操作数是按照二进制位彼次对应位相与的，逻辑与是两个操作数作为整体来相与的。</strong>（举例： 0xAA&amp;0xF0&#x3D;0xA0, 0xAA &amp;&amp; 0xF0&#x3D;1）</p>
<h2 id="位或"><a href="#位或" class="headerlink" title="位或|"></a>位或|</h2><p>(1)注意：位或符号是一个|，两个||是逻辑或。<br>(2)真值表： 1|0&#x3D;1 1|1&#x3D;1 0|0&#x3D;0 0|1&#x3D;1<br>(3)从真值表可以看出：位或操作的特点是：只有 2 个 0 相位或才能得到 0，只要有 1 个 1结果就一定是 1.<br>(4)位或和逻辑或的区别：<strong>位或时两个操作数是按照二进制位彼次对应位相与的，逻辑或是两个操作数作为整体来相或的。</strong></p>
<h2 id="位取反"><a href="#位取反" class="headerlink" title="位取反~"></a>位取反~</h2><p>(1)注意： C 语言中位取反是~， C 语言中的逻辑取反是!<br>(2)按位取反是将操作数的二进制位逐个按位取反（1 变成 0， 0 变成 1）；而逻辑取反是真（在 C 语言中只要不是 0 的任何数都是真）变成假（在 C 语言中只有 0 表示假）、假变成真。<br>任何非 0 的数被按逻辑取反再取反就会得到 1；<br>任何非 0 的数被按位取反再取反就会得到他自己； </p>
<h2 id="位异或"><a href="#位异或" class="headerlink" title="位异或^"></a>位异或^</h2><p>(1)位异或真值表： 1^1&#x3D;0 0^0&#x3D;0 1^0&#x3D;1 0^1&#x3D;1<br>(2)位异或的特点： 2 个数如果相等结果为 0，不等结果为 1。记忆方法：异或就是相异就或操作起来。<br>位与、位或、位异或的特点总结：<br>位与：（任何数，其实就是 1 或者 0）与 1 位与无变化，与 0 位与变成 0<br>位或：（任何数，其实就是 1 或者 0）与 1 位或变成 1，与 0 位或无变化<br>位异或：（任何数，其实就是 1 或者 0）与 1 位异或会取反，与 0 位异或无变化 </p>
<h2 id="左移位-lt-lt-与右移位-gt-gt"><a href="#左移位-lt-lt-与右移位-gt-gt" class="headerlink" title="左移位&lt;&lt; 与右移位&gt;&gt;"></a>左移位&lt;&lt; 与右移位&gt;&gt;</h2><p>C 语言的移位要取决于数据类型。<br>对于无符号数，左移时右侧补 0（相当于逻辑移位）<br>对于无符号数，右移时左侧补 0（相当于逻辑移位）<br>对于有符号数，左移时右侧补 0（叫算术移位，相当于逻辑移位）<br>对于有符号数，右移时左侧补符号位（如果正数就补 0，负数就补 1，叫算术移位）<br><strong>嵌入式中研究的移位，以及使用的移位都是无符号数</strong> </p>
<h2 id="位与位或位异或在操作寄存器时的特殊作用"><a href="#位与位或位异或在操作寄存器时的特殊作用" class="headerlink" title="位与位或位异或在操作寄存器时的特殊作用"></a>位与位或位异或在操作寄存器时的特殊作用</h2><h3 id="寄存器操作的要求（特定位改变而不影响其他位）"><a href="#寄存器操作的要求（特定位改变而不影响其他位）" class="headerlink" title="寄存器操作的要求（特定位改变而不影响其他位）"></a>寄存器操作的要求（特定位改变而不影响其他位）</h3><p>(1)ARM 是内存与 IO 统一编址的， ARM 中有很多内部外设， SoC 中 CPU 通过向这些内部外设的寄存器写入一些特定的值来操控这个内部外设，进而操控硬件动作。所以可以说：<strong>读写寄存器就是操控硬件</strong>。<br>(2)寄存器的特点是按位进行规划和使用。但是寄存器的读写却是整体 32 位一起进行的（也就是说你只想修改 bit5～ bit7 是不行的，必须整体 32bit 全部写入）<br>(3)寄存器操作要求就是：在设定特定位时不能影响其他位。<br>(4)如何做到？答案是：<strong>读-改-写三部曲。读改写的操作理念</strong>，就是：当我想改变一个寄存器中某些特定位时，我不会直接去给他写，我会先读出寄存器整体原来的值，然后在这个基础上修改我想要修改的特定位，再将修改后的值整体写入寄存器。这样达到的效果是：在不影响其他位原来值的情况下，我关心的位的值已经被修改了。 </p>
<h3 id="特定位清零用-amp"><a href="#特定位清零用-amp" class="headerlink" title="特定位清零用&amp;"></a>特定位清零用&amp;</h3><p>(1)回顾上节讲的位与操作的特点：（任何数，其实就是 1 或者 0）与 1 位与无变化，与 0位与变成 0<br>(2)如果希望将一个寄存器的某些特定位变成 0 而不影响其他位，可以构造一个合适的 1 和0 组成的数和这个寄存器原来的值进行位与操作，就可以将特定位清零。<br>(3)举例：假设原来 32 位寄存器中的值为： 0xAAAAAAAA，我们希望将 bit8～ bit15 清零而其他位不变，可以将这个数与 0xFFFF00FF 进行位与即可。 </p>
<h3 id="特定位置-1-用"><a href="#特定位置-1-用" class="headerlink" title="特定位置 1 用|"></a>特定位置 1 用|</h3><p>(1)回顾上节讲的位或操作的特点：任何数，其实就是 1 或者 0）与 1 位或变成 1，与 0 位<br>或无变化<br>(2)操作手法和刚才讲的位与是类似的。我们要构造这样一个数：要置 1 的特定位为 1，其<br>他位为 0，然后将这个数与原来的数进行位或即可。 </p>
<h3 id="特定位取反用"><a href="#特定位取反用" class="headerlink" title="特定位取反用^"></a>特定位取反用^</h3><p>(1)回顾上节讲的位异或操作的特点：（任何数，其实就是 1 或者 0）与 1 位异或会取反，与 0 位异或无变化<br>(2)操作手法和刚才讲的位与是类似的。我们要构造这样一个数：要取反的特定位为 1，其他位为 0，然后将这个数与原来的数进行位异或即可。 </p>
<h2 id="如何用位运算构建特定二进制数-1少的用"><a href="#如何用位运算构建特定二进制数-1少的用" class="headerlink" title="如何用位运算构建特定二进制数 (1少的用)"></a>如何用位运算构建特定二进制数 (1少的用)</h2><p>对寄存器特定位进行置 1 或者清 0 或者取反，关键性的难点在于要事先构建一个特别的数，这个数和原来的值进行位与、位或、位异或等操作，即可达到我们对寄存器操作的要求 。</p>
<h3 id="使用移位获取特定位为-1-的二进制数"><a href="#使用移位获取特定位为-1-的二进制数" class="headerlink" title="使用移位获取特定位为 1 的二进制数"></a>使用移位获取特定位为 1 的二进制数</h3><blockquote>
<table>
<thead>
<tr>
<th>一个 1</th>
<th>0x1</th>
</tr>
</thead>
<tbody><tr>
<td><strong>两个 1</strong></td>
<td><strong>0x3</strong></td>
</tr>
<tr>
<td><strong>三个1</strong></td>
<td><strong>0x7</strong></td>
</tr>
<tr>
<td><strong>四个1</strong></td>
<td><strong>0xf</strong></td>
</tr>
<tr>
<td><strong>五个1</strong></td>
<td><strong>0x1f</strong></td>
</tr>
<tr>
<td><strong>六个1</strong></td>
<td><strong>0x3f</strong></td>
</tr>
<tr>
<td><strong>七个1</strong></td>
<td><strong>0x7f</strong></td>
</tr>
<tr>
<td><strong>八个1</strong></td>
<td><strong>0xff</strong></td>
</tr>
</tbody></table>
</blockquote>
<p>(1)最简单的就是用移位来获取一个特定位为 1 的二进制数。譬如我们需要一个 bit3～ bit7为 1（隐含意思就是其他位全部为 0）的二进制数，可以这样： (0x1f&lt;&lt;3)<br>(2)更难一点的要求：获取 bit3～ bit7 为 1，同时 bit23～ bit25 为 1，其余位为 0 的数：((0x1f&lt;&lt;3) | (0x7&lt;&lt;23)) </p>
<h3 id="再结合位取反获取特定位为-0-的二进制数（1多的用）"><a href="#再结合位取反获取特定位为-0-的二进制数（1多的用）" class="headerlink" title="再结合位取反获取特定位为 0 的二进制数（1多的用）"></a>再结合位取反获取特定位为 0 的二进制数（1多的用）</h3><p>(1)这次我们要获取 bit4～ bit10 为 0，其余位全部为 1 的数。怎么做？<br>(2)利用上面讲的方法就可以： (0xf&lt;&lt;0)|(0x1fffff&lt;&lt;11)<br>但是问题是：连续为 1 的位数太多了，这个数字本身就很难构造，所以这种方法的优势损失掉了。<br>(3)这种特定位（比较少）为 0 而其余位（大部分）为 1 的数，不适合用很多个连续 1 左移的方式来构造，适合左移加位取反的方式来构造。<br>(2)思路是：先试图构造出这个数的位相反数，再取反得到这个数。（譬如本例中要构造的数 bit4～ bit10 为 0 其余位为 1，那我们就先构造一个 bit4～ bit10 为 1，其余位为 0 的数，然后对这个数按位取反即可） ~(0x7f&lt;&lt;4) </p>
<h3 id="位操作实战"><a href="#位操作实战" class="headerlink" title="位操作实战"></a>位操作实战</h3><p>(1)给定一个整型数 a，设置 a 的 bit3，保证其他位不变。<br>a |&#x3D; (1&lt;&lt;3)<br>(2)给定一个整形数 a，设置 a 的 bit3<del>bit7，保持其他位不变<br>a |&#x3D; (0x1f&lt;&lt;3)<br>(3)给定一个整型数 a，清除 a 的 bit15，保证其他位不变。<br>a &amp;&#x3D; ~(1&lt;&lt;15)<br>(4)给定一个整形数 a，清除 a 的 bit15</del>bit23，保持其他位不变。<br>a &amp;&#x3D; <del>(0x1ff&lt;&lt;15)<br>(5)给定一个整形数 a，取出 a 的 bit3</del>bit8。<br>a &amp;&#x3D; (0x3f&lt;&lt;3)<br>a &gt;&gt;&#x3D; 3<br>(6)给一个寄存器的 bit7～ bit17 赋值 937<br>a &amp;&#x3D; ~(0x7ff&lt;&lt;7)<br>a |&#x3D; (937&lt;&lt;7)<br>(7)给一个寄存器的 bit7～ bit17 中的值加 17<br>b &#x3D; ((a &amp; (0x7ff&lt;&lt;7))&gt;&gt;7 + 17)&lt;&lt;7<br>a &amp;&#x3D; ~(0x7ff&lt;&lt;7)<br>a |&#x3D; b<br>(8)给一个寄存器的 bit7～ bit17 赋值 937，同时给 bit21～ bit25 赋值 17.<br>a &amp;&#x3D; ~((0x7ff&lt;&lt;7) | (0x1f&lt;&lt;21))<br>a |&#x3D; ((937&lt;&lt;7) | (17&lt;&lt;21)) </p>
<h1 id="C语言指针"><a href="#C语言指针" class="headerlink" title="C语言指针"></a>C语言指针</h1><h2 id="指针变量和普通变量的区别"><a href="#指针变量和普通变量的区别" class="headerlink" title="指针变量和普通变量的区别"></a>指针变量和普通变量的区别</h2><p>首先必须非常明确：指针的实质就是个变量，它跟普通变量没有任何本质区别。指针完整的名字叫指针变量，简称指针。 </p>
<p><strong>指针的出现是为了实现间接访问</strong>，间接访问（CPU 的间接寻址）是 CPU 设计时决定的 .</p>
<h2 id="指针使用三部曲：定义指针变量、关联指针变量、解引用"><a href="#指针使用三部曲：定义指针变量、关联指针变量、解引用" class="headerlink" title="指针使用三部曲：定义指针变量、关联指针变量、解引用"></a>指针使用三部曲：定义指针变量、关联指针变量、解引用</h2><p>(1)当我们 int *p 定义一个指针变量 p 时，因为 p 是局部变量，所以也遵循 C 语言局部变量的一般规律（定义局部变量并且未初始化，则值是随机的），所以此时 p 变量中存储的是一个随机的数字。<br>(2)此时如果我们解引用 p，则相当于我们访问了这个随机数字为地址的内存空间。那这个空间到底能不能访问不知道（也许可以也许不行），所以如果直接定义指针变量未绑定有效地址就去解引用几乎必死无疑。<br>(3)定义一个指针变量，不经绑定有效地址就去解引用，就好象拿一个上了镗的枪在四面八方中随意开了一枪。<br>(4)指针绑定的意义就在于：让指针指向一个可以访问、应该访问的地方，指针的解引用是为了间接访问目标变量.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="type">int</span> a = <span class="number">23</span>;		<span class="comment">//a实质就是一个编译器中的符号，但是编译器将符号和一个内存空间联系起来，这个空间代表着变量。</span></span><br><span class="line">    <span class="type">int</span> *p;			<span class="comment">//定义指针变量</span></span><br><span class="line">    <span class="type">int</span> *p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x\n&quot;</span>, p);<span class="comment">//%p和%x打印指针，打印出来的数值都是一样的。</span></span><br><span class="line">    <span class="comment">/*绑定指针变量，就是给指针赋值，让这个指针指向另一个变量，当没有绑定指针变量时候，这个指针不能被解引用*/</span></span><br><span class="line">    p = &amp;a;			<span class="comment">//让p指向a</span></span><br><span class="line">    p2 = (<span class="type">int</span> *)<span class="number">4</span>;	<span class="comment">//让p指向内存地址为4的那个变量</span></span><br><span class="line">    <span class="comment">/*解引用 ，如果没有绑定就解引用，那一定出错*/</span></span><br><span class="line">    *p = <span class="number">555</span>;		<span class="comment">//把555放入p指向的变量中。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>星号*<br>(1)C 语言中*****可以表示乘号，也可以表示指针符号。这两个用法是毫无关联的，只是恰好用了同一个符号而已。<br>(2)****<em>在用于指针相关功能的是后续有 2 种用法：第一种是指针定义时， ***** 结合前面的类型用于表明要定义的指针的类型；第二种功能是指针解引用，解引用时</em>p 表示 p 指向的变量本身。<br>3.2.2.取地址符&amp;<br>取地址符使用时直接加在一个变量的前面，然后取地址符和变量加起来构成一个新的符号，这个符号表示这个变量的地址。<br>3.2.3.指针定义并未初始化、与指针定义然后赋值的区别<br>(1)指针定义时可以初始化，指针的初始化其实就是给指针变量初值（跟普通变量的初始化没有任何本质区别）。<br>(2)指针变量定义同时初始化的格式是： int a &#x3D; 32; int *p &#x3D; &amp;a;<br>(3)不初始化时指针变量先定义再赋值： int a &#x3D; 32; int *p; p &#x3D; &amp;a; </p>
<p>左值与右值<br>(1)放在赋值运算符左边的就叫左值，右边的就叫右值。所以赋值操作其实就是：左值 &#x3D; 右<br>值;<br>(2)当一个变量做左值时，编译器认为这个变量符号的真实含义是这个变量所对应的那个内<br>存空间；当一个变量做右值时，编译器认为这个变量符号的真实含义是这个变量的值，也<br>就是这个变量所对应的内存空间中存储的那个数。</p>
<h2 id="野指针问题"><a href="#野指针问题" class="headerlink" title="野指针问题"></a>野指针问题</h2><blockquote>
<p>(1)野指针，就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）<br>(2)野指针很可能触发运行时段错误（Sgmentation fault）<br>(3)因为指针变量在定义时如果未初始化，值也是随机的。指针变量的值其实就是别的变量（指针所指向的那个变量）的地址，所以意味着这个指针指向了一个地址是不确定的变量，这时候去解引用就是去访问这个地址不确定的变量，所以结果是不可知的。<br>(4)野指针因为指向地址是不可预知的。所以有 3 种情况：第一种是指向不可访问（操作系统不允许访问的敏感地址，譬如内核空间）的地址，结果是触发段错误，这种情况算好的了，因为编译器会报错；第二种是指向一个可用的、而且没有什么特别意义的空间（譬如我们曾经使用过但是已经不用的栈空间或堆空间），这时候程序运行不会出错，也不会对当前程序造成损害，这种情况下会掩盖你的程序错误，让你以为程序没问题，其实是有问题的；第三种情况就是指向了一个可用的空间，而且这个空间其实在程序中正在被使用（譬如说是程序的一个变量 x），那么野指针的解引用就会刚好修改这个变量 x 的值，导致这个变量莫名其妙的被改变，程序出现离奇的错误。一般最终都会导致程序崩溃，或者数据被损害。这种危害是最大的。<br>(5)指针变量如果是局部变量，则分配在栈上，本身遵从栈的规律（反复使用，使用完不擦出，所以是脏的，本次在栈上分配到的变量的默认值是上次这个栈空间被使用时余留下来的值），就决定了栈的使用多少会影响这个默认值。因此野指针的值是有一定规律不是完全随机的，但是这个值的规律对我们没意义。因为不管落在上面的野指针是 3 种情况的哪一种，都不是我们想看到的。 </p>
</blockquote>
<h2 id="怎么避免野指针？"><a href="#怎么避免野指针？" class="headerlink" title="怎么避免野指针？"></a>怎么避免野指针？</h2><p>(1)野指针的错误来源就是指针定义了以后没有初始化，也没有赋值（总之就是指针没有明<br>确的指向一个可用的内存空间），然后去解引用。<br>(2)知道了野指针产生的原因，避免方法就出来了：在指针的解引用之前，一定确保指针指<br>向一个绝对可用的空间。<br>(3)常规的做法是：</p>
<blockquote>
<p>第一点：定义指针时，同时初始化为 NULL<br>第二点：在指针使用之前，将其赋值绑定给一个可用地址空间<br>第三点：在指针解引用之前， 先去判断这个指针是不是 NULL<br>第四点：指针使用完之后，将其赋值为 NULL </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = &amp;a;			<span class="comment">//正确使用指针方法，解引用指针前跟一个绝对可用的地址绑定</span></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="literal">NULL</span>;		<span class="comment">//使用完指针变量后，记得重新赋值为NULL</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NULL-到底是什么？"><a href="#NULL-到底是什么？" class="headerlink" title="NULL 到底是什么？"></a>NULL 到底是什么？</h3><p>(1)NULL 在 C&#x2F;C++中定义为：<br>#ifdefine _cplusplus &#x2F;&#x2F;定义这个符号就表示当前是 C++环境<br>#define NULL 0 &#x2F;&#x2F;在 C++中 NULL 就是 0<br>#else<br>#define NULL (void *)0 &#x2F;&#x2F;在 C 中 NULL 是强制类型转换为 void *的 0<br>#endif<br>(2)在 C 语言中， int *p，你可以 p &#x3D; (int *)0，但是不可以 p &#x3D; 0，因为类型不同<br>(3)所以 NULL 的实质其实就是地址 0，然后我们给指针赋初值为 NULL，其实就是让指针指向 0 地址处。为什么指向 0 地址处？有 2 点原因：第一层原因是 0 地址处作为一个特殊地址（我们认为指针指向这里就表示指针没有被初始化，就表示野指针）；第二层原因是这个 0 地址在一般的操作系统中都是不可被访问的，如果不按规矩（不检查是否等于 NULL就去解引用）写代码直接去解引用就会触发段错误，编译器会报错嘀。 (指针指向这个敏感地址没有问题，只要不解引用就 ok)</p>
<h3 id="const-修饰指针的-4-种形式"><a href="#const-修饰指针的-4-种形式" class="headerlink" title="const 修饰指针的 4 种形式"></a>const 修饰指针的 4 种形式</h3><p>(1)const 关键字，在 C 语言中用来修饰变量，表示这个变量是常量。<br>(2)const 修饰指针有 4 种形式，区分清楚这 4 种即可全部理解 const 和指针。<br>第一种： const int *p; &#x2F;&#x2F;const 修饰 p 指向的变量20<br>第二种： int const *p; &#x2F;&#x2F;const 修饰 p 指向的变量<br>第三种： int * const p; &#x2F;&#x2F;const 修饰指针变量 p<br>第四种： const int * const p; &#x2F;&#x2F;const 即修饰 p 指向的变量也修饰指针变量 p<br>(3)关于指针变量的理解，主要涉及到 2 个变量：第一个是指针变量 p 本身，第二个是 p 指向的那个变量(*p)。一个 const 关键字只能修饰一个变量，所以弄清楚这 4 个表达式的关键就是搞清楚 const 放在某个位置是修饰谁。</p>
<h2 id="深入学习数组"><a href="#深入学习数组" class="headerlink" title="深入学习数组"></a>深入学习数组</h2><h3 id="从内存角度来理解数组"><a href="#从内存角度来理解数组" class="headerlink" title="从内存角度来理解数组"></a>从内存角度来理解数组</h3><p>(1)从内存角度讲，数组变量就是一次分配多个变量，而且这多个变量在内存中的存储单元是依次相连接的。<br>(2)我们分开定义多个变量（譬如 int a, b, c, d）和和一次定义一个数组（int a[4]）这两种定义方法相同点是都定义了 4 个 int 型变量，而且这 4 个变量都是独立的、单个使用的；不同点是单独定义时 a、 b、 c、 d 在内存中的地址不一定相连，但是定义成数组后，数组中的 4 个元素地址肯定是依次相连的。<br>(3)数组中多个变量虽然必须单独访问，但是因为他们的地址彼此相连，因此很适合用指针来操，因此数组和指针天生就有一种羁绊。 </p>
<p>(1)这 4 个符号搞清楚了，数组相关的很多问题就都有答案了。理解这些符号的时候要和左值右值结合起来，也就是搞清楚每个符号分别做左值和右值时的不同含义。<br>(2)a 就是数组名。 a 做左值表示整个数组所有空间（10*4&#x3D;40 字节）， 但因为 C 语言规定数组操作时要独立单个操作，不能整体操作数组，所以 a 不能做左值； a 做右值表示数组首元素（数组的第 1 个元素，也就是 a[0]）的首地址（首地址就是起始地址，就是 4 个字<br>节中最开始第一个字节的地址）。 a 做右值等于&amp;a[0]。<br>(3)a[0]表示数组的首元素，也就是数组的第 1 个元素。 a[0]做左值时表示首元素对应的内存空间（连续 4 个字节）； a[0]做右值时表示数组第 1 个元素的值（也就是数组第 1 个元素对应的内存空间中存储的那个数）<br>(4)&amp;a 就是数组名 a 取地址，字面意思来看就应该是数组的地址。 &amp;a 不能做左值（&amp;a 实质是一个常量，不是变量，因此不能赋值，所以自然不能做左值。）； &amp;a 做右值时表示整个数组的首地址。<br>(5)&amp;a[0]字面自已就是数组第 1 个元素的首地址（搞清楚[]和&amp;的优先级， []的优先级要高于&amp;，所以 a 先和[]结合再取地址）。 &amp;a[0]不能做左值（&amp;a[0]实质是一个常量，不是变量，因此不能赋值，所以自然不能做左值。）； 做右值时表示数组首元素地址。 &amp;a[0]做右值等于 a。 </p>
<h2 id="指针和数组的天生羁绊"><a href="#指针和数组的天生羁绊" class="headerlink" title="指针和数组的天生羁绊"></a>指针和数组的天生羁绊</h2><h3 id="以指针方式来访问数组元素"><a href="#以指针方式来访问数组元素" class="headerlink" title="以指针方式来访问数组元素"></a>以指针方式来访问数组元素</h3><p>(1)数组元素使用时不能整体访问，只能单个访问。访问方式有 2 种：数组形式和指针形式。<br>(2)数组格式访问数组元素是：数组名[下标];<br>(3)指针方式访问数组元素是： *(指针+偏移量); *(数组名+偏移量);如果指针是数组首元素地址（a 或者&amp;a[0]），那么偏移量就是下标；指针也可以不是首元素地址而是其他哪个元素的地址，这时候偏移量就要考虑叠加了。<br>(4)数组下标方式和指针方式均可以访问数组元素，两者的实质其实是一样的。在编译器内部都是用指针方式来访问数组元素的，数组下标方式只是编译器提供给编程者一种壳（语法糖）而已。所以用指针方式来访问数组才是本质的方法。 </p>
<h3 id="指针和数组类型的匹配问题"><a href="#指针和数组类型的匹配问题" class="headerlink" title="指针和数组类型的匹配问题"></a>指针和数组类型的匹配问题</h3><p>(1)int *p; int a[5]; p &#x3D; a; &#x2F;&#x2F;类型匹配， a 相当于&amp;a[0]<br>(2)int *p; int a[5]; p &#x3D; &amp;a; &#x2F;&#x2F;类型不匹配p 是 int *，是 int 指针类型，而&amp;a 是整个数组的指针，也就是数组指针类型，所以不匹配<br>(3)&amp;a 和 a、 &amp;a[0]从数值来看是相等的，但是意义来看就不同了。从意义来看， a 和&amp;a[0]是数组首元素地址，而&amp;a 是整个数组的首地址；从类型来看， a 和&amp;a[0]是元素的指针，也就是 int <em>类型的；而&amp;a 是数组指针，是 int (</em>)[5]类型。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">34</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a;					<span class="comment">//p指向数组首地址&amp;a[0]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(p+1) = %d\n&quot;</span>,*(p+<span class="number">1</span>));	<span class="comment">//相当于a[1]</span></span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;a = 0x%x\n&quot;</span>, a);	<span class="comment">//数组的首元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = 0x%x\n&quot;</span>, &amp;a);	<span class="comment">//整个数组的首地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0] = 0x%x\n&quot;</span>, &amp;a[<span class="number">0</span>]);	<span class="comment">//数组首地址的地址</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针与强制类型转换"><a href="#指针与强制类型转换" class="headerlink" title="指针与强制类型转换"></a>指针与强制类型转换</h2><h3 id="变量的数据类型的含义"><a href="#变量的数据类型的含义" class="headerlink" title="变量的数据类型的含义"></a>变量的数据类型的含义</h3><p>(1)所有的类型的数据存储在内存中，都是按照二进制格式存储的。所以内存中只知道 1 和0，不知道 int 的还是 float 的还是其他类型。<br>(2)int、 short、 char 等属于整型，他们的存储方式（数转换成二进制往内存中存放的方式）是相同的，只是内存格子大小不同（所以这几种整型就彼此叫二进制兼容格式）；而 float、double 的存储方式彼此不同，和整型更不同。<br>(3)int a &#x3D; 5; 时，编译器给 a 分配 4 字节空间，并且将 5 按照 int 类型的存储方式转换成二进制存到 a 所对应的内存空间中去（a 做左值的）；我们 printf 去打印 a 的时候（a 此时做右值）， printf 内部的 vsprintf 函数会按照格式化字符串（就是 printf 传参的第一个字<br>符串参数中的%d 之类的东西）所代表的类型去解析 a 所对应的内存空间，解析出的值用来输出。也就是说，存进去时是按照这个变量本身的数据类型来存储的（譬如本例中 a 为int 所以按照 int 格式来存储）；但是取出来时是按照 printf 中%d 之类的格式化字符串的格<br>式来提取的。此时虽然 a 所代表的内存空间中的 1010 序列并没有变（内存是没被修改的）但是怎么理解（怎么把这些 1010 转成数字）就不一定了。譬如我们用%d 来解析，那么还是按照 int 格式解析则值自然还是 5；但是如果用%f 来解析，则 printf 就以为 a 对应的内存空间存储的是一个 float 类型的数，会按照 float 类型来解析，值自然是很奇怪的一个数字了。 </p>
<p>分析几个题目：</p>
<ul>
<li>按照 int 类型存却按照 float 类型取 一定会出错</li>
<li>按照 int 类型存却按照 char 类型取 有可能出错也有可能不出错</li>
<li>按照 short 类型存却按照 int 类型取 有可能出错也有可能不出错</li>
<li>按照 float 类型存却按照 double 取 一定会出错</li>
</ul>
<h3 id="指针数据类型转换实例分析-1（int-gt-char-）"><a href="#指针数据类型转换实例分析-1（int-gt-char-）" class="headerlink" title="指针数据类型转换实例分析 1（int * -&gt; char *）"></a>指针数据类型转换实例分析 1（int * -&gt; char *）</h3><p>(1)int 和 char 类型都是整型的，类型兼容的。所以互转的时候有可能出错有可能对。<br>(2)int 和 char 的不同在于 char 只有 1 个字节而 int 有 4 个字节，所以 int 的范围比 char大。在 char 所表示的范围之内 int 和 char 是可以互转的不会出错；但是超过了 char 的范围后， char 转成 int 不会错。 </p>
<h2 id="指针、数组与-sizeof-运算符"><a href="#指针、数组与-sizeof-运算符" class="headerlink" title="指针、数组与 sizeof 运算符"></a>指针、数组与 sizeof 运算符</h2><p>sizeof 运算符<br>(1)sizeof 是 C 语言中的一个运算符（sizeof 不是函数，虽然用法很像函数）， sizeof 的作用是用来返回()里边的变量或者数据类型占用的内存字节数。<br>(2)sizeof 存在的价值？主要是因为在不同平台下各种数据类型所占的字节数不尽相同（譬如 int 在 32 位系统中为 4 字节，在 16 位系统中为 2 字节…）。所以程序中需要使用 sizeof来判断当前变量&#x2F;数据类型在当前环境下占几个字节。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(str) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(str));	<span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(str[0]) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(str[<span class="number">0</span>]));	<span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;strlen(str) = %d&quot;</span>, <span class="built_in">strlen</span>(str));	<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = str;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(p) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(p));	<span class="comment">//4 相当于sizeof(char *)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(*p) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(*p));<span class="comment">//1 相当于sizeof( char) </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;strlen(p) = %d\n&quot;</span>, <span class="built_in">strlen</span>(p));	<span class="comment">//5	相当于strlen(char)</span></span><br></pre></td></tr></table></figure>

<p>(1)32 位系统中所有指针的长度都是 4，不管是什么类型的指针。<br>(2)strlen 是一个 C 库函数，用来返回一个字符串的长度（注意， 字符串的长度是不计算字符串末尾的’\0’的）。一定要注意 strlen 接收的参数必须是一个字符串（字符串的特征是以’\0’结尾）。 </p>
<p>void fun(int b[100])<br>{<br>sizeof(b) &#x2F;&#x2F; 4<br>}<br>(1)函数传参，形参可以用数组的<br>(2)函数形参是数组时，实际传递的不是整个数组，而是数组的首元素地址。也就是说函数<br>传参用数组来传，实际相当于传递的是指针（指针指向数组的首元素地址）。</p>
<h3 id="通过-sizeof-获取数组元素个数的技巧"><a href="#通过-sizeof-获取数组元素个数的技巧" class="headerlink" title="通过 sizeof 获取数组元素个数的技巧"></a>通过 sizeof 获取数组元素个数的技巧</h3><p>int a[56];<br>int b &#x3D; sizeof(a) &#x2F; sizeof(a[0]); &#x2F;&#x2F; 整个数组字节数&#x2F;数组中一个元素的字节数<br>printf(“b &#x3D; %d.\n”, b); &#x2F;&#x2F; 结果应该是数组的元素个数<br>3.8.8. #define 和 typedef 的区别<br>#define dpChar char *<br>typedef char *tpChar;<br>dpChar p1, p2; sizeof(p1) sizeof(p2)<br>tpChar p3, p4; sizeof(p3) sizeof(p4)<br>dpChar p1, p2; &#x2F;&#x2F;展开： char *p1, p2; 相当于 char *p1, char p2;<br>tpChar p3, p4; &#x2F;&#x2F; 等价于： char *p3, char *p4;</p>
<h2 id="指针与函数传参"><a href="#指针与函数传参" class="headerlink" title="指针与函数传参"></a>指针与函数传参</h2><h3 id="普通变量作为函数形参30"><a href="#普通变量作为函数形参30" class="headerlink" title="普通变量作为函数形参30"></a>普通变量作为函数形参30</h3><p>(1)函数传参时，普通变量作为参数时，形参和实参名字可以相同也可以不同，实际上都是<br>用实参来替代相对应的形参的。<br>(2)在子函数内部，形参的值等于实参。原因是函数调用时把实参的值赋值给了形参。<br>(3)这就是很多书上写的“传值调用”（相当于实参做右值，形参做左值）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p.\n&quot;</span>, &amp;a);</span><br><span class="line">func1(a);</span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d.\n&quot;</span>, b); <span class="comment">// 在函数内部，形参 b 的值等于实参 a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in func1, &amp;b = %p.\n&quot;</span>, &amp;b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&amp;a 和&amp;b 不同，说明 a 和 b 不是同一个变量（在内存中 a 和 b 是独立的 2 个内存空间）</span></span><br><span class="line">但是 a 和 b 是有关联的，实际上 b 是 a 赋值得到的。</span><br></pre></td></tr></table></figure>

<h3 id="数组作为函数形参"><a href="#数组作为函数形参" class="headerlink" title="数组作为函数形参"></a>数组作为函数形参</h3><p>(1)数组作为形参传参时，实际传递的不是整个数组，而是数组的首元素地址（也就是整个<br>数组的首地址。因为传参时是传值，所以首元素地址和数组的首地址这两个没区别）。所<br>以在子函数内部，传进来的数组名就等于是一个指向数组首元素的指针。所以 sizeof 得到<br>的是 4。<br>(2)在子函数内传参得到的数组首元素首地址，和外面得到的首元素首地址是相同的。很多<br>人把这种特性叫做“传址调用”（所谓的传址调用就是调用子函数时传了地址（也就是指<br>针），此时可以通过传进去的地址来访问实参。）<br>(3)数组作为函数参数时， []里的数组是可有可无的。为什么？因为数组名做形参传递的实<br>际只是个指针，根本没有数组长度这个信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %p.\n&quot;</span>, a);</span><br><span class="line">func2(a);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d.\n&quot;</span>, <span class="keyword">sizeof</span>(a)); <span class="comment">//4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;in func2, a = %p.\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针作为函数形参"><a href="#指针作为函数形参" class="headerlink" title="指针作为函数形参"></a>指针作为函数形参</h3><p>和数组作为函数形参是一样的，这就好像指针方式访问数组元素和数组方式访问数组元素<br>的结果一样是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %p.\n&quot;</span>, a);</span><br><span class="line">func3(a);</span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">(<span class="type">int</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d.\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;in func2, a = %p.\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体变量和结构体变量指针作为函数形参"><a href="#结构体变量和结构体变量指针作为函数形参" class="headerlink" title="结构体变量和结构体变量指针作为函数形参"></a>结构体变量和结构体变量指针作为函数形参</h3><p>(1)结构体变量作为函数形参的时候，实际上和普通变量（类似于 int 之类的）传参时的表现是一模一样的。所以说结构体变量其实也是普通变量而已。<br>(2)因为结构体一般都很大，所以如果直接用结构体变量进行传参，那么函数调用效率就会很低。（因为在函数传参时需要将实参赋值给形参，所以当传参的变量越大调用效率就会越低。）怎么解决？思路只有一个那就是不要传变量了，改传变量的指针（地址）进去。<br>(3)结构体因为自身太大，所以传参应该用结构体指针来传 .</p>
<h3 id="传值调用与传址调用"><a href="#传值调用与传址调用" class="headerlink" title="传值调用与传址调用"></a>传值调用与传址调用</h3><p>(1)传值调用描述的是这样一种现象： x 和 y 作为实参，自己并没有真身进入 swap1 函数内部，而只是拷贝了一份自己的副本（副本具有和自己一样的值，但是是不同的变量）进子函数 swap1，然后我们在子函数 swap1 中交换的实际是副本而不是 x、 y 真身。所以在<br>swap1 内部确实是交换了，但是到外部的 x 和 y 根本没有受影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line">swap1(x, y);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;in swap1, a = %d, b = %d.\n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d.\n&quot;</span>, x, y); <span class="comment">// x=3,y=5，交换失败</span></span><br></pre></td></tr></table></figure>

<p>(2)在 swap2 中 x 和 y 真的被改变了（但是 x 和 y 真身还是没有进入 swap2 函数内，而是swap2 函数内部跑出来把外面的 x 和 y 真身给改了）。实际上实参 x 和 y 永远无法真身进入子函数内部（进去的只能是一份拷贝），但是在 swap2 我们把 x 和 y 的地址传进去给子<br>函数，于是在子函数内可以通过指针解引用方式从函数内部访问到外部的 x 和 y 真身，从而改变 x 和 y。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>;</span><br><span class="line">swap2(&amp;x, &amp;y);</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap2</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;in swap2, *a = %d, *b = %d.\n&quot;</span>, *a, *b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d.\n&quot;</span>, x, y); <span class="comment">// x=5,y=3，交换成功 </span></span><br></pre></td></tr></table></figure>

<h4 id="函数传参中使用-const-指针"><a href="#函数传参中使用-const-指针" class="headerlink" title="函数传参中使用 const 指针"></a>函数传参中使用 const 指针</h4><p>(1)const 一般用在函数参数列表中，用法是 const int *p;（意义是指针变量 p 本身是可变的，而 p 所指向的变量是不可变的）<br>(2)const 用来修饰指针做函数传参，作用就在于声明在函数内部不会改变这个指针指向的内容，所以给该函数传一个不可改变的指针（char *p &#x3D; “linux”;这种）不会触发错误，而一个未声明为 const 的指针的函数，你给他传一个不可更改的指针的时候就要小心了。 </p>
<h3 id="函数需要向外部返回多个值怎么办？"><a href="#函数需要向外部返回多个值怎么办？" class="headerlink" title="函数需要向外部返回多个值怎么办？"></a>函数需要向外部返回多个值怎么办？</h3><p>(1)一般来说，函数的输入部分就是函数参数，输出部分就是返回值。问题是函数的参数可以有很多个，而返回值只能有 1 个。这就造成我们无法一个函数返回多个值。<br>(2)实际编程中，一个函数需要返回多个值是非常普遍的，因此完全依赖于返回值是不靠谱的，通常的做法是用参数来做返回。（在典型 linux 风格函数中，返回值是不用来返回结果的，而是用来返回 0 或者负数来表示查询执行结果是对还是错，是成功还是失败，它是返回给调用它的进程的）。<br>(3)普遍做法，编程中函数的输入和输出都是靠函数参数的，返回值只是用来表示函数执行的结果是对还是错。如果这个参数是用来做输入的，就叫输入型参数；如果这个参数的目的是用来做输出的，就叫输出型参数。<br>(4)输出型参数就是用来让函数内部把数据输出到函数外部的 </p>
<h2 id="函数指针与-typedef"><a href="#函数指针与-typedef" class="headerlink" title="函数指针与 typedef"></a>函数指针与 typedef</h2><h3 id="函数指针的实质（还是指针变量）"><a href="#函数指针的实质（还是指针变量）" class="headerlink" title="函数指针的实质（还是指针变量）"></a>函数指针的实质（还是指针变量）</h3><p>(1)函数指针的实质还是指针，还是指针变量。本身占 4 字节（在 32 位系统中，所有的指针都是 4 字节）<br>(2)函数指针、结构体指针、数组指针、普通指针之间并没有本质区别，区别在于指针指向的东西是个什么玩意儿。<br>(3)函数的实质是一段代码，这一段代码在内存中是连续分布的（一个函数的大括号括起来的所有语句将来编译出来生成的可执行程序是连续的），所以对于函数来说很关键的就是函数中的第一句代码的地址，这个地址就是所谓的函数地址，在 C 语言中用函数名这个符号来表示。<br>(4)结合函数的实质，函数指针其实就是一个普通变量，这个普通变量的类型是函数指针变量类型，它的值就是某个函数的地址（也就是它的函数名这个符号在编译器中对应的值）。 </p>
<h3 id="typedef-关键字的用法"><a href="#typedef-关键字的用法" class="headerlink" title="typedef 关键字的用法"></a>typedef 关键字的用法</h3><p>(1)typedef 是 C 语言中的一个关键字，作用是用来定义（或者叫重命名类型）<br>(2)C 语言中的类型一共有 2 种：一种是编译器定义的原生类型（基础数据类型，如 int、double 之类的）；第二种是用户自定义类型，不是语言自带的，是程序员自己定义的（譬如数组类型、结构体类型、函数类型……）。<br>(3)数组指针、指针数组、函数指针等都属于用户自定义类型。<br>(4)有时候自定义类型太长了，用起来不方便，所以用 typedef 给它重命名一个短点的名字。<br>(5)注意： <strong>typedef 是给类型重命名，也就是说 typedef 加工出来的都是类型，而不是变量。</strong> </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://example.com">HF</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://example.com/2023/10/06/2023-10-6-%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8A%E7%9A%84C%E8%AF%AD%E8%A8%80/">https://example.com/2023/10/06/2023-10-6-%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8A%E7%9A%84C%E8%AF%AD%E8%A8%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://example.com" target="_blank">涵风 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post_share"><div class="social-share" data-image="/img/taozhuang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/08/2023-10-7-%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"><img class="prev-cover" src="/img/taozhuang.jpg" onerror="onerror=null;src='/img/fr.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">嵌入式软件安装合集</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/05/2023-10-5-%E4%B8%8A%E4%BD%8D%E6%9C%BA%E7%9A%84%E6%BF%80%E5%85%89%E5%99%A8%E6%8E%A7%E5%88%B6/"><img class="next-cover" src="/img/taozhuang.jpg" onerror="onerror=null;src='/img/fr.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">上位机控制激光器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/15/2023-6-15-%E7%BB%8F%E5%85%B8%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/" title="经典滤波算法"><img class="cover" src="/img/taozhuang.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-15</div><div class="title">经典滤波算法</div></div></a></div><div><a href="/2023/01/13/2022-11-25-C-issue2/" title="C issue2"><img class="cover" src="/img/taozhuang.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-13</div><div class="title">C issue2</div></div></a></div><div><a href="/2022/12/17/2022-12-17-C%E9%94%99%E9%A2%98/" title="C错题"><img class="cover" src="/img/taozhuang.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-17</div><div class="title">C错题</div></div></a></div><div><a href="/2022/11/25/2022-11-25-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/" title="C issue1"><img class="cover" src="/img/taozhuang.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="title">C issue1</div></div></a></div><div><a href="/2022/10/20/2022-10-20-C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/" title="C语言算法项"><img class="cover" src="/img/taozhuang.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-20</div><div class="title">C语言算法项</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxaing.gif" onerror="this.onerror=null;this.src='/img/fr.gif'" alt="avatar"/></div><div class="author-info__name">HF</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">117</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">加菲猫中的一句话：应该有更好的方式开始新一天,而不是千篇一律地在每个上午都醒来。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">为什么需要内存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">程序运行为什么需要内存？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BC%96%E5%88%B6%E5%92%8C%E5%AF%BB%E5%9D%80%E3%80%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">1.3.</span> <span class="toc-text">内存编制和寻址、内存对齐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E5%86%85%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">C语言操作内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%EF%BC%9A%E8%A1%A8%E7%A4%BA%E5%86%85%E5%AD%98%E6%A0%BC%E5%AD%90%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88%E6%AF%8F%E4%B8%AA%E6%A0%BC%E5%AD%90-1-%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%89%E5%92%8C%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">2.0.1.</span> <span class="toc-text">C 语言数据类型的本质含义：表示内存格子的个数（每个格子 1 个字节）和解析方法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%8C%87%E9%92%88%E6%9D%A5%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98"><span class="toc-number">2.0.2.</span> <span class="toc-text">用指针来间接访问内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-number">2.0.3.</span> <span class="toc-text">用数组来管理内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.0.4.</span> <span class="toc-text">内存管理之结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E6%A0%88"><span class="toc-number">2.0.5.</span> <span class="toc-text">内存管理之栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">2.0.5.1.</span> <span class="toc-text">栈的应用举例：局部变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%A0%86"><span class="toc-number">2.0.6.</span> <span class="toc-text">内存管理之堆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">复杂数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%9B%BE%E7%AD%89"><span class="toc-number">3.1.</span> <span class="toc-text">链表、哈希表（散列表）、二叉树、图等</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">C语言位操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E4%B8%8E-amp"><span class="toc-number">4.1.</span> <span class="toc-text">位与&amp;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E6%88%96"><span class="toc-number">4.2.</span> <span class="toc-text">位或|</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%8F%96%E5%8F%8D"><span class="toc-number">4.3.</span> <span class="toc-text">位取反~</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%BC%82%E6%88%96"><span class="toc-number">4.4.</span> <span class="toc-text">位异或^</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E4%BD%8D-lt-lt-%E4%B8%8E%E5%8F%B3%E7%A7%BB%E4%BD%8D-gt-gt"><span class="toc-number">4.5.</span> <span class="toc-text">左移位&lt;&lt; 与右移位&gt;&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E4%B8%8E%E4%BD%8D%E6%88%96%E4%BD%8D%E5%BC%82%E6%88%96%E5%9C%A8%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8%E6%97%B6%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">4.6.</span> <span class="toc-text">位与位或位异或在操作寄存器时的特殊作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C%E7%9A%84%E8%A6%81%E6%B1%82%EF%BC%88%E7%89%B9%E5%AE%9A%E4%BD%8D%E6%94%B9%E5%8F%98%E8%80%8C%E4%B8%8D%E5%BD%B1%E5%93%8D%E5%85%B6%E4%BB%96%E4%BD%8D%EF%BC%89"><span class="toc-number">4.6.1.</span> <span class="toc-text">寄存器操作的要求（特定位改变而不影响其他位）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E4%BD%8D%E6%B8%85%E9%9B%B6%E7%94%A8-amp"><span class="toc-number">4.6.2.</span> <span class="toc-text">特定位清零用&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE-1-%E7%94%A8"><span class="toc-number">4.6.3.</span> <span class="toc-text">特定位置 1 用|</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E4%BD%8D%E5%8F%96%E5%8F%8D%E7%94%A8"><span class="toc-number">4.6.4.</span> <span class="toc-text">特定位取反用^</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E6%9E%84%E5%BB%BA%E7%89%B9%E5%AE%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0-1%E5%B0%91%E7%9A%84%E7%94%A8"><span class="toc-number">4.7.</span> <span class="toc-text">如何用位运算构建特定二进制数 (1少的用)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A7%BB%E4%BD%8D%E8%8E%B7%E5%8F%96%E7%89%B9%E5%AE%9A%E4%BD%8D%E4%B8%BA-1-%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-number">4.7.1.</span> <span class="toc-text">使用移位获取特定位为 1 的二进制数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E7%BB%93%E5%90%88%E4%BD%8D%E5%8F%96%E5%8F%8D%E8%8E%B7%E5%8F%96%E7%89%B9%E5%AE%9A%E4%BD%8D%E4%B8%BA-0-%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%EF%BC%881%E5%A4%9A%E7%9A%84%E7%94%A8%EF%BC%89"><span class="toc-number">4.7.2.</span> <span class="toc-text">再结合位取反获取特定位为 0 的二进制数（1多的用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%AE%9E%E6%88%98"><span class="toc-number">4.7.3.</span> <span class="toc-text">位操作实战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88"><span class="toc-number">5.</span> <span class="toc-text">C语言指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">指针变量和普通变量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E3%80%81%E5%85%B3%E8%81%94%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E3%80%81%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">指针使用三部曲：定义指针变量、关联指针变量、解引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">野指针问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">怎么避免野指针？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NULL-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.4.1.</span> <span class="toc-text">NULL 到底是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E7%9A%84-4-%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">5.4.2.</span> <span class="toc-text">const 修饰指针的 4 种形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.</span> <span class="toc-text">深入学习数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%86%85%E5%AD%98%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%90%86%E8%A7%A3%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.1.</span> <span class="toc-text">从内存角度来理解数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A9%E7%94%9F%E7%BE%81%E7%BB%8A"><span class="toc-number">5.6.</span> <span class="toc-text">指针和数组的天生羁绊</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E6%8C%87%E9%92%88%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">5.6.1.</span> <span class="toc-text">以指针方式来访问数组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">5.6.2.</span> <span class="toc-text">指针和数组类型的匹配问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.7.</span> <span class="toc-text">指针与强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">5.7.1.</span> <span class="toc-text">变量的数据类型的含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90-1%EF%BC%88int-gt-char-%EF%BC%89"><span class="toc-number">5.7.2.</span> <span class="toc-text">指针数据类型转换实例分析 1（int * -&gt; char *）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%8E-sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.8.</span> <span class="toc-text">指针、数组与 sizeof 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-sizeof-%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">5.8.1.</span> <span class="toc-text">通过 sizeof 获取数组元素个数的技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-number">5.9.</span> <span class="toc-text">指针与函数传参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%8230"><span class="toc-number">5.9.1.</span> <span class="toc-text">普通变量作为函数形参30</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82"><span class="toc-number">5.9.2.</span> <span class="toc-text">数组作为函数形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82"><span class="toc-number">5.9.3.</span> <span class="toc-text">指针作为函数形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82"><span class="toc-number">5.9.4.</span> <span class="toc-text">结构体变量和结构体变量指针作为函数形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC%E8%B0%83%E7%94%A8%E4%B8%8E%E4%BC%A0%E5%9D%80%E8%B0%83%E7%94%A8"><span class="toc-number">5.9.5.</span> <span class="toc-text">传值调用与传址调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E4%B8%AD%E4%BD%BF%E7%94%A8-const-%E6%8C%87%E9%92%88"><span class="toc-number">5.9.5.1.</span> <span class="toc-text">函数传参中使用 const 指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%9C%80%E8%A6%81%E5%90%91%E5%A4%96%E9%83%A8%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">5.9.6.</span> <span class="toc-text">函数需要向外部返回多个值怎么办？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E-typedef"><span class="toc-number">5.10.</span> <span class="toc-text">函数指针与 typedef</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9E%E8%B4%A8%EF%BC%88%E8%BF%98%E6%98%AF%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">5.10.1.</span> <span class="toc-text">函数指针的实质（还是指针变量）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">5.10.2.</span> <span class="toc-text">typedef 关键字的用法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/19/2023-10-19-%E7%A1%AC%E4%BB%B6%E4%BC%A0%E8%BE%93/" title="硬件传输"><img src="/img/taozhuang.jpg" onerror="this.onerror=null;this.src='/img/fr.gif'" alt="硬件传输"/></a><div class="content"><a class="title" href="/2023/10/19/2023-10-19-%E7%A1%AC%E4%BB%B6%E4%BC%A0%E8%BE%93/" title="硬件传输">硬件传输</a><time datetime="2023-10-19T07:20:32.000Z" title="发表于 2023-10-19 15:20:32">2023-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/17/2023-10-17-boa%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E5%B8%83/" title="boa服务器发布"><img src="/img/taozhuang.jpg" onerror="this.onerror=null;this.src='/img/fr.gif'" alt="boa服务器发布"/></a><div class="content"><a class="title" href="/2023/10/17/2023-10-17-boa%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E5%B8%83/" title="boa服务器发布">boa服务器发布</a><time datetime="2023-10-17T07:20:32.000Z" title="发表于 2023-10-17 15:20:32">2023-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/17/2023-10-18-%E4%B8%B2%E5%8F%A3%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/" title="串口应用编程"><img src="/img/taozhuang.jpg" onerror="this.onerror=null;this.src='/img/fr.gif'" alt="串口应用编程"/></a><div class="content"><a class="title" href="/2023/10/17/2023-10-18-%E4%B8%B2%E5%8F%A3%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/" title="串口应用编程">串口应用编程</a><time datetime="2023-10-17T07:20:32.000Z" title="发表于 2023-10-17 15:20:32">2023-10-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/11/2023-10-11-LCD%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/" title="LCD应用层编程"><img src="/img/taozhuang.jpg" onerror="this.onerror=null;this.src='/img/fr.gif'" alt="LCD应用层编程"/></a><div class="content"><a class="title" href="/2023/10/11/2023-10-11-LCD%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/" title="LCD应用层编程">LCD应用层编程</a><time datetime="2023-10-11T07:20:32.000Z" title="发表于 2023-10-11 15:20:32">2023-10-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By HF</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">生活就像一颗巧克力，你永远都不会知道下一颗的滋味。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'neutral' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><div class="aplayer no-destroy" data-id="2127967295" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script id="canvas_nest" defer="defer" color="214,237,240" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>